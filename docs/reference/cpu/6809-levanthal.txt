c\ OSBORNE/McGRAW-HILL

6809 ASSEMBLY LANGUAGE SUBROUTINES
ee

Assembly language
subroutines for the
6809

L.A. LEVENTHAL
and

S. CORDES

McGRAW-HILL BOOK COMPANY
London - New York: St Louis - San Francisco - Auckland

Bogota - Guatemala - Hamburg - Lisbon - Madrid - Mexico
Montreal - New Delhi - Panama: Paris - San Juan- Sao Paulo
Singapore - Sydney - Tokyo - Toronto

Published by
McGRAW-HILL Book Company (UK) Limited
MAIDENHEAD °*BERKSHIRE * ENGLAND

British Library Cataloguing in Publication Data
Leventhal, Lance A, 1945-—
Assembly language subroutines for the

6809.
1. Motorola 6809 microprocessor systems.
Assembly languages
I. Title

II. Cordes, S

005.2765
ISBN 0-07-707152-2
Library of Congress Cataloguing-in-Publication Data
Leventhal, Lance A, 1945-

Assembly language subroutines for the 6809 / L. A. Leventhal and S. Cordes
. em.
Includes index.
ISBN 0-07-707152-2
1. Motorola 6809 (Computer) -- Programming. 2. Assembler language
(Computer program language) 3. Subroutines (Computer programs)
I. Cordes, S.

II. Title.

QA76.8.M689L49
005.265--dc 19

1989
88-39561

First published in Japanese
Copyright © 1985 L. A. Leventhal and S. Cordes
12348909
Typeset by Ponting-Green Publishing Services, London,
and printed and bound in Great Britain at the University Press, Cambridge

Copyright ©1989 McGraw-Hill Book Company (UK) Limited. All rights
reserved. No part of: this publication may be reproduced, stored in a retrieval
system, or transmitted, in any form or by any means, electronic, mechanical,
photocopying, recording, or otherwise, without the prior permission of
McGraw-Hill Book Company (UK) Limited.

Contents

Preface
Nomenclature
introduction

Code conversion
1A_
1B
1C
1D
1E
1F

Binary to BCD conversion
4
BCD to binary conversion
7
Binary to hexadecimal ASCII conversion
10
Hexadecimal ASCII to binary conversion
13
Conversion of a binary number to decimal ASCII
Conversion of ASCII decimal to binary
20

Array manipulation and indexing
2A Memory fill
26
2B___ Block move
30
2C Two-dimensional byte array indexing
2D Two-dimensional word array indexing
2E N-dimensional array indexing
43

35
39

Arithmetic
3A 16-bit multiplication
49
3B = 16-bit division
54
3C =Miultiple-precision binary addition

61

16

vi

Assembly language subroutines for the 6809

3J_
3K
3L

Multiple-precision binary subtraction
65
Multiple-precision binary multiplication
69
Multiple-precision binary division
74
Multiple-precision binary comparison
81
Multiple-precision decimal addition
85
Multiple-precision decimal subtraction
88
Miultiple-precision decimal multiplication
92
Miultiple-precision decimal division
98
=Miultiple-precision decimal comparison
105

Bit manipulation and shifts
4A
4B
4C
4D
4E
4F
4G

107

Bit field extraction
107
Bit field insertion
112
Multiple-precision arithmetic shift right
117
Miultiple-precision logical shift left
122
Miultiple-precision logical shift right
126
Multiple-precision rotate right
130
Miultiple-precision rotate left
135

String manipulation
SA
5B
SC
5D
SE
SF
5G

140

String compare
140
String concatenation
146
Find the position of a substring
151
Copy asubstring from a string
157
Delete a substring from astring
164
Insert a substring intoa string
170
Remove excess spaces from a string
178

Array operations

182

6A _ 8-bit array summation
182
6B
16-bit array summation
186
6C Find maximum byte-length element
6D Find minimum byte-length element
6E Binary search
198
6F Quicksort
204
6G RAMtest
216
6H Jump table
222

Data structure manipulation
7A
7B
7C
7D

Queue manager
225
Stack manager
233
Singly linked list manager
Doubly linked list manager

190
194

225
239
244

Contents

input/output
Read a line from a terminal
250
Write a line to an output device
261
Parity checking and generation
265
CRC16 checking and generation
269
I/O device table handler
275
Initialize I/O ports
287
Delay milliseconds
294

Interrupts
9A
9B

9C
9D

vii

250

297

Unbuffered interrupt-driven input/output
using a 6850 ACIA
297
Unbuffered interrupt-driven input/output
using a 6821 PIA
307
Buffered interrupt-driven input/output
using a6850 ACIA =—s_- 317
Real-time clock and calendar
329

6809 instruction set summary

338

Programming reference for the 6821 PIA device

344

ASCIll character set

349

Preface

This book is intended as both a source and a reference for the 6809
assembly language programmer. It contains a collection of useful subroutines described in a standard format and accompanied by an extensive documentation package. All subroutines employ standard parameter
passing techniques and follow the rules from the most popular
assembler.

The

documentation

covers

the procedure,

parameters,

results, execution time, and memory usage; it also includes at least one
example.
The collection emphasizes common tasks that occur in many applications. These tasks include code conversion, array manipulation, arithmetic, bit manipulation, shifting functions, string manipulation, sorting,

and searching. We have also provided examples of input/output (I/O)
routines, interrupt service routines, and initialization routines for common family chips such as parallel interfaces, serial interfaces, and
timers. You should be able to use these programs as subroutines in
actual applications and as starting points for more complex programs.
This book is intended for the person who wants to use assembly
language immediately, rather than just learn about it. The reader could
be
@ An engineer, technician, or programmer who must write assembly
language programs for a design project.

e A microcomputer user who wants to write an I/O driver, a diagnostic
program, a utility, or a systems program in assembly language.

Assembly language subroutines for the 6809

@ An experienced assembly language programmer who needs a quick
review of techniques for a particular microprocessor.

e A system designer who needs a specific routine or technique for
immediate use.
© A high-level language programmer who must debug or optimize
programs at the assembly level or must link a program written in a
high-level language to one written in assembly language.
e A maintenance programmer who must understand
specific assembly language programs work.

quickly how

e A microcomputer owner who wants to understand the operating
system of a particular computer, or who wants to modify standard I/O
routines or systems programs.
@ A student, hobbyist, or teacher who wants to see examples of working
assembly language programs.
This book can also serve as a supplement for students of the Assembly
Language Programming series.
This book should save the reader time and effort. The reader should
not have to write, debug, test, or optimize standard routines, or search
through a textbook for particular examples. The reader should instead
be able to obtain easily the specific information, technique, or routine
he or she needs.
Obviously, a book with such an aim demands feedback from its
readers. We have, of course, tested all programs thoroughly and documented them carefully. If you find any errors, please inform the publisher. If you have suggestions for better methods or for additional
topics, routines, or programming hints, please tell us about them. We
have used our programming experience to develop this book, but we
need your help to improve it. We would greatly appreciate your comments, criticisms, and suggestions.

Nomenclature

We have used the following nomenclature in this book to describe the
architecture of the 6809 processor, to specify operands, and to represent
general values of numbers and addresses.

6809 architecture

Figure N-1 shows the register structure of the 6809 microprocessor. Its
byte-length registers are:
15

0
X —

Index Register

Y — Index Register
U —
S —

Pointer Registers

User Stack Pointer

Hardware Stack Pointer

Program Counter

PA

8

Accumulators

O

7

0
Direct Page Register

7

0
eEyFLH} i [n[z] vic

Figure N-1

Condition Code Regis

6809 register structure.
xi

Xi!

Assembly language subroutines for the 6809

A
B
CC
DP

(accumulator A)
(accumulator B)
(condition code register)
(direct page register)

The CC register consists of bits with independent functions and meanings, arranged as shown in Figure N-2.
The 6809’s word-length registers are:

D

(double accumulator, same as A and B together with A being
the more significant byte)

PC

(program counter)

Sor SP (hardware stack pointer)
U

(user stack pointer)

X

(index register X)

Y

(index register Y)
6

5

43

2 #1

FED bbe

. arry
Overflow
Zero
Negative
IRQ Mask
Half Carry
FIRQ Mask
Entire Flag

Figure N-2 6809 condition code (CC) register.
The 6809’s flags (see Figure N-2) are as follows:

C (carry)
E (entire, used to differentiate between regular interrupts that save
all registers and fast interrupts that do not)
F (fast interrupt mask bit)
H (half-carry, i.e. carry from bit 3 of a byte)
I (regular interrupt mask bit)
N (negative or sign)
V_ (overflow)

Nomenclature

xii

6809 assembler
Delimiters include

space
,(comma)

[|

/

After a label or operation code and before a comment on
the same line as an instruction
Between operands in the address field and ahead of the
designations for zero offset indexing, autoincrementing,
and autodecrementing
Around indirect addresses
Before an entire line of comments
Optional after a label except not allowed in
EQU statements
Around strings in FCC pseudo-operations

Pseudo-operations include
END
EQU
FCB
FCC
FDB
ORG
RMB

SETDP

End of program
Equate; define the attached label
Form constant byte; enter byte-length data
Form constant character string; enter character data
Form double byte constant; enter word-length data
Set (location counter to) origin; place subsequent object
code starting at the specified address
Reserve memory bytes; allocate a specified number of
bytes for data storage
Specify memory page to be treated as the direct page in
subsequent assembly

Designations include
Number systems
% (prefix) or B (suffix)
& (prefix) or D (suffix)

Binary
Decimal

$ (prefix) or H (suffix)

Hexadecimal

@ (prefix) or Q (suffix)

Octal

The default mode is decimal; hexadecimal numbers using the H suffix
must start with a digit (i.e. you must add a leading zero if the number
starts with a letter).
Others
—
——
+

ASCII character
Autodecrementing by 1 (before a register name)
Autodecrementing by 2 (before a register name)
Autoincrementing by 1 (after a register name)

Xiv

Assembly language subroutines for the 6809

++
$
<
>
#
PCR

Autoincrementing by 2 (after a register name)
Current value of location (program) counter
Force the assembler to use direct (page) addressing
Force the assembler to use extended (direct) addressing
Immediate addressing (in front of an operand)
Relative to the current value of the location counter (as in
DEST,PCR)

Defaults include:

Direct page is page 0 unless a SETDP
otherwise.

pseudo-operation

specifies

Unmarked addresses are either direct (if they are on the page specified
as the direct page) or extended (direct).
Unmarked numbers are decimal.

Introduction

Each description of an assembly language subroutine contains the
following information:
@ Purpose of the routine
@ Procedure
@ Entry conditions

@ Exit conditions
@ Examples
@ Registers used

@ Execution time
@ Program size

@ Data memory required
@ Special cases

The program listing also includes much of this information as well as
comments describing each section.
We have made each routine as general as possible. This is difficult for
the input/output (I/O) and interrupt service routines described in Chapters 8 and 9 since in practice these routines are always computerdependent. In such cases, we have limited the dependence to
generalized input and output handlers and interrupt managers. We have
1

Assembly language subroutines for the 6809

drawn specific examples from the popular Radio Shack TRS-80 Color

Computer (with BASIC in ROM), but the general principles are applicable to other 6809-based computers as well.
All routines use the following parameter passing techniques:

1. A single 8-bit parameter is passed in accumulator A. A second 8-bit
parameter is passed in accumulator B.
2. A single 16-bit parameter is passed in accumulators A and B (more
significant byte in A) if it is data and in index register X if it is an address.
3. Larger number of parameters are passed in the hardware stack,
either directly or indirectly. We assume that the subroutine entry is via a
JSR instruction that places the return address at the top of the stack, and
hence on top of the parameters.

Where there is a trade-off between execution time and memory usage,
we have chosen the approach that minimizes execution time. We have
also chosen the approach that minimizes the number of repetitive calculations. For example, consider the case of array indexing. The number of
bytes between the starting addresses of elements differing only by 1 ina
particular subscript (known as the size of that subscript) depends only on
the number of bytes per element and the bounds of the array. This allows
us to calculate the sizes of the various subscripts as soon as we know the
bounds. We therefore use the sizes as parameters for the indexing
routines, so that they need not be calculated each time a particular array
is indexed.
We have specified the execution time for most short routines. For
longer routines, we provide an approximate execution time. The execution time of programs with many branches will obviously depend on
which path the computer follows in a particular case. A complicating
factor is that a conditional branch requires different numbers of clock
cycles depending on whether the processor actually branches. Thus, a
precise execution time is often impossible to define. The documentation
always contains at least one typical example showing an approximate or
maximum execution time.
Our philosophy on error indicators and special cases has been the
following:
1. Routines should provide an easily tested indicator (such as the Carry
flag) of whether any errors or exceptions have occurred.
2. Trivial cases, such as no elements in an array or strings of zero length,
should result in immediate exits with minimal effect on the underlying
data.

Introduction

3

3. Misspecified data (such as a maximum string length of zero or an
index beyond the end of an array) should result in immediate exits with
minimal effects on the underlying data.
4. The documentation should include a summary of errors and exceptions (under the heading of ‘Special cases’).
5. Exceptions that may actually be convenient for the user (such as
deleting more characters than could possibly be left in a string rather
than counting the precise number) should be handled in a reasonable
way, but should still be indicated as errors.

Obviously, no method of handling errors or exceptions can ever be
completely consistent or well-suited to all applications. Our approach is
that a reasonable set of subroutines must deal with this issue, rather

than ignoring it or assuming that the user will always provide data in the
proper form.

7 Code conversion

1A_ Binary to BCD conversion
(BN2BCD)
Converts one byte of binary data to two bytes of BCD data.

Procedure The program subtracts 100 repeatedly from the original
data to determine the hundreds digit, then subtracts 10 repeatedly from
the remainder to determine the tens digit, and finally shifts the tens digit
left four positions and combines it with the ones digit.

Entry conditions.

Binary datain A

Exit conditions
BCD data in D

Examples

1.

Data:

(A) = 6Dj¢ (109 decimal)

Result:

(D) = 010946

1A_

Binary to BCD conversion (BN2BCD)

2.

Data:

Result:
a

5

(A) = B76 (183 decimal)

(D) = 01834¢

Registers used

A,B,CC

Execution time

140 cycles maximum, depends on the number of

subtractions required to determine the tens and hundreds digits
Program size

30 bytes

Data memory required 2 stack bytes
Sa en

Title:
Name:

Binary
BN2BCD

Purpose:

Converts
bytes of

one
BCD

byte
data

Entry:

Register

A =

Binary

Exit:

Register

D =

BCD

Registers

Used:

to

BCD

Conversion

of

binary

data

to

data

data

A,B,CC

Time:

140

Size:

Program
Data

cycles

maximum

30 bytes
2 bytes

on

stack

HF
FH
t+
eH
£
+
FF
HF
F

BN2BCD:
*

DIOOLP:

*CALCULATE 100'S DIGIT
*DIVIDE DATA BY 100 USING SUBTRACTIONS
* B = QUOTIENT
* A = REMAINDER
*
LDB
#3 FF
START QUOTIENT AT
INCB
ADD 1 TO QUOTIENT
SUBA
#100
SUBTRACT 100 FROM

-1
DIVIDEND

two

Assembly language subroutines for the 6809
BCC
ADDA).
STB

D100LP
#100
,7Ss

JUMP IF DIFFERENCE STILL POSITIVE4
IF NOT, ADD THE LAST 100 BACK
SAVE 100'S DIGIT ON STACK

*
*CALCULATE 10'S AND 1'S DIGITS
*DIVIDE THE REMAINDER FROM CALCULATING
* B = 10'S DIGIT

* A =

1'S

THE

100'S

DIGIT

BY

DIGIT

*

DIOLP:

LDB
INCB
SUBA
BCC
ADDA

#$FF

START QUOTIENT AT -1
ADD 1 TO QUOTIENT
SUBTRACT 10 FROM DIVIDEND
JUMP IF DIFFERENCE STILL POSITIVE
IF NOT, ADD THE LAST 10 BACK

:

#10
D1OLP
#10

*

*COMBINE
*
LSLB
LSLB
LSLB
LSLB
STA
ADDB

1'S

AND

10'S

DIGITS

MOVE

778
yot

10'S

DIGIT

TO

HIGH

NIBBLE

SAVE 1'S DIGIT ON STACK
COMBINE 1'S AND 10'S DIGITS

*

*RETURN
x
LDA
RTS

WITH

D =

SAMPLE

EXECUTION

BCD

DATA

ot

RETURN

100'S

DIGIT

INA

F
+

SC1A:
*CONVERT
LDA
JSR

OA HEXADECIMAL
#S0A
BN2BCD

TO

*CONVERT
LDA
JSR

FF HEXADECIMAL
#S FF
BN2BCD

TO

*CONVERT
LDA
JSR

O HEXADECIMAL
#0
BN2BCD

TO

END

10

BCD

D =

0010H

255

D =

(A =

O00,

B =

10H)

(A =

02,

B =

55H)

(A =

00,

B =

00)

BCD

0255H

O BCD
D =

0000

IN

B

10

1B

BCDto binary conversion (BCD2BN)

7

1B BCD to binary conversion
(BCD2BN)
Converts one byte of BCD data to one byte of binary data.

Procedure The program masks off the more significant digit and
multiplies it by 10 using shifts. Note that 10 = 8 + 2, and multiplying by
8 or by 2 is equivalent to one or three right shifts, respectively, of the
more significant digit. The program then adds the product to the less
significant digit.

Entry conditions
BCD data in A

Exit conditions

Binary datain A

Examples

1.
2.

Data:

(A) = 9%.

Result:

(A) = 6316 = 9910

Data:

(A) = 2316

Result:

(A) = 1716 = 2310

Registers used

A,B, CC

Executiontime

46 cycles

Program size

18 bytes

8

Assembly language subroutines for the 6809

Data memory required

Title:

BCD

Name:

BCD2BN

Purpose:

Converts
bytes of

one byte of
binary data

Entry:

Register

A =

BCD

Exit:

Register

A =

Binary

data

18 bytes
1 byte on

stack

Registers

Used:

to

1 stack byte

Binary

Conversion

BCD

data

to

two

data

A,B,CC

Time:

46

cycles

Size:

Program
Data

HH
FF
HF
e+
+
F

BCD2BN:
*

*SHIFT
*
TFR
ANDA
LSRA
STA

UPPER

DIGIT

A,B
#$FO
78

RIGHT

TO

MULTIPLY

IT

BY

8

SAVE ORIGINAL BCD VALUE IN B
MASK OFF UPPER DIGIT
SHIFT RIGHT 1 BIT
SAVE UPPER DIGIT TIMES 8 ON STACK

*

*ADD
*
ANDB
ADDB
STB

UPPER

DIGIT

#S0F
pot
7798

TIMES

8 TO

LOWER

DIGIT

MASK OFF LOWER DIGIT
ADD LOWER DIGIT TO STACK
SAVE SUM ON STACK

VALUE

*

*SHIFT UPPER DIGIT TIMES 8 RIGHT TWICE
*THE RESULT IS UPPER DIGIT TIMES 2
*
LSRA
MULTIPLY HIGH DIGIT BY 2
LSRA
*
*UPPER DIGIT * 10 = UPPER DIGIT * 8 + UPPER DIGIT
*
ADDA
RTS

pot

SAMPLE

EXECUTION

+

*

ADD

STACK

VALUE

TO

TWICE

HIGH

* 2
DIGIT

1B

BCDto binary conversion (BCD2BN)

SC1B:
*CONVERT
LDA
JSR

O BCD TO
#0
BCD2BN

*CONVERT

99

LDA

#$99

JSR

BCD2BN

BCD

*CONVERT

23

LDA

#$23

JSR

BCD2BN

END

BCD

TO

O HEXADECIMAL

A =
63

HEXADECIMAL

A =
TO

17

00

63H

HEXADECIMAL
A =

17H

10

Assembly language subroutines for the 6809

1C Binary to hexadecimal ASCII conversion
(BN2HEX)
Converts one byte of binary data to two ASCII characters corresponding to the two hexadecimal digits.

Procedure The program masks off each hexadecimal digit separately
and converts it to its ASCII equivalent. This involves a simple addition
of 30i6 if the digit is decimal. If the digit is non-decimal, we must add an

extra 7 to bridge the gap between ASCII 9 (3916) and ASCII A (4116).

Entry conditions

Binary datain A

Exit conditions

ASCII version of more significant hexadecimal digit in A
ASCII version of less significant hexadecimal digit in B

Examples

1.

2.

Data:
Result:

(A)=FBie6
(A) = 4616 (ASCII F)
(B) = 4216 (ASCII B)

Data:

(A) =594¢6

Result:

(A) = 3516 (ASCII 5)

(B) = 3946 (ASCII 9)

Registers used

A,B, CC

Execution time
digit

37 cycles plus 2 extra cycles for each non-decimal

1C

Binary to hexadecimal ASCII conversion (BN2HEX)

Program size

27 bytes

Data memory required

Title:
Name:

Binary
BN2HEX

Purpose:

None

to

Converts
ASCII

Hex

ASCII

one

byte

of

binary

Entry:

Register

A =

Binary

data

Exit:

Register
Register

A =
B =

ASCII
ASCII

more
less

Registers

Used:

data

to

two

characters

significant
significant

digit
digit

A,B,CC

Time:

Approximately

Size:

Program

27

Data

None

37

cycles

bytes

OF
FF
HH
He
+e
HF
F
ee
+

BN2HEX:
*

*CONVERT

MORE

SIGNIFICANT

A,B

SAVE
MOVE

DIGIT

TO

ASCII

*

TFR
LSRA
LSRA
LSRA

AD30:

LSRA
CMPA

#9

BLS
ADDA

AD30
#7

ADDA

#'0

ORIGINAL BINARY VALUE
HIGH DIGIT TO LOW DIGIT

BRANCH
IF HIGH DIGIT
IS DECIMAL
ELSE ADD 7 SO AFTER ADDING
'O' THE
* CHARACTER WILL BE IN ‘'A'..'F'
ADD ASCII O TO MAKE A CHARACTER

*

*CONVERT

LESS

SIGNIFICANT

DIGIT

TO

ASCII

*

AD30LD:

ANDB

#3$0F

CMPB
BLS
ADDB

#9
AD3OLD
#7

ADDB

#'0

RTS

MASK

OFF

LOW

DIGIT

BRANCH
IF LOW DIGIT
ELSE ADD 7 SO AFTER
* CHARACTER
WILL BE
ADD ASCII
O TO MAKE

IS DECIMAL
ADDING
'O! THE
IN '‘A'..'F!
A CHARACTER

11

12

Assembly language subroutines for the 6809

SAMPLE

EXECUTION

+&

SC1C:

*CONVERT
LDA
JSR

O TO ASCII
#0
BN2HEX

*CONVERT
LDA

FF HEXADECIMAL
#$ FF

JSR

*CONVERT
LDA
JSR
END

'O0'

BN2HEX

23 HEXADECIMAL
#$23
BN2HEX

*A='0'=30H,
TO

ASCII

'FF!

*A='F'=46H,

TO

ASCII

B='0'=30H

B='F'=46H

'23'

*A='2'=32H,

B='3'=33H

1D

Hexadecimal ASCII to binary conversion (HEX2BN)

13

1D Hexadecimal ASCII to binary conversion
(HEX2BN)
Converts two ASCII characters (representing two hexadecimal digits) to
one byte of binary data.

Procedure The program converts each ASCII character separately to a
hexadecimal digit. This involves a simple subtraction of 3015 (ASCII 0) if
the digit is decimal. If the digit is non-decimal, the program must subtract
another 7 to account for the gap between ASCII 9 (3916) and ASCII A
(4116). The program then shifts the more significant digit left four bit
positions and combines it with the less significant digit. The program does
not check the validity of the ASCII characters (i.e. whether they are
indeed the ASCII representations of hexadecimal digits).

Entry conditions

More significant ASCII digit in A, less significant ASCII digit in B

Exit conditions

Binary datain A

Examples

1.

Data:
Result:

2. Data:
Result:

(A) = 4446 (ASCII D)
(B) = 3716 (ASCII 7)
(A) = D7i6

(A) = 3116 (ASCII 1)
(B) = 4216 (ASCII B)
(A) = 1Bi¢

Registers used

A,B, CC

Execution time

39 cycles plus 2 extra cycles for each non-decimal digit

14

Assembly language subroutines for the 6809

Program size

25 bytes

Data memory required

Title:
Name:

Purpose:

1 stack byte

Hex ASCII
HEX2BN

to

Binary

Converts

two

ASCII

byte

of

binary

characters

Entry:

Register
Register

A
B

ASCII
ASCII

more
less

Exit:

Register

A =

Binary

data

Registers

to

one

data

significant
significant

digit
digit

A,B,CC

Used:

Time:

Approximately

39

cycles

Size:

Program
Data

25 bytes
1 byte on

SIGNIFICANT

DIGIT

stack

HKe
HE
+e
HF
+
Fe

*
*

CONVERT

MORE

TO BINARY

*

HEX2BN:

SHFTMS:

+

SUBA
CMPA
BLS
SUBA
LSLA
LSLA
LSLA
LSLA
CONVERT
SUBB
CMPB
BLS
SUBB

#'0
#9
SHFTMS
#7

LESS

SUBTRACT ASCII OFFSET CASCII 0)
CHECK IF DIGIT DECIMAL
BRANCH IF DECIMAL
ELSE SUBTRACT OFFSET FOR LETTERS
SHIFT DIGIT TO MORE SIGNIFICANT BITS

SIGNIFICANT

#'0
#9
CMBDIG
#7

DIGIT

TO

BINARY

SUBTRACT ASCII OFFSET (ASCII 0)
CHECK IF DIGIT DECIMAL
BRANCH IF DECIMAL
ELSE SUBTRACT OFFSET FOR LETTERS

*
*

COMBINE

LESS

SIGNIFICANT,

MORE

SIGNIFICANT

DIGITS

SAVE

LESS

SIGNIFICANT

DIGIT

*

CMBDIG:

STB

,78

IN

STACK

1D

Hexadecimal ASCII to binary conversion (HEX2BN)

ADDA
RTS

pot

ADD

DIGITS

*
*

*

SAMPLE EXECUTION

*
*
S$C1D:
*CONVERT
LDA
LDB
JSR

ASCII
'C7'
#'C
#'7
HEX2BN

TO

*CONVERT
LDA
LDB
JSR

ASCII '2F'
#'2
#'F
HEX2BN

TO

*CONVERT
LDA
LDB
JSR

ASCII '2A'
#'2
#'A
HEX2BN

TO

END

C7?

HEXADECIMAL

A=C7H

2F

HEXADECIMAL

A=2FH

2A

A=2AH

HEXADECIMAL

16

Assembly language subroutines for the 6809

1E Conversion of a binary number to decimal ASCII
(BN2DEC)
Converts a 16-bit signed binary number into an ASCII string. The string
consists of the length of the number in bytes, an ASCII minus sign (if
needed), and the ASCII digit. Note that the length is a binary number,
not an ASCII number.
Procedure The program takes the absolute value of the number if it is
negative. The program then keeps dividing the absolute value by 10
until the quotient becomes 0. It converts each digit of the quotient to
ASCII by adding ASCII 0 and concatenates the digits along with an
ASCII minus sign (in front) if the original number was negative.

Entry conditions

Base address of output buffer in X
Value to convert in D (between —32 767 and +32 767)
Exit conditions
Order in buffer:

Length of the string in bytes (a binary number)
ASCII — (if original number was negative)
ASCII digits (most significant digit first)
oO

Examples
1.

Data:

Value to convert = 3EB7i¢

Result (in output buffer):
05 (number of bytes in buffer)
31 (ASCII 1)
36 (ASCII 6)
30 (ASCII 0)
35 (ASCII 5)
35 (ASCII 5)
1.e. 3EB71¢6

2.

Data:

=

16 05510

Value to convert = FFC81¢

1E

Conversion of a binary number to decimal ASCII (BN2DEC)

17

Result (in output buffer):
03 (number of bytes in buffer)
2D (ASCII —)
35 (ASCII 5)
36 (ASCII 6)
1.e. FFC81¢ = —5619, when considered

as a signed two’s complement number

Registers used _ All

Execution time
Program size

Approximately 1000 cycles
99 bytes

Data memory required 1 stack byte for each digit in the string. This
does not include the output buffer, which should be 7 bytes long.

Title:

Binary

Name:

BN2DEC

Purpose:

to Decimal

ASCII

Converts
to ASCII

a 16-bit
data

signed

Entry:

Register
Register

D
X

Exit:

The first byte of the buffer is the
Length, followed by the characters

Registers

Approximately

Size:

Program
Data

HH
He
FF
HK
HF
+
+

ORIGINAL
ABSOLUTE

99
up

number

Value to convert
Output buffer address

Used:

Time:

SAVE
TAKE

binary

1000

cycles

bytes
to 5 bytes

DATA IN BUFFER
VALUE IF DATA NEGATIVE

on

stack

18

Assembly language subroutines for the 6809

BN2DEC:

STD
BPL
LDD
SUBD

1,X
CNVERT
#0
1,X

SAVE DATA
BRANCH IF
ELSE TAKE

INITIALIZE

STRING

CLR

7X

DIVIDE BINARY
OF TEN

LENGTH

DATA

TO

IN BUFFER
DATA POSITIVE
ABSOLUTE VALUE

ZERO

STRING

LENGTH

BY

SUBTRACTING

10 BY

=

ZERO
POWERS

IV10:

LDY
FIND

#-1000
NUMBER

OF

START

QUOTIENT

THOUSANDS

IN

AT

-1000

QUOTIENT

THOUSD:

LEAY
SUBD
BCC
ADDD
+

FIND

1000,Y
#10000
THOUSD
#10000
NUMBER

OF

ADD 1000 TO QUOTIENT
SUBTRACT 10000 FROM DIVIDEND
BRANCH IF DIFFERENCE STILL POSITIVE
ELSE ADD BACK LAST 10000

HUNDREDS

IN

QUOTIENT

LEAY

-100,Y

START

NUMBER

OF

HUNDREDS

AT

-1

LEAY
SUBD
BCC
ADDD

100,Y
#1000
HUNDD
#1000

ADD 100 TO QUOTIENT
SUBTRACT 1000 FROM DIVIDEND
BRANCH IF DIFFERENCE STILL POSITIVE
ELSE ADD BACK LAST 1000

HUNDD:

+

FIND

NUMBER

OF

TENS

IN

QUOTIENT

LEAY

-10,Y

START

NUMBER

OF

TENS

AT

-1

LEAY
SUBD
BCC
ADDD

10,Y
#100
TENSD
#100

ADD 10 TO QUOTIENT
SUBTRACT 100 FROM DIVIDEND
BRANCH IF DIFFERENCE STILL
ELSE ADD BACK LAST 100

TENSD:

+

FIND

NUMBER

OF

ONES

IN

POSITIVE

QUOTIENT

LEAY

-1,Y

START

NUMBER

OF

ONES

AT

-1

LEAY
SUBD
BCC
ADDD
STB

1,Y
#10
ONESD
#10
,7s

INC

7X

ADD 1 TO QUOTIENT
SUBTRACT 10 FROM DIVIDEND
BRANCH IF DIFFERENCE STILL POSITIVE
ELSE ADD BACK LAST 10
SAVE REMAINDER IN STACK
*THIS IS NEXT DIGIT, MOVING LEFT
*LEAST SIGNIFICANT DIGIT GOES INTO STACK
*
FIRST
ADD 1 TO LENGTH BYTE

ONESD:

1E

Conversion ofa binary number to decimal ASCII (BN2DEC)

TFR
CMPD
BNE

Y,D
#0
DIV10

MAKE QUOTIENT INTO NEW
CHECK IF DIVIDEND ZERO
BRANCH IF NOT - DIVIDE

DIVIDEND
BY

10 AGAIN

CHECK IF ORIGINAL BINARY DATA WAS NEGATIVE
IF SO, PUT ASCII - AT FRONT OF BUFFER
+
+

LDA
LDB
BPL
LDB
STB
INC

,Xt+
7X
BUFLOAD
#'7X+
-2,X

GET LENGTH BYTE (NOT INCLUDING SIGN)
GET HIGH BYTE OF DATA
BRANCH IF DATA POSITIVE
OTHERWISE, GET ASCII MINUS SIGN
STORE MINUS SIGN IN BUFFER
ADD 1 TO LENGTH BYTE FOR SIGN

MOVE STRING OF DIGITS FROM STACK TO BUFFER
MOST SIGNIFICANT DIGIT IS AT TOP OF STACK
CONVERT DIGITS TO ASCII BY ADDING ASCII O
SF
+

BUFLOAD:
LDB
ADDB
STB
DECA
BNE
RTS

SAMPLE

pot
#'0
,X+
BUFLOAD

GET NEXT DIGIT FROM STACK,
CONVERT DIGIT TO ASCII
SAVE DIGIT IN BUFFER
DECREMENT BYTE COUNTER
LOOP IF MORE BYTES LEFT

MOVING

EXECUTION

+£
H
+

SC1E:

*CONVERT
LDD
LDX
JSR

*CONVERT
LDD
LDX
JSR

*CONVERT
LDD
LDX
JSR

BUFFER:

RMB
END

O TO ASCII
#0
#BUFFER
BN2DEC

'O'

D=0
X=BASE ADDRESS OF BUFFER
CONVERT
* BUFFER SHOULD CONTAIN
*
BINARY 1 (LENGTH)
*
ASCII O (STRING)
32767 TO ASCII '32767'
#32767
D=32767
#BUFFER
X=BASE ADDRESS OF BUFFER
BN2DEC
CONVERT
* BUFFER SHOULD CONTAIN
*
BINARY 5 (LENGTH)
*
ASCII 32767 (STRING)
-32767 TO ASCII '-32767'
#-32767
=-32767
#BUFFER
X=BASE ADDRESS OF BUFFER
BN2DEC
CONVERT
* BUFFER SHOULD CONTAIN
*
BINARY 6 (LENGTH)
*
ASCII - (SIGN)
*
ASCII 32767 (STRING)
7
7-BYTE BUFFER

RIGHT

19

20

Assembly language subroutines for the 6809

1F Conversion of ASCII decimal to binary
(DEC2BN)
Converts an ASCII string consisting of the length of the number (in
bytes), a possible ASCII + or — sign, and a series of ASCII digits to two
bytes of binary data. Note that the length is an ordinary binary number,
not an ASCII number.

Procedure The program checks if the first byte is a sign and skips over
it if it is. The program then uses the length of the string to determine the
leftmost digit position. Moving left to right, it converts each digit to
decimal (by subtracting ASCII 0), validates it, multiplies it by the
corresponding power of 10, and adds the product to the running total.
Finally, the program subtracts the binary value from zero if the string
started with a minus sign. The program exits immediately, setting the
Carry flag, if it finds something other than a leading sign or a decimal
digit in the string.

Entry conditions

Base address of string in X

Exit conditions

Binary value in D
The Carry flag is 0 if the string was valid; the Carry flag is 1 if the string
contained an invalid character.
Note that the result is a signed two’s complement 16-bit number.

Examples

1.

Data:

String consists of
04 (number of bytes in string)
31 (ASCII 1)
32 (ASCII 2)
33 (ASCII 3)
34 (ASCII 4)

Result:

(D) = 04D21¢ (binary data)

i.e. the number is + 123416

IF

Conversion of ASCII decimal to binary (DEC2BN)

21

1.€. +1234: = 04D216
2.

Data:

String consists of
06 (number of bytes in string)
2D (ASCII —)
33 (ASCII 3)
32 (ASCII 2)
37 (ASCII 7)
35 (ASCII 5)
30 (ASCII 0)
i.e. the number is —32 7504)

Result:

(D) = 801646 (binary data)
le. —32 75010 = 8012146

Registers used

A,B,CC, X,Y

Execution time Approximately
maximum of 125 cycles overhead
Program size

eee

60 cycles per ASCII

digit plus a

154 bytes

Data memory required

2 stack bytes

Special cases

1. If the string contains something other than a leading sign or a
decimal digit, the program returns with the Carry flag set to 1. The
result in D is invalid.
2. Ifthe string contains only a leading sign (ASCII + or ASCII —), the
program returns with the Carry flag set to 1 and a result of 0.

Title:
Name:

OF
Oe
+
FF
Fe

Decimal
DEC2BN

ASCII

to

Binary

Assembly language subroutines for the 6809

*

Purpose:

*
*
*

Converts ASCII
of binary data

characters

Entry:

Register

X =

Input

buffer

Exit:

Register D =
If no errors
Carry = 0
else
Carry = 1

Binary
then

data

to

two

bytes

address

*

*
x
*
*
*
*

*

Registers

Used:

ALL

*

*
*

Time:

Approximately 60 cycles per ASCII digit
plus a maximum of 125 cycles overhead

Size:

Program
Data

*

*
*

154 bytes
2 bytes

on

stack

*
*
*

*

SAVE

BUFFER

POINTER,

INITIALIZE

BINARY

VALUE

TO

ZERO

*

DEC2BN:
TFR
LDD

X,Y
#0

SAVE BUFFER POINTER TO EXAMINE SIGN
INITIALIZE
BINARY VALUE TO ZERO

PSHS

D

SAVE

BINARY

LDA

eX+

GET

BYTE

OF

ACTUAL

VALUE

ON

STACK

IS

SIGN

COUNT

*
*

CHECK

IF

FIRST

BYTE

STRING

*
LDB
CMPB
BEQ
CMPB
BEQ

2Xt+
#'STMSD
ot
STMSD

GET FIRST BYTE OF ACTUAL
CHECK IF IT IS ASCII BRANCH
IF IT IS
CHECK IF IT IS ASCII +
BRANCH
IF IT IS

STRING

*

*
*
*

FIRST BYTE IS NOT A SIGN
SET A FLAG, MOVE POINTER BACK TO START
INCREASE BYTE COUNT BY 1 SINCE NO SIGN

AT FIRST
INCLUDED

DIGIT

*
CLR
LEAX

-2,K
-1,X

INDICATE NO SIGN IN BUFFER
MOVE POINTER BACK TO FIRST

INCA

ADD

START
COULD

CONVERSION
AT MOST
BE UP TO SIX BYTES

1 TO

BYTE

DIGIT

COUNT

*

*
*

SIGNIFICANT
DIGIT
INCLUDING
SIGN

*

STMSD:

CMPA
BEQ
CMPA
BEQ
CMPA
BEQ
CMPA

#6
TENKD
#5
ONEKD
#4
HUNDD
#3

LOOK FOR 10000'S DIGIT
BRANCH IF FOUND
LOOK FOR 1000'S DIGIT
BRANCH IF FOUND
LOOK FOR 100'S DIGIT
BRANCH IF FOUND
LOOK FOR TENS DIGIT

IN

BUFFER

LATER

1F

Conversion of ASCII decimal to binary (DEC2BN)

BEQ
CMPA
BEQ
BRA

TENSD
#2
ONESD
ERREXIT

BRANCH IF FOUND
LOOK FOR ONES DIGIT
BRANCH IF FOUND
NO DIGITS, INDICATE

CONVERT 10000'S DIGIT TO BINARY
10000 = 40*250
NOTE: MUL CANNOT MULTIPLY BY MORE

THAN

ERROR

255

ENKD:

LDB
JSR
CMPB
BHI
LDA
MUL
LDA
MUL
ADDD
STD

Xt
CHVALD
#3
ERREXIT
#40
#250

GET 10000'S ASCII DIGIT
CONVERT TO BINARY, CHECK
CHECK IF DIGIT TOO LARGE
TAKE ERROR EXIT IF IT IS
MULTIPLY BY 10000 IN TWO
FIRST MULTIPLY BY 40
THEN MULTIPLY BY 250

a)
7s

ADD PRODUCT
SAVE SUM ON

TO BINARY
STACK

CONVERT 1000'S DIGIT TO BINARY
1000 = 4*250
NOTE: MUL CANNOT MULTIPLY BY MORE

THAN

VALIDITY

STEPS

VALUE

255

FH
HE
&
+

ONEKD:
LDB
JSR
LDA
MUL
LDA
MUL
ADDD
STD
CONVERT

Xt
CHVALD
#4
#250

GET 1000'S ASCII DIGIT
CONVERT TO BINARY, CHECK VALIDITY
MULTIPLY BY 1000 IN TWO STEPS
FIRST MULTIPLY BY 4
THEN MULTIPLY BY 250

a)
a)

ADD PRODUCT
SAVE SUM ON

100'°S

DIGIT

TO

TO BINARY
STACK

VALUE

BINARY

HUNDD:
LDB
JSR
LDA
MUL
ADDD
STD
CONVERT

Xt
CHVALD
#100

GET 100'S ASCII DIGIT
CONVERT TO BINARY, CHECK
MULTIPLY BY 100

a)
79

ADD PRODUCT
SAVE SUM ON

TENS

DIGIT

TO

TO BINARY
STACK

VALIDITY

VALUE

BINARY

TENSD:
LDB
JSR
LDA
MUL
ADDD
STD
CONVERT

Xt
CHVALD
#10
a)
79
ONES

DIGIT

GET 10'S ASCII DIGIT
CONVERT TO BINARY, CHECK VALIDITY
MULTIPLY BY 10
!
ADD PRODUCT TO BINARY VALUE
SAVE SUM ON STACK
TO

BINARY

23

24

Assembly language subroutines for the 6809

ONESD:
LDB
JSR
CLRA
ADDD
STD
*
*
*

CHECK

*
*
*

*
*
*
VALEXIT:

Xt
CHVALD
78
)
FOR

MINUS

LDB
BEQ
LDB
CMPB
BNE

7Y
VALEXIT
1,Y
#'VALEXIT

NEGATIVE

NUMBER,

LDD
SUBD
STD

#0
79
a)

EXIT

WITH

PULS
CLC
RTS
*
*
*
ERREXIT:

ERROR

GET ONES ASCII DIGIT
CONVERT TO BINARY, CHECK VALIDITY
EXTEND TO 16 BITS
ADD DIGIT TO BINARY VALUE
SAVE SUM ON STACK

D

PULS
SEC
RTS

SO

SUBTRACT

VALUE

FROM

ZERO

SUBTRACT

VALUE

FROM

ZERO

VALUE

NEGATIVE

IN

SET

CARRY

AS

BYTE

VALUE

D

RETURN TOTAL
CLEAR CARRY,

-

D

CHECK IF THERE WAS A SIGN
BRANCH IF NO SIGN
GET SIGN BYTE
CHECK IF IT IS ASCII BRANCH IF IT ISN'T

SAVE

BINARY

EXIT

SIGN

FLAG

TO

IN D
INDICATING

RETURN

RETURN TOTAL
SET CARRY TO

NO

ERROR

IN D
INDICATE

ERRORS

CONDITION

ERROR

RHI III III III III III IIIT III KKK KERR RRA KAI IAAI AREER ERE
KKK
*ROUTINE: CHVALD
*PURPOSE: CONVERTS ASCII TO DECIMAL, CHECKS VALIDITY OF DIGITS
*ENTRY: ASCII DIGIT IN B
*EXIT: DECIMAL DIGIT IN B, EXITS TO ERREXIT IF DIGIT INVALID
*REGISTERS USED: B,CC
FI III II III IIIT III III HII IKEA ERE RRR EKR RIKER ERA ERERERAKRK KK KEK
CHVALD:
SUBB
#'0
CONVERT TO DECIMAL BY SUBTRACTING
BCS
EREXIT
BRANCH IF ERROR (VALUE TOO SMALL)
CMPB
#9
CHECK IF RESULT IS DECIMAL DIGIT
BHI
EREXIT
BRANCH IF ERROR (VALUE TOO LARGE)
RTS
RETURN DECIMAL DIGIT IN B
EREXIT:
LEAS
2,8
REMOVE RETURN ADDRESS FROM STACK
BRA
ERREXIT
LEAVE VIA ERROR EXIT

SAMPLE
+

EXECUTION

ASCII

0

1F

Conversion of ASCII decimal to binary (DEC2BN)

SC1F:

$1:
Se:

$3:

*CONVERT
LDX
JSR

ASCII "1234" TO 04D2 HEX
#S$1
X=BASE ADDRESS
DEC2BN
D=04D2 HEX

*CONVERT
LDX
JSR

*CONVERT
LDX
JSR
FCB
FCC
FCB
FCC
FCB
FCC
END

OF

$1

ASCII '+32767' TO
#S2
X=BASE
DEC2BN
D=7FFF

7FFF HEX
ADDRESS OF
HEX

S2

ASCII '-32768' TO
#83
X=BASE
DEC2BN
D=8000

8000 HEX
ADDRESS OF
HEX

$3

4

11234/
6
1+32767/
6
/-32768/

25

Array manipulation
and indexing

2A Memory fill
(MFILL)
Places a specified value in each byte of a memory area of known size,
starting at a given address.

Procedure The program simply fills the memory area with the value
one byte at a time.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Value to be placed in memory
More significant byte of area size (in bytes)
Less significant byte of area size (in bytes)
More significant byte of base address
Less significant byte of base address

26

ZA

Memory fill (MFILL)

27

Exit conditions

The area from the base address through the number of bytes given by
the area size is filled with the specified value. The area thus filled starts
at BASE and continues through BASE+SIZE—1 (BASE is the base
address and SIZE is the area size in bytes).

Examples
1.

Data:

Value = FFi¢

Area size (in bytes) = 038016
Result:

2.

Data:

Result

Base address = 1AE04¢
FFy6 placed in addresses 1AE016— 1E5F1¢

Value = 12). (6809 operation code for NOP)
Area size (in bytes) = 1C654¢
Base address = E34Ci¢
1216 placed in addresses E34C,¢ — FFB01¢

Registers used

A,CC, X,Y

Execution time

14 cycles per byte plus 38 cycles overhead

Program size

18 bytes

Data memory required

None

Special cases
1.

A size of 0000,6 is interpreted as 10000,.. It therefore causes the

program to fill 65 536 bytes with the specified value.
2. Filling areas occupied or used by the program itself will cause
unpredictable results. Obviously, filling the stack area requires special
caution, since the return address is saved there.

Assembly language subroutines for the 6809

Title:

Memory

Name:

MFILL

Purpose:

Fills

Entry:

TOP

Fill

an

OF

area

of

memory

with

a value

STACK

High byte of return address
Low byte of return address
Value to be placed in memory
High byte of area size in bytes
Low byte of area size in bytes
High byte of base address
Low byte of base address
Exit:

Area

Registers

Used:

filled

with

value

A,CC,U,X

Time:

14

cycles

Size:

Program

per
18

FROM

byte

plus

38

cycles

overhead

bytes

OBTAIN

PARAMETERS

STACK

PULS

Y

SAVE

PULS

A

GET

BYTE

LDX
STY
PULS

2,8
2,8
Y

GET
PUT
GET

BASE ADDRESS
RETURN ADDRESS
AREA SIZE

AT

A TIME

FILL:
RETURN

ADDRESS

TO

FILL

IN

Y

WITH

BACK

IN

*

x
*
FILLB:

FILL

MEMORY

ONE

STA
LEAY
BNE
RTS

7X+
-1,Y
FILLB

SAMPLE

EXECUTION

*
*FILL

BF1

BYTE

FILL ONE BYTE WITH VALUE
DECREMENT BYTE COUNTER
CONTINUE UNTIL COUNTER =

+¢
+

SC2A:

THROUGH

BF1+15

WITH

00

O

STACK

2A

Memory fill (MFILL)

29

*®

LDY
LDX
LDA
PSHS
JSR

#BF1
#S1ZE1
#0
A,X,Y
MFILL

BASE ADDRESS
NUMBER OF BYTES
VALUE TO FILL WITH
PUSH PARAMETERS
FILL MEMORY

*

*FILL
*
LDY
LDX
LDA
PSHS
JSR
SIZE1
SIZE2
BF1:
BF2:

EQU
EQU
RMB
RMB
END

BF2

THROUGH

BF2+1999

WITH

12

HEX

#BF2
#SIZE2
#$12
A,X,Y
MFILL

BASE ADDRESS
NUMBER OF BYTES
VALUE TO FILL WITH
PUSH PARAMETERS
FILL MEMORY

16
2000
SIZE1
SIZE2

SIZE OF BUFFER
SIZE OF BUFFER
BUFFER 1
BUFFER 2

(NOP'S

1 (10 HEX)
2 (07D0 HEX)

OPCODE)

30

Assembly language subroutines forthe 6809

2B Block move
(BLKMOV)
Moves a block of data from a source area to a destination area.

Procedure The program determines if the base address of the destination area is within the source area. If it is, then working up from the
base address would overwrite some

source data. To avoid this, the

program works down from the highest address (sometimes called a
move right). Otherwise, the program simply moves the data starting
from the lowest address (sometimes called a move left). An area size
(number of bytes to move) of 0000;6 causes an exit with no memory

changed. The program provides automatic address wraparound mod
64K.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of number of bytes to move
Less significant byte of number of bytes to move

More significant byte of base address of destination area
Less significant byte of base address of destination area

More significant byte of base address of source area
Less significant byte of base address of source area

Exit conditions

The block of memory is moved from the source area to the destination
area. If the number of bytes to be moved is NBYTES, the base address
of the destination area is DEST, and the base address of the source area

is SOURCE, then the data in addresses SOURCE through SOURCE +
NBYTES — 1 is moved to addresses DEST through DEST + NBYTES
— 1.

2B

Block move (BLKMOV)

31

Examples
1.

Data:

Result:

2.

Number of bytes to move = 02004¢
Base address of destination area = 05D14¢
Base address of source area = 035Ei¢
The contents of locations 035E;.-055Di¢ are moved to
05D 116 —O7D04¢.

Data:

Number of bytes to move = 1B7Aj¢

Result:

Base address of destination area = C9464.
Base address of source area = C3001,
The contents of locations C300; — DE791¢ are moved to
C946,6«-E4BF 16-

Note that Example 2 presents a more difficult problem than Example 1
because the source and destination areas overlap. If, for instance, the

program simply moved data to the destination area starting from the

lowest address, it would initially move the contents of C300,¢ to C946i6.
This would destroy the old contents of C946,¢, which are needed later in

the move. The solution to this problem is to move the data starting from
the highest address if the destination area is above the source area but
overlaps it.

Registers used

All

Execution time 20 cycles per byte plus 59 cycles overhead if data can
be moved starting from the lowest address (i.e. left); 95 cycles overhead
if data must be moved starting from the highest address (i.e. right)
because of overlap.

Program size

55 bytes

Data memory required

None

Special cases
1. A size (number of bytes to move) of 0 causes an immediate exit with
no memory changed.

32

Assembly language subroutines for the 6809

2. Moving data to areas occupied or used by the program itself or by
the stack will have unpredictable results.

Title:

Block

Name:

BLKMOV

Move

Purpose:

Move

Entry:

TOP

data
OF

from

source

to destination

STACK

High byte of return address
Low byte of return address
High byte of number of bytes to move
Low byte of number of bytes to move
High byte of base address of
destination area
Low byte of base address of
destination area
High byte of base address of source
area
Low byte of base address of source
area
Exit:

Data

Registers

Used:

moved

from

source

to

destination

ALL

Time:

20 cycles per byte
Overhead is: 59 cycles if no problem
overlap, 95 cycles if overlap

Size:

Program

EXIT

IMMEDIATELY

IF

55

AREA

with

bytes

SIZE

IS

0

wort
OF
HH
HK
FF
He
HF
+e
SH
FE
+
€
HH
LKMOV:

LDD
BEQ

2,8
BLKEXIT

GET AREA SIZE
RETURN IMMEDIATELY

IF

SIZE

IS

ZERO

DETERMINE IF DESTINATION AREA IS ABOVE SOURCE AREA AND
OVERLAPS IT (OVERLAP CAN BE MOD 64K).
OVERLAP OCCURS
IF BASE ADDRESS OF DESTINATION AREA MINUS BASE ADDRESS
OF SOURCE AREA (MOD 64K) IS LESS THAN NUMBER OF BYTES
TO MOVE
HF
+

LDD
SUBD

4,8
6,8

GET BASE
SUBTRACT

ADDRESS OF DESTINATION
BASE ADDRESS OF SOURCE

2B

Block move (BLKMOV)

33

CMPD
BLO

2,8
MVRIGHT

COMPARE DIFFERENCE TO AREA
BRANCH IF OVERLAP PROBLEM

SIZE

NO

SO

BLOCK

ADDRESS

*
*

OVERLAP

MOVE

STARTING

FROM

LOWEST

*

MVLEFT:

BYTEL:

PULS
LDU
STD
LDA
STA
LEAX
BNE
RTS

D,X,Y
a)
a)
,Ut+
7Yt+
-1,X
BYTEL

GET RETURN ADDRESS, SIZE, DESTINATION
GET SOURCE ADDRESS
PUT RETURN ADDRESS BACK IN STACK
GET NEXT BYTE FROM SOURCE
MOVE IT TO DESTINATION
DECREMENT BYTE COUNTER
CONTINUE UNTIL COUNTER = OQ

OVERLAP SO MOVE BLOCK STARTING
TO AVOID DESTROYING DATA

FROM

HIGHEST

ADDRESS

+
+

MVRIGHT:
LDD
ADDD
TFR
LDD
ADDD
TFR
PULS
LEAS
STD

4,8
2,8
D,Y
6,S
2,8
D,U
D,X
2,58
79

GET BASE ADDRESS OF DESTINATION
ADD LENGTH TO OBTAIN TOP ADDRESS
SAVE TOP ADDRESS OF DESTINATION
GET BASE ADDRESS OF SOURCE
ADD LENGTH TO OBTAIN TOP ADDRESS
SAVE TOP ADDRESS OF SOURCE
GET RETURN ADDRESS, SIZE
ADJUST STACK POINTER TO REMOVE EXTRA
PUT RETURN ADDRESS BACK IN STACK

LDA
STA
LEAX
BNE

,7U
,7Y
-1,X
BYTEL

GET NEXT BYTE FROM SOURCE
MOVE IT TO DESTINATION
DECREMENT BYTE COUNTER
CONTINUE UNTIL COUNTER = 0

BYTER:

BLKEXIT:
RTS

SAMPLE

EXECUTION

+

SRC1
SRC2
DEST
LEN

EQU
EQU
EQU
EQU

$1000
$2008
$2010
$11

BASE ADDRESS OF
BASE ADDRESS OF
BASE ADDRESS OF
NUMBER OF BYTES

FIRST SOURCE AREA
SECOND SOURCE AREA
DESTINATION AREA
TO MOVE

SC2B:

MOVE 11 HEX BYTES
DEMONSTRATES MOVE

FROM
LEFT

1000-1010 HEX TO 2010-2020
(LOWEST ADDRESS UP)

HEX

++
+

LDU
LDY
LDX
PSHS

#SRC1
#DEST
#LEN
U,X,Y

BASE ADDRESS OF
BASE ADDRESS OF
NUMBER OF BYTES
SAVE PARAMETERS

SOURCE AREA
DESTINATION
TO MOVE
IN STACK

AREA

BYTES

34

Assembly language subroutines for the 6809
JSR

BLKMOV

MOVE

DATA

FROM

SOURCE

TO

DESTINATION

MOVE 11 HEX BYTES FROM 2008-2018 HEX TO 2010-2020 HEX
DEMONSTRATES MOVE RIGHT CHIGHEST ADDRESS DOWN) SINCE
SOURCE AND DESTINATION AREAS OVERLAP AND DESTINATION
IS ABOVE SOURCE
HF
+

LDU
LDY
LDX
PSHS
JSR
END

#SRC2
#DEST
#LEN
U,X,Y
BLKMOV

BASE ADDRESS OF SOURCE AREA
BASE ADDRESS OF DESTINATION AREA
NUMBER OF BYTES TO MOVE
SAVE PARAMETERS IN STACK
MOVE DATA FROM SOURCE TO DESTINATION

2C

Two-dimensional byte array indexing (D2BYTE)

35

2C Two-dimensional byte array indexing
(D2BYTE)
Calculates the address of an element of a two-dimensional byte-length
array, given the array’s base address, the element’s two subscripts, and
the size of a row (i.e. the number of columns). The array is assumed to
be stored in row major order (i.e. by rows), and both subscripts are
assumed to begin at 0.
Procedure The program multiplies the row size (number of columns
in a row) times the row subscript (since the elements are stored by rows)
and adds the product to the column subscript. It then adds the sum to
the base address.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

More significant byte of column subscript
Less significant byte of column subscript

More significant byte of the size of a row (in bytes)
Less significant byte of the size of a row (in bytes)
More significant byte of row subscript
Less significant byte of row subscript
More significant byte of base address of array
Less significant byte of base address of array

Exit conditions
Address of element in X

Examples
1.

Data:

Base address = 3C00i¢

Column subscript = 0004;¢

36

Assembly language subroutines for the 6809

Size of row (number of columns) = 001816
Result:

Row subscript = 000316
Element address = 3C00;¢6 + 000316 X 0018:6 + 0004;6 =
3C00i6 + 004816 + 000416 = 3C4Ci¢

i.e. the address of ARRA Y(3,4) is 3C4Cj¢.
2.

Data:

Base address = 6A4A4¢6

Column subscript = 003716
Size of row (number of columns) = 005046
Row subscript = 000216
Result

Element address = 6A4Aj6 + 000216 X 005016 + 003716 =
6A4Ai6 + OOA016 + 003716 = 6B21146

i.e. the address of ARRAY(2,35) is 6B21 16.

Note that all subscripts are hexadecimal (e.g. 3716 = 5540).
The general formula is
ELEMENT ADDRESS = ARRAY BASE ADDRESS + ROW SUBSCRIPT xXROW SIZE + COLUMN SUBSCRIPT
Note that we refer to the size of the row subscript; this is the number of
consecutive memory addresses for which the subscript has the same
value. It is also the distance in bytes from the address of an element to
the address of the element with the same column subscript but a row
subscript 1 larger.

Registers used

CC, D, xX, Y

Execution time

Approximately 785 cycles

Program size

36 bytes

Data memory required

Title:
Name:

FH
HS
HF
&
+

None

Two-Dimensional
D2BYTE

Byte

Array

Indexing

2C

Two-dimensional byte array indexing (D2BYTE)

Purpo se:

37

Given the base address of a byte array,
two subscripts
'I' and 'J', and the size
of the first subscript in bytes, calculate
the address of ALI,J].
The array is assumed
to be stored in row major order (A{0,0],
ACO,1],...,ACK,L]), and both dimensions
are assumed to begin at zero as in the
following Pascal declaration:
A:ARRAYCO..2,0..7]

TOP

OF

OF

BYTE;

STACK

High byte of return address
Low byte of return address
High byte of second subscript (column element)
Low byte of second subscript (column element)
High byte of first subscript size, in bytes
Low byte of first subscript size, in bytes
High byte of first subscript (row element)
Low byte of first subscript
(row element)
High byte of array base address
Low byte of array base address
NOTE:

The first subscript
a row in bytes.
Exit:

Register

Regis ters

Used:

X =

Element

size

is

the

+

COLUMN

length

address

CC,D,X,Y

Time:

Approximately

Size:

Program

36

785

cycles

bytes

*

*ELEMENT ADDRESS = ROW SIZE*ROW
*
SUBSCRIPT + BASE ADDRESS
*

SUBSCRIPT

LDD
#0
START ELEMENT ADDRESS AT 0
LDY
#16
SHIFT COUNTER = 16
*
*MULTIPLY ROW SUBSCRIPT * ROW SIZE USING SHIFT AND
*
ADD ALGORITHM
*
MUL16:

LSR
ROR
BCC
ADDD

4,8
7S
LEFTSH
6,S

SHIFT HIGH BYTE OF ROW SIZE
SHIFT LOW BYTE OF ROW SIZE
JUMP IF NEXT BIT OF ROW SIZE IS 0
OTHERWISE, ADD SHIFTED ROW SUBSCRIPT
* TO ELEMENT ADDRESS

LSL
ROL

7,8
6,S

SHIFT
SHIFT

LEFTSH:
LOW BYTE OF ROW SUBSCRIPT
HIGH BYTE PLUS CARRY

of

38

Assembly language subroutines for the 6809
LEAY
-1,Y
DECREMENT SHIFT COUNTER
BNE
MUL16
LOOP 16 TIMES
*
*ADD COLUMN SUBSCRIPT TO ROW SUBSCRIPT * ROW SIZE
*
ADDD
2,8
ADD COLUMN SUBSCRIPT
ADDD
8,S
ADD BASE ADDRESS OF ARRAY
TFR
D,X
EXIT WITH ELEMENT ADDRESS IN X
*
*REMOVE PARAMETERS FROM STACK AND EXIT
*
PULS
D
GET RETURN ADDRESS
LEAS
6,S
REMOVE PARAMETERS FROM STACK
STD
79
PUT RETURN ADDRESS BACK IN STACK
RTS

SAMPLE

EXECUTION

&€
&
+

SC2c:
LDU
LDY
LDX
LDD
PSHS
JSR

#ARY
SUBS1
SSUBS1
SUBS2
U,X,Y,D
D2BYTE

BASE ADDRESS OF ARRAY
FIRST SUBSCRIPT
SIZE OF FIRST SUBSCRIPT
SECOND SUBSCRIPT
PUSH PARAMETERS
CALCULATE ADDRESS
*FOR
*X =

THE INITIAL TEST DATA
ADDRESS OF ARY(2,4)

*

ARY

+

(2%*8)

+

4

*
= ARY + 20 CCONTENTS
ARE
*NOTE BOTH SUBSCRIPTS
START

21)
AT O

*

*DATA
*
SUBS1:
SSUBS1:

FDB
FDB

SUBS2:

FDB
(3
FCB
FCB

*THE
ARY:

ARRAY

FCB
END

2
8

ROWS

SUBSCRIPT 1
SIZE OF SUBSCRIPT
* PER ROW)
4
SUBSCRIPT 2
OF 8 COLUMNS)
1,2,3,4,5,6,7,8
9,10,11,12,13,14,15,16

17,18,19,20,21,22,23,24

1 (NUMBER

OF

BYTES

2D

Two-dimensional word array indexing (D2WORD)

39

2D Two-dimensional word array indexing
(D2WORD)
Calculates the address of an element of a two-dimensional word-length
(16-bit) array, given the array’s base address, the element’s two subscripts, and the size of a row (i.e. the number of columns). The array is
assumed to be stored in row major order (i.e. by rows), and both
subscripts are assumed to begin at 0.

Procedure The program multiplies the row size (number of bytes in a
row) times the row subscript (since the elements are stored by rows),
adds the product to the doubled column subscript (doubled because
each element occupies 2 bytes), and adds the sum to the base address.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of column subscript
Less significant byte of column subscript

More significant byte of the size of a row (in bytes)
Less significant byte of the size of a row (in bytes)
More significant byte of row subscript
Less significant byte of row subscript
More significant byte of base address of array
Less significant byte of base address of array
Exit conditions

Base address of element in X
The element occupies the address in X and the next higher address

Examples

1.

Data:

Base address = 5E14i¢6
Column subscript = 000816

40

Assembly language subroutines for the 6809
Size of row (in bytes) = 001Cj¢ (i.e. each row has 00144
or 000E16 word-length elements)

Row subscript = 000516
Result:

Element base address = 5E14i6 + 000516 X 001Ci¢ +
000816 X 2 = 5E1446 + 008Ci¢ + 001016 = SEBO,6

i.e. the base address of ARRAY(5,8) is 5EBOi. and the
element occupies addresses 5EB0,. and SEB1\¢.
2.

Data:

Base address = B1001¢
Column subscript = 00021.

Size of row (in bytes) = 000816 (i.e. each row has four
word-length elements)
Result:

Row subscript = 00064¢
Element’s base address = B100;¢ + 000616 < 000816
+ 000216 X 2 = B100i6 + 003016 + 000446
= B134i6
i.e. the base address of ARRAY(6,2) is B134,6 and the
element occupies addresses B1341¢ and B1354¢.

The general formula is
ELEMENT’S BASE ADDRESS = ARRAY BASE ADDRESS
ROW SUBSCRIPT xX ROW SIZE + COLUMN SUBSCRIPT x 2

+

Note that one parameter of this routine is the size of a row in bytes. The
size for word-length elements is the number of columns per row times 2
(the size of an element in bytes). The reason for choosing this parameter
rather than the number of columns or the maximum column index is
that it can be calculated once (when the array bounds are determined)
and used whenever the array is accessed. The alternative parameters
(number of columns or maximum column index) would require extra
calculations during each indexing operation.

Registers used

CC,D, X, Y

Execution time

Approximately 790 cycles

Program size

38 bytes

2D

Two-dimensional word array indexing (D2WORD)

Data memory required

41

None

Title:
Name:

Two-Dimensional
D2WORD

Word

Purpose:

Given the base address of a word array,
two subscripts
'I' and 'J', and the size
of the first subscript in bytes, calculate
the address of ALI,J].
The array is assumed
to be stored in row major order (AC0,0],
ACO,11,...,ACK,L1),
and both dimensions
are assumed to begin at zero as in the
following Pascal declaration:
A:ARRAYLO..2,0..7]

Entry:

Array

OF

Indexing

WORD;

TOP OF STACK
High byte of return address
Low byte of return address

High byte of second subscript
(column element)
Low byte of second subscript (column element)
High byte of first subscript size, in bytes
Low byte of first subscript size, in bytes
High byte of first subscript (row element)
Low byte of first subscript
(row element)
High byte of array base address
Low byte of array base address
NOTE:

The first subscript
a row in words * 2,
Exit:

Register

Registers

Used:

X =

size

Element's

base

is

the

length

address

CC,D,X,Y

Time:

Approximately

Size:

Program

38

790

cycles

bytes

FOF
OF
FHF
+e
He
KF
HF
KH
Fe
F
+
F

D2WORD:
*

*ELEMENT ADDRESS = ROW SIZE*ROW SUBSCRIPT + 2*COLUMN
*
SUBSCRIPT + BASE ADDRESS
*
LDD
#0
START ELEMENT ADDRESS AT Q
LDY
#16
SHIFT COUNTER = 16
*
*MULTIPLY ROW SUBSCRIPT * ROW SIZE USING SHIFT AND
*
ADD ALGORITHM
*

of

42

Assembly language subroutines for the 6809

MUL16:

4,8
5,8
LEFTSH
6,S

LSR
ROR
BCC
ADDD

SHIFT HIGH BYTE OF ROW SIZE
SHIFT LOW BYTE OF ROW SIZE
JUMP IF NEXT BIT OF ROW SIZE IS QO
OTHERWISE, ADD SHIFTED ROW SUBSCRIPT
* TO ELEMENT ADDRESS

LEFTSH:
LSL
7,8
SHIFT LOW BYTE OF ROW SUBSCRIPT
ROL
6,S
SHIFT HIGH BYTE PLUS CARRY
LEAY
-1,Y
DECREMENT SHIFT COUNTER
BNE
MUL16
LOOP 16 TIMES
*
*ADD COLUMN SUBSCRIPT TWICE TO ROW SUBSCRIPT * ROW SIZE
*
ADDD
ADD COLUMN SUBSCRIPT
ADDD
ADD COLUMN SUBSCRIPT AGAIN
ADDD
ADD BASE ADDRESS OF ARRAY
TFR
EXIT WITH ELEMENT ADDRESS IN X
*
*REMOVE PARAMETERS FROM STACK AND EXIT
*
PULS
GET RETURN ADDRESS
LEAS
REMOVE PARAMETERS FROM STACK
STD
PUT RETURN ADDRESS BACK ON STACK
RTS

SAMPLE

EXECUTION

nm C2D:
+

#ARY
SUBS1
SSUBS1
SUBS2
U,X,Y,D
D2WORD

LDU
LDY
LDX
LDD
PSHS
JSR

BASE ADDRESS
OF ARRAY
FIRST SUBSCRIPT
SIZE OF FIRST SUBSCRIPT

SECOND

SUBSCRIPT

PUSH PARAMETERS
CALCULATE
ADDRESS
*FOR THE INITIAL TEST DATA
*X = ADDRESS OF ARY(2,4)

*

=

ARY

+

(2%*16)

+

4 *

2

*
= ARY + 40 (CONTENTS
ARE
*NOTE BOTH SUBSCRIPTS
START

2100H)
AT OQ

*

*DATA
*
SUBS1:
SSUBS1:

FDB
FDB

2
16

SUBS2:

FDB

4

*THE
ARY:

ARRAY

(3
FDB
FDB
FDB
END

ROWS

SUBSCRIPT 1
SIZE OF SUBSCRIPT
* PER ROW)
SUBSCRIPT 2

1 (NUMBER

OF

BYTES

OF 8 COLUMNS)
0100H,0200H,0300H,0400H,0500H,0600H,0700H,0800H
0900H,1000H,1100H,1200H,1300H,1400H,1500H,1600H
1700H,1800H,1900H,2000H,2100H,2200H,2300H,2400H

2E

N-dimensional array indexing (NDIM)

43

2E N-dimensional array indexing
(NDIM)
Calculates the base address of an element of an N-dimensional array
given the array’s base address and Npairs of sizes and subscripts. The
size of a dimension is the number of bytes from the base address of an
element to the base address of the element with an index 1 larger in the
dimension but the same in all other dimensions. The array is assumed to
be stored in row major order (i.e. by rows), and both subscripts are
assumed to begin at 0.
Note that the size of the rightmost subscript is simply the size of an
element in bytes; the size of the next subscript is the size of an element
times the maximum value of the rightmost subscript plus 1, and so on.
All subscripts are assumed to begin at 0. Otherwise, the user must
normalize them (see the second example at the end of the listing).

Procedure The program loops on each dimension, calculating the
offset in it as the subscript times the size. After calculating the overall
offset, the program adds it to the array’s base address to obtain the
element’s base address.

Entry Conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of number of dimensions
Less significant byte of number of dimensions
More significant byte of size of rightmost dimension
Less significant byte of size of rightmost dimension
More significant byte of rightmost subscript
Less significant byte of rightmost subscript

More significant byte of size of leftmost dimension
Less significant byte of size of leftmost dimension
More significant byte of leftmost subscript

Assembly language subroutines for the 6809

Less significant byte of leftmost subscript
More significant byte of base address of array
Less significant byte of base address of array

Exit conditions

Base address of element in X
The element occupies memory addresses START through START +
SIZE — 1, where START is the calculated address and SIZE is the size

of an element in bytes.
Example
Data:

Base address = 3C00i6
Number of dimensions = 000316

Rightmost subscript = 000516
Rightmost size = 000346 (3-byte entries)
Middle subscript = 000316
Middle size = 001216 (six 3-byte entries)
Leftmost subscript = 000416

Leftmost size = 007Ei¢ (seven sets of six 3-byte entries)
Result:

Element base address = 3C00i¢ + 000516 < 000316 + 000316 x
0012;6

+ 0004,6

K OO7Eig

=

3C00i6

+ OOOFi6

+ 003616

+

O1F816 = 3ECD 46,

i.e. the element

is ARRAY(4,3,5);

it occupies addresses

3E3D 16 — 3E3Fi6. (The maximum values of the various subs-

cripts are 6 (leftmost) and 5 (middle), with each element
occupying 3 bytes.)
The general formula is

ELEMENT BASE ADDRESS = ARRAY BASE ADDRESS +

‘>,SUBSCRIPT; x SIZE,
where:
N is the number of dimensions

SUBSCRIPT; is the ith subscript
SIZE; is the size of the ith dimension

Note that we use the size of each dimension as a parameter to reduce the
number of repetitive multiplications and to generalize the procedure.

2E

N-dimensional array indexing (NDIM)

45

The sizes can be calculated and saved as soon as the bounds of the array
are known. Those sizes can then be used whenever indexing is performed on the array. Obviously, the sizes do not change if the bounds
are fixed, and they should not be recalculated as part of each indexing
operation. The sizes are also general, since the elements can themselves
consist of any number of bytes.

Registers used

All

Execution time
cycles overhead

Approximately 720 cycles per dimension plus 67

Program size

49 bytes

Data memory required

None

Special case If the number of dimensions is 0, the program returns
with the base address in X.

HH
FF
He
FE
HF
+

Title:
Name:

N-Dimensional
NDIM

Array

Indexing

Purpose:

Calculate the address of an element in an
N-dimensional array given the base address,
N pairs of size in bytes and subscripts, and
the number of dimensions of the array.
The
array is assumed to be stored in row major
order (e.g., AL0,0,01,AL0,0,11,...,A00,1,0],
ACO,1,11,...).
Also, it is assumed that all
dimensions begin at O as in the following
Pascal declaration:
A:ARRAYLO..10,0..3,0..5] OF SOMETHING

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
High byte of number of dimensions

46

Assembly language subroutines for the 6809
Low byte of number of dimensions
High byte of dim N-1 size
Low byte of dim N-1 size
High byte of dim N-1 subscript
Low byte of dim N-1 subscript
High byte of dim N-2 size
Low byte of dim N-2 size
High byte of dim N-2 subscript
Low byte of dim N-2 subscript

High byte of array base address
Low byte of array base address
NOTE:

All

Exit:

sizes

Register

Registers

Used:

are

X =

in

bytes.

Element's

base

address

ALL

Time:

Approximately 720 cycles
67 cycles overhead

Size:

Program

49

per

dimension

plus

bytes

HH
HE
FH
He
FF
+e
HF
+
&

*
*

EXIT

IMMEDIATELY

IF

NUMBER

OF

DIMENSIONS

IS

ZERO

ZERO

DIMENSIONS

*

NDIM:
PULS
LDX

U
2,8

SAVE RETURN ADDRESS
GET BASE ADDRESS IF

LDY

pott

GET

BEQ

EXITNDIM

BRANCH

NUMBER

IF

OF

DIMENSIONS

NUMBER

OF

DIMENSIONS

IS

ZERO

SIZECI)*SUBSCRIPT(I)

FOR

*

*ELEMENT ADDRESS
*
I = 0 TO N-1

=

BASE

ADDRESS

+

*

LDD
#0
START ELEMENT ADDRESS AT ZERO
x
*MULTIPLY ROW SUBSCRIPT * ROW SIZE USING SHIFT AND
*
ADD ALGORITHM
*

NEXTDIM:
LDX

#16

SHIFT

COUNTER

=

16

LSR
ROR
BCC
ADDD

7S
1,8
LEFTSH
2,8

SHIFT HIGH BYTE OF ROW SIZE
SHIFT LOW BYTE OF ROW SIZE
JUMP IF NEXT BIT OF ROW SIZE IS 0
OTHERWISE, ADD SHIFTED ROW SUBSCRIPT

MUL16:

*

TO

ELEMENT

ADDRESS

SHIFT

LOW

OF

LEFTSH:
LSL

3,8

BYTE

ROW

SUBSCRIPT

2E

N-dimensional array indexing (NDIM)

ROL
LEAX
BNE

2,8
-1,X
MUL16

SHIFT HIGH BYTE
DECREMENT SHIFT
LOOP 16 TIMES

47

PLUS CARRY
COUNTER

*

*MOVE STACK POINTER PAST FINISHED DIMENSION
*
LEAS
4,8
REMOVE SIZE, SUBSCRIPT FROM STACK
*
*CONTINUE IF MORE DIMENSIONS LEFT
*
LEAY
-1,Y
DECREMENT NUMBER OF DIMENSIONS
BNE
NEXTDIM
BRANCH IF ANY DIMENSIONS LEFT
*
*ADD TOTAL OFFSET TO BASE ADDRESS OF ARRAY
*
ADDD
a)
ADD BASE ADDRESS OF ARRAY
TFR
D,X
MOVE ELEMENT ADDRESS TO X
EXITNDIM:
STU
RTS

SAMPLE

79

PUT

RETURN

ADDRESS

BACK

IN

STACK

EXECUTION

+
&

SC2E:

*
*CALCULATE ADDRESS OF AY1[£1,3,0]
*SINCE LOWER BOUNDS OF ARRAY 1 ARE
*
NOT NECESSARY TO NORMALIZE THEM
*
LDU
LDY
LDX
LDD
PSHS
LDU
LDY
LDX
LDD
PSHS
JSR

#AY1
#1
A1SZ1
#3
U,X,Y,D
#A1SZ2
#0
#A1S723
#A1DIM
U,X,Y,D
NDIM

ALL

ZERO,

BASE ADDRESS OF ARRAY
FIRST SUBSCRIPT
SIZE OF FIRST SUBSCRIPT
SECOND
SUBSCRIPT
PUSH PARAMETERS
SIZE OF SECOND
SUBSCRIPT
THIRD SUBSCRIPT
SIZE OF THIRD SUBSCRIPT
NUMBER OF DIMENSIONS
PUSH PARAMETERS
CALCULATE
ADDRESS
*AY = STARTING
ADDRESS OF

*
*

=
=

ARY + (1%*126)
ARY+189

+

IT

IS

ARY1(1,3,0)

(3%21)

+

(0*3)

*
*CALCULATE ADDRESS OF AY2C~-1,6]
* SINCE LOWER BOUNDS OF ARRAY 2 DO NOT START AT QO, SUBSCRIPTS
* MUST BE NORMALIZED
*
LDX
#AY2
BASE ADDRESS OF ARRAY
LDD
#-4
GET UNNORMALIZED FIRST SUBSCRIPT
SUBD
#A2D1L
NORMALIZE FIRST SUBSCRIPT (SUBTRACT
* LOWER BOUND

48

Assembly language subroutines for the 6809
PSHS
LDX
LDD
SUBD

D,X
#A2S71
#6
#A2D2L

PSHS
LDX
LDD
PSHS
JSR

D,X
#A2ST2
#A2DIM
D,X
NDIM

PUSH PARAMETERS
SIZE OF FIRST SUBSCRIPT
GET UNNORMALIZED SECOND SUBSCRIPT
NORMALIZE SECOND SUBSCRIPT (SUBTRACT
* LOWER BOUND
PUSH PARAMETERS
SIZE OF SECOND SUBSCRIPT
NUMBER OF DIMENSIONS
PUSH PARAMETERS
CALCULATE ADDRESS
*AY = STARTING ADDRESS OF AY2(-1,6)
*
AY2+00(-1)-(-5))*18)4+0(6-2)
*2)
*
= AY2+80

*DATA
*AY1 : ARRAYCA1D1L..A1D1H,A1D2L..A1D2H,A1D3L..A1D3H]
3-BYTE ELEMENTS
*
co
..
3
,
0
.
.5
,
0
..6
J
A1DIM
EQU
3
NUMBER OF DIMENSIONS
A1D1L
EQU
0
LOW BOUND OF DIMENSION 1
A1D1H
EQU
3
HIGH BOUND OF DIMENSION 1
A1D2L
EQu
0
LOW BOUND OF DIMENSION 2
A1D2H
EQU
5
HIGH BOUND OF DIMENSION 2
A1D3L
EQU
0
LOW BOUND OF DIMENSION 3
A1D3H
EQU
6
HIGH BOUND OF DIMENSION 3
A1SZ3
EQU
3
SIZE OF ELEMENT IN DIMENSION 3
A1SZ2
EQU
CCA1D3H-A1D3L)+1)*A1SZ3
SIZE OF ELEMENT IN D2
A1SZ1
EQU
CCA1TD2H-A1D2L)+1)*A1SZ2
SIZE OF ELEMENT IN D1
AY1:
RMB
CCATDIH-A1D1L)+1)*A1SZ1
ARRAY
*AY2 : ARRAY CA2D1L..A2D1H,A2D2L..A2D2H] OF WORD
*
C -5 «21
-1
,
2
«. 10
J
A2DIM
EQU
2
NUMBER OF DIMENSIONS
A2Dd1L
EQU
“5
LOW BOUND OF DIMENSION
A2D1H
EQU
-1
HIGH BOUND OF DIMENSION
A2Dd2L
EQU
2
LOW BOUND OF DIMENSION
A2D2H
EQU
10
HIGH BOUND OF DIMENSION
A2SZ2
EQU
2
SIZE OF
A2SZ1
EQU
CCA2D2H-A2D2L)+1)*A2SZ2
SIZE OF
AY2:
RMB
(CA2D1H-A2D1L)+1)*A2SZ1
ARRAY
END

1
1
2
2
ELEMENT
ELEMENT

IN D2
IN D1

3 Arithmetic

3A 16-bit multiplication
(MUL16)
Multiplies two 16-bit operands obtained from the stack and returns the
32-bit product in the stack. All numbers are stored in the usual 6809
style with their more significant bytes on top of the less significant bytes.
Procedure
The program multiplies each byte of the multiplier by
each byte of the multiplicand. It then adds the 16-bit partial products to
form a full 32-bit product.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of multiplier
Less significant byte of multiplier
More significant byte of multiplicand
Less significant byte of multiplicand

49

50

Assembly language subroutines for the 6809

Exit conditions
Order in stack (starting from the top)
More significant byte of more significant word of product
Less significant byte of more significant word of product

More significant byte of less significant word of product
Less significant byte of less significant word of product

Examples

1.

2.

Data:

Multiplier = 001216 (1810)

Result:

Multiplicand = 03D 116 (97710)
Product = 000044B2;¢ (17 586j0)

Data:

Multiplier = 37D116 (14289;0)
Multiplicand = A0454¢ (41 02949)

Result:

Product = 22F1AB551¢ (586 264 38110)

The more significant word of the product is incorrect if either operand is
a signed negative number. To handle this case, determine the product’s
sign and replace all negative operands with their absolute values (two’s
complements) before calling MUL16.
To reduce the product to a 16-bit value for compatibility with other
16-bit arithmetic operations, follow the subroutine call with

LEAS

2,8

DROP MORE SIGNIFICANT WORD

Of course, this makes sense only in cases (such as Example 1) in which
the more significant word is 0.

Registers used

CC,D,U,X

Execution time

Approximately 200 cycles

Program size

64 bytes

Data memory required

2 stack bytes

3A

16-bit multiplication (MUL 16)

51

Title:
Name:

16 Bit
MUL16

Multiplication

Purpose:

Multiply two unsigned 16-bit words
return a 32-bit unsigned product.

Entry:

TOP

OF

and

STACK

High byte of return address
Low byte of return address
High byte of multiplier
Low byte of multiplier
High byte of multiplicand
Low byte of multiplicand

Exit:

Product = multiplicand * multiplier
TOP OF STACK
High byte of high word of product
Low byte of high word of product
High byte of low word of product
Low byte of low word of product

Registers

Used:

CC,D,U,X

Time:

Approximately

Size:

Program
Data

200

cycles

64 bytes
2 stack bytes

HF
KH
+F
HF

MUL16:
*
*

CLEAR

PARTIAL

LDU
CLRA
CLRB
STD
PSHS

3

PRODUCT

IN

FOUR

STACK

BYTES

*

,9
D

SAVE RETURN ADDRESS
CLEAR 4-BYTE PARTIAL

PRODUCT

ON

USE BYTES OCCUPIED
PLUS 2 EXTRA BYTES

BY
ON

RETURN
TOP OF

ADDRESS
STACK

LOW

BYTE

*

*
*

MULTIPLY
LOW BYTE
OF MULTIPLICAND

OF

MULTIPLIER

TIMES

5,5
7,8

GET
GET

OF
OF

NW
.“nn

MULTIPLY BYTES
STORE LOW BYTE OF PRODUCT
STORE HIGH BYTE OF PRODUCT

*

LDA
LDB

MUL
STB
STA

*

MULTIPLY

LOW

BYTE

OF

LOW
LOW

BYTE
BYTE

MULTIPLIER

MULTIPLIER
MULTIPLICAND

TIMES

HIGH

BYTE

STACK

52

Assembly language subroutines for the 6809
OF

MULTIPLICAND

LDA
LDB
MUL
ADDB

GET LOW BYTE OF MULTIPLIER
GET HIGH BYTE OF MULTIPLICAND
MULTIPLY BYTES
ADD LOW BYTE OF PRODUCT TO
* PARTIAL PRODUCT

STB
ADCA

ADD HIGH BYTE OF PRODUCT
* TO PARTIAL PRODUCT

PLUS

STA

STORE

MULTIPLY HIGH BYTE
OF MULTIPLICAND

OF

LDA
LDB
MUL
ADDB

GET HIGH BYTE OF MULTIPLIER
GET LOW BYTE OF MULTIPLICAND
MULTIPLY BYTES
ADD LOW BYTE OF PRODUCT TO
* PARTIAL PRODUCT

HIGH

BYTE

MULTIPLIER

OF

TIMES

CARRY

PRODUCT
LOW

BYTE

&
+t

STB
ADCA

ADD HIGH BYTE OF PRODUCT
* TO PARTIAL PRODUCT

STA
BCC
INC

PLUS

CARRY

BRANCH IF NO CARRY
ELSE INCREMENT MOST SIGNIFICANT
* BYTE OF PARTIAL PRODUCT

MULTIPLY HIGH BYTE
OF MULTIPLICAND

OF

MULTIPLIER

TIMES

HIGH

BYTE

LDA
LDB
MUL
ADDB

GET HIGH BYTE OF MULTIPLIER
GET HIGH BYTE OF MULTIPLICAND
MULTIPLY BYTES
ADD LOW BYTE OF PRODUCT TO PARTIAL
* PRODUCT
ADD HIGH BYTE OF PRODUCT PLUS CARRY
* TO PARTIAL PRODUCT
* HIGH BYTES OF PRODUCT END UP IN D

+

MULHH:

ADCA

+

RETURN

WITH

32-BIT

LDX
LEAS
PSHS
JMP

SAMPLE
t+
+
&

SC3A:

PRODUCT

AT

TOP

OF

STACK

GET LOWER 16 BITS OF PRODUCT
REMOVE PARAMETERS FROM STACK
PUT 32-BIT PRODUCT AT TOP OF
EXIT TO RETURN ADDRESS

EXECUTION

FROM
STACK

STACK

3A

PRODMS:
PRODLS:

16-bit multiplication (MUL 16)

LDY
LDX
PSHS
JSR

#1023
#255
X,Y
MUL16

PULS
STX

X,Y
PRODMS

STY

PRODLS

RMB
RMB

2
2

53

GET MULTIPLICAND
GET MULTIPLIER
SAVE PARAMETERS IN STACK
16-BIT MULTIPLY
*RESULT OF 1023 * 255 = 260865
* = 0003FBO1 HEX
GET PRODUCT
IN MEMORY PRODMS
= OOH
*
PRODMS+1 = 03H
*
PRODLS
= FBH
*
PRODLS+1 = O1H
MORE SIGNIFICANT
LESS SIGNIFICANT

WORD OF PRODUCT
WORD OF PRODUCT

54

Assembly language subroutines for the 6809

3B 16-bit division
(SDIV16, UDIV16, SREM16, UREM16)
Divides two 16-bit operands obtained from the stack and returns either
the quotient or the remainder at the top of the stack. There are four
entry points: SDIV16 and SREM16 return a 16-bit signed quotient or
remainder, respectively, from dividing two 16-bit signed operands.
UDIV16 and UREM16 return a 16-bit unsigned quotient or remainder,
respectively, from dividing two 16-bit unsigned operands. All 16-bit
numbers are stored in the usual 6809 style with the more significant byte
on top of the less significant byte. The divisor is stored on top of the
dividend. If the divisor is 0, the Carry flag is set to 1 and the result is 0;
otherwise, the Carry flag is cleared.
Procedure If the operands are signed, the program determines the
signs of the quotient and remainder and takes the absolute values of all
negative operands. The program then performs an unsigned division
using a shift-and-subtract algorithm. It shifts the quotient and dividend
left, placing a 1 bit in the quotient each timea trial subtraction succeeds.
Finally, it negates (i.e. subtracts from zero) all negative results. The
Carry flag is cleared if the division is proper and set if the divisor is 0. A
0 divisor also causes a return with a result (quotient or remainder) of 0.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of divisor
Less significant byte of divisor
More significant byte of dividend
Less significant byte of dividend

Exit conditions
Order in stack starting from the top
More significant byte of result (quotient or remainder)
Less significant byte of result (quotient or remainder)
If the divisor is non-zero, Carry = 0 and the result is normal

3B

16-bit division (SDIV16, UDIV16, SREM16, UREM 16)

55

If the divisor is zero, Carry = 1 and the result is 0000,¢.

Examples
1.

Data:

Result:

Dividend = 03E016 = 99216
Divisor = 00B616 = 18216

Quotient (from UDIV16) = 0005;6
Remainder (from UREM16) = 005216 = 008210

Carry = 0 (no divide-by-0 error)
2.

Data:

Dividend = D73Ai6 = —10 43810
Divisor = O2F1i6 = 75310

Result:

Quotient (from SDIV16) = FFF3i6 = —1340

Remainder (from SREM16) = FD77i¢6 = —64949
Carry = 0 (no divide-by-zero error)
Note that this routine produces a signed remainder. Its sign is the same
as that of the dividend. To convert a negative remainder into an unsigned one, simply subtract 1 from the quotient and add the divisor to the
remainder. The result of Example 2 is then
Quotient

= FFF 216 =

—1410

Remainder (always positive) = 006816 = 1044

Registers used

A,B,CC, X, Y

Execution time: A maximum of 955 cycles plus an overhead of 10
(UREM16), 2 (UDIV16), 119 (SREM16), or 103 (SDIV16) cycles.
Execution time depends on how many trial subtractions are successful
and thus require the replacement of the previous dividend by the
remainder. Each successful trial subtraction takes 9 extra cycles.
Program size

145 bytes

Data memory required

3 stack bytes

Special case If the divisor is 0, the program returns with the Carry
flag set to 1 and a result (quotient or remainder) of 0.

Assembly language subroutines for the 6809 |

oro

Title:
Name:

16-Bit Division
SDIV16, UDIV16,

Purpose:

SDIV16
Divide
return

SREM16,

2 signed
a 16-bit

UREM16

16-bit
signed

words and
quotient.

UDIV16

Divide
return

2 unsigned 16-bit
a 16-bit unsigned

words and
quotient

SREM16
Divide 2 signed 16-bit words and
return a 16-bit signed remainder
UREM16

Divide
return

2 unsigned 16-bit
a 16-bit unsigned

words and
remainder

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
High byte of divisor
Low byte of divisor
High byte of dividend
Low byte of dividend

Exit:

TOP

OF

STACK

High byte of result
Low byte of result
If

no

errors

then

Carry := 0
else
divide by zero error
Carry := 1
quotient
: = 0
remainder
: = 0
Registers

Used:

A,B,CC,X,Y

Time:

Approximately

Size:

Program
Data

FHF
HH
HS
HF
t+
KH
FH
+
e+
F
H
H

*
*SIGNED

DIVISION,

RETURNS

REMAINDER

955

cycles

145 bytes
3 stack

bytes

3B

16-bit division (SDIV16, UDIV16, SREM16, UREM16)

*

SREM16:
LDA
STA
BRA

#S$F F
278
CHKSGN

INDICATE
REMAINDER
TO BE
SAVE INDICATOR ON STACK
GO CHECK SIGNS

RETURNED

*

*SIGNED

DIVISION,

RETURNS

CLR

a79

QUOTIENT

*

SDIV16:
INDICATE

QUOTIENT

TO

BE

RETURNED

*
*IF

DIVISOR

*
THAT
*
CHKSGN:

IS

QUOTIENT

NEGATIVE,

IS

LDD
PSHS
LEAX
TST
BPL
SUBD
STD
COM
BRA

TAKE

ITS

ABSOLUTE

VALUE

AND

INDICATE

NEGATIVE

#0
D
5,8
7X
CHKDVD
7X
7X
1,$
CHKZRO

.

INDICATE QUOTIENT, REMAINDER POSITIVE
SAVE INDICATOR ON STACK
POINT TO DIVISOR
CHECK IF DIVISOR IS POSITIVE
BRANCH IF DIVISOR IS POSITIVE
ELSE TAKE ABSOLUTE VALUE OF DIVISOR
INDICATE

QUOTIENT

IS

NEGATIVE

*

*IF DIVIDEND IS
*
REMAINDER IS
*
CHKDVD:
LEAX
TST
BPL
LDD
SUBD
STD
COM
COM

NEGATIVE,
NEGATIVE,

TAKE ITS ABSOLUTE VALUE, INDICATE
AND INVERT SIGN OF QUOTIENT

2,X
7X
CHKZRO
#0
7X
7X
7S
1,8

THAT

POINT TO HIGH BYTE OF DIVIDEND
CHECK IF DIVIDEND IS POSITIVE
BRANCH IF DIVIDEND IS POSITIVE
ELSE TAKE ABSOLUTE VALUE OF DIVIDEND

INDICATE REMAINDER IS NEGATIVE
INVERT SIGN OF QUOTIENT

*

*UNSIGNED

16-BIT

DIVISION,

RETURNS

QUOTIENT

*

UDIV16:
CLR
BRA

278
CLRSGN

INDICATE

QUOTIENT

TO

BE

RETURNED

*

*UNSIGNED

16-BIT

DIVISION,

RETURNS

REMAINDER

*

UREM16:
LDA
STA

#SFF
7s

DIVISION,

INDICATE

LDD
PSHS

#0
D

INDICATE

REMAINDER

TO

BE

RETURNED

*

*UNSIGNED

QUOTIENT,

REMAINDER

BOTH

POSITIVE

*

CLRSGN:
INDICATE

QUOTIENT,

REMAINDER

POSITIVE

57

58

Assembly language subroutines for the 6809

*CHECK FOR ZERO DIVISOR
*EXIT, INDICATING ERROR, IF FOUND
*
CHKZRO:
LEAX
57S
POINT TO DIVISOR
LDD
7X
TEST DIVISOR
BNE
STRTDV
BRANCH IF DIVISOR NOT ZERO
STD
2,X
DIVISOR IS ZERO, SO MAKE RESULT
SEC
INDICATE DIVIDE BY ZERO ERROR
BRA
EXITDV
EXIT INDICATING ERROR
*
*DIVIDE UNSIGNED 32-BIT DIVIDEND BY UNSIGNED 16-BIT DIVISOR
*MEMORY ADDRESSES HOLD BOTH DIVIDEND AND QUOTIENT.
EACH TIME WE
*
SHIFT THE DIVIDEND ONE BIT LEFT, WE ALSO SHIFT A BIT OF THE
*
QUOTIENT IN FROM THE CARRY AT THE FAR RIGHT
*AT THE END, THE QUOTIENT HAS REPLACED THE DIVIDEND IN MEMORY
*
AND THE REMAINDER IS LEFT IN REGISTER D
*
STRTDV:
LDD
#0
EXTEND DIVIDEND TO 32 BITS WITH
LDY
#16
BIT COUNT = 16
CLC
START CARRY AT ZERO
*

*SHIFT
*
DIV16:

32-BIT

DIVIDEND

ROL

3,X

ROL

2,X

LEFT

WITH

QUOTIENT

ENTERING

AT

FAR

RIGHT

SHIFT
LOW BYTE OF DIVIDEND
* QUOTIENT
BIT ENTERS
FROM CARRY
SHIFT NEXT BYTE OF DIVIDEND

ROLB

SHIFT

NEXT

BYTE

OF

DIVIDEND

ROLA

SHIFT

HIGH

BYTE

OF

DIVIDEND

*
*DO A TRIAL SUBTRACTION OF DIVISOR FROM DIVIDEND
*IF DIFFERENCE IS NON-NEGATIVE, SET NEXT BIT OF QUOTIENT.
*
PERFORM ACTUAL SUBTRACTION, REPLACING QUOTIENT WITH DIFFERENCE.
*IF DIFFERENCE IS NEGATIVE, CLEAR NEXT BIT OF QUOTIENT
*
CMPD
7X
TRIAL SUBTRACTION OF DIVISOR
BCS
CLRCRY
BRANCH IF SUBTRACTION FAILS
SUBD
7x
TRIAL SUBTRACTION SUCCEEDED,
* SO SUBTRACT DIVISOR FROM
* DIVIDEND
SEC
SET NEXT BIT OF QUOTIENT TO 1
BRA
DECCNT
CLRCRY:
CLC
TRIAL SUBTRACTION FAILED, SO
* SET NEXT BIT OF QUOTIENT TO O
*
*UPDATE BIT COUNTER
*CONTINUE THROUGH 16 BITS
*
DECCNT:
LEAY
-1,Y
CONTINUE UNTIL ALL BITS DONE
BNE
DIV16
*
*SHIFT LAST CARRY INTO QUOTIENT

ZERO

O

3B

16-bit division (SDIV16, UDIV16, SREM16, UREM 16)

ROL
ROL

3X
2,X

SHIFT LAST CARRY INTO QUOTIENT
INCLUDING MORE SIGNIFICANT BYTE

*
*SAVE REMAINDER IN STACK
*NEGATE REMAINDER IF INDICATOR
*
STD
7X
TST
79
BEQ
TSTQSN
LDD
#0
SUBD
7X
STD
7X

SHOWS

IT

IS

NEGATIVE

SAVE REMAINDER IN STACK
CHECK IF REMAINDER IS POSITIVE
BRANCH IF REMAINDER IS POSITIVE
ELSE NEGATE IT
SAVE

NEGATIVE

IT

IS

REMAINDER

*

*NEGATE
*
TSTQSN:

QUOTIENT

IF

TST
BEQ
LDD
SUBD
STD

INDICATOR

SHOWS

1,8
TSTRTN
#0
7,8
7,8

NEGATIVE

CHECK IF QUOTIENT IS POSITIVE
BRANCH IF QUOTIENT IS POSITIVE
ELSE NEGATE IT
SAVE

NEGATIVE

QUOTIENT

*

*SAVE QUOTIENT
*
TSTRITN:
CLC
TST
BEQ
LDD
STD

OR

REMAINDER,

DEPENDING

ON

FLAG

IN

STACK

INDICATE NO DIVIDE-BY-ZERO ERROR
TEST QUOTIENT/REMAINDER FLAG
BRANCH TO RETURN QUOTIENT
REPLACE QUOTIENT WITH REMAINDER

2,8
EXITDV
7X
7,8

*

*REMOVE
*

PARAMETERS

FROM

LDX
LEAS
JMP

3,8
7,8
7x

STACK

AND

EXIT

EXITDV:
SAVE RETURN ADDRESS
REMOVE
PARAMETERS
FROM
EXIT TO RETURN ADDRESS

STACK

*
*

*

SAMPLE

EXECUTION

*
*

SC3B:
*

*SIGNED
*

DIVIDE,

LDY
LOX
PSHS
JSR
PULS
STX

OPRND1

/ OPRND2,

OPRND1
OPRND2
X,Y
SDIV16
X
QUOTNT

STORE

QUOTIENT

AT

QUOTNT

GET DIVIDEND
GET DIVISOR
SAVE PARAMETERS IN STACK
SIGNED DIVIDE, RETURN QUOTIENT
GET QUOTIENT
RESULT OF -1023 / 123 = -8
* IN MEMORY QUOTNT
= FF HEX

59

60

Assembly language subroutines for the 6809
*

QUOTNT

+

1 =

F8

HEX

*

*UNSIGNED

DIVIDE,

OPRND1

/ OPRND2,

STORE

QUOTIENT

AT

QUOTNT

*

LDY
LDX
PSHS
JSR
PULS
STX

OPRND1
OPRND2
X,Y
UDIV16
X
QUOTNT

GET DIVIDEND
GET DIVISOR
SAVE PARAMETERS IN STACK
UNSIGNED DIVIDE, RETURN QUOTIENT
GET QUOTIENT
RESULT OF 64513 / 123 = 524
* IN MEMORY QUOTNT
= 02 HEX
*
QUOTNT + 1
OC HEX

*

*SIGNED

DIVIDE,

OPRND1

/ OPRDN2,

STORE

REMAINDER

AT

REMNDR

*

LDY
LDX
PSHS
JSR
PULS
STX

OPRND1
OPRND2
X,Y
SREM16
X
REMNDR

GET DIVIDEND
GET DIVISOR
SAVE PARAMETERS IN STACK
SIGNED DIVIDE, RETURN REMAINDER
GET REMAINDER
REMAINDER OF -1023 / 123 = -39
* IN MEMORY REMNDR
= FF HEX
*
REMNDR + 1
C7? HEX

*

*UNSIGNED

DIVIDE,

OPRND1

/ OPRND2,

STORE

REMAINDER

AT

REMNDR

*

*
*DATA
*
OPRND1
OPRND2
QUOTNT
REMNDR

LDY
LDX
PSHS
JSR
PULS
STX

OPRND1
OPRND2
X,Y
UREM16
X
REMNDR

GET DIVIDEND
GET DIVISOR
SAVE PARAMETERS IN STACK
UNSIGNED DIVIDE, RETURN REMAINDER
GET QUOTIENT
RESULT OF 64513 / 123 = 61
* IN MEMORY REMNDR
O00 HEX
*
REMNDR + 1
3D HEX

FDB
FDB
RMB
RMB
END

-1023
123

DIVIDEND (64513
DIVISOR
QUOTIENT
REMAINDER

UNSIGNED)

3C

Multiple-precision binary addition (MPBADD)

61

3C Multiple-precision binary addition
(MPBADD
Adds two multi-byte unsigned binary numbers. Both are stored with
their least significant bytes at the lowest address. The sum replaces the
number with the base address lower in the stack. The length of the
numbers (in bytes) is 255 or less.

Procedure The program clears the Carry flag initially and adds the
operands one byte at a time, starting with the least significant bytes. The
final Carry flag indicates whether the overall addition produced a carry.
A length of 0 causes an immediate exit with no addition.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes
More significant byte of base address of second operand (address containing the least significant byte of array 2)
Less significant byte of base address of second operand (address containing the least significant byte of array 2)

More significant byte of base address of first operand and sum (address
containing the least significant byte of array 1)
Less significant byte of base address of first operand and sum (address
containing the least significant byte of array 1)

Exit conditions

First operand (array 1) replaced by first operand (array 1) plus second
operand (array 2)

Example

Data: — Length of operands (in bytes) = 6
Top operand (array 2) = 19D028A193EAi6

62

Assembly language subroutines for the 6809

Result:

Bottom operand (array 1) = 293EABF059C74¢
Bottom operand (array 1) = Bottom operand (array 1) +
Top operand (array 2) = 430ED491EDB14,
Carry = 0

Registers used

A,B, CC, U, xX

Execution time 21 cycles per byte plus 36 cycles overhead.
example, adding two 6-byte operands takes

For

21 X 6 + 36 = 162 cycles

Program size

25 bytes

Data memory required

None

Special case A length of 0 causes an immediate exit with the sum
equal to the bottom operand (i.e. array 1 is unchanged). The Carry flag
is cleared.

HE
HF
He
+e
KH
te
+
F

Title:

Multiple-Precision

Name:

MPBADD

Purpose:

Add 2 arrays of
Array1
:= Array

Entry:

TOP

Binary

Addition

binary bytes
1 + Array 2

OF STACK
High byte of return address
Low byte of return address
Length of the arrays in bytes
High byte of array 2 address
Low byte of array 2 address
High byte of array 1 address
Low byte of array 1 address

The

arrays

are

unsigned

binary

numbers

3C Multiple-precision binary addition (MPBADD)

63

with a maximum Length of 255 bytes,
ARRAYLO]
is the least significant
byte, and ARRAYCLENGTH-1]
is the
most significant byte.
Array1

Exit:

Registers

Used:

:=

Array1l

+

Array2

A,B,CC,U,X

Time:

21

cycles

Size:

Program

per
25

byte

plus

36

cycles

overhead

bytes

HEH
HK
HF
Fe
F
ee
+

MPBADD:
*
*CHECK IF LENGTH
*EXIT WITH CARRY
*
CLC
2,8
LDB
ADEXIT
BEQ

*
*ADD
*
LDX
LDU

ARRAYS

ONE

OF ARRAYS IS ZERO
CLEARED IF IT IS
CLEAR CARRY TO START
CHECK LENGTH OF ARRAYS
BRANCH CEXIT) IF LENGTH
BYTE

AT

A TIME

5,S
3,8

GET
GET

BASE
BASE

/Ut+
7X
7Xt+

GET BYTE
ADD WITH
SAVE SUM

FROM ARRAY 2
CARRY TO BYTE
IN ARRAY 1

ADDBYT

CONTINUE

UNTIL

ALL

FROM

AND

EXIT

ADDRESS
ADDRESS

OF
OF

IS

ARRAY
ARRAY

ZERO

1
2

ADDBYT:
LDA
ADCA
STA
DECB
BNE
*
*REMOVE
*

PARAMETERS

STACK

BYTES

FROM

ARRAY

SUMMED

ADEXIT:
LDX
LEAS
JMP

7S
7,8
7X

SAMPLE

EXECUTION

SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

+

SC3C:
LDY
LDX
LDA

PSHS
JSR

AY1ADR
AY2ADR
#SZAYS
A,X,Y
MPBADD

GET FIRST OPERAND
GET SECOND OPERAND
LENGTH OF ARRAYS IN BYTES
SAVE PARAMETERS IN STACK
MULTIPLE~PRECISION BINARY ADDITION
*RESULT OF 12345678H + 9ABCDEFOH

1

Assembly language subroutines for the 6809
*

=

ACF13568H

*

IN

MEMORY

AY1

=

68H

*
*

AY1+1
AY1+2

=
=

35H
F1H

*

AY1+3

=

ACH

*

AY1+4

=

OOH

*

AY1+5

=

OOH

*

AY1+6

=

QOH

*

*
DATA
*
SZAYS

EQU

7

LENGTH

AY1ADR
AY2ADR

FDB
FDB

AY1
AY2

BASE
BASE

AY1:
AY2:

FCB
FCB

$78 ,$56,$34,$12,0,0,0
$FO,$DE,$BC,$9A,0,0,0

OF

ARRAYS

ADDRESS
ADDRESS

OF
OF

IN

BYTES

ARRAY
ARRAY

1
2

3D

Multiple-precision binary subtraction (MPBSUB)

65

3D Multiple-precision binary subtraction
(MPBSUB)
Subtracts two multi-byte unsigned binary numbers. Both are stored with
their least significant bytes at the lowest address. The subtrahend
(number to be subtracted) is stored on top of the minuend (number
from which it is subtracted). The difference replaces the minuend. The
length of the numbers (in bytes) is 255 or less.

Procedure The program clears the Carry flag initially and subtracts
the subtrahend from the minuend one byte at a time, starting with the
least significant bytes. The final Carry flag indicates whether the overall
subtraction required a borrow. A length of 0 causes an immediate exit
with no subtraction.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes
More significant byte of base address of subtrahend
Less significant byte of base address of subtrahend
More significant byte of base address of minuend
Less significant byte of base address of minuend
Exit conditions

Minuend replaced by minuend minus subtrahend

Example

Data:

Result:

— Length of operands (in bytes) = 4
Minuend = 2F5BA7C3i¢
Subtrahend = 14DF35B84¢
Muinuend = 1A7C720Bi¢

Carry = 0, since no borrow is necessary

66

Assembly language subroutines for the 6809
Registers used

A,B,CC, U, X

Execution time 21 cycles per byte plus 36 cycles overhead.
example, subtracting two 6-byte operands takes

For

21 X 6 + 36 = 162 cycles

Program size

25 bytes

Data memory required

None

Special case A length of 0 causes an immediate exit with the minuend
unchanged (i.e. the difference is equal to the minuend). The Carry flag
is cleared.

Title:

Multiple-Precision

Name:

MPBSUB

Binary

Subtraction

Purpose:

Subtract 2 arrays of
Minuend
:= Minuend -

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
Length of the arrays in bytes
High byte of subtrahend address
Low byte of subtrahend address
High byte of minuend address
Low byte of minuend address

binary bytes
Subtrahend

The arrays are unsigned binary numbers
with a maximum length of 255 bytes,
ARRAYCOJ is the least significant
byte, and ARRAYCLENGTH-1]
is the
most significant byte.
Exit:
Registers
Time:
OF
FH
HF
+
FF
HH
+
FF

Minuend
Used:

:=

Minuend

-

Subtrahend

A,B,CC,U,X
21

cycles

per

byte

plus

36

cycles

overhead

3D

Multiple-precision binary subtraction (MPBSUB)
Program

Size:

25

67

bytes

+
€
+

MPBSUB:
*

*CHECK IF LENGTH
*EXIT WITH CARRY
*
CLC
LDB
2,8
BEQ
SBEXIT

OF ARRAYS IS ZERO
CLEARED IF IT IS
CLEAR CARRY TO START
CHECK LENGTH OF ARRAYS
BRANCH CEXIT) IF LENGTH

IS

ZERO

*

*SUBTRACT
*

ARRAYS

ONE

BYTE

AT

A TIME

LDX
LDU

3,58
3,8

GET
GET

BASE
BASE

ADDRESS
ADDRESS

LDA
SBCA
STA
DECB
BNE

,U
7Xt+
7U+

GET BYTE OF MINUEND
SUBTRACT BYTE OF SUBTRAHEND
SAVE DIFFERENCE IN MINUEND

SUBBYT

CONTINUE

UNTIL

ALL

FROM

AND

EXIT

OF
OF

SUBTRAHEND
MINUEND

SUBBYT:

BYTES

WITH

BORROW

SUBTRACTED

*

*REMOVE
*

PARAMETERS

STACK

SBEXIT:

LDX
LEAS
JMP

7s
7,8
7X

SAMPLE

EXECUTION

SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

+¢
+
&

SC3D:
LDY
LDX
LDA
PSHS
JSR

*

DATA

AY1ADR
AY2ADR
#SZAYS
A,X,Y
MPBSUB

GET BASE ADDRESS OF MINUEND
GET BASE ADDRESS OF SUBTRAHEND
GET LENGTH OF ARRAYS IN BYTES
SAVE PARAMETERS IN STACK
MULTIPLE-PRECISION BINARY SUBTRACTION
*RESULT OF 2F3E4D5CH-175E809FH
*
= 17DFCCBDH
* IN MEMORY AY1
= BDH
*
AY1+1
= CCH
*
AY1+2
= DFH
*
AY1+3
= 17H
*
AY1+4
= OOH
*
AY1+5
= OOH
*
AY1+6
= OOH

68

Assembly language subroutines for the 6809

SZAYS

EQU

td

LENGTH

OF

AY1ADR
AY2ADR

FOB
FDB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AY2:

FCB
FCB

$5C,$4D,$3E,$2F,0,0,0
$9F,$80,$5E,$17,0,0,0

END

ARRAYS
OF
OF

IN

BYTES

ARRAY
ARRAY

1
2

3E

Multiple-precision binary multiplication (MPBMUL)

69

3E Multiple-precision binary multiplication
(MPBMUL)
Multiplies two multi-byte unsigned binary numbers. Both are stored
with their least significant byte at the lowest address. The product
replaces the multiplicand. The length of the numbers (in bytes) is 255 or
less. Only the less significant bytes of the product are returned to
provide compatibility with other multiple-precision binary operations.

Procedure The program multiplies the numbers one byte at a time,
Starting with the least significant bytes. It keeps a full double-length
unsigned partial product in memory locations starting at PPROD (more
significant bytes) and in the multiplicand (less significant bytes). The less
significant bytes of the product replace the multiplicand as it is shifted.
A length of 0 causes an exit with no multiplication.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes
More significant byte of base address of multiplicand
Less significant byte of base address of multiplicand
More significant byte of base address of multiplier
Less significant byte of base address of multiplier

Exit conditions

Multiplicand replaced by multiplicand times multiplier

Example

Data:

Result:

— Length of operands (in bytes) = 4
Multiplicand = = 0005D1F746 = 38143110
Multiplier = 0O000AB116 = 273710
Multiplicand = 3E39D1C71.6 = 1043976647,

70

Assembly language subroutines for the 6809

Note that MPBMUL returns only the less significant bytes (i.e. the
number of bytes in the multiplicand and multiplier) of the product to
maintain compatibility with other multiple-precision binary arithmetic
operations. The more significant bytes of the product are available
Starting with their least significant byte at address PPROD. The user
may need to check those bytes for a possible overflow.

Registers used

All

Execution time Depends on the length of the operands and on the
number of non-zero bytes in the multiplicand. If all bytes in the multiplicand are non-zero, the execution time is approximately

90 x LENGTH? + 90 x LENGTH + 39
If, for example, the operands are 4 bytes (32 bits) long, the execution
time is approximately
90 x 16 + 90 X 4 + 39 = 1440 + 360 + 39 = 1839 cycles

There is a saving of 90 x LENGTH cycles for each multiplicand byte
that is 0.
Program size

96 bytes

Data memory required 256 bytes anywhere in RAM for the more
significant bytes of the partial product (starting at address PPROD).
This includes an overflow byte. Also 2 stack bytes.

Special case A length of 0 causes an immediate exit with the product
equal to the multiplicand. The Carry flag is cleared.

Title:
Name:

t+
HF
€
+

Purpo

se:

Multiple-Precision
MPBMUL

Binary

Multiply

of binary

2 arrays

Multiplication

bytes

3E

Multiple-precision binary multiplication (MPBMUL)

*

Multiplicand

:=

Multiplicand

71

* multiplier

*

*

TOP OF STACK
High byte of return address
Low byte of return address
Length of the arrays in bytes
High byte of multiplicand address
Low byte of multiplicand address
High byte of multiplier address
Low byte of multiplier address

Entry:

*
*
*
*

*

*
*

The arrays are unsigned binary numbers
with a maximum Length of 255 bytes,
ARRAYLO]
is the least significant
byte, and ARRAYCLENGTH-1]
is the
most significant byte.

*
*
*
*
*

*

*

Multiplicand

Exit:

:=

Multiplicand

* multiplier

*
*

Registers

ALL

Used:

*

*

Time:

Assuming all multiplicand bytes are non-zero,
then the time is approximately:
(90 * lLength*2) + (90 * length) + 39 cycles

Size:

Program
Data

*
*

*
*
*

96 bytes
256 bytes

plus

2 stack

bytes

*
*

MPBMUL:
*
*
*
*

CHECK LENGTH OF OPERANDS
EXIT IF LENGTH IS ZERO
SAVE LENGTH FOR USE AS LOOP

COUNTER

*

LDB
BEQ
PSHS
LEAS

2,8
EXITML
B
-1,8

GET ARRAY LENGTH
EXIT (RETURN) IF LENGTH IS ZERO
SAVE LENGTH AS MULTIPLICAND BYTE COUNTER
RESERVE SPACE FOR MULTIPLICAND BYTE

*
*
*

CLEAR PARTIAL
OVERFLOW)

PRODUCT

AREA

(COPERAND

LENGTH

PLUS

1 BYTE

*

LDX
CLRA

#PPROD

POINT TO
GET ZERO

STA
DECB
BNE

7Xt+

CLEAR

CLRPRD

CONTINUE

PARTIAL PRODUCT
FOR CLEARING

AREA

CLRPRD:

BYTE

OF

PARTIAL

PRODUCT

UNTIL

ALL

BYTES

LOOP OVER ALL MULTIPLICAND BYTES
MULTIPLYING EACH ONE BY ALL MULTIPLIER

BYTES

*
*
*
*

PROCBT:

LDU

5,5

POINT

TO

MULTIPLICAND

CLEARED

FOR

72

Assembly language subroutines for the 6809
LDA
STA
BEQ

,U
79
MOVBYT

MULTIPLY BYTE
MULTIPLIER

OF

GET NEXT BYTE OF MULTIPLICAND
SAVE NEXT BYTE OF MULTIPLICAND
SKIP MULTIPLICATION IF BYTE IS

MULTIPLICAND

TIMES

EACH

BYTE

ZERO

OF

e+
+
e

MULSTP:
LDB
CLRA
TFR
LDY
LDX

4,8

GET LENGTH OF OPERANDS IN BYTES
SAVE AS 16-BIT LOOP COUNTER IN
REGISTER U
POINT TO PARTIAL PRODUCT
POINT TO MULTIPLIER

D,U
#PPROD
7,8

MULLUP:
LDA
LDB
MUL
ADDB
STB
ADCA
STA
BCC
CLRA

Xt
7s

GET NEXT BYTE OF MULTIPLIER
GET CURRENT BYTE OF MULTIPLICAND
MULTIPLY
ADD RESULT TO PREVIOUS PRODUCT

7
7Yt+
rv
7X
DECCTR

BRANCH IF ADDITION DOES
OTHERWISE, RIPPLE CARRY

NOT

PRODUCE

CARRY

OVRFL:
INCA
INC
BEQ

A,Y
OVRFL

MOVE ON TO NEXT BYTE
INCREMENT NEXT BYTE
BRANCH IF CARRY KEEPS

LEAU
BNE

-1,U
MULLUP

DECREMENT BYTE COUNT
LOOP UNTIL MULTIPLICATION

RIPPLING

DECCTR:

MOVE LOW BYTE OF PARTIAL PRODUCT
THIS OVERWRITES THE MULTIPLICAND
LATEST MULTIPLICATION LOOP

INTO
BYTE

DONE

RESULT AREA
USED IN THE

+
e

MOVBYT:
LDX
LDY
LDB
STB
STX
*

SHIFT

LDB

5,58
#PPROD
rv
7Xt+
5,58
PARTIAL

POINT TO MULTIPLICAND AND RESULT
POINT TO PARTIAL PRODUCT AREA
GET BYTE OF PARTIAL PRODUCT
STORE IN ORIGINAL MULTIPLICAND
SAVE UPDATED MULTIPLICAND POINTER

PRODUCT

RIGHT

ONE

BYTE

4,58

GET

1,Y

GET NEXT BYTE OF PARTIAL
MOVE BYTE RIGHT
DECREMENT BYTE COUNT
CONTINUE UNTIL ALL BYTES
CLEAR OVERFLOW

LENGTH

OF

OPERANDS

IN

BYTES

SHFTRT:
LDA
STA
DECB
BNE
CLR
*

COUNT
DEC
BNE

7Y+

SHFTRT
yal
MULTIPLICAND
1,8
PROCBT

PRODUCT

SHIFTED

DIGITS
DECREMENT DIGIT COUNTER
CONTINUE THROUGH ALL MULTIPLICAND

DIGITS

3E

Multiple-precision binary multiplication (MPBMUL)

LEAS

2,8

REMOVE

PARAMETERS

LDU
LEAS
JMP

REMOVE

TEMPORARIES

FROM

STACK

79
7,Ss
,U

SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

256

PARTIAL

WITH

73

*
*

FROM

STACK

AND

EXIT

*

EXITML:

DATA
PROD:

RMB

SAMPLE

PRODUCT

BUFFER

OVERFLOW

BYTE

EXECUTION

UO
&
+
¢

SC3E:

LDX
LDY
LDA
PSHS
JSR

AY1TADR
AY2ADR
#SZAYS
A,X,Y
MPBMUL

GET MULTIPLICAND
GET MULTIPLIER
LENGTH OF OPERANDS IN BYTESS
SAVE PARAMETERS IN STACK
MULTIPLE-PRECISION BINARY MULTIPLICATION
*RESULT OF 12345H * 1234H = 14B60404H
* IN MEMORY AY1
= O4H
*
AY1+1
= Q4H
*
AY1+2
= B6H
*
AY1+3
= 14H
*
AY1+4
= OOH
*
AY1+5
= OOH
*
AY1+6
= QOH

BRA

SC3E

CONTINUE

*
DATA
*
SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FDB
FDB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AY2:

FCB
FCB

$45,$23,$01,0,0,0,0
$34,$12,0,0,0,0,0

*

END

OPERANDS
OF
OF

IN

ARRAY
ARRAY

BYTES
1
2

74

Assembly language subroutines for the 6809

3F Multiple-precision binary division
(MPBDIV)
Divides two multi-byte unsigned binary numbers. Both are stored with
their least significant byte at the lowest address. The quotient replaces
the dividend, and the address of the least significant byte of the remainder ends up in register X. The length of the numbers (in bytes) is 255 or
less. The Carry flag is cleared if no errors occur; if a divide by 0 is
attempted, the Carry flag is set to 1, the dividend is left unchanged, and

the remainder is set to 0.

Procedure The program divides using the standard shift-and-subtract
algorithm, shifting quotient and dividend and placing a 1 bit in the
quotient each time a trial subtraction succeeds. An extra buffer holds
the result of the trial subtraction; that buffer is simply switched with the
buffer holding the dividend if the subtraction succeeds. The program
sets the Carry flag if the divisor is 0 and clears Carry otherwise.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes
More significant byte of base address of divisor
Less significant byte of base address of divisor

More significant byte of base address of dividend
Less significant byte of base address of dividend

Exit conditions

Dividend replaced by quotient (dividend divided by divisor).
If the divisor is non-zero, Carry = 0 and the result is normal.
If the divisor is 0, Carry = 1, the dividend is unchanged, and the
remainder is 0.
The remainder is stored starting with its least significant byte at the
address in X.

3F

Multiple-precision binary division (MPBDIV)

75

Example

Data:

— Length of operands (in bytes) = 3
Top operand (array 2 or divisor) = 000F4516 = 3909,

Bottom operand (array 1 or dividend) = 35A2F7,¢ =
351512710
Result:

Bottom operand (array 1) = Bottom operand (array 1) /
Top operand (array 2) = 00038316 = 899;

Remainder (starting at address in X) = 0003A816 = 93649
Carry flag = 0 to indicate no divide by zero error.

Registers used _ All

Execution time Depends on the length of the operands and on the
number of 1 bits in the quotient (requiring a replacement of the dividend
by the remainder). If the average number of 1 bits in the quotient is four
per byte, the execution time is approximately

400 x LENGTH? + 580 x LENGTH + 115 cycles"
where LENGTH is the length of the operands in bytes. If, for example,
LENGTH = 4 (32-bit division), the approximate execution time is

400 x 47 + 580 x 4 + 115 = 8835 cycles

Program size

137 bytes

Data memory required 514 bytes anywhere in RAM for the buffers
holding either the high dividend or the result of the trial subtraction (255
bytes starting at addresses HIDE1 and HIDE2, respectively), and for the
pointers that assign the buffers to specific purposes (2 bytes starting at
addresses HDEPTR and DIFPTR, respectively). Also 2 stack bytes.

Special cases

1. A length of 0 causes an immediate exit with the Carry flag cleared,
the quotient equal to the original dividend, and the remainder undefined.

76

Assembly language subroutines for the 6809
2. A divisor of 0 causes an exit with the Carry flag set to 1, the quotient
equal to the original dividend, and the remainder equal to 0.

Title:

Multiple-Precision

Name:

MPBDIV

Purpose:

Divide
Array1

2 arrays
:= Array

Entry:

TOP

STACK

OF

Binary

of binary
1 / Array

Division

bytes
2

High byte of return address
Low byte of return address
Length of arrays in bytes
High byte of divisor address
Low byte of divisor address
High byte of dividend address
Low byte of dividend address
The arrays are unsigned binary numbers
with a maximum length of 255 bytes,
ARRAYCO] is the least significant
byte, and ARRAYCLENGTH-1]
jis the
most significant byte.

Exit:

Array1 := Array1 / Array2
Register X = Base address of remainder
If no errors then
Carry := 0
else
divide-by-zero error
Carry := 1
quotient
:= array 1 unchanged
remainder
:= 0

Registers

Used:

ALL

Time:

Assuming there are length/2 1 bits in the
quotient then the time is approximately
(400 * Length"2) + (580 * Length) +
115 cycles

Size:

Program
Data

137
514

bytes
bytes

plus

2 stack

NO

IF

LENGTH

OF

OPERANDS

bytes

OF
FH
HF
FE
+F
HF
H
H

MPBDIV:

*

EXIT

INDICATING

ERROR

IS

ZERO

3F

Multiple-precision binary division (MPBDIV)

LDB
BEQ

2,8
GOODRT

TEST LENGTH OF OPERANDS
BRANCH (GOOD EXIT) IF LENGTH

77

IS

ZERO

SET UP HIGH DIVIDEND AND DIFFERENCE POINTERS
CLEAR HIGH DIVIDEND AND DIFFERENCE ARRAYS
ARRAYS 1 AND 2 ARE USED INTERCHANGEABLY FOR THESE TWO
PURPOSES.
THE POINTERS ARE SWITCHED WHENEVER A
TRIAL SUBTRACTION SUCCEEDS
HF
+¢
+

LDX
STX
LDU
STU
CLRA

#HIDE1
HDEPTR
#HIDE2
DIFPTR

GET BASE ADDRESS OF ARRAY 1
DIVIDEND POINTER = ARRAY 1
GET BASE ADDRESS OF ARRAY 2
DIFFERENCE POINTER = ARRAY 2
GET ZERO FOR CLEARING ARRAYS

STA
STA
DECB
BNE

7Xt+
,U+

CLEAR
CLEAR

CLRHI

CONTINUE

CLRHI:

CHECK
IF IT

BYTE
BYTE

OF
OF

ARRAY
ARRAY

THROUGH

1
2

ALL

BYTES

WHETHER DIVISOR IS ZERO
IS, EXIT INDICATING DIVIDE-BY-ZERO

ERROR

+

LDB
LDX

2,8
3,8

GET
GET

LENGTH OF OPERANDS
BASE ADDRESS OF DIVISOR

LDA
BNE
DECB
BNE
SEC

Xt
INITDV

EXAMINE BYTE OF DIVISOR
BRANCH IF BYTE IS NOT ZERO
CONTINUE THROUGH ALL BYTES

CHKZRO:

BRA

CHKZRO

DVEXIT

ALL BYTES ARE ZERO - INDICATE
* DIVIDE-BY-ZERO ERROR
EXIT

SET COUNT TO NUMBER OF
COUNT
(LENGTH * 8)

BITS

IN

THE

OPERANDS

NITDV:

LDB
LDA
MUL
PSHS
+

DIVIDE

2,8
#8

GET LENGTH OF OPERANDS IN
MULTIPLY LENGTH TIMES 8

BYTES

D

SAVE

STACK

USING

TRIAL

CLC

BIT

COUNT

AT

TOP

OF

SUBTRACTIONS

START

QUOTIENT

WITH

O BIT

SHFTST:
LDX
LDB

*
*
*
SHFTQU:

7,8
4,8

SHIFT

QUOTIENT

ROL
DECB

,X+

AND

POINT TO BASE
GET LENGTH OF

ADDRESS OF DIVIDEND
OPERANDS IN BYTES

LOWER

LEFT

DIVIDEND

ONE

BIT

SHIFT BYTE OF QUOTIENT/DIVIDEND
CONTINUE THROUGH ALL BYTES

LEFT

78

Assembly language subroutines for the 6809
BNE
SHIFT

+

SHFTQU
UPPER

DIVIDEND

LEFT

HDEPTR
4,8

LDX
LDB

WITH

CARRY

POINT TO BASE
GET LENGTH OF

FROM

LOWER

DIVIDEND

ADDRESS OF UPPER DIVIDEND
OPERANDS IN BYTES

SHFTRM:
ROL
DECB
BNE

SHIFT BYTE OF UPPER DIVIDEND
CONTINUE THROUGH ALL BYTES

Xt

LEFT

SHFTRM

TRIAL SUBTRACTION OF DIVISOR FROM DIVIDEND
SAVE DIFFERENCE IN CASE IT IS NEEDED LATER
+

LDU
LDX
LDY
LDB
CLC

DIFPTR
HDEPTR
5,8
4,8

POINT TO DIFFERENCE
POINT TO UPPER DIVIDEND
POINT TO DIVISOR
GET LENGTH OF OPERANDS IN
CLEAR BORROW INITIALLY

LDA
SBCA
STA
DECB
BNE

Xt
7Y¥+
,Ut+

GET BYTE OF UPPER DIVIDEND
SUBTRACT BYTE OF DIVISOR WITH
SAVE DIFFERENCE
CONTINUE THROUGH ALL BYTES

BYTES

SUBDVS:
BORROW
|

SUBDVS

NEXT BIT OF QUOTIENT IS 1 IF SUBTRACTION WAS SUCCESSFUL,
O IF IT WAS NOT
THIS IS COMPLEMENT OF FINAL BORROW FROM SUBTRACTION
+

BCC

RPLCDV

BRANCH IF SUBTRACTION WAS SUCCESSFUL,
* I.E., IT PRODUCED NO BORROW
OTHERWISE, TRIAL SUBTRACTION FAILED SO
* MAKE NEXT BIT OF QUOTIENT ZERO

CLC
BRA

SETUP

TRIAL SUBTRACTION SUCCEEDED, SO REPLACE
WITH DIFFERENCE BY SWITCHING POINTERS
SET NEXT BIT OF QUOTIENT TO 1

UPPER

DIVIDEND

PLCDV:

LDX
LDU
STU
STX
SEC

HDEPTR
DIFPTR
HDEPTR
DIFPTR

DECREMENT

16-BIT

LDX
LEAX
STX
BNE

7s
-1,8
79
SHFTST

GET
GET
NEW
USE
SET

BIT

HIGH DIVIDEND POINTER
DIFFERENCE POINTER
HIGH DIVIDEND = DIFFERENCE
OLD HIGH DIVIDEND FOR NEXT
NEXT BIT OF QUOTIENT TO 1

COUNT

BY

DIFFERENCE

1

SETUP:

SHIFT

LAST

CARRY

GET SHIFT
DECREMENT

COUNT
SHIFT

COUNT

BY

CONTINUE

UNLESS

SHIFT

COUNT

IF

NECESSARY

INTO

QUOTIENT

1
EXHAUSTED

3F

Multiple-precision binary division (MPBDIV)

79

LEAS
BCC
LDX
LDB

2,8
GOODRT
3,8
2,8

REMOVE SHIFT COUNTER FROM STACK
BRANCH IF NO CARRY
POINT TO LOWER DIVIDEND/QUOTIENT
GET LENGTH OF OPERANDS IN BYTES

ROL
DECB
BNE

7Xt+

SHIFT BYTE OF QUOTIENT
CONTINUE THROUGH ALL BYTES

LASTSH:

LASTSH

*

CLEAR

*

CARRY

TO

INDICATE

NO

ERRORS

*

GOODRT:
CLC

CLEAR

CARRY

-

NO

DIVIDE-BY-ZERO

ERROR

*

REMOVE

*

PARAMETERS

FROM

STACK

AND

EXIT

*

DVEXIT:

LDX
LDU
LEAS
JMP

HDEPTR
79
7,S
7U

GET BASE ADDRESS OF REMAINDER
SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM STACK
EXIT TO RETURN ADDRESS

POINTER TO HIGH DIVIDEND
POINTER TO DIFFERENCE BETWEEN
* DIVIDEND AND DIVISOR
HIGH DIVIDEND BUFFER 1
HIGH DIVIDEND BUFFER 2

*

DATA

*
*

HDEPTR:
DIFPTR:

RMB
RMB

2
2

HIDE1:
HIDE2:

RMB
RMB

255
255

SAMPLE

HIGH

EXECUTION

&
+

SC3F:

LDX
LDY
LDA
PSHS
JSR

AY1ADR
AY2ADR
#SZAYS
A,X,Y
MPBDIV

GET DIVIDEND
GET DIVISOR
LENGTH OF ARRAYS IN BYTES
SAVE PARAMETERS IN STACK
MULTIPLE-PRECISION BINARY DIVISION
*RESULT OF 14B60404H / 1234H = 12345H
*

BRA

*

DATA

SC3F

AY1

=

*

IN

MEMORY

AY1+1

=

45H

23H

*

AY1+2

=

O1H

*
*
*

AY1+3
AY1+4
AY1+5

=
=
=

OOH
OOH
OOH

*

AY1+6

=

OOH

80

Assembly language subroutines for the 6809

SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FDB
FOB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AY2:

FCB
FCB

$04,$04,$B86,$14,0,0,0,0
$34,$12,0,0,0,0,0,0

ARRAYS
OF
OF

IN

BYTES

ARRAY
ARRAY

1 (DIVIDEND)
2 (DIVISOR)

3G

Multiple-precision binary comparison (MPBCMP)

81

3G _ Multiple-precision binary comparison
(MPBCMP}.
Compares two multi-byte unsigned binary numbers and sets the Carry
and Zero flags. Sets the Zero flag to 1 if the operands are equal and to 0
otherwise. Sets the Carry flag to 1 if the subtrahend is larger than the
minuend and to 0 otherwise. Thus, it sets the flags as if it had subtracted
the subtrahend from the minuend.

Procedure The program compares the operands one byte at a time,
Starting with the most significant bytes and continuing until it finds
corresponding bytes that are not equal. If all the bytes are equal, it exits
with the Zero flag set to 1. Note that the comparison starts with the
operands’ most significant bytes, whereas the subtraction (Subroutine
3D) starts with the least significant bytes.
ac
Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Length of the operands in bytes
More significant byte of base address of subtrahend
Less significant byte of base address of subtrahend
More significant byte of base address of minuend
Less significant byte of base address of minuend

Exit conditions
Flags set as if subtrahend had been subtracted from minuend
Zero flag = 1 if subtrahend and minuend are equal, 0 if they are not
equal

Carry flag = 1 if subtrahend is larger than minuend in the unsigned
sense, 0 if it less than or equal to the minuend
nanan

82

Assembly language subroutines for the 6809
Examples

1.

Data:

Result:

2.

Data:

Length of operands (in bytes) = 6
Top operand (subtrahend) = 19D028A193EAi6
Bottom operand (minuend) = 4E67BC15A266i6
Zero flag = 0 (operands are not equal)
Carry flag = 0 (subtrahend is not larger than minuend)
Length of operands (in bytes) = 6
Top operand (subtrahend) = 19D028A193EA1¢
Bottom operand (minuend) = 19D028A193EAi¢6

Result:
3.

Data:

Zero flag = 1 (operands are equal)
Carry flag = 0 (subtrahend is not larger than minuend)
Length of operands (in bytes) = 6

Result:

Top operand (subtrahend) = 19D028A193EAj¢
Bottom operand (minuend) = 0F37E5991D7Ci6
Zero flag = 0 (operands are not equal)

Carry flag = 1 (subtrahend is larger than minuend)

Registers used

All

Execution time 20 cycles per byte that must be examined plus
approximately 47 cycles overhead. That is, the program continues until
it finds corresponding bytes that are not the same; each pair of bytes it
must examine requires 20 cycles. There is a savings of 5 cycles if it finds
unequal bytes.

Examples:

1.

Comparing two 6-byte numbers that are equal takes
20 X 6 + 47 = 167 cycles

2.

Comparing two 8-byte numbers that differ in the next to most
significant bytes takes
20 X 2 + 47 — 5 = 82 cycles

Program Size:

30 bytes

3G

Multiple-precision binary comparison (MPBCMP)

Data memory required

Special case

83

None

A length of 0 causes an immediate exit with both the

Carry flag and the Zero flag set to 1.

Title:
Name:

Multiple-Precision

Purpose:

Compare 2 arrays
return the Carry
cleared

Entry:

TOP

Binary

Comparison

MPBCMP

OF

of binary bytes and
and Zero flags set or

STACK

High byte of return address
Low byte of return address
Length of operands in bytes
High byte of subtrahend address
Low byte of subtrahend address
High byte of minuend address
Low byte of minuend address
The arrays are unsigned binary numbers
with a maximum Length of 255 bytes,
ARRAYCO] is the least significant
byte, and ARRAYCLENGTH-1]
is the
most significant byte.
Exit:

IF

minuend = subtrahend THEN
C=0,Z=1
IF minuend > subtrahend THEN
C=0,Z=0
IF minuend < subtrahend THEN
C=1,Z=0
IF array length = O THEN
C=1,Z=1

Registers

Used:

ALL

Time:

20

Size:

Program

cycles per byte that
47 cycles overhead
30

must

be

examined

bytes

OHF
HN
HF
FH
KH
He
+

CHECK IF LENGTH OF ARRAYS IS ZERO
EXIT WITH SPECIAL FLAG SETTING (C=1,
+
+

Z=1)

IF

IT

IS

plus

84

Assembly language subroutines for the 6809

MPBCMP:
LDU
SEC
LDB
BEQ

a)
2,8
EXITCP

COMPARE ARRAYS
BYTES COMPARED

BYTE

SAVE RETURN ADDRESS
SET CARRY IN CASE LENGTH IS 0
GET LENGTH OF ARRAYS IN BYTES
BRANCH CEXIT) IF LENGTH IS ZERO
* C=1,Z=1 IN THIS CASE
AT

A TIME

UNTIL

UNEQUAL

BYTES

ARE

FOUND

+
€
+

LDX
LDY
LEAX
LEAY

GET BASE ADDRESS
GET BASE ADDRESS
DETERMINE ENDING
DETERMINE ENDING

LDA
CMPA
BNE
DECB
BNE

GET BYTE FROM MINUEND
COMPARE TO BYTE FROM SUBTRAHEND
BRANCH CEXIT) IF BYTES ARE NOT EQUAL

OF MINUEND
OF SUBTRAHEND
ADDRESS OF MINUEND
ADDRESS OF SUBTRAHEND

CMPBYT:

CMPBYT

REMOVE PARAMETERS
BE CAREFUL NOT TO

CONTINUE UNTIL ALL BYTES COMPARED
* IF PROGRAM FALLS THROUGH, THEN THE
* ARRAYS ARE IDENTICAL AND THE FLAGS
* SET PROPERLY (C=0,2=1)
FROM STACK AND EXIT
AFFECT FLAGS (PARTICULARLY

ZERO

ARE

FLAG)

&
t+
+
+

EXITCP:
LEAS
JMP

7,8

SAMPLE

EXECUTION

,U

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

&
+

SC3G:
LDX
LDY
LDA
PSHS
JSR

AY1ADR
AY2ADR
#SZAYS
A,X,Y
MPBCMP

GET BASE ADDRESS OF MINUEND
GET BASE ADDRESS OF SUBTRAHEND
GET LENGTH OF OPERANDS IN BYTES
SAVE PARAMETERS IN STACK
MULTIPLE-PRECISION BINARY COMPARISON
*RESULT OF COMPARE (2F3E4D5CH,175E809FH)
*
IS C=0,2=0

*
DATA
*
SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FDB
FDB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AY2:

FCB
FCB

$5€,$4D,$3E,$2F,0,0,0
$9F,$80,$5E,$17,0,0,0

*

END

OPERANDS
OF
OF

IN

ARRAY
ARRAY

BYTES
1
2

OR

ALL

3H

Multiple-precision decimal addition (MPDADD)

85

3H Miultiple-precision decimal addition
(MPDADD
Adds two multi-byte unsigned decimal (BCD) numbers. Both numbers
are stored with their least significant digits at the lowest address. The
sum replaces the number with the base address lower in the stack. The
length of the numbers (in bytes) is 255 or less.

Procedure The program clears the Carry flag initially and then adds
the operands one byte (two digits) at a time, starting with the least
significant digits. The final Carry flag indicates whether the overall
addition produced a carry. The sum replaces the operand with the base
address lower in the stack (array 1 in the listing). A length of 0 causes an
immediate exit with no addition.
meee

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes

More significant byte of base address of second operand (address containing the least significant byte of array 2)
Less significant byte of base address of second operand (address containing the least significant byte of array 2)

More significant byte of base address of first operand and sum (address
containing the least significant byte of array 1)
Less significant byte of base address of first operand and sum (address
containing the least significant byte of array 1)
Exit conditions

First operand (array 1) replaced by first operand (array 1) plus second
operand (array 2)
a
Example

Data: — Length of operands (in bytes) = 6
Top operand (array 2) = 1960288193151.6
Bottom operand (array 1) = 2934716059871.
Result: Bottom operand (array 1) = Bottom operand (array 1) +
Top operand (array 2) = 489500425302,.

en

Carry = 0

86

Assembly language subroutines for the 6809

Registers used

A,B,CC,U,X

Execution time 23 cycles per byte plus 36 cycles overhead.
example, adding two 6-byte operands takes

For

23 X 6 + 36 = 174 cycles

Program size

26 bytes

Data memory required

None

Special case A length of 0 causes an immediate exit with the sum
equal to the bottom operand (i.e. array 1 is unchanged). The Carry flag
is cleared.
Title:

Multiple-Precision

Name:

MPDADD

Purpose:

Add 2 arrays of
Array?
:= Array

Entry:

TOP

OF

Decimal

BCD bytes
1 + Array

Addition

2

STACK

High byte of return address
Low byte of return address
Length of the arrays in bytes
High byte of array 2 address
Low byte of array 2 address
High byte of array 1 address
Low byte of array 1 address
The arrays are unsigned BCD numbers
with a maximum length of 255 bytes,
ARRAYLO]
is the least significant.
byte, and ARRAYCLENGTH-1]
is the
most significant byte

Exit:

Array?

Registers

Used:

:=

Array1

+ Array2

A,B,CC,U,X

Time:

23

cycles

Size:

Program

per
26

byte

bytes

OHO
OH
OE
OF
oF
OOOOH
Ee
Fe
t
+

MPDADD:
*

*CHECK IF LENGTH
*EXIT WITH CARRY

OF ARRAYS IS ZERO
CLEARED IF IT IS

plus

36

cycles

overhead

3H

Multiple-precision decimal addition (MPDADD)

87

*®

CLC
LDB
BEQ

2,8
:
ADEXIT

CLEAR CARRY TO START
CHECK LENGTH OF ARRAYS
BRANCH CEXIT) IF LENGTH

IS

ZERO

*

*ADD
*

OPERANDS

2 DIGITS

AT

A TIME

.

LDX
LDU

5,S
3,8

GET
GET

BASE
BASE

ADDRESS
ADDRESS

OF
OF

ARRAY
ARRAY

LDA
ADCA
DAA
STA
DECB
BNE

,U+
7X
Xt

GET 2 DIGITS FROM ARRAY
ADD 2 DIGITS FROM ARRAY
MAKE ADDITION DECIMAL
SAVE SUM IN ARRAY 1

ADDBYT

CONTINUE

UNTIL

ALL

FROM

AND

EXIT

1
2

ADDBYT:
2
1 WITH

DIGITS

SUMMED

*

*REMOVE
*

PARAMETERS

STACK

ADEXIT:

+

LDX
LEAS
JMP

a)
7,8
7X

SAMPLE

EXECUTION

SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

SC3H:
LDY
LDX
LDA
PSHS
JSR

AY1ADR
AY2ADR
#SZAYS
A,X,Y
MPDADD

GET FIRST OPERAND
GET SECOND OPERAND
LENGTH OF OPERANDS
SAVE PARAMETERS IN
MULTIPLE-PRECISION

IN BYTES
STACK
BCD ADDITION

*RESULT OF 12345678H
* = 48259706H

+ 35914028H

*

AY1

=

06H

*
*
*
*

IN

MEMORY

AY1+1
AY1+2
AY1+3
AY1+4

=
=
=
=

97H
25H
48H
OOH

*

AY1+5

=

OOH

*

AY1+6

=

QOH

BRA

SC3H

REPEAT

TEST

*
DATA
*
SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FOB
FDB

AY1
AY2

BASE
BASE

AY1:
AY2:

FCB
FCB

$78,$56,$34,$12,0,0,0
$28,$40,$91,$35,0,0,0

*

OPERANDS

ADDRESS
ADDRESS

OF
OF

IN

ARRAY
ARRAY

BYTES
1
2

CARRY

88

Assembly language subroutines for the 6809

31 Multiple-precision decimal subtraction
(MPDSUB)
Subtracts two multi-byte unsigned decimal (BCD) numbers. Both are
stored with their least significant digits at the lowest address. The
subtrahend (number to be subtracted) is stored on top of the minuend

(number from which it is subtracted). The difference replaces the minuend. The length of the numbers (in bytes) is 255 or less.

Procedure The program first clears the Carry flag and then subtracts
the subtrahend from the minuend one byte (two digits) at a time,
starting with the least significant digits. It does the decimal subtraction
by forming the ten’s complement of the subtrahend and adding it to the
minuend. The final Carry flag indicates (in an inverted sense) whether
the overall subtraction required a borrow. A length of 0 causes an
immediate exit with no subtraction.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes

More significant byte of base address of subtrahend
Less significant byte of base address of subtrahend
More significant byte of base address of minuend
Less significant byte of base address of minuend

Exit conditions

Minuend replaced by minuend minus subtrahend

Example

Data: | Length of operands (in bytes) = 6
Minuend = 2934716059876
Subtrahend = 1960288193151.

3!

Multiple-precision decimal subtraction (MPDSUB)
Result:

89

Minuend = 0974427866721.

Carry = 1, since no borrow is necessary

Registers used

A,B, CC, U, X

Execution time 27 cycles per byte plus 36 cycles overhead.
example, subtracting two 6-byte operands takes

For

27 X 6 + 36 = 198 cycles

Program size

30 bytes

Data memory required

None

Special case Alength of 0 causes an immediate exit with the minuend
unchanged (i.e., the difference is equal to the minuend). The Carry flag
is set (1).

Title:

Multiple-Precision

Name:

MPDSUB

Purpose:

Subtract 2 arrays of BCD bytes
Minuend := Minuend - Subtrahend

Entry:

TOP

OF

Decimal

Subtraction

STACK

High byte of return address
Low byte of return address
Length of the operands in bytes
High byte of subtrahend address
Low byte of subtrahend address
High byte of minuend address
Low byte of minuend address
The arrays are unsigned BCD numbers with a
maximum length of 255 bytes, ARRAYLO]
is the
least significant byte, and ARRAYLCLENGTH-1]
the most significant byte.
OF
HH
SF
HF
He
+
€©
*

90
*

Assembly language subroutines for the 6809
Exit:

Minuend

: =

Minuend

-

Subtrahend

*

*

Registers

Used:

A,B,CC,U,X

*

*

Time:

27

cycles

Size:

Program

per

byte

plus

36

cycles

overhead

*

*

30

bytes

*
*
*

MPDSUB:
*

*CHECK
IF LENGTH
*EXIT WITH CARRY

OF ARRAYS
SET IF IT

IS
IS

ZERO

*

SEC
LDB

2,8

SET CARRY TO
CHECK LENGTH

BEQ

SBEXIT

BRANCH

START
OF ARRAYS

(CEXIT)

IF

LENGTH

IS

ZERO

*

*SUBTRACT
OPERANDS
2 DIGITS AT A TIME BY ADDING TEN'S
*
COMPLEMENT
OF SUBTRAHEND
TO MINUEND
*CARRY
IS INVERTED
BORROW
IN TEN'S COMPLEMENT
ARITHMETIC
*NOTE THAT DAA WORKS ONLY AFTER ADDITION
INSTRUCTIONS
*BYTE OF TEN'S COMPLEMENT
= 99 HEX + INVERTED
BORROW
*
- BYTE OF SUBTRAHEND.
RESULT
IS ALWAYS NON-NEGATIVE

*
*

AND CARRY AND HALF CARRY ARE ALWAYS
WITH SUBTRACTING BCD OPERANDS

0,

SO

NO

PROBLEM

*

LDX
LDU

5,5
3,8

GET
GET

BASE
BASE

LDA
ADCA
SUBA
ADDA

#$99
#0
/Ut+
7X

FORM
OF
ADD

rX+

MAKE
SAVE

SUBBYT

CONTINUE

ADDRESS
ADDRESS

OF
OF

MINUEND
SUBTRAHEND

SUBBYT:

DAA
STA

2 DIGITS OF
SUBTRAHEND
2 DIGITS

OF

10'S

COMPLEMENT

MINUEND

RESULT DECIMAL
DIFFERENCE OVER

MINUEND

DECB

BEQ

UNTIL

ALL

AND

EXIT

DIGITS

SUBTRACTED

*

*REMOVE

PARAMETERS

FROM

STACK

*

SBEXIT:
LDX
LEAS
JMP

9
7,8
Xx

SAVE RETURN ADDRESS
REMOVE PARAMETERS
FROM
EXIT TO RETURN ADDRESS

STACK

*
*

*

SAMPLE

EXECUTION

*
*

SC3I:

LDY

AY1ADR

GET

BASE

ADDRESS

OF

MINUEND

3!
LDX
LDA
PSHS
JSR

Multiple-precision decimal subtraction (MPDSUB)
AY2ADR
#SZAYS
A,X,Y
MPDSUB

GET BASE ADDRESS OF SUBTRAHEND
GET LENGTH OF OPERANDS IN BYTES
SAVE PARAMETERS IN STACK
MULTIPLE-PRECISION DECIMAL SUBTRACTION
*RESULT OF 28364150H-17598093H
*
= 10766057H
*
*

IN

MEMORY

AY1
AY1+1

=
=

57H
60H

76H
10H
OOH
OOH
OOH

*

AY1+2

=

*

AY1+3

=

*
*
*

AY1+4
AY1+5
AY1+6

=
=
=

BRA

SC3I

REPEAT

TEST

*
DATA
*
SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FDB
FDB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AYe:

FCB
FCB

$50,$41,$36,$28,0,0,0
$93 ,$80,$59,$17,0,0,0

*

END

OPERANDS
OF
OF

IN

ARRAY
ARRAY

BYTES
1
2

91

92

Assembly language subroutines for the 6809

3J Miultiple-precision decimal multiplication
(MPDMUL)
Multiplies two multi-byte unsigned decimal (BCD) numbers. Both
numbers are stored with their least significant digits at the lowest
address. The product replaces the multiplicand. The length of the
numbers (in bytes) is 255 or less. Only the less significant bytes of the
product are returned to provide compatibility with other multipleprecision decimal operations.
Procedure The program handles each digit of the multiplicand separately. It masks the digit off, shifts it (if it is the upper digit of a byte), and
then uses it as a counter to determine how many times to add the
multiplier to the partial product. The least significant digit of the partial
product is saved as the next digit of the full product, and the partial
product is shifted right 4 bits. The program uses a flag to determine
whether it is currently working with the upper or lower digit of a byte. A
length of 0 causes an exit with no multiplication.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes
More significant byte of base address of multiplicand
Less significant byte of base address of multiplicand
More significant byte of base address of multiplier
Less significant byte of base address of multiplier

Exit conditions

Multiplicand replaced by multiplicand times multiplier

Example

Data:

Length of operands (in bytes) = 4

3J

Multiple-precision decimal multiplication (MPDMUL)

Result:

93

Multiplicand = 00035181.
Multiplier = 00006294.
Multiplicand = 221422826,,

Note that MPDMUL returns only the less significant bytes (i.e. the
number of bytes in the multiplicand and multiplier) of the product to
maintain compatibility with other multiple-precision decimal arithmetic
operations. The more significant bytes of the product are available
starting with their least significant byte at address PROD. The user may
have to check those bytes for a possible overflow or extend the operands
with additional zeros.
eee

Registers used

All

Execution time Depends on the length of the operands and on the size
of the digits in the multiplicand (since those digits determine how many
times the multiplier must be added to the partial product). If the average
digit in the multiplicand has a value of 5, then the execution time is
approximately
170 x LENGTH? + 370 x LENGTH + 80 cycles

where LENGTH is the number of bytes in the operands. If, for example,
LENGTH =6 (12 digits), the approximate execution time is

170 x 67 + 370 x 6 + 80 = 170 X 36 + 2220 + 80
= 6120 + 2300
= 8420 cycles
Program size

164 bytes

Data memory required 511 bytes anywhere in RAM. This is temporary storage for the high bytes of the partial product (256 bytes Starting
at address PROD) and for the multiplicand (255 bytes starting at address
MCAND). Also 3 stack bytes.

Special case A length of 0 causes an immediate exit with the multiplicand unchanged. The more significant bytes of the product (starting at
address PROD) are undefined.
me

94

Assembly language subroutines for the 6809

Title:

Multiple-Precision

Name:

MPDMUL

Purpose:

Multiply 2 arrays of BCD bytes
Multiplicand
: = Multiplicand * multiplier

Entry:

TOP

OF

Decimal

Multiplication

STACK

High byte of return address
Low byte of return address
Length of the arrays in bytes
High byte of multiplicand address
Low byte of multiplicand address
High byte of multiplier address
Low byte of multiplier address
The arrays are unsigned BCD numbers
with a maximum length of 255 bytes,
ARRAYLO]
is the Least significant
byte, and ARRAYCLENGTH-1]
is the
most significant byte.

Exit:

Multiplicand

Registers

Used:

:=

Multiplicand

* multiplier

ALL

Time:

Assuming average digit value of multiplicand
is 5, then the time is approximately
(170 * lLength*2)+ (370 * Length) + 80 cycles

Size:

Program
Data

164
511

bytes
bytes

plus

3 stack

bytes

OFH
HH
FF
HS
HF
KH
KF
F
+
F
H+
ee

*
*
*
*
MPDMUL:

TEST
EXIT

LOB
LBEQ
*
*
*
*

LENGTH OF
IF LENGTH

OPERANDS
IS ZERO

2,58
EXITML

GET LENGTH OF
BRANCH CEXIT)

OPERANDS IN BYTES
IF LENGTH IS ZERO

SAVE DIGIT COUNTER AND UPPER/LOWER DIGIT FLAG
MAKE ROOM FOR NEXT DIGIT OF MULTIPLICAND ON

ON STACK,
STACK

CLRA
PSHS
LEAS

(LOWER DIGIT)
STACK
NEXT DIGIT

A,B
-1,8

CLEAR DIGIT FLAG INITIALLY
SAVE LENGTH, DIGIT FLAG ON
RESERVE SPACE ON STACK FOR
* OF MULTIPLICAND

3J

Multiple-precision decimal multiplication (MPDMUL)

SAVE MULTIPLICAND IN TEMPORARY BUFFER (MCAND)
CLEAR PARTIAL PRODUCT CONSISTING OF UPPER BYTES
STARTING AT PROD AND LOWER BYTES REPLACING
MULTIPLICAND
+

LDX
LDY
LDU

6,58
#MCAND
#PROD

GET
GET
GET

BASE
BASE
BASE

ADDRESS
ADDRESS
ADDRESS

OF
OF
OF

MULTIPLICAND
TEMPORARY BUFFER
UPPER PRODUCT

LDA
STA
CLRA
STA
STA
DECB
BNE
STA

7X
7Yt+

MOVE BYTE
BUFFER

7,X+
,U+

CLEAR
CLEAR

INITLP
/U

CONTINUE THROUGH ALL BYTES
CLEAR OVERFLOW BYTE ALSO

INITLP:
OF

BYTE
BYTE

MULTIPLICAND

OF
OF

LOWER
UPPER

TO

TEMPORARY

PRODUCT
PRODUCT

LOOP THROUGH ALL BYTES OF MULTIPLICAND
USE EACH DIGIT TO DETERMINE HOW MANY TIMES
MULTIPLIER TO PARTIAL PRODUCT

TO

LDU

MULTIPLICAND

ADD

HE
+

#MCAND

LOOP THROUGH
DURING LOWER
DURING UPPER

POINT

2 DIGITS PER
DIGIT, DIGIT
DIGIT, DIGIT

TO

FIRST

BYTE
FLAG
FLAG

=|
=

BYTE

OF

oO

FF

HEX

£€
+

PROCDG:
LDA
LDB
BEQ
LSRA
LSRA
LSRA
LSRA

,U
1,8
MASKDG

ANDA
BEQ
STA

#S0F
MOVDIG
79

GET BYTE OF MULTIPLICAND
GET DIGIT FLAG
BRANCH IF ON LOWER DIGIT
SHIFT UPPER DIGIT TO LOWER

DIGIT

MASKDG:
MASK OFF CURRENT DIGIT
BRANCH (SKIP ADDITION)
SAVE DIGIT ON STACK

ADD MULTIPLIER TO PRODUCT
DIGIT OF MULTIPLICAND

NUMBER

OF

TIMES

IF

DIGIT

GIVEN

BY

IS

DMULT:

LDB
LDY
LDX
CLC

5,58
#PROD
8,58

GET LENGTH OF OPERANDS
GET BASE ADDRESS OF PRODUCT
GET BASE ADDRESS OF MULTIPLIER
CLEAR CARRY INITIALLY

LDA
ADCA
DAA
STA
DECB
BNE

7Xt+
rv

GET NEXT BYTE OF MULTIPLIER
ADD TO BYTE OF UPPER PRODUCT
MAKE SUM DECIMAL
STORE AS NEW PRODUCT
DECREMENT LOOP COUNTER
CONTINUE UNTIL LOOP COUNTER =

ADBYTE:

7Yt+
ADBYTE

O

ZERO

95

96

Assembly language subroutines for the 6809
LDA
ADCA
DAA
STA
DEC
BNE
STORE
THE

7X
#0

ADD

CARRY

TO

OVERFLOW

BYTE

MAKE SUM DECIMAL
SAVE NEW OVERFLOW BYTE
DECREMENT NUMBER OF ADDITIONS
CONTINUE UNITL ALL ADDITIONS DONE

Pal
79
ADMULT

THE LEAST SIGNIFICANT DIGIT
NEXT DIGIT OF MULTIPLICAND

OF

UPPER

PRODUCT

AS

+

MOVDIG:
LDX
LDY
LDB
ANDB
LDA
BEQ
ASLB
ASLB
ASLB
ASLB
ADDB
STB
BRA

6,8
#PROD
ry
#S0F
1,8
LOWDGT

GET BASE ADDRESS OF MULTIPLICAND
GET BASE ADDRESS OF UPPER PRODUCT
GET LEAST SIGNIFICANT BYTE OF PRODUCT
MASK OFF LOWER DIGIT
GET DIGIT FLAG
BRANCH IF ON LOWER DIGIT
ELSE SHIFT PRODUCT DIGIT TO UPPER DIGIT

7X
7X+
SHFPRD

ADD

BRANCH

TO

STB

7X

STORE

DIGIT

TO

UPPER

DIGIT

SHIFT

OF

MULTIPLICAND

BYTE

PRODUCT

LOWDGT:
*
*
*
SHFPRD:

SHIFT

PARTIAL

PRODUCT

RIGHT

IN MULTIPLICAND

1 DIGIT

ONE

(4

DIGIT

BITS)

LDA

#4

SHIFT

(4 BITS)

LDB
INCB
LDY
LEAY
CLC

5,8

GET LENGTH
SHIFT LENGTH+1 BYTES TO INCLUDE
POINT TO PARTIAL PRODUCT
POINT PAST OVERFLOW BYTE
CLEAR CARRY INTO OVERFLOW

SETSHF:

#PROD
B,Y

OVERFLOW

SHFARY:

ROR
DECB
BNE
DECA
BNE
+

77Y
SHFARY

DECREMENT SHIFT COUNT
CONTINUE THROUGH 4 1-BIT

SETSHF

CHANGE

OVER

LDA
CMPA
BEQ
STA
BRA
MOVE

SHIFT BYTE OF PRODUCT RIGHT
CONTINUE THROUGH ALL BYTES

TO

NEXT

#3 FF
1,8
HIDIG
1,8
PROCDG
ON

TO

NEXT

DIGIT

IF

ON

LOWER

SHIFTS

DIGIT

GET UPPER DIGIT MARKER
COMPARE TO DIGIT FLAG
BRANCH IF ON UPPER DIGIT
ELSE SET DIGIT FLAG TO UPPER
PROCESS NEXT DIGIT
BYTE

IF

ON

UPPER

DIGIT

DIGIT

FLAG

DIGIT

HIDIG:
CLR

1,8

CLEAR

TO

INDICATE

LOW

DIGIT

3J

Multiple-precision decimal multiplication (MPDMUL)

LEAU
LDD
ADDD
STD
DEC
BNE
LEAS

a)
a)
ROCDG
S

PROCEED TO NEXT BYTE OF MULTIPLICAND
GET MULTIPLICAND POINTER
POINT TO NEXT BYTE
SAVE MULTIPLICAND POINTER
DECREMENT DIGIT COUNTER
PROCESS NEXT DIGIT
REMOVE TEMPORARY STORAGE FROM STACK

*
*

REMOVE

PARAMETERS

LDU
LEAS
JMP

79

FROM

STACK

AND

EXIT

*

EXITML:

,U

GET RETURN ADDRESS
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

256
255

PRODUCT BUFFER WITH
MULTIPLICAND BUFFER

STACK

DATA
PROD:

MCAND:

RMB
RMB

SAMPLE

OVERFLOW

BYTE

EXECUTION

£€
+
&

SC3J:
LDX
LDY
LDA
PSHS
JSR

AY1ADR
AY2ADR
#SZAYS
A,X,Y
MPDMUL

GET MULTIPLICAND
GET MULTIPLIER
GET LENGTH OF ARRAYS IN BYTES
SAVE PARAMETERS IN STACK
MULTIPLE-PRECISION DECIMAL MULTIPLICATION
*RESULT OF 1234H * 5718H = 7056012H
*

IN

MEMORY

*
*
*
*
*
*
BRA

SC3J

REPEAT

TEST

SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FDB
FDB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AY2:

FCB
FCB

$34,$12
$18 ,$57

,0
70

AY1

=

12H

AY1+1
AY1+2
AY1+3
AY1+4
AY1+5
AY1+6

=
=
=
=
=
=

60H
O5H
O7H
OOH
OOH
OOH

ARRAYS
OF
OF

IN

BYTES

ARRAY
ARRAY

1
2

97

98

Assembly language subroutines for the 6809

3K Multiple-precision decimal division
(MPDDIV)
Divides two multi-byte unsigned decimal (BCD) numbers. Both
numbers are stored with their least significant digits at the lowest
address. The quotient replaces the dividend; the base address of the
remainder is also returned. The length of the numbers (in bytes) is 255
or less. The Carry flag is cleared if no errors occur; if a divide by0 is
attempted, the Carry flag is set to 1, the dividend is unchanged, and the
remainder is set to 0.

Procedure The program divides by determining how many times the
divisor can be subtracted from the dividend. It saves that number in the
quotient, makes the remainder into the new dividend, and rotates the
dividend and the quotient left one digit. The program subtracts using
ten’s complement arithmetic; the divisor is therefore replaced by its
nine’s complement to increase speed.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Length of the operands in bytes

More significant byte of base address of divisor
Less significant byte of base address of divisor
More significant byte of base address of dividend
Less significant byte of base address of dividend

Exit Conditions

Dividend replaced by dividend divided by divisor
If the divisor is non-zero, Carry = 0 and the result is normal
If the divisor is zero, Carry = 1, the dividend is unchanged, and the
remainder Is zero
The base address of the remainder (i.e. the address of its least significant
digits) is in register X. The divisor is replaced by its nine’s complement

3K

Multiple-precision decimal division (MPDDIV)

99

Example

Data:

Result:

Length of operands (in bytes) = 4
Dividend = 221422984.
Divisor = 00006294.
Dividend = 00003518;¢

Remainder (base address in X) = 00000006,,
Carry = 0, indicating no divide-by-0 error

Registers used

All

Execution time Depends on the length of the operands and on the
size of the digits in the quotient (determining how many times the
divisor must be subtracted from the dividend). If the average digit in the
quotient has a value of 5, the execution time is approximately
410 x LENGTH? + 750 x LENGTH + 150 cycles
where LENGTH is the length of the operands in bytes. If, for example,
LENGTH = 6 (12 digits), the approximate execution time is
410 x 67 + 750 x 6 + 150 = 410 x 36 + 4500 + 150
= 14760 + 4650
= 19410 cycles
Program size

169 bytes

Data memory required 514 bytes anywhere in RAM. This includes
the buffers holding either the high dividend or the result of the trial
subtraction (255 bytes each starting at addresses HIDE1 and HIDE2,
respectively), and the pointers that assign the buffers to specific purposes (2 bytes each starting at addresses HDEPTR and DIFPTR,
respectively). Also 3 stack bytes.
Special cases

1. A length of 0 causes an immediate exit with the Carry flag cleared,
the quotient equal to the original dividend, and the remainder
undefined.
2. A divisor of 0 causes an exit with the Carry flag set to 1, the quotient
equal to the original dividend, and the remainder equal to 0.

100

Assembly language subroutines for the 6809

Title:

Multiple-Precision

Name:

MPDDIV

Purpose:

Divide 2 arrays of BCD bytes
Quotient
:= Dividend / divisor

Entry:

TOP

OF

Decimal

Division

STACK

High byte of return address
Low byte of return address
Length of operands in bytes
High byte of divisor address
Low byte of divisor address
High byte of dividend address
Low byte of dividend address
The arrays are unsigned BCD numbers
with a maximum Length of 255 bytes,
ARRAYCO] is the least significant
byte, and ARRAYCLENGTH-1]
is the
most significant byte.
Exit:

Dividend := dividend
If no errors then
Carry := 0
Dividend unchanged
remainder
:= 0

Registers

Used:

/ divisor

ALL

Time:

Assuming the average digit value in the
quotient is 5, then the time is approximately
(410 * lLength”™2) + (750 * Length) + 150
cycles

Size:

Program
Data

169
510

bytes
bytes

plus

OPERANDS
CLEARED
IF

LENGTH

IS

3 stack

bytes

HEH
HH
FF
HE
He
KF
HF
FH
HH
&
+

*

*
*

CHECK LENGTH OF
EXIT WITH CARRY

ZERO

*

MPDDIV:

CLC
LDB
LBEQ
*

2,S
EXITDV

CLEAR CARRY IN CASE OF ZERO LENGTH
GET LENGTH OF OPERANDS
BRANCH (EXIT) IF LENGTH IS ZERO

SET UP HIGH DIVIDEND AND DIFFERENCE POINTERS
CLEAR HIGH DIVIDEND AND DIFFERENCE ARRAYS

3K

Multiple-precision decimal division (MPDDIV)

101

ARRAYS 1 AND 2 ARE USED INTERCHANGEABLY FOR THESE TWO
PURPOSES.
THE POINTERS ARE SWITCHED WHENEVER A
TRIAL SUBTRACTION SUCCEEDS
+

LDX
STX
LDU
STU
CLRA

#HIDE1
HDEPTR
#HIDE2
DIFPTR

GET BASE ADDRESS OF ARRAY 1
DIVIDEND POINTER = ARRAY 1
GET BASE ADDRESS OF ARRAY 2
DIFFERENCE POINTER = ARRAY 2
GET ZERO FOR CLEARING

STA
STA
DECB
BNE

Xt
,U+

CLEAR BYTE OF ARRAY 1
CLEAR BYTE OF ARRAY 2
CONTINUE THROUGH ALL BYTES

CLRHI:

+

CLRHI

CHECK

WHETHER

DIVISOR

IS

ZERO

-

EXIT

WITH

CARRY

LDB
LDX

GET LENGTH OF OPERANDS
POINT TO DIVISOR

LDA
BNE
DECB
BNE
SEC
LBRA

GET BYTE OF DIVISOR
BRANCH (EXIT) IF BYTE IS NOT
CONTINUE THROUGH ALL BYTES

SET

IF

IT

CHKZRO:
ZERO

CHKZRO
ALL BYTES ARE ZERO - SET CARRY AND
INDICATING DIVIDE-BY-ZERO ERROR

EXITDV

*
*

TAKE

NINES

COMPLEMENT

OF

DIVISOR

TO

SIMPLIFY

*

SUBTRACTION

NINESC:

LDB
LDX

GET LENGTH OF OPERANDS
POINT TO DIVISOR

LDA
SUBA
STA
DECB
BNE

TAKE

NINESB

SET COUNT
COUNT

TO NUMBER OF DIGITS
LENGTH * 2 + 1

LDB
CLRA
ASLB
ROLA
ADDD
PSHS
CLR

2,8

NINESB:

NINES

CONTINUE

COMPLEMENT

THROUGH

PLUS

ALL

OF

EACH

BYTES

1

+

7S

GET LENGTH OF OPERANDS
EXTEND LENGTH TO 16 BITS
MULTIPLY LENGTH TIMES 2
2 * LENGTH + 1
SAVE DIGIT COUNT ON STACK
SAVE TENS COUNT ON STACK

*
*

SET

UP

FOR

DIGIT

SHIFT

*

DIGSET:

LDY
LEAY
STY

-1,Y
1,8

GET DIGIT COUNT
DECREMENT DIGIT COUNT
SAVE DECREMENTED DIGIT

COUNT

BYTE

EXIT

IS

102

Assembly language subroutines for the 6809
BRANCH IF
FOUR BITS

CHKTNS
#4

BEQ
LDA

ALL
PER

DIGITS
DIGIT

DONE

*
*

DIGIT

SHIFT

*

DIGSHF:

LDX
LSL
LDB

POINT TO DIVIDEND
SHIFT HIGH BIT INTO CARRY
GET LENGTH OF OPERANDS

79

5,8

*
*

SHIFT

QUOTIENT

AND

LOWER

DIVIDEND

LEFT

ONE

BIT

*

SHFTQU:
ROL
DECB
BNE
+

SHIFT

SHIFT BYTE OF QUOTIENT/DIVIDEND
CONTINUE THROUGH ALL BYTES
SHFTQU
UPPER

DIVIDEND
HDEPTR
5,5

LDX
LDB

LEFT

LEFT

WITH

CARRY

POINT TO BASE
GET LENGTH OF

FROM

LOWER

ADDRESS OF
OPERANDS

DIVIDEND

UPPER

DIVIDEND

SHFTUP:
ROL
DECB
BNE
DECA
BNE

SHIFT BYTE OF UPPER DIVIDEND
CONTINUE THROUGH ALL BYTES

LEFT

SHFTUP

DIGSHF

DECREMENT DIGIT
LOOP UNTIL DONE

BIT

COUNT

PERFORM DIVISION BY TRIAL SUBTRACTIONS
KEEP REMAINDER IN CASE IT IS NEEDED LATER
FINAL CARRY IS AN INVERTED BORROW
+
&

CLR

a)

TENS

COUNTER

=

O

LDU
LDX
LDY
LDB
SEC

DIFPTR
HDEPTR

POINT TO DIFFERENCE
POINT TO UPPER DIVIDEND
POINT TO DIVISOR
GET LENGTH OF OPERANDS IN BYTES
SET INVERTED BORROW INITIALLY
* TO FORM 10'S COMPLEMENT

SETSUB:

5,58

SUBDVS:

LDA
ADCA

7Y¥t+

DAA
STA
DECB
BNE

SUBDVS

IF

GET BYTE OF HIGH DIVIDEND
SUBTRACT BYTE OF DIVISOR BY
* BYTE OF NINE'S COMPLEMENT
MAKE DIFFERENCE DECIMAL
SAVE DIFFERENCE
CONTINUE THROUGH ALL BYTES

ADDING

DIFFERENCE IS POSITIVE (CARRY SET), REPLACE HIGH
DIVIDEND WITH DIFFERENCE AND ADD 10 TO 10'S COUNT

+
+

BCC
LDX
LDU
STU

DIGSET
HDEPTR
DIFPTR
HDEPTR

BRANCH IF DIFFERENCE IS NEGATIVE
GET HIGH DIVIDEND POINTER
GET DIFFERENCE POINTER
NEW HIGH DIVIDEND = DIFFERENCE

3K

Multiple-precision decimal division (MPDDIV)

STX
LDA
ADDA
STA
BRA

DIFPTR
#$10
79
yo)
SETSUB

USE
ADD

OLD HIGH DIVIDEND
10 TO 10'S COUNT

SAVE SUM
CONTINUE

ON STACK
WITH TRIAL

FOR

103

NEXT

DIFFERENCE

SUBTRACTIONS

*
*

DO

LAST

SHIFT

IF

TENS

COUNT

IS

NOT

ZERO

*

CHKTNS:

LDA
LEAS
BEQ
PSHS
LDA

a)
3,8
GOODRT

GET TENS COUNT
REMOVE TEMPORARIES FROM STACK
BRANCH IF TENS COUNT IS ZERO
SAVE TENS COUNT
4 BIT SHIFT TO MOVE DIGIT

CSHIFT:

LDX
LDB
LSL

POINT TO QUOTIENT
GET LENGTH OF OPERANDS
SHIFT TENS COUNT INTO CARRY

ROL
DECB
BNE
DECA
BNE
LEAS

SHIFT QUOTIENT LEFT 1 BIT
CONTINUE THROUGH ALL BYTES

LSTSHF:

LSTSHF
CSHIFT
1,8

CONTINUE

THROUGH

4 BIT

REMOVE

TEMPORARY

STORAGE

CLEAR

CARRY

GOOD

SHIFT
FROM

STACK

GOODRT:

CLC

FOR

RETURN

*
*

REMOVE

PARAMETERS

FROM

STACK

AND

EXIT

*

EXITDV:
LDX
LDU
LEAS
JMP

HDEPTR
79
,U

GET BASE ADDRESS OF REMAINDER
SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM STACK
EXIT TO RETURN ADDRESS

255
255

POINTER TO HIGH DIVIDEND
POINTER TO DIFFERENCE BETWEEN
* DIVIDEND AND DIVISOR
HIGH DIVIDEND BUFFER 1
HIGH DIVIDEND BUFFER 2

*
*

DATA

*

HDEPTR:
DIFPTR:

RMB
RMB

HIDE1:
HIDE2:

RMB
RMB

SAMPLE

EXECUTION

&
+

SC3K:

LDX
LDY
LDA
PSHS

AY1ADR
AY2ADR
#SZAYS
A,X,Y

GET DIVIDEND
GET DIVISOR
LENGTH OF ARRAYS IN BYTES
SAVE PARAMETERS IN STACK

HIGH

104

Assembly language subroutines for the 6809
JSR

MPDDIV

MULTIPLE-PRECISION
*RESULT OF 3822756
*

IN

MEMORY

AY1

=

97H

*
*

AY1+1
AY1+2

=
=

30H
OOH

*

AY1+3

=

QOH

*
*
*

AY1+4
AY1+5
AY1+6

=
=
=

OOH
OOH
QOH

BRA

SC3K

REPEAT

TEST

SZAYS

EQU

7

LENGTH

OF

AY1ADR
AY2ADR

FDB
FDB

AY1
AY2

BASE
BASE

ADDRESS
ADDRESS

AY1:
AY2:

FCB
FCB

$56,$27,%$82,$03,0,0,0
$34,$12,0,0,0,0,0,0

END

DECIMAL DIVISION
/ 1234 = 3097

ARRAYS

OF
OF

IN

BYTES

ARRAY
ARRAY

1 (DIVIDEND)
2 (DIVISOR)

3L

3L

Multiple-precision decimal comparison

105

Multiple-precision decimal comparison
Compares two multi-byte unsigned decimal (BCD) numbers, setting the
Carry and Zero flags. Sets the Zero flag to 1 if the operands are equal
and to 0 otherwise. Sets the Carry flag to 1 if the subtrahend is larger
than the minuend and to 0 otherwise. It thus sets the flags as if it had
subtracted the subtrahend from the minuend.

Note This program is exactly the same as Subroutine 3G, the
multiple-precision binary comparison, since the form of the operands
does not matter if they are only being compared. See Subroutine 3G for
a listing and other details.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Length of the operands in bytes
More significant byte of base address of subtrahend
Less significant byte of base address of subtrahend
More significant byte of base address of minuend
Less significant byte of base address of minuend

Exit conditions
Flags set as if subtrahend had been subtracted from minuend

Zero flag = 1 if subtrahend and minuend are equal, 0 if they are not
equal
Carry flag = 1 if subtrahend is larger than minuend in the unsigned
sense, 0 if it less than or equal to the minuend

Examples

1.

Data:

Length of operands (in bytes) = 6
Top operand (subtrahend) = 196528719340;6

106

Assembly language subroutines for the 6809
Bottom operand (minuend) = 45678015326646

2.

Result:

Zero flag = 0 (operands are not equal)
Carry flag = 0 (subtrahend is not larger than minuend)

Data:

Length of operands (in bytes) = 6
Top operand (subtrahend) = 1965287193404.
Bottom operand (minuend) = 1965287193404.
Zero flag = 1 (operands are equal)
Carry flag = 0 (subtrahend is not larger than minuend)

Result:
3.

Data:

Result:

Length of operands (in bytes) = 6
Top operand (subtrahend) = 1965287193401.
Bottom operand (minuend) = 0737859910746
Zero flag = 0 (operands are not equal)
Carry flag = 1 (subtrahend is larger than minuend)

Bit manipulation and
shifts

4A _ Bit field extraction
(BFE)
Extracts a field of bits from a word and returns it in the least significant
bit positions. The width of the field and its lowest bit position are
specified.
Procedure The program obtains a mask consisting of right-justified 1
bits covering the width of the field. It shifts the mask left to align it with
the specified lowest bit position and obtains the field by logically
ANDing the mask with the data. It then normalizes the bit field by
shifting it right to make it start in bit 0.
we
Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Starting (lowest) bit position in the field (0-15)
Width of the field in bits (0-15)
More significant byte of data
Less significant byte of data

107

108

Assembly language subroutines for the 6809
Exit conditions

Bit field in register D (normalized to bit 0)

Examples
1.

2.

Data:

Value = F67Cy46 = 1111011001111100,

Result:

Lowest bit position = 4
Width of field in bits = 8
Bit field = 0067;. = 0000000001100111,
We have extracted 8 bits from the original data, starting
with bit 4 (i.e. bits 4-11).

Data:

Value = A2D4,. = 1010001011010100,

Result:

Lowest bit position = 6
Width of field in bits = 5
Bit field = 000B;. = 0000000000001011,
We have extracted 5 bits from the original data, starting
with bit 6 (i.e. bits 6-10).

Registers used

A,B,CC,U,xX

Execution time 27 x LOWEST BIT POSITION plus 85 cycles overhead. The lowest bit position determines how many times the program
must shift the mask left and the bit field right. For example, if the field
starts in bit 6, the execution time is

27 X 6 + 85 = 162 + 85 = 247 cycles

Program size

67 bytes (including the table of masks)

Data memory required

None

Special cases

1. Requesting a field that would extend beyond the end of the word
causes the program to return with only the bits through bit 15. That is,

4A_

Bit field extraction (BFE)

109

no wraparound is provided. If, for example, the user asks for a 10-bit
field starting at bit 8, the program will return only 8 bits (bits 8 — 15).
2. Both the lowest bit position and the number of bits in the field are
interpreted mod 16. That is, for example, bit position 17 is equivalent to
bit position 1 and a field of 20 bits is equivalent toafield of 4 bits.

3.

Requesting a field of zero width causes a return with a result of 0.

Title:

Bit

Name:

BFE

Purpose:

Field

Extract

a field

of

word and return
to bit QO.

the

NOTE:

Entry:

Extraction

bits

from

field

a

IF THE REQUESTED FIELD IS TOO
LONG, THEN ONLY THE BITS THROUGH
BIT 15 WILL BE RETURNED.
FOR
EXAMPLE, IF A 4 BIT FIELD IS
REQUESTED STARTING AT BIT 15, THEN
ONLY 1 BIT (BIT 15) WILL BE
RETURNED.

TOP OF
High

STACK
byte of return address
Low byte of return address
Lowest (starting) bit position
the field (0..15)
Width of field in bits (1..16)
High byte of data
Low byte of data

Exit:

Register

Registers

Used:

D =

Field

(normalized

85

Size:

cycles overhead
(27 * lowest bit

Program

to

67

plus
position)

cycles

bytes

HH
t+
He
FH
HF
KH
+
H
FHF
H

BFE:

LDU
EXIT

rs
WITH

in

A,B,CC,U,X

Time:

+

16-bit

normalized

ZERO

RESULT

SAVE

RETURN

ADDRESS

IF

WIDTH

OF

FIELD

IS

ZERO

bit

0)

110

Assembly language subroutines for the 6809
CLRB
LDA
BEQ

MAKE LOW BYTE OF FIELD
GET FIELD WIDTH
BRANCH (EXIT) IF FIELD
* NOTE: RESULT IN D IS

3,8
EXITBF

ZERO

INITIALLY

WIDTH
ZERO

IS

USE FIELD WIDTH TO OBTAIN EXTRACTION MASK FROM
MASK CONSISTS OF A RIGHT-JUSTIFIED SEQUENCE OF
WITH LENGTH GIVEN BY THE FIELD WIDTH

ZERO

ARRAY
1 BITS

+

DECA
ANDA
ASLA
LEAX
LDX

SUBTRACT 1 FROM FIELD WIDTH TO FORM INDEX
BE SURE INDEX IS 0 TO 15
MULTIPLY BY 2 SINCE MASKS ARE WORD-LENGTH
MSKARY,PCR
GET BASE ADDRESS OF MASK ARRAY
A,X
GET MASK FROM ARRAY

#S$0F

SHIFT MASK
POSITION

LEFT LOGICALLY
IN FIELD

TO

ALIGN

IT

WITH

LOWEST

BIT

LDA
ANDA
BEQ

2,8
#S0F
GETFLD

STA
STA
TFR

79
1,8
X,D

GET LOWEST BIT POSITION
MAKE SURE VALUE IS BETWEEN O AND 15
BRANCH WITHOUT SHIFTING IF LOWEST
* BIT POSITION IS 0
SAVE LOWEST BIT POSITION IN STACK TWICE
TO COUNT SHIFTS OF MASK, RESULT
MOVE MASK TO REGISTER D FOR SHIFTING

PS)
SHFTMS

SHIFT LOW BYTE OF MASK LEFT LOGICALLY
SHIFT HIGH BYTE OF MASK LEFT
CONTINUE UNTIL 1 BITS ALIGNED TO
FIELD'S LOWEST BIT POSITION

+
+

SHFTMS:
ASLB
ROLA
DEC
BNE
OBTAIN

FIELD

BY

LOGICALLY

ANDING

SHIFTED

MASK

WITH

VALUE

GETFLD:
5,58
4,8

ANDB
ANDA

AND
AND

NORMALIZE FIELD TO BIT
LOWEST BIT POSITION

LOW BYTE OF VALUE WITH MASK
HIGH BYTE OF VALUE WITH MASK
O BY

SHIFTING

RIGHT

LOGICALLY

FROM

+

TST
BEQ

1,8
EXITBF

TEST LOWEST BIT POSITION
BRANCH (EXIT) IF LOWEST POSITION

LSRA
RORB
DEC
BNE

1,8
SHFTFL

SHIFT HIGH BYTE OF FIELD RIGHT LOGICALLY
SHIFT LOW BYTE OF FIELD RIGHT
CONTINUE UNTIL LOWEST BIT OF FIELD IS
IN BIT POSITION 0

REMOVE

PARAMETERS

LEAS
JMP

6,S
7VU

IS

0

SHFTFL:

*
*

FROM

STACK

AND

EXIT

*

EXITBF:

*

ARRAY

OF

MASKS

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS
WITH

1 TO

15

ONE

BITS

STACK

RIGHT-JUSTIFIED

4A

Bit field extraction (BFE)

MSKARY:
FDB
FDB
FDB
FFB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB

%0000000000000001
%0000000000000011
40000000000000111
%0000000000001111
%0000000000011111
40000000000111111
%0000000001111111
%0000000011111111
%0000000111111111
%0000001111111111
40000011111111111
40000111111111111
4£0001111111111111
40011111111111111
40111111111111111

SAMPLE

EXECUTION

LDA
LDB
LDX
PSHS
JSR

POS
NBITS
VAL
A,B,X
BFE

BRA

SC4A

FDB
FCB
FCB

$1234

SC4A:
GET LOWEST BIT POSITION
GET FIELD WIDTH IN BITS
GET DATA
SAVE PARAMETERS IN STACK
EXTRACT BIT FIELD
*RESULT FOR VAL=1234H, NBITS=4
*
POS=4 IS D = 0003H

*DATA
VAL
NBITS
POS

DATA
FIELD WIDTH IN BITS
LOWEST BIT POSITION

111

112

Assembly language subroutines for the 6809

4B Bit field insertion
(BFI)
Inserts a field of bits into a word. The width of the field and its lowest
(starting) bit position are the parameters.
Procedure The program obtains a mask consisting of right-justified 0
bits covering the width of the field. It then shifts the mask and the bit
field left to align them with the specified lowest bit position. It logically
ANDs the mask and the original data word, thus clearing the required
bit positions, and then logically ORs the result with the shifted bit field.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Starting (lowest) bit position in the field (0-15)
Width of the field in bits (0-15)
More significant byte of bit field (value to insert)
Less significant byte of bit field (value to insert)
More significant byte of data
Less significant byte of data

Exit conditions
Result in register D

The result is the original data value with the bit field inserted, starting at
the specified lowest bit position

Examples

1.

Data:

Value = F67Ci¢ = 1111011001111100,
Lowest bit position = 4
Number of bits in the field = 8
Bit field = 008B,._ = 0000000010001011,

4B

Bit field insertion (BFI)

Result:

113

Value with bit field inserted = F8BC,. =

1111100010111100,
The 8-bit field has been inserted into the original value
starting at bit 4 (i.e. into bits 4— 11)
2.

Data:

Value = A2D4i6 = 1010001011010100,

Lowest bit position = 6
Number of bits in the field = 5
Bit field = 001516 = 0000000000010101,
Result:

Value with bit field inserted = A554,. =

1010010101010100,
The 5-bit field has been inserted into the original value
starting at bit 6 (i.e. into bits 6 — 10). Those five bits were
01011, (OBi6) and are now 10101, (1546).

Registers used

A,B,CC,U,X

Execution time 30 x LOWEST BIT POSITION plus 91 cycles overhead. The lowest bit position of the field determines how many times
the program must shift the mask and the field left. For example, if the
starting position is bit 10, the execution time is
30 x 10 + 91 = 300 + 91 = 391 cycles

Program size

67 bytes (including the table of masks)

Data memory required

None

Special cases

1. Attempting to insert a field that would extend beyond the end of the
word causes the program to insert only the bits through bit 15. That is,
no wraparound is provided. If, for example, the user attempts to insert a
6-bit field starting at bit 14, only 2 bits (bits 14 and 15) are actually
replaced.

2. Both the lowest bit position and the length of the bit field are
interpreted mod 16. That is, for example, bit position 17 is the same as

114

Assembly language subroutines for the 6809

bit position 1 and a 20-bit field is the same as a 4-bit field.

3. Attempting to insert a field of zero width causes a return with a
result equal to the initial data.
*
*
*
*

*

Title:

Bit

*

Name:

BFI

Field Insertion

Purpose:

*

Inserts a field of bits which is
normalized to bit 0 into a 16-bit

*

NOTE:

*
*

*
x

word.

IF THE REQUESTED
FIELD
IS TOO LONG, THEN
ONLY THE BITS THROUGH
BIT 15 WILL BE
INSERTED.
FOR EXAMPLE,
IF A 4-BIT
FIELD
IS TO BE INSERTED
STARTING
AT BIT 15,
THEN ONLY THE FIRST BIT WILL BE INSERTED
AT BIT 15.

*

*
*
*
*

*

*

TOP

Entry:

OF

STACK

High byte of return address
Low byte of return address
Bit position at which inserted field
start (0..15)
Number of bits in the field (1..16)
High byte of value to insert
Low byte of value to insert
High byte of value
Low byte of value

*

*
*
*
*
*
*
*
*

will

*

*

Register

Exit:

D =

Value

with

field

inserted

*

*

Registers

A,B,CC,U,X

Used:

*

*
*

91

Time:

cycles overhead
(30 * Lowest bit

plus
position)

cycles

*

*

Program

Size:

6/7 bytes

*
*
*

BFI:

+

EXIT

LOD
TST
BEQ

SAVE

Po)

LDU
WITH

DATA

AS

EXITBF

RESULT

RETURN
IF

ADDRESS

FIELD

WIDTH

IS

ZERO

GET DATA
CHECK FIELD WIDTH
BRANCH (EXIT) IF FIELD WIDTH IS
* RESULT IN D IS ORIGINAL DATA

ZERO

4B

Bit field insertion (BFI)

115

USE FIELD WIDTH TO OBTAIN MASK FROM ARRAY
MASK HAS A NUMBER OF RIGHT-JUSTIFIED O BITS
BY FIELD WIDTH

GIVEN

+

LDA
DECA
ANDA
ASLA
LEAX
LDX

3,8

GET FIELD WIDTH
CONVERT FIELD WIDTH TO ARRAY INDEX
#S0F
MAKE SURE INDEX IS O TO 15
MULTIPLY BY 2 SINCE MASKS ARE WORD-LENGTH
MSKARY,PCR
GET BASE ADDRESS OF MASK ARRAY
A,X
GET MASK FROM ARRAY

SHIFT
THE

MASK AND FIELD
FIELD'S LOWEST

LDA
ANDA
BEQ

2,58
#30F
INSERT

STA

7s

TFR

X,D

TO BE INSERTED
BIT POSITION
©

LEFT

TO

ALIGN

THEM

WITH

+€

GET LOWEST BIT POSITION
BE SURE POSITION IS 0 TO 15
BRANCH IF POSITION IS O AND NO SHIFTING
* IS NECESSARY
SAVE LOWEST POSITION IN STACK FOR USE
* AS COUNTER
MOVE MASK TO REGISTER D FOR SHIFTING

SHFTLP:
SEC
ROLB
ROLA
ASL
ROL
DEC
BNE

5,S
4,58
7s
SHFTLP

FILL MASK WITH ONES
SHIFT LOW BYTE OF MASK LEFT, PUTTING
* 1 IN BIT O
SHIFT HIGH BYTE OF MASK LEFT
SHIFT LOW BYTE OF INSERT VALUE LEFT
SHIFT HIGH BYTE OF INSERT VALUE LEFT

CONTINUE UNTIL INSERT VALUE'S LEAST
* SIGNIFICANT BIT IS IN LOWEST BIT
* POSITION

*
*

USE

MASK

TO

CLEAR

FIELD,

THEN

OR

IN

INSERT

VALUE

*

INSERT:
ANDA
ANDB
ORA
ORB

6,58
7,8
4,8
3,8

AND HIGH BYTE OF VALUE WITH MASK
AND LOW BYTE OF VALUE WITH MASK
OR IN HIGH BYTE OF INSERT VALUE
OR IN LOW BYTE OF INSERT VALUE

REMOVE

PARAMETERS

LEAS
JMP

8,S
,U

MASK ARRAY
HAS 0 BITS

USED TO CLEAR THE BIT FIELD INITIALLY
RIGHT-JUSTIFIED
IN 1 TO 15 BIT POSITIONS

FDB
FDB
FOB

41111111111111110
4£1111111111111100
4£1111111111111000

*
*

FROM

STACK

AND

EXIT

*

EXITBF:
REMOVE PARAMETERS
FROM
EXIT TO RETURN ADDRESS

+
+

MSKARY:

STACK

A

116

Assembly language subroutines for the 6809
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB

SAMPLE

41111111111110000
%1111111111100000
41111111111000000
41111111110000000
%41111111100000000
%1111111000000000
%1111110000000000
%1111100000000000
%1111000000000000
%1110000000000000
%1100000000000000
%41000000000000000

EXECUTION

+
&

SC4B:
LDA
LOB
LDX
LDY
PSHS
JSR

POS
NBITS
VALINS
VAL
A,B,X,Y
BFI

BRA

SC4B

FDB
FDB
FCB
FCB

$1234
SOOOE
4
$OC

GET LOWEST BIT POSITION OF FIELD
GET FIELD WIDTH IN BITS
GET VALUE TO INSERT
GET VALUE
SAVE PARAMETERS IN STACK
INSERT BIT FIELD
*RESULT FOR VAL=1234H, VALINS=O0EH,
*
NBITS = 4, POS = OCH IS
*
REGISTER D = E234H

*DATA

VAL
VALINS
NBITS
POS

END

DATA VALUE
VALUE TO INSERT
FIELD WIDTH IN BITS
LOWEST BIT POSITION

IN

FIELD

4C

Multiple-precision arithmetic shift right (MPASR)

117

4C Multiple-precision arithmetic shift right
(MPASR)
Shifts a multi-byte operand right arithmetically by a specified number of
bit positions. The length of the operand (in bytes) is 255 or less. Sets the
Carry flag from the last bit shifted out of the rightmost bit position. The
operand is stored with its least significant byte at the lowest address.

Procedure The program obtains the sign bit from the most significant
byte, saves that bit in the Carry, and then rotates the entire operand
right 1 bit, starting with the most significant byte. It repeats the operation for the specified number of shifts.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Number of shifts (bit positions)
Length of the operand in bytes
More significant byte of base address of operand (address of its least
significant byte)
Less significant byte of base address of operand (address of its least
significant byte)

Exit conditions

Operand shifted right arithmetically by the specified number of bit
positions. The original sign bit is extended to the right.
The Carry flag is set from the last bit shifted out of the rightmost bit
position. It is cleared if either the number of shifts or the length of the
operand is 0.

Examples

i.

Data:

— Length of operand (in bytes) = 8

118

Assembly language subroutines for the 6809

Result:

2.

Data:

Result:

Operand = 85A4C719FE06741E4¢6
Number of shifts = 4
Shifted operand = F85A4C719FE06741
46.
This is the original operand shifted right 4 bits
arithmetically. The four most significant bits thus all take
on the value of the original sign bit (1).
Carry = 1, since the last bit shifted from the rightmost bit
position was 1.
Length of operand (in bytes) = 4
Operand = 3F6A42D316
Number of shifts = 3
Shifted operand = O7ED485A4¢.

This is the original operand shifted right 3 bits
arithmetically. The three most significant bits thus all take
on the value of the original sign bit (0).
Carry = 0, since the last bit shifted from the rightmost bit
position was 0).

Registers used

A,B,CC,U,X

Execution time NUMBER OF SHIFTS xX (28 + 13 x LENGTH OF
OPERAND IN BYTES) + 50 cycles.
If, for example, NUMBER OF SHIFTS = 6 and LENGTH OF
OPERAND IN BYTES = 8, the execution time is

6 x (28+ 13 x 8) + 50 = 6 X 132 + 50 = 842 cycles
Program size

39 bytes

Data memory required

None

Special cases

1. Ifthe length of the operand is 0, the program exits immediately with
the operand unchanged and the Carry flag cleared.
2. Ifthe number of shifts is 0, the program exits immediately with the
operand unchanged and the Carry flag cleared.

4C

Multiple-precision arithmetic shift right (MPASR)

Title:

Multiple-Precision

Name:

MPASR

Purpose:

Arithmetic
N bits.

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
Number of bits to shift
Length of the operand in bytes
High byte of operand base address
Low byte of operand base address

shift

Arithmetic

right

Shift

a multi-byte

119

Right

operand

The operand is stored with ARRAYCO] as its
Least significant byte and ARRAYCLENGTH-1]
as its most significant byte
Exit:

Operand shifted right with the
Significant bit propagated.
Carry := Last bit shifted from
significant position.

Registers

Used:

most
least

A,B,CC,U,X

Time:

50

Size:

cycles overhead plus
(13 * length) + 28 cycles

Program

39

per

shift

TO

SHIFT

bytes

HH
HF
KH
FE
+
H
F

LDU

79

EXIT
IS

IF LENGTH OF
ZERO.
CARRY

CLC
LDA
BEQ
LDA
BEQ
*

SAVE

POINTER

4,8

TO

RETURN

OPERAND OR
IS CLEARED

ADDRESS

NUMBER OF
IN EITHER

BITS
CASE

CLEAR CARRY INITIALLY
GET NUMBER OF BITS TO SHIFT
EXIT IF NUMBER OF BITS TO SHIFT IS
GET LENGTH OF OPERAND
EXIT IF LENGTH OF OPERAND IS ZERO

2,8
EXITAS
3,58
EXITAS

DECA
LDX

SAVE

MOST

SIGNIFICANT

BYTE

OF

OPERAND

OFFSET OF MOST SIGNIFICANT BYTE
* LENGTH OF OPERAND - 1
GET BASE ADDRESS OF OPERAND

=

ZERO

120

Assembly language subroutines for the 6809
LEAX
STX

A,X
79

POINT TO MOST SIGNIFICANT BYTE
SAVE POINTER TO MOST SIGNIFICANT

SHIFT ENTIRE OPERAND RIGHT ONE BIT ARITHMETICALLY
USE SIGN OF MOST SIGNIFICANT BYTE AS INITIAL CARRY
TO PRODUCE ARITHMETIC SHIFT

BYTE

INPUT

Fe
+
e

ASRLP:
LDX
LDA
ASLA
LDB
SHIFT
START

79
Xt

POINT TO MOST SIGNIFICANT BYTE
GET MOST SIGNIFICANT BYTE
SHIFT BIT 7 TO CARRY FOR SIGN EXTENSION
GET LENGTH OF OPERAND IN BYTES

3,8
EACH
WITH

BYTE
MOST

OF OPERAND RIGHT
SIGNIFICANT BYTE

ONE

BIT

7 7X

ROTATE

BYTE

RIGHT

ASRLP1

CONTINUE

+
F
+

ASRLP1:
ROR
DECB
BNE
+

COUNT
DEC
BNE

NUMBER

OF

2,8
ASRLP

NEXT

THROUGH

ALL

BYTES

DECREMENT NUMBER OF
CONTINUE UNTIL DONE

SHIFTS

SHIFTS

*
*

REMOVE

PARAMETERS

LEAS
JMP

6,S
,U

SAMPLE

EXECUTION

FROM

STACK

AND

EXIT

*

EXITAS:

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

t+
+

SC4C:
LDA
LDB
LDX
PSHS
JSR

SHIFTS
#SZAY
AYADR
A,B,X
MPASR

GET NUMBER OF SHIFTS
GET LENGTH OF OPERAND IN BYTES
GET BASE ADDRESS OF OPERAND
SAVE PARAMETERS IN STACK
ARITHMETIC SHIFT RIGHT
*RESULT OF SHIFTING AY=EDCBA087654321H
*4 BITS IS AY=FEDCBA98765432H,
C=0
*

BRA
*

*DATA

SECTION

SC4C

AY

=

032H

*

IN

MEMORY

AY+1

=

O54H

x
*

AY+2
AY+3

=
=

0O76H
098H

*
*
*

AY+4
AY+5
AY+6

=
=
=

OBAH
ODCH
OFEH

4C

SZAY
SHIFTS:
AYADR:
AY:

EQU
FCB
FDB
FCB
END

Multiple-precision arithmetic shift right (MPASR)

7
4
AY

LENGTH OF OPERAND IN BYTES
NUMBER OF SHIFTS
BASE ADDRESS OF OPERAND

$21,$43,$65,$87,$A9,$CB,S$ED

121

122

4D

Assembly language subroutines for the 6809

Multiple-precision logical shift left

(MPLSL)

Shifts a multi-byte operand left logically by a specified number of bit
positions. The length of the operand (in bytes) is 255 or less. Sets the
Carry flag from the last bit shifted out of the leftmost bit position. The
operand is stored with its least significant byte at the lowest address.

Procedure The program clears the Carry initially (to fill with a 0 bit)
and then shifts the entire operand left 1 bit, starting with the least
significant byte. It repeats the operation for the specified number of
shifts.
Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Number of shifts (bit positions)
Length of the operand in bytes

More significant byte of base address of operand (address of its least
significant byte)
Less significant byte of base address of operand (address of its least
significant byte)
Exit conditions

Operand shifted left logically by the specified number of bit positions.
The least significant bit positions are filled with Os.

The Carry flag is set from the last bit shifted out of the leftmost bit
position. It is cleared if either the number of shifts or the length of the
operand is 0.

Examples

1.

Data:

Length of operand (in bytes) = 8
Operand = 85A4C719FE06741Ei¢

Number of shifts = 4

4D

Multiple-precision logical shift left (MPLSL)
Result:

123

Shifted operand = 5A4C719FE06741E0j¢.

This is the original operand shifted left 4 bits logically.
The four least significant bits are all cleared.
Carry = 0, since the last bit shifted from the leftmost bit
position was 0.

2.

Data:

Result:

Length of operand (in bytes) = 4
Operand = 3F6A42D34¢
Number of shifts = 3
Shifted operand = FB521698,..

This is the original operand shifted left 3 bits logically.
The three least significant bits are all cleared. |
Carry = 1, since the last bit shifted from the leftmost bit
position was 1.

Registers used

A,B,CC,U, xX

Execution time NUMBER OF SHIFTS x (24 + 13 x LENGTH OF
OPERAND IN BYTES) + 32 cycles.
If for example, NUMBER OF SHIFTS = 6 and LENGTH OF

OPERAND IN BYTES = 8, the execution time is

6 x (24 + 13 x 8) + 32 = 6 x 128 + 32 = 800 cycles

Program size

31 bytes

Data memory required

None

Special cases

1.
2.

Ifthe length of the operand is 0, the program exits immediately with
the operand unchanged and the Carry flag cleared.
Ifthe number of shifts is 0, the program exits immediately with the
operand unchanged and the Carry flag cleared.

124

Assembly language subroutines for the 6809

*
*
*
*

*

Title:

Multiple-Precision

*

Name:

MPLSL

Logical

Shift

Left

Purpose:

Logical
N bits.

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
Number of bits to shift
Length of the operand in bytes
High byte of operand base address
Low byte of operand base address

*
*
*

*
*

shift

left

a multi-byte

operand

*

*
*
*
*

*
*
*
*

The operand is stored with ARRAYCOJ as its
least significant byte and ARRAYCLENGTH-1]
as its most significant byte

*
*

*
*

*

Operand shifted left filling the least
significant bits with zeros.
CARRY := Last bit shifted from most
significant position

Exit:

*
*

*
*
*

Registers

A,B,CC,U,X

Used:

*

*

32

Time:

*

cycles overhead plus
((13 * Length) + 24) cycles

per

shift

*®

*

Program

Size:

31

bytes

*
*
*

MPLSL
LDU

a)

EXIT
IS

IF LENGTH OF
CARRY
ZERO.

SAVE

RETURN

ADDRESS

*
*
*

OPERAND OR
IS CLEARED

NUMBER OF
IN EITHER

BITS
CASE

TO

SHIFT

*

CLC
LDA
BEQ
LDA
BEQ

EXITLS
3,8
EXITLS

CLEAR CARRY
GET NUMBER OF BITS TO SHIFT
EXIT IF NUMBER OF BITS TO SHIFT IS
GET LENGTH OF OPERAND
EXIT IF LENGTH OF OPERAND IS ZERO

*
*
*
*

LSLLP:

SHIFT ENTIRE OPERAND LEFT
USE ZERO AS INITIAL CARRY

ONE BIT LOGICALLY
INPUT TO PRODUCE LOGICAL

SHIFT

ZERO

4D

Multiple-precision logical shift left (MPLSL)

LDX
LDB
CLC
SHIFT
START

4,8
3,8

EACH
WITH

POINT TO LEAST SIGNIFICANT BYTE
GET LENGTH OF OPERAND IN BYTES
CLEAR CARRY TO FILL WITH ZEROS

BYTE OF OPERAND LEFT ONE
LEAST SIGNIFICANT BYTE

BIT

,X+

SHIFT

BYTE

LEFT

LSLLP1

CONTINUE

THROUGH

ALL

BYTES

DECREMENT NUMBER OF
CONTINUE UNTIL DONE

SHIFTS

+

LSLLP1:
ROL
DECB
BNE
*+

COUNT

DEC
BNE

NUMBER

OF

2,8
LSLLP

NEXT

SHIFTS

*
*

REMOVE

PARAMETERS

LEAS
JMP

6,58
,U

SAMPLE

EXECUTION

FROM

STACK

AND

EXIT

*

EXITLSL:
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

HE
+

SC4D:

LDA
LDB
LDX
PSHS
JSR

SHIFTS
#SZAY
AYADR
A,B,X
MPLSL

BRA

SC4D

GET NUMBER OF SHIFTS
GET LENGTH OF OPERAND IN BYTES
GET BASE ADDRESS OF OPERAND
SAVE PARAMETERS IN STACK
LOGICAL SHIFT LEFT
*RESULT OF SHIFTING AY=EDCBA087654321H
*4 BITS IS AY=DCBA9876543210H, C=0
*
IN MEMORY AY
= 010H
*
AY+1 = 032H
*
AY+2 = 054H
*
AY+3 = 076H
*
AY+4 = 098H
x
AY+5 = OBAH
*
AY+6 = ODCH

*

*DATA SECTION
*
SZAY
EQU
SHIFTS:
FCB
AYADR:
FDB
AY:
FCB
END

7
4

LENGTH
NUMBER

AY

BASE

OF
OF

OPERAND
SHIFTS

ADDRESS

OF

$21,$43,$65,$87,$A9,$CB,SED

IN

BYTES

OPERAND

125

126

Assembly language subroutines for the 6809

4E Miultiple-precision logical shift right
(MPLSR)
Shifts a multi-byte operand right logically by a specified number of bit
positions. The length of the operand (in bytes) is 255 or less. Sets the
Carry flag from the last bit shifted out of the rightmost bit position. The
operand is stored with its least significant byte at the lowest address.

Procedure The program clears the Carry initially (to fill with a 0 bit)
and then shifts the entire operand right 1 bit, starting with the most
significant byte. It repeats the operation for the specified number of
shifts.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Number of shifts (bit positions)
Length of the operand in bytes
More significant byte of base address of operand (address of its least
significant byte)
Less significant byte of base address of operand (address of its least
significant byte)

Exit conditions

Operand shifted right logically by the specified number of bit positions.
The most significant bit positions are filled with Os.
The Carry flag is set from the last bit shifted out of the rightmost bit
position. It is cleared if either the number of shifts or the length of the
operand is 0.

Examples

1.

Data:

Length of operand (in bytes) = 8

4E

Multiple-precision logical shift right (MPLSR)

127

Operand = 85A4C719FE06741Ej¢6
Number of shifts = 4
Result:

Shifted operand = 085A4C719FE06741¢.

This is the original operand shifted right 4 bits logically.
The four most significant bits are all cleared.
Carry = 1, since the last bit shifted from the rightmost bit
position was 1.

2.

Data:

Length of operand (in bytes) = 4
Operand = 3F6A42D316

Number of shifts = 3
Result:

Shifted operand = O7ED485A4¢.

This is the original operand shifted right 3 bits logically.
The three most significant bits are all cleared.
Carry = 0, since the last bit shifted from the rightmost bit
position was 0.

Registers used

A,B,CC, X,U

Execution time NUMBER OF SHIFTS x (23 + 13 x LENGTH OF
OPERAND IN BYTES) + 48 cycles.
If, for example, NUMBER OF SHIFTS = 6 and LENGTH
OPERAND IN BYTES = 8, the execution time is

OF

6 X (23 + 13 x 8) + 48 = 6 X 127 + 48 = 810cycles

Program size

37 bytes

Data memory required

None

Special cases
1.
2.

Ifthe length of the operand is 0, the program exits immediately with
the operand unchanged and the Carry flag cleared.
If the number of shifts is 0, the program exits immediately with the
operand unchanged and the Carry flag cleared.

Assembly language subroutines for the 6809

128
* ok
*
*
*

Title:

Multiple-Precision

*

Name:

MPLSR

Purpose:

Logical
N bits.

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
Number of bits to shift
Length of the operand in bytes
High byte of operand base address
Low byte of operand base address

Logical

Shift

Right

*
*
*

*
*

shift

right

a multi-byte

operand

*

*
*
*
*
*
*

*
*

The operand is stored with ARRAYC[O] as its
least significant byte and ARRAYCLENGTH-1]
as its most significant byte

*
*

*
*

*

Exit:

Operand shifted right filling the most
significant bits with zeros.
Carry := Last bit shifted from least

*
*

significant

*

position.

*

*

Registers

Used:

A,B,CC,U,X

*

*

48

Time:

*

cycles overhead plus
((13 * Length) + 23) cycles

per

shift

*

*
*

Size:

Program

37

bytes

*
*

MPLSR
79

EXIT
IS

IF LENGTH OF
ZERO.
CARRY

CLC
LDA
BEQ
LDA
BEQ
*

SAVE

LDU

SAVE
LDX
LEAX
STX

OPERAND OR
IS CLEARED

4 rs
A 7X
79

TO

ADDRESS

NUMBER OF
IN EITHER

BITS
CASE

TO

SHIFT

CLEAR CARRY INITIALLY
GET NUMBER OF BITS TO SHIFT
EXIT IF NUMBER OF BITS TO SHIFT IS
GET LENGTH OF OPERAND
EXIT IF LENGTH OF OPERAND IS ZERO

2,8
EXITLS
3,8
EXITLS
POINTER

RETURN

END

OF

OPERAND

GET BASE ADDRESS OF OPERAND
CALCULATE ENDING ADDRESS OF OPERAND
SAVE ENDING ADDRESS OF OPERAND

ZERO

4E

Multiple-precision logical shift right (MPLSR)

SHIFT ENTIRE OPERAND RIGHT ONE BIT
USE ZERO AS INITIAL CARRY INPUT TO

LOGICALLY
PRODUCE LOGICAL

129

SHIFT

LSRLP:
LDX
LDB
CLC

SHIFT
START

)
3,58

EACH
WITH

POINT TO END OF OPERAND
GET LENGTH OF OPERAND IN
CLEAR CARRY TO FILL WITH

BYTE
MOST

OF OPERAND RIGHT
SIGNIFICANT BYTE

ONE

BYTES
ZEROS

BIT

€
+

LSRLP1:
ROR
DECB
BNE
COUNT
DEC
BNE

77X

SHIFT

LSRLP1

CONTINUE

NUMBER

OF

2,8
LSRLP

REMOVE

PARAMETERS

LEAS
JMP

6,S
7U

SAMPLE

EXECUTION

NEXT

BYTE

RIGHT

THROUGH

ALL

BYTES

DECREMENT NUMBER OF
CONTINUE UNTIL DONE

SHIFTS

SHIFTS

FROM

STACK

AND

EXIT

EXITLS:
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

Oo C4E:
+

LDA
LDB
LDX
PSHS
JSR

SHIFTS
#SZAY
AYADR
A,B,X
MPLSR

GET NUMBER OF SHIFTS
GET LENGTH OF OPERAND IN BYTES
GET BASE ADDRESS OF OPERAND
SAVE PARAMETERS IN STACK
LOGICAL SHIFT RIGHT
*RESULT OF SHIFTING AY=EDCBA087654321H
*4 BITS IS AY=OEDCBA98765432H, C=0
*

BRA

AY

=

032H

*

IN

MEMORY

AY+1

=

O54H

*

AY+2

=

0O76H

*

AY+3

=

098H

*
*

AY+4
AY+5

=
=

OBAH
ODCH

*

AY+6

=

OOEH

SC4E

*

*DATA SECTION
*
SZAY
EQU
SHIFTS:
FCB
AYADR:
FDB
AY:
FCB
END

7
4
AY

LENGTH OF OPERAND
IN BYTES
NUMBER OF SHIFTS
BASE ADDRESS OF OPERAND

$21,$43,%$65,$87,$A9,$CB,SED

130

4F

Assembly language subroutines for the 6809

Miultiple-precision rotate right

(MPRR)

Rotates a multi-byte operand right by a specified number of bit positions
as if the most significant bit and least significant bit were connected. The
length of the operand (in bytes) is 255 or less. Sets the Carry flag from
the last bit shifted out of the rightmost bit position. The operand is
stored with its least significant byte at the lowest address.

Procedure The program shifts bit 0 of the least significant byte of the
operand to the Carry flag and then shifts the entire operand right 1 bit,
starting with the most significant byte. It repeats the operation for the
specified number of rotates.

Entry conditions

Order in stack (starting from the top)

More significant byte of return address
Less significant byte of return address

Number of rotates (bit positions)
Length of the operand in bytes

More significant byte of base address of operand (address of its least
significant byte)
Less significant byte of base address of operand (address of its least
significant byte)

Exit conditions

Operand rotated right by the specified number of bit positions. The
most significant bit positions are filled from the least significant bit
positions.
The Carry flag is set from the last bit shifted out of the rightmost bit
position. It is cleared if either the number of shifts or the length of the
operand is 0.

4F

Multiple-precision rotate right (MPRR)

131

Examples

1.

Data:

Result:

Length of operand (in bytes) = 8
Operand = 85A4C719FE06741E1.¢
Number of rotates = 4
Shifted operand = E85A4C719FE06741,¢.

This is the original operand rotated right 4 bits. The four
most significant bits are equivalent to the original four
least significant bits.
Carry = 1, since the last bit shifted from the rightmost bit
position was 1.

2.

Data:

Length of operand (in bytes) = 4
Operand = 3F6A42D34¢

Number of rotates = 3
Result:

Shifted operand = 67ED485A
ig.

This is the original operand rotated right 3 bits. The three
most significant bits (011) are equivalent to the original
three least significant bits.
Carry = 0, since the last bit shifted from the rightmost bit
position was 0.
ee

Registers used

A,B,CC, U, xX

Execution time NUMBER OF ROTATES x (32 + 13 x LENGTH
OF OPERAND IN BYTES) + 48 cycles.
If, for example, NUMBER OF ROTATES = 6 and LENGTH OF
OPERAND IN BYTES =8, the execution time is

6 x (32 + 13 x 8) + 48 = 6 x 136 + 48 = 864 cycles
Program size

40 bytes

Data memory required

None

Special cases

1. Ifthe length of the operand is 0, the program exits immediately with
the operand unchanged and the Carry flag cleared.

132

Assembly language subroutines for the 6809

2. Ifthe number of rotates is 0, the program exits immediately with the
operand unchanged and the Carry flag cleared.

Title:

Multiple-Precision

Name:

MPRR

Purpose:

Rotate right
N bits.

Entry:

TOP

OF

Rotate

Right

a multi-byte

operand

STACK

High byte of return address
Low byte of return address
Number of bits to rotate
Length of the operand in bytes
High byte of operand base address
Low byte of operand base address
The operand is stored with ARRAYL[O] as its
Least significant byte and ARRAYCLENGTH-1]
as its most significant byte
Operand rotated right
Carry := Last bit shifted from
significant position.
Registers

Used:

least

A,B,CC,U,X

Time:

48

Size:

cycles overhead plus
((13 * Length) + 32) cycles

Program

40

per

shift

bytes

HHO
HHH
HHH
OO
OH
Oe
OF
He
OHHH
HO
+
&

MPRR
LDU

739

SAVE

RETURN

ADDRESS

EXIT
IS

IF LENGTH OF
ZERO.
CARRY

CLC
LDA

2,8

CLEAR CARRY INITIALLY
GET NUMBER OF BITS TO

BEQ

EXITRR

EXIT

LDA
BEQ

3,58
EXITRR

GET LENGTH OF OPERAND
EXIT IF LENGTH OF OPERAND

*

*
*

OPERAND OR
IS CLEARED

NUMBER OF
IN EITHER

BITS
CASE

TO

ROTATE

*

+

SAVE

POINTER

TO

END

OF

IF

NUMBER

OPERAND

OF

BITS

ROTATE
TO

ROTATE

IS

ZERO

IS

ZERO

4F

Multiple-precision rotate right (MPRR)

LDX
LEAX
STX

4,58
A,X
79

133

GET BASE ADDRESS OF OPERAND
POINT TO END OF OPERAND
SAVE POINTER TO END OF OPERAND

ROTATE ENTIRE OPERAND RIGHT ONE BIT
USE PREVIOUS LEAST SIGNIFICANT BIT AS
TO PRODUCE ROTATION

INITIAL

CARRY

INPUT

+OF

RRLP:

LDX
LDA
LSRA
LDB
LDX

SHIFT
START

ROR
DECB
BNE
+

COUNT

DEC
BNE

4,8
7X

POINT TO LEAST SIGNIFICANT BYTE
GET LEAST SIGNIFICANT BYTE
SHIFT BIT 0 TO CARRY FOR USE IN
GET LENGTH OF OPERAND IN BYTES
POINT TO END OF OPERAND

3,8
a)

EACH
WITH

BYTE
MOST

OF OPERAND RIGHT
SIGNIFICANT BYTE

7X

SHIFT

RRLP1

CONTINUE

NUMBER

OF

2,58
RRLP

NEXT

ONE

ROTATION

BIT

BYTE

RIGHT

THROUGH

ALL

BYTES

DECREMENT NUMBER OF
CONTINUE UNTIL DONE

ROTATES

ROTATES

*
*

REMOVE

PARAMETERS

LEAS
JMP
RTS

6,8
,U

SAMPLE

EXECUTION

FROM

STACK

AND

EXIT

*

EXITRR:

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

t+
Fe
+
F

SC4F:

LDA
LDB
LDX
PSHS
JSR

ROTATS
#STZAY
AYADR
A,B,X
MPRR

GET NUMBER OF ROTATES
GET LENGTH OF OPERAND IN BYTES
GET BASE ADDRESS OF OPERAND
SAVE PARAMETERS IN STACK
ROTATE RIGHT
*RESULT OF ROTATING AY=EDCBA087654321H
*4 BITS IS AY=1EDCBA98765432H, C=O
*
*

IN

MEMORY

AY
AY+1

=
=

032H
054H

*
*

AY+2

AY+3

=
=

O76H
098H

*
*
*

AY+4
AY+5
AY+6

=
=
=

OBAH
ODCH
O1EH

134

Assembly language subroutines for the 6809
BRA

SC4F

*

*DATA SECTION
*
SZAY
EQU
ROTATS:
FCB
AYADR:
FDB
AY:
FCB
END

C
LENGTH OF OPERAND IN BYTES
4
NUMBER OF ROTATES
AY
BASE ADDRESS OF OPERAND
$21,$43,%$65,$87,$A9,$CB,SED

4G

Multiple-precision rotate left (MPRL)

135

4G Miultiple-precision rotate left
(MPRL)
Rotates a multi-byte operand left by a specified number of bit positions
as if the most significant bit and least significant bit were connected. The
length of the number (in bytes) is 255 or less. Sets the Carry flag from
the last bit shifted out of the leftmost bit position. The operand is stored
with its least significant byte at the lowest address.

Procedure The program shifts bit 7 of the most significant byte of the
operand to the Carry flag. It then shifts the entire operand left 1 bit,
starting with the least significant byte. It repeats the operation for the
specified number of rotates.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Number of rotates (bit positions)
Length of the operand in bytes
More significant byte of base address of operand (address of its least
significant byte)
Less significant byte of base address of operand (address of its least
significant byte)
Exit conditions

Operand rotated left by the specified number of bit positions (the least
significant bit positions are filled from the most significant bit positions).
The Carry flag is set from the last bit shifted out of the leftmost bit
position. It is cleared if either the number of shifts or the length of the
operand is 0.

Examples

1.

Data:

Length of operand (in bytes) = 8

136

Assembly language subroutines for the 6809

Result:

2.

Data:

Result:

Operand = 85A4C719FE06741E4¢6
Number of rotates = 4
Shifted operand = 5A4C719FE06741E8¢.
This is the original operand rotated left 4 bits. The four
least significant bits are equivalent to the original four
most significant bits.
Carry = 0, since the last bit shifted from the leftmost bit
position was 0.

Length of operand (in bytes) = 4
Operand = 3F6A42D34¢6
Number of rotates = 3
Shifted operand = FB521699;¢.

This is the original operand rotated left 3 bits. The three
least significant bits (001) are equivalent to the original
three most significant bits.
Carry = 1, since the last bit shifted from the leftmost bit
position was 0.

Registers used

A,B,CC, U, X

Execution time NUMBER OF ROTATES x (34 + 13 x LENGTH
OF OPERAND IN BYTES) + 50 cycles.
If, for example, NUMBER OF ROTATES = 6 and LENGTH OF
OPERAND IN BYTES = 8, the execution time 1s

6 X (34+ 13 X 8) + 50
= 6 X 138
+ 50 = 878 cycles
Program size

41 bytes

Data memory required

None

Special cases

1. Ifthe length of the operand is 0, the program exits immediately with
the operand unchanged and the Carry flag cleared.

2. Ifthe number of rotates is 0, the program exits immediately with the
operand unchanged and the Carry flag cleared.

4G

Multiple-precision rotate left (MPRL)

137

Title:
Name:

Multiple-Precision

Purpose:

Rotate left
N bits.

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
Number of bits to rotate
Length of the operand in bytes
High byte of operand base address
Low byte of operand base address

Rotate

Left

MPRL

a multi-byte

operand

The operand is stored with ARRAYLO] as its
Least significant byte and ARRAYLLENGTH-1]
as its most significant byte
Exit:

Number rotated left
Carry := Last bit shifted from
significant position.

Registers

the

most

Used:

Time:

50

Size:

cycles overhead plus
((13 * Length) + 34) cycles

Program

41

per

shift

bytes

FHF
HK
HF
FE
+£
FF
FK

LDU

Pa)

EXIT
IS

IF LENGTH OF
ZERO.
CARRY

CLC
LDA
BEQ
LDA
BEQ
*

SAVE

SAVE

TO

DECA
LDX
LEAX

OPERAND OR
IS CLEARED

>
&

<n

ADDRESS

NUMBER OF
IN EITHER

BITS
CASE

TO

ROTATE

CLEAR CARRY
GET NUMBER OF BITS TO ROTATE
EXIT IF NUMBER OF BITS TO ROTATE IS
GET LENGTH OF OPERAND
EXIT IF LENGTH OF OPERAND IS ZERO

2,58
EXITRL
3,8
EXITRL
POINTER

RETURN

MOST

SIGNIFICANT

BYTE

OF

OPERAND

OFFSET OF MOST SIGNIFICANT BYTE
* LENGTH OF OPERAND - 1
GET BASE ADDRESS OF OPERAND
POINT TO MOST SIGNIFICANT BYTE

=

ZERO

138

Assembly language subroutines for the 6809
STX

79

SAVE

POINTER

TO

MOST

ROTATE ENTIRE OPERAND LEFT ONE BIT
USE PREVIOUS MOST SIGNIFICANT BIT AS
TO PRODUCE ROTATION

SIGNIFICANT

INITIAL

CARRY

BYTE

INPUT

ama LLP:
&
+

LDX
LDA
ASLA
LDB
LDX

SHIFT
START

79
Xt

POINT TO MOST SIGNIFICANT BYTE
GET MOST SIGNIFICANT BYTE
SHIFT BIT 7 TO CARRY FOR USE IN
GET LENGTH OF OPERAND IN BYTES
GET BASE ADDRESS OF OPERAND

3,8
4,8

EACH
WITH

BYTE OF OPERAND RIGHT ONE
LEAST SIGNIFICANT BYTE

BIT

7X

SHIFT

BYTE

LEFT

RLLP1

CONTINUE

THROUGH

ALL

BYTES

DECREMENT NUMBER OF
CONTINUE UNTIL DONE

ROTATES

ROTATION

LLP1:
ROL
DECB
BNE
+

COUNT
DEC
BNE

NUMBER

OF

2,8
RRLP

NEXT

ROTATES

*
*

REMOVE

PARAMETERS

LEAS
JMP

6,S
,U

SAMPLE

EXECUTION

FROM

STACK

AND

EXIT

*

EXITRL:

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

+

SC4G:
LDA
LDB
LDX
PSHS
JSR

ROTATS
#SZAY
AYADR
A,B,X
MPRL

GET NUMBER OF ROTATES
GET LENGTH OF OPERAND IN BYTES
GET BASE ADDRESS OF OPERAND
SAVE PARAMETERS IN STACK
ROTATE LEFT
*RESULT OF ROTATING AY=EDCBA087654321H
*4 BITS IS AY=DCBA987654321EH, C=0
*

BRA

SC4G

AY

=

O1EH

*
*
*
*

IN

MEMORY

AY+1
AY+2
AY+3
AY+4

=
=
=
=

032H
O54H
O76H
098H

*

AY+5

=

OBAH

*

AY+6

=

ODCH

4G
*DATA SECTION
*
SZAY
EQU
ROTATS:
FCB
AYADR:
FDB
AY:
FCB
END

Multiple-precision rotate left (MPRL)

7
4
AY

LENGTH OF OPERAND IN BYTES
NUMBER OF ROTATES
BASE ADDRESS OF OPERAND

$21,$43,$65,$87,$A9,$CB,$ED

139

5 String manipulation

5A String compare
(STRCMP)
Compares two strings and sets the Carry and Zero flags accordingly.
Sets the Zero flag to 1 if the strings are identical and to 0 otherwise. Sets
the Carry flag to 1 if the string with the base address higher in the stack
(string 2) is larger than the other string (string 1), and to 0 otherwise.
Each string consists of at most 256 bytes, including an initial byte
containing the length. If the two strings are identical through the length
of the shorter, the longer string is considered to be larger.

Procedure The program first determines which string is shorter. It
then compares the strings one byte at a time through the length of the
shorter. It exits with the flags set if it finds corresponding bytes that
differ. If the strings are the same through the length of the shorter, the
program sets the flags by comparing the lengths.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

140

5A_

String compare (STRCMP)

141

More significant byte of base address of string 2
Less significant byte of base address of string 2

More significant byte of base address of string 1
Less significant byte of base address of string 1
Exit conditions

Flags set as if string 2 had been subtracted from string 1. If the strings
are the same through the length of the shorter, the flags are set as if the
length of string 2 had been subtracted from the length of string 1.
Zero flag = 1 if the strings are identical, 0 if they are not identical.
Carry flag = 1 if string 2 is larger than string 1, 0 if they are identical or
string 1 is larger. If the strings are the same through the length of the
shorter, the longer one is considered to be larger.
Examples

1.

Data:

3.

Data:

String 1 = 05‘PRINT” (05 is the length of the string)
String 2 = 03‘END?’ (03 is the length of the string)
Result: Zero flag = 0 (strings are not identical)
Carry flag = 0 (string 2 is not larger than string 1)
2. Data:
String 1 = 05‘PRINT” (05 is the length of the string)
String 2 = 02‘PR’ (02 is the length of the string)
Result: Zero flag = 0 (strings are not identical)
Carry flag = 0 (string 2 is not larger than string 1)
The longer string (string 1) is considered to be larger. To determine
whether string 2 is an abbreviation of string 1, use Subroutine 5C (Find
the position of a substring). String 2 is an abbreviation if it is part of
string 1 and starts at the first character.

Result:

String 1 = 05‘PRINT? (05 is the length of the string)
String 2 = 06°‘SYSTEM?” (06 is the length of the string)
Zero flag = 0 (strings are not identical)
Carry flag = 1 (string 2 is larger than string 1)

We are assuming here that the strings consist of ASCII characters.
Note that the initial length byte is a hexadecimal number, not a character. We have represented this byte as two hexadecimal digits in front of
the string; the string itself is surrounded by single quotation marks.
This routine treats spaces like other characters. Assuming ASCII
strings, the routine will, for example, find that SPRINGMAID is larger

142

Assembly language subroutines for the 6809
than SPRING MAID, since an ASCII M (4Dj¢) is larger than an ASCII

space (2046).
Note that this routine will not order strings alphabetically as defined
in common uses such as indexes and telephone directories. Instead, it
uses the ASCII character order shown in Appendix 3. Note, in particular, that:

1.

Spaces precede all other printing characters.

2.

Periods, commas, and dashes precede numbers.

3.

Numbers precede letters.

4.

Capital letters precede lower-case letters.

This ordering produces such non-standard results as the following:

1.

9TH AVENUE SCHOOL would precede CAPITAL CITY
SCHOOL (or, in fact, any string starting with a letter). 9TH
AVENUE will not be treated as if it started with the letter N.

2.

EZ8 MOTEL would precede East Street Motel since a capital Z
precedes a lower-case a.

3.

NEW YORK would precede NEWARK or NEWCASTLE since a
space precedes any letter.

Registers used

A,B, CC, U, X

Execution time

1. If the strings are not identical through the length of the shorter, the
execution time is approximately
45 + 20 X NUMBER OF CHARACTERS COMPARED

If, for example, the routine compares five characters before finding a
disparity, the execution time is approximately
45 + 20 x 5 = 45 + 100 = 145 cycles
2. If the strings are identical through the length of the shorter, the
execution time is approximately
|
66 + 20 X LENGTH OF SHORTER STRING

5A

String compare (STRCMP)

143

If, for example, the shorter string is 8 bytes long, the execution time is

66 + 20 X 8 = 66 + 160 = 226 cycles
Program size

36 bytes

Data memory required

None

Special case If either string (but not both) has a 0 length, the program returns with the flags set as though the other string were larger. If
both strings have 0 length, they are considered to be equal.
ee nae
jw SSL.
*

*

Title

*

Name:

String
STRCMP

Compare

*

*

Purpose:

Compare 2 strings
or cleared.

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
High byte of string 2 address
Low byte of string 2 address
High byte of string 1 address
Low byte of string 1 address

*

Each string
followed by
Exit:

Registers

IF

string
Z=1,C=0
IF string
Z=0,C=0
IF string
Z=0,C=1
Used:

and

return

C and

2 flags

set

consists of a length byte
a maximum of 255 characters.

1 =

string

2 THEN

1 >

string

2 THEN

1 <

string

2 THEN

A,B,CC,U,X

Time:

45 cycles overhead plus 20 cycles per byte plus
21 cycles if the strings are identical through
the Length of the shorter one.

Size:

Program

*DETERMINE
*LENGTH OF

36

bytes

WHICH STRING IS SHORTER
SHORTER = NUMBER OF BYTES

TO

COMPARE

144

Assembly language subroutines for the 6809

LDX
LDU
LDB
CMPB
BCS

4,8
2,8
7Xt+
,U+
BEGCMP

LDB

-1,U

GET BASE ADDRESS OF STRING 1
GET BASE ADDRESS OF STRING 2
GET LENGTH OF STRING 1
COMPARE TO LENGTH OF STRING 2
BRANCH IF STRING 1 IS SHORTER
* ITS LENGTH IS NUMBER OF BYTES
OTHERWISE, STRING 2 IS SHORTER
* ITS LENGTH IS NUMBER OF BYTES

TO

COMPARE

TO

COMPARE

*

*COMPARE
*EXIT AS

STRINGS
SOON AS

THROUGH LENGTH OF SHORTER
CORRESPONDING CHARACTERS DIFFER

*

BEGCMP:
TSTB
BEQ

CHECK IF SHORTER
BRANCH CEXIT) IF

EXITSC

STRING HAS
IT DOES

ZERO

LENGTH

CMPLP:
GET CHARACTER FROM STRING 1
COMPARE TO CHARACTER FROM STRING 2
BRANCH IF CHARACTERS ARE NOT EQUAL
* 2,C WILL BE PROPERLY SET OR CLEARED
COUNT CHARACTERS
CONTINUE UNTIL ALL BYTES COMPARED

Xt

LDA
CMPA
BNE

EXITSC

DECB
CMPLP
BNE
*
*STRINGS SAME THROUGH LENGTH OF SHORTER
*SO USE LENGTHS TO SET FLAGS
*
GET LENGTH OF STRING 1
C4,S]
LDA
COMPARE LENGTH OF STRING
[2,8]
CMPA
*
*REMOVE PARAMETERS FROM STACK AND EXIT

2

*

EXITSC:
LDU
LEAS
JMP

+

SAMPLE

SAVE RETURN ADDRESS
REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

73

,V

EXECUTION:

SC5A:

SC5A

BRA

FCB
FCC

BASE ADDRESS OF STRING 1
BASE ADDRESS OF STRING 2
SAVE PARAMETERS IN STACK
COMPARE STRINGS
*COMPARING "STRING 1" AND "STRING
*
RESULTS IN STRING 1 LESS THAN
*
STRING 2, SO Z=0,C=1
LOOP THROUGH TEST

#S1
#S2
X,Y
STRCMP

LDY
LDX
PSHS
JSR

TEST

STACK

DATA

$20
/STRING

1

2"

5A
$2

FCB
FCC

END

String compare (STRCMP)
$20
/STRING

2

145

146

Assembly language subroutines for the 6809

5B String concatenation
(CONCAT)
Combines (concatenates) two strings, placing the second immediately
after the first in memory. If the concatenation would produce a string
longer than a specified maximum, the program concatenates only
enough of string 2 to give the combined string its maximum length. The
Carry flag is cleared if all of string 2 can be concatenated. It is set to 1 if
part of string 2 must be dropped. Each string consists of at most 256
bytes, including an initial byte containing the length.

Procedure The program uses the length of string 1 to determine
where to start adding characters, and the length of string 2 to determine
how many characters to add. If the sum of the lengths exceeds the
maximum, the program indicates an overflow. It then reduces the
number of characters it must add to the maximum length minus the
length of string 1. Finally, it moves the characters from string 2 to the
end of string 1, updates the length of string 1, and sets the Carry flag to
indicate whether characters were discarded.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Maximum length of string 1

More significant byte of base address of string 2
Less significant byte of base address of string 2
More significant byte of base address of string 1
Less significant byte of base address of string 1

Exit conditions

String 2 concatenated at the end of string 1 and the length of string 1
increased accordingly. If the combined string would exceed the
maximum length, only the part of string 2 that would give string 1 its

5B

String concatenation (CONCAT)

147

maximum length is concatenated. If any part of string 2 must be
dropped, the Carry flag is set to 1. Otherwise, the Carry flag is cleared.
eS
ES eee eee

Examples
1.

Data:

Maximum length of string 1 = OEy¢ = 141

String 1 = 07 JOHNSON’ (07 is the length of the string)
String 2 = 05‘, DON’ (0S is the length of the string)

2.

Result:

String 1 = OC-JJOHNSON, DON’ (0Cig = 1210 is the
length of the combined string with string 2 placed after
string 1)
Carry = 0, since no characters were dropped

Data:

String 1 = 07‘JOHNSON’ (07 is the length of the string)
String 2 = 09‘, RICHARD’ (09 is the length of the string)

Result:

String 1 = OE‘JOHNSON, RICHA’ (OEi¢ = 1410 is the
maximum length allowed, so the last two characters of
string 2 have been dropped)
Carry = 1, since characters had to be dropped

Note that we are representing the initial byte (containing the string’s
length) as two hexadecimal digits in both examples.

Registers used

All

Execution time

Approximately

17 x NUMBER
cycles overhead

OF CHARACTERS

CONCATENATED

plus 95

NUMBER OF CHARACTERS CONCATENATED is usually the
length of string 2, but will be the maximum length of string 1 minus its
current length if the combined string would be too long. If, for example,
NUMBER OF CHARACTERS CONCATENATED is 1446 (2010), the
execution time is
17 X 20 + 95 = 340 + 95 = 435 cycles

The overhead is an extra 28 cycles if the string must be truncated.

148

Assembly language subroutines for the 6809

Program size

59 bytes

Data memory required

None

Special cases

1. If the concatenation would make the string exceed its specified
maximum length, the program concatenates only enough of string 2 to
reach the maximum. If any of string 2 must be truncated, the Carry flag
is set to 1.
2. If string 2 has a length of 0, the program exits with the Carry flag
cleared (no errors) and string 1 unchanged. That is, a length of 0 for
either string is interpreted as 0, not as 256.
3. Ifthe original length of string 1 exceeds the specified maximum, the
program exits with the Carry flag set to 1 (indicating an error) and string
1 unchanged.

Title

String

Name:

CONCAT

Concatenation

Purpose:

Concatenate

Entry:

TOP OF
High

+
%

2 strings

HH
+t
HF
HE
He
HH
F
+

one

string.

STACK
byte of return address
Low byte of return address
Maximum length of string 1
High byte of string 2 address
Low byte of string 2 address
High byte of string 1 address
Low byte of string 1 address

Each string
followed by
Exit:

into

consists of a length byte
a maximum of 255 characters.

String 1 := string 1 concatenated with string 2
If no errors then
Carry := 0
else
begin
Carry := 1
if the concatenation makes string 1 too
long, concatenate only the part of string 2
that results in string 1 having its maximum
Length
if lLength(string1) > maximum Length then

5B

String concatenation (CONCAT)

*
*

no

concatenation

149
is

done

Time:

Approximately 17 * (length
plus 95 cycles overhead

of

Size:

Program

end

*

*

Registers

Used:

ALL

%

*
*

string

2)

cycles

*

*

59

bytes

SAVE

RETURN

*

CONCAT:
LDU

9

ADDRESS

*

*DETERMINE
WHERE TO START ADDING CHARACTERS
*CONCATENATION
STARTS AT THE END OF STRING
1
*END OF STRING
1 = BASE 1 + LENGTH1
+ 1, WHERE
*
THE EXTRA 1 IS FOR THE LENGTH BYTE
*

CLR
LDX
LDA
LEAX
LEAX

1,8
5,58
x
A,X
1,X

INDICATE
NO TRUNCATION
NECESSARY
GET BASE ADDRESS OF STRING
1
GET LENGTH OF STRING
1
POINT TO LAST BYTE IN STRING
1
POINT JUST BEYOND
END OF STRING
1

*

*NEW CHARACTERS
COME
*
BASE2+1
(SKIPPING

FROM
OVER

STRING
LENGTH

2, STARTING
BYTE)

AT

*

LDY
LDB

3,8
7X+

BEQ

SETTRN

GET BASE ADDRESS OF STRING 2
GET LENGTH OF STRING 2 AND POINT TO
* FIRST DATA BYTE
BRANCH
CEXIT)
IF STRING 2 HAS ZERO LENGTH
* NO. ERROR IN THIS CASE

*

*DETERMINE
HOW MANY CHARACTERS
TO CONCATENATE
*THIS
IS LENGTH OF STRING 2 IF COMBINED
STRING WOULD
LENGTH
*
NOT EXCEED MAXIMUM
*OTHERWISE,
IT IS THE NUMBER THAT WOULD BRING COMBINED
*
STRING TO ITS MAXIMUM
LENGTH - THAT IS, MAXIMUM
LENGTH
*
MINUS
1
LENGTH OF STRING
*

STB
ADDA

79
78

BCS
CMPA
BLS

TOOLNG
2,58
DOCAT

SAVE LENGTH OF STRING 2 IN STACK
ADD STRING
LENGTHS
TO DETERMINE
LENGTH
STRING
* OF COMBINED
BRANCH
IF LENGTH WILL EXCEED 255 BYTES
COMPARE TO MAXIMUM
LENGTH
BRANCH
IF LENGTH DOES NOT EXCEED MAXIMUM

*

*COMBINED
IS TOO LONG
STRING
* INDICATE
STRING OVERFLOW WITH FF MARKER
IN STACK
* SET NUMBER OF CHARACTERS
TO CONCATENATE
=
MAXLEN
* SET NEW LENGTH OF STRING
1 TO MAXIMUM
LENGTH

~

S1LEN

*

TOOLNG:
COM
LDB

1,8
2,58

INDICATE
STRING TRUNCATION
(MARKER = FF)
NUMBER OF CHARACTERS
TO CONCATENATE
=

150

Assembly language subroutines for the 6809
SUBB
BLS

(5,$]
SETTRN

LDA

2,8

MAXIMUM LENGTH - STRING 1 LENGTH
BRANCH CEXIT) IF ORIGINAL STRING WAS
* TOO LONG
NEW LENGTH = MAXIMUM LENGTH

*

*CONCATENATE STRINGS BY
* TO THE AREA FOLLOWING
*

MOVING
STRING

CHARACTERS
1

FROM

STRING

2

DOCAT:
STA
TSTB
BEQ

(5,S]

SAVE NEW LENGTH
IN STRING
1'S LENGTH BYTE
CHECK NUMBER OF BYTES TO CONCATENATE
BRANCH
CEXIT)
IF NO BYTES TO CONCATENATE

SETTRN

CATLP:
LDA
STA
DECB
BNE

Yt
,Xt+

GET BYTE
FROM STRING
2
MOVE BYTE TO AREA FOLLOWING
STRING
CONTINUE
UNTIL ALL BYTES MOVED

1

CATLP

*
*SET

*CARRY

CARRY

FROM

TRUNCATION

= 1 IF CHARACTERS

INDICATOR

IN

STACK

HAD TO BE TRUNCATED,

O OTHERWISE

*

SETTRN:
ROR

1,8

SET CARRY
* CARRY =

FROM
1 IF

TRUNCATION
INDICATOR
TRUNCATION,
O IF NOT

FROM

AND

EXIT

*

*REMOVE

PARAMETERS

STACK

x
LEAS

7,8

REMOVE

JMP

,U

EXIT

PARAMETERS
TO

RETURN

FROM

STACK

ADDRESS

*

*

SAMPLE

EXECUTION:

*

SC5B:
LDY
LDX
LDA
PSHS
JSR

#$1
#82
#$20
A,X,Y
CONCAT

GET BASE ADDRESS
OF STRING
1
GET BASE ADDRESS
OF STRING 2
GET MAXIMUM
LENGTH OF STRING
SAVE PARAMETERS
IN STACK
CONCATENATE
STRINGS

*RESULT
*
*

OF

1

CONCATENATING

"LASTNAME"
AND ", FIRSTNAME"
IS $1 = 13H,"LASTNAME,
FIRSTNAME"

BRA

SC5B

LOOP

THROUGH

TEST

FCB
FCC
FCB

8
/LASTNAME
$0B

LENGTH

OF

S71

IN

LENGTH

OF

S2

IN

FCC

/,

*

*TEST

DATA

*

$1:
S2:

END

FIRSTNAME

BYTES
/ 32
BYTES

BYTE

MAX

LENGTH

/ 32

BYTE

MAX

LENGTH

5C

5C

Find the position of a substring (POS)

151

Find the position of a substring

(POS)

Searches for the first occurrence of a substring within a string. Returns
the index at which the substring starts if it is found and 0 otherwise. The
string and the substring each consist of at most 256 bytes, including an
initial byte containing the length. Thus, if the substring is found, its
starting index cannot be less than 1 or more than 255.

Procedure The program moves through the string searching for the
substring. It continues until it finds a match or until the remaining part
of the string is shorter than the substring and hence cannot possibly
contain it. If the substring does not appear in the string, the program
clears register A; otherwise, the program places the substring’s starting
index in register A.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of base address of substring
Less significant byte of base address of substring
More significant byte of base address of string
Less significant byte of base address of string

Exit conditions

Register A contains index at which first occurrence of substring starts if
it is found; register A contains 0 if substring is not found
Examples
1.

Data:

String = 1D‘ENTER SPEED IN MILES PER HOUR’
(1D16 = 2940 is the length of the string)

Result:

Register A contains 1015 (1610), the index at which the
substring ‘MILES’ starts

Substring = 05‘MILES’ (05 is the length of the substring)

152

Assembly language subroutines for the 6809

2.

Data:
Result:

3.

Data:
Result:

4.

String = 1B‘SALES FIGURES FOR JUNE 1981’ (1Bi¢
= 2740 Is the length of the string)
Substring = 04’JUNE’ (04 is the length of the substring)
Register A contains 1316 (1910), the index at which the
substring ‘JUNE’ starts
String = 10‘LET Y1 = X1 + R7 (106 = 1610 is the length
of the string)
Substring = 02‘R4’ (02 is the length of the substring)
Register A contains 0, since the substring *R4’ does not
appear in the string LET Y1 = X1 + R7

Data:

String = 07‘RESTOREP’ (07 is the length of the string)
Substring = 03‘RES’ (03 is the length of the substring)

Result:

Register A contains 1, the index at which the substring
‘RES’ starts. An index of 1 indicates that the substring
could be an abbreviation of the string. Interactive programs, such as BASIC interpreters and word processors,
often use abbreviations to save on typing and storage.

Registers used

All

Execution time Data-dependent, but the overhead is approximately
100 cycles, each successful match of one character takes 20 cycles, and
each unsuccessful match of one character takes 58 cycles. The worst case
is when the string and substring always match except for the last character in the substring, such as
String = ‘AAAAAAAAB’
Substring = ‘AAB’
The execution time in that case is

(STRING LENGTH — SUBSTRING LENGTH + 1) x (20 x (SUBSTRING LENGTH ~1) + 58) + 100
If, for example, STRING LENGTH

= 9 and SUBSTRING LENGTH

= 3 (as in the example above), the execution time is

(9 -—3+4+1) x (20 x 3 — 1) + 58) + 100 =7 x 98 + 100
= 686 + 100
= 786 cycles.

5C

Find the position of a substring (POS)

Program size

153

71 bytes

Data memory required

2 stack bytes

Special case

1. If either the string or the substring has a length of 0, the program
exits with 0 in register A, indicating that it did not find the substring.
2. If the substring is longer than the string, the program exits with 0 in
register A, indicating that it did not find the substring.
3. If the program returns an index of 1, the substring may be regarded
as an abbreviation of the string. That is, the substring occurs in the
string, starting at the first character. A typical example would be a string
PRINT and a substring PR.

4. If the substring occurs more than once in the string, the program
will return only the index to the first occurrence (the one with the
smallest starting index).
Title

Find

Name:

POS

Purpose:

Search for the first occurrence of a substring
in a string and return its starting index.
If the substring is not found, a 0 is returned.

Entry:

TOP

the

Position

of

a Substring

+

OF

STACK

High byte of return address
Low byte of return address
High byte of substring address
Low byte of substring address
High byte of string address
Low byte of string address

Each string
followed by
Exit:

Registers

OH
NH
HF
t+
+

Time:

consists of a length byte
a maximum of 255 characters.

If

the substring is found then
Register A = its starting index
else
Register A = 0
Used:

ALL

Since

the

algorithm

is

so

data

dependent

154

Assembly language subroutines for the 6809
a simple formula is impossible but the
following statements are true and a
worst case is given below:
100 cycles
Each match
A mismatch

overhead.
of 1 character takes
takes 58 cycles

20

cycles

Worst case timing occurs when the
string and substring always match
except for the last character of the
substring, such as:
string = 'AAAAAAAAAB'
substring = 'AAB'
Size:

Program
Data

71 bytes
2 stack

bytes

HH
HF
+£
KF
F
+

POS:

LDU

a)

SAVE

RETURN

ADDRESS

*

*EXIT,
*
HAS
*
CLRA
LDX
LDY
LDB
BEQ
TST
BEQ
SUBB
BCS

INDICATING SUBSTRING NOT FOUND, IF STRING OR SUBSTRING
ZERO LENGTH OR IF SUBSTRING IS LONGER THAN STRING

2,8
4,8
7Yt+
EXITPO
7X
EXITPO
7X
EXITPO

INDICATE SUBSTRING NOT FOUND
GET BASE ADDRESS OF SUBSTRING
GET BASE ADDRESS OF STRING
GET STRING LENGTH
BRANCH CEXIT) IF STRING LENGTH IS ZERO
CHECK SUBSTRING LENGTH
BRANCH CEXIT) IF SUBSTRING LENGTH IS ZERO
COMPARE STRING LENGTH, SUBSTRING LENGTH
BRANCH (EXIT) IF SUBSTRING IS LONGER THAN
* STRING

*

*SAVE INITIAL LOOP VARIABLES IN STACK
*THESE ARE (BOTTOM TO TOP):
x
ADDRESS OF FIRST CHARACTER IN SUBSTRING
*
LENGTH OF PART OF STRING THAT MUST BE EXAMINED
*
LENGTH OF SUBSTRING
*
ADDRESS OF FIRST CHARACTER IN STRING CPOINTER TO
*
INITIAL SECTION TO BE EXAMINED)
*
LENGTH OF PART THAT MUST BE EXAMINED IS
I NCB
* STRING LENGTH - SUBSTRING LENGTH + 1
* REMAINDER IS TOO SHORT TO CONTAIN
* SUBSTRING
LDA
eXt+
GET SUBSTRING LENGTH, MOVE POINTER TO
* FIRST CHARACTER IN SUBSTRING
STX
2,8
SAVE ADDRESS OF FIRST CHARACTER IN
* SUBSTRING
STD
7s
SAVE LENGTHS IN STACK AS INITIAL VALUES
* FOR COUNTERS
PSHS
Y
SAVE ADDRESS OF FIRST STRING BYTE

5C

Find the position of a substring (POS)

*
*SEARCH FOR SUBSTRING IN STRING
*START SEARCH AT BASE OF STRING
*CONTINUE UNTIL REMAINING STRING
*

SHORTER

155

THAN

SUBSTRING

CMPPOS:
LDY
LDX
LDB

PS)
4,S
2,8

GET
GET
GET

CURRENT STARTING POSITION
BASE ADDRESS OF SUBSTRING
SUBSTRING LENGTH

IN

STRING

NOT

FOUND

*

*COMPARE BYTES OF SUBSTRING WITH BYTES OF
* STARTING AT CURRENT POSITION IN STRING
*

STRING,

CHBYTE:
LDA
CMPA
BNE
DECB
BNE

7Yt+
Xt
NOTFND

GET BYTE OF STRING
COMPARE TO BYTE OF SUBSTRING
BRANCH IF NOT SAME, SUBSTRING
CONTINUE THROUGH SUBSTRING

CHBYTE

*

*SUBSTRING FOUND
* STRING
*
LDD
rs
SUBD

6,8

TFR
BRA

B,A
REMTMP

*

-

CALCULATE

INDEX

AT

WHICH

IT

STARTS

IN

GET STARTING ADDRESS OF SECTION CONTAINING
* SUBSTRING
SUBTRACT ADDRESS OF STRING'S LENGTH
* BYTE. DIFFERENCE ENDS UP IN B
SAVE INDEX IN A
EXIT, REMOVING TEMPORARIES
FROM STACK

*ARRIVE HERE IF SUBSTRING NOT
*MOVE STRING POINTER UP 1 FOR
*COUNT NUMBER OF COMPARISONS
*

FOUND
NEXT COMPARISON

NOTFND:
LDD
ADDD
STD
DEC
BNE
CLRA

a)
#1
79
3,8
CMPPOS

*
*REMOVE
*

MOVE CURRENT (STARTING)
STRING UP 1 CHARACTER

POSITION

SEARCH THROUGH SECTION OF STRING
THAT COULD CONTAIN SUBSTRING
SUBSTRING NOT FOUND AT ALL - MAKE
* STARTING INDEX ZERO

TEMPORARY

STORAGE,

PARAMETERS

FROM

STACK

LEAS

2,8

REMOVE

TEMPORARIES

FROM

STACK

LEAS
JMP

6,8
,U

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

REMTMP:

EXITPO:

SAMPLE

EXECUTION:

IN

AND

EXIT

156

Assembly language subroutines for the 6809

SC5C:

LDY
LDX
PSHS
JSR

#STG
#SSTG
X,Y
POS

BRA

SC5C¢

TEST
STG:
SSTG:

FCB
FCC
FCB
FCC
END

GET BASE ADDRESS OF STRING
GET BASE ADDRESS OF SUBSTRING
SAVE PARAMETERS IN STACK
FIND POSITION OF SUBSTRING
* SEARCHING "AAAAAAAAAB" FOR "AAB"
* RESULTS IN REGISTER A=8
LOOP THROUGH TEST

DATA
SOA
LENGTH
/AAAAAAAAAB
3
LENGTH
/AAB

OF

STRING

OF

SUBSTRING

/ 32

BYTE

MAX

/ 32

BYTE

MAX

5D

Copya substring froma string (COPY)

157

5D Copy a substring from a string
(COPY)
Copies a substring froma string, given a starting index and the number
of bytes to copy. Each string consists of at most 256 bytes, including an
initial byte containing the length. If the starting index of the substring is
0 (i.e. the substring would start in the length byte) or is beyond the end
of the string, the substring is given a length of 0 and the Carry flag is set
to 1. If the substring would exceed its maximum length or would extend
beyond the end of the string, then only the maximum number or the
available number of characters (up to the end of the string) are placed in
the substring, and the Carry flag is set to 1. If the substring can be
formed as specified, the Carry flag is cleared.

Procedure ‘The program exits immediately if the number of bytes to
copy, the maximum length of the substring, or the starting index is 0. It
also exits immediately if the starting index exceeds the length of the
string. If none of these conditions holds, the program checks whether
the number of bytes to copy exceeds either the maximum length of the
substring or the number of characters available in the string. If either is
exceeded, the program reduces the number of bytes to copy accordingly. It then copies the bytes from the string to the substring. The
program clears the Carry flag if the substring can be formed as specified
and sets the Carry flag if it cannot.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Number of bytes to copy
Starting index to copy from

More significant byte of base address of substring
Less significant byte of base address of substring
More significant byte of base address of string
Less significant byte of base address of string

Maximum length of substring

158

Assembly language subroutines for the 6809
Exit conditions

Substring contains characters copied from string. If the starting index is
0, the maximum length of the substring is 0, or the starting index is
beyond the length of the string, the substring will have a length of 0 and
the Carry flag will be set to 1. If the substring would extend beyond the
end of the string or would exceed its specified maximum length, only the
available characters from the string (up to the maximum length of the
substring) are copied into the substring; the Carry flag is set in this case
also. If no problems occur in forming the substring, the Carry flag is
cleared.

Examples
1.

2.

Data:

String = 10‘LET Y1 = R7 + X4 (1016 = 1640 is the length

Result:

of the string)
Maximum length of substring = 2
Number of bytes to copy = 2
Starting index = 5
Substring = 02‘Y1’ (2 is the length of the substring).
We have copied 2 bytes from the string starting at character #5 (i.e. characters 5 and 6)
Carry = 0, since no problems occur in forming the substring

Data:

String = 0E‘8657 POWELL ST’ (OEi6 = 1410 is the length
of the string)
Maximum length of substring = 1046 = 1610
Number of bytes to copy = 0D46 = 1310

Result:

Starting index = 06
Substring = 09‘POWELL ST’ (09 is the length of the
substring)
Carry = 1, since there were not enough characters available in the string to provide the specified number of bytes
to copy

3.

Data:

String = 169414 HEGENBERGER
2210 is the length of the string)

DRIVE’

(1616 =

Maximum length of substring = 1016 = 160
Number of bytes to copy = 11i6 = 1710
Result:

Starting index = 06
Substring = 100HEGENBERGER DRIV’ (1016 = 1610 is
the length of the substring)

5D

Copyasubstring from a string (COPY)

159

Carry = 1, since the number of bytes to copy exceeded the
maximum length of the substring

Registers used

All

Execution time

Approximately

17 x NUMBER OF BYTES COPIED plus 150 cycles overhead

NUMBER OF BYTES COPIED is the number specified if no problems
occur, or the number available or the maximum length of the substring
if copying would extend beyond either the string or the substring. If, for
example, NUMBER OF BYTES COPIED = 1219 (0Cj¢), the execution

time is
17 X 12 + 150 = 204 + 150 = 354 cycles

Program size

85 bytes

Data memory required

None

Special cases
1. If the number of bytes to copy is 0, the program assigns the substring a length of 0 and clears the Carry flag, indicating no error.
2. Ifthe maximum length of the substring is 0, the program assigns the
substring a length of 0 and sets the Carry flag to 1, indicating an error.
3. If the starting index of the substring is 0, the program assigns the
substring a length of 0 and sets the Carry flag to 1, indicating an error.
4. Ifthe source string does not even reach the specified starting index,
the program assigns the substring a length of 0 and sets the Carry flag to
1, indicating an error.
5. If the substring would extend beyond the end of the source string,
the program places all the available characters in the substring and sets
the Carry flag to 1, indicating an error. The available characters are the
ones from the starting index to the end of the string.

160

Assembly language subroutines for the 6809

6. If the substring would exceed its specified maximum length, the
program places only the specified maximum number of characters in the
substring. It sets the Carry flag to 1, indicating an error.
*
*

Title
Name:

Copy
COPY

a Substring

from

a String

Purpose:

Copy a substring from a string
index and the number of bytes.

Entry:

TOP

*

OF

given

a starting

STACK

High byte of return address
Low byte of return address
Number of bytes to copy
Starting index to copy from
High byte of destination string address
Low byte of destination string address
High byte of source string address
Low byte of source string address
Maximum Length of destination string
Each string
followed by

Exit:

Registers

FF
He
SF
HE
FE
BH
HF
EH
FH
F
H+

COPY:

consists of a length byte
a maximum of 255 characters.

Destination string := The substring from the
string.
If no errors then
Carry := 0
else
begin
the following conditions cause an
error and the Carry flag = 1.
if Cindex = 0) or (maxlen = 0) or
(index > length(source)
then
the destination string will have a zero
length.
if Cindex + count - 1) > lLength(source))
then
the destination string becomes everything
from index to the end of source string.
end

Used:

All

Time:

Approximately (17 * count)
150 cycles overhead

Size:

Program

85

bytes

cycles

plus

5D

Copyasubstring froma string (COPY)

LDU
*

a)

SAVE

RETURN

161

ADDRESS

*EXIT IF ZERO BYTES TO COPY, ZERO MAXIMUM SUBSTRING
*
LENGTH, OR ZERO STARTING INDEX
*LENGTH OF SUBSTRING IS ZERO IN ALL CASES
*
CLR
79
LENGTH OF SUBSTRING = 0
LDA
2,8
CHECK NUMBER OF BYTES TO COPY
BEQ
OKEXIT
BRANCH IF ZERO BYTES TO COPY, NO ERROR
* SUBSTRING WILL JUST HAVE ZERO LENGTH
LDA
8,S
CHECK MAXIMUM LENGTH OF SUBSTRING
BEQ
EREXIT
TAKE ERROR EXIT IF SUBSTRING HAS ZERO
MAXIMUM LENGTH
LDA
3,8
CHECK STARTING INDEX
BEQ
EREXIT
TAKE ERROR EXIT IF STARTING INDEX IS
* ZERO (LENGTH BYTE)
*
*CHECK IF SOURCE
*TAKE ERROR EXIT
*
LDX
CMPA

6,8
7X

BHI

EREXIT

STRING REACHES
IF IT DOESN'T

STARTING

GET ADDRESS OF SOURCE STRING
COMPARE STARTING INDEX TO LENGTH OF
* SOURCE STRING
TAKE ERROR EXIT IF STARTING INDEX IS
* TOO LARGE

*
*CHECK IF THERE ARE ENOUGH CHARACTERS
* TO SATISFY THE NEED
*THERE ARE IF STARTING INDEX + NUMBER
* IS LESS THAN OR EQUAL TO THE LENGTH
* STRING
*
CLR
LDB
ADDA
BCS
DECA

1,8
2,8
2,8
REDLEN

INDEX

IN

SOURCE

STRING

OF BYTES TO COPY
OF THE SOURCE

-

INDICATE NO TRUNCATION NEEDED
COUNT = NUMBER OF BYTES TO COPY
ADD COUNT TO STARTING INDEX
BRANCH IF SUM IS GREATER THAN 255
CALCULATE INDEX OF LAST BYTE IN AREA
* SPECIFIED FOR COPYING
COMPARE TO LENGTH OF SOURCE STRING
BRANCH IF SOURCE STRING IS LONGER

CMPA
7X
BLS
CHKMAX
*
*CALLER ASKED FOR TOO MANY CHARACTERS
*JUST RETURN EVERYTHING BETWEEN STARTING
*
THE SOURCE STRING
*COUNT := LENGTHC(SSTRG) - STARTING INDEX
*INDICATE TRUNCATION OF COUNT
*

INDEX

AND

THE

7X
3,8

GET LENGTH OF SOURCE STRING
COUNT = LENGTH - STARTING INDEX

+

1,8

INDICATE TRUNCATION
* SETTING MARKER TO

+

END

1

REDLEN:
LDB
SUBB
INCB
COM
*
*DETERMINE

IF

THERE

1

IS

ENOUGH

ROOM

IN

OF
FF

THE

COUNT

BY

SUBSTRING

1

OF

162

Assembly language subroutines for the 6809
*CHECK IF COUNT IS LESS THAN OR EQUAL TO MAXIMUM
*
OF DESTINATION STRING.
IF NOT, SET COUNT TO
*
MAXIMUM LENGTH
*IF COUNT > MAXLEN THEN COUNT == MAXLEN
*

LENGTH

CHKMAX:
CMPB
BLS

8,S
MOVSTR

LOB

8,S

COMPARE COUNT TO MAXIMUM SUBSTRING LENGTH
BRANCH (NO PROBLEM) IF COUNT IS LESS
* THAN OR EQUAL TO MAXIMUM
OTHERWISE, REPLACE COUNT WITH MAXIMUM

*

*MOVE
*

SUBSTRING

TO

DESTINATION

STRING

MOVSTR:
STB
LDA
LEAX
LDY
LEAY

7s
3,8
A,X
4,8
1,Y

SAVE COUNT (LENGTH OF SUBSTRING)
GET STARTING INDEX
POINT TO FIRST CHARACTER IN SOURCE STRING
POINT TO BASE OF DESTINATION STRING
POINT TO FIRST CHARACTER IN SUBSTRING

LDA
STA
DECB
BNE
ROL

7X+
7Y¥t+
MVLP
1,8

GET BYTE FROM SOURCE STRING
MOVE BYTE TO DESTINATION STRING
CONTINUE THROUGH SPECIFIED NUMBER OF
BYTES (COUNT)
MAKE CARRY INDICATE WHETHER REQUEST WAS
* FULLY SATISFIED (1 IF IT WAS, O IF NOT)

BCS

EREXIT

MVLP:

*

OKEXIT:
EREXIT:

*MAKE
*Q0 IF
*
CLC
BRA
SEC

CARRY INDICATE
NOT, 1 IF THEY

WHETHER
DID
CLEAR

ERRORS

CARRY,

OCCURRED

GOOD

EXIT

ERROR

EXIT

EXITCP
SET

CARRY,

*

*SET
*

LENGTH

OF

SUBSTRING

(COUNT)

EXITCP:
LDA
STA
*
*REMOVE
*
LEAS
JMP

7S
C4,8]
PARAMETERS
9,S
,U

SAMPLE

EXECUTION:

LDA
PSHS
LDY
LDX

MXLEN
A
#SSTG
#DSTG

GET SUBSTRING LENGTH
SAVE LENGTH IN SUBSTRING'S

FROM

STACK

AND

LENGTH

EXIT

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

SC5D:

MAXIMUM LENGTH OF SUBSTRING
SAVE MAXIMUM LENGTH IN STACK
BASE ADDRESS OF SOURCE STRING
BASE ADDRESS OF DESTINATION STRING

BYTE

5D
LDB
LDA
PSHS
JSR

BRA

Copya substring from a string (COPY)
IDX
CNT
A,B,X,Y
COPY

SC5D

STARTING INDEX TO COPY FROM
NUMBER OF BYTES TO COPY
SAVE PARAMETERS IN STACK
COPY SUBSTRING
*COPYING 3 CHARACTERS STARTING AT
* FROM '12.345E+10'
GIVES '345'
LOOP THROUGH TEST

163

INDEX

*

*DATA
*
IDX
CNT
MXLEN
SSTG

DSTG

SECTION

FCB
FCB
FCB
FCB
FCC
FCB
FCC
END

4
STARTING INDEX FOR COPYING
3
NUMBER OF CHARACTERS TO COPY
$20
MAXIMUM LENGTH OF DESTINATION STRING
SOA
LENGTH OF STRING
/12.345E+10
/ 32 BYTE MAX
LENGTH OF SUBSTRING
0
/
/ 32 BYTE MAX

4

164

Assembly language subroutines for the 6809

5E Delete a substring from a string
(DELETE)
Deletes a substring from a string, given a starting index and a length.
The string consists of at most 256 bytes, including an initial byte containing the length. The Carry flag is cleared if the deletion can be
performed as specified. The Carry flag is set if the starting index is 0 or
beyond the length of the string; the string is left unchanged in either
case. If the deletion extends beyond the end of the string, the Carry flag
is set to 1 and only the characters from the starting index to the end of
the string are deleted.

Procedure The program exits immediately if either the starting index
or the number of bytes to delete is 0. It also exits if the starting index is
beyond the length of the string. If none of these conditions holds, the
program checks whether the string extends beyond the area to be
deleted. If it does not, the program simply truncates the string by setting
the new length to the starting index minus 1. If it does, the program
compacts the string by moving the bytes above the deleted area down.
The program then determines the new string’s length and exits with the
Carry cleared if the specified number of bytes were deleted, and with
the Carry set to 1 if any errors occurred.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
Number of bytes to delete

Starting index to delete from
More significant byte of base address of string
Less significant byte of base address of string

Exit conditions

Substring deleted from string. If no errors occur, the Carry flag is
cleared. If the starting index is 0 or beyond the length of the string, the
Carry flag is set and the string is unchanged. If the number of bytes to

5E

Delete a substring from a string (DELETE)

165

delete would go beyond the end of the string, the Carry flag is set and
the characters from the starting index to the end of the string are
deleted.

ee

Examples

1.

Data:

Result:

String = 26‘SSALES FOR MARCH AND APRIL OF
THIS YEAR’ (2616 = 38; is the length of the string)
Number of bytes to delete = 0Aj6 = 10j0
Starting index to delete from = 10,6 = 164
String = 1C‘SALES FOR MARCH OF THIS YEAR’
(1Cig = 2810 is the length of the string with 10 bytes

deleted starting with the 16th character — the deleted
material is ‘AND APRIL’)
Carry = 0, since no problems occurred in the deletion

2.

Data:

String = 28°THE PRICE IS $3.00 ($2.00 BEFORE JUNE
1)’ (2816 = 40 o is the length of the string)

Result:

Number of bytes to delete = 3016 = 4810
Starting index to delete from = 1316 = 1919

String = 12‘THE PRICE IS $3.00’ (12:6 = 1810 is the
length of the string with all remaining bytes deleted)
Carry = 1, since there were not as many bytes left in the
string as were supposed to be deleted

Registers used

All

Execution time

Approximately

17 x NUMBER OF BYTES MOVED DOWN + 120 cycles overhead

NUMBER OF BYTES MOVED DOWN is0 if the string can be
truncated and is STRING LENGTH — STARTING INDEX —
NUMBER OF BYTES TO DELETE +1 if the string must be compacted. That is, it takes extra time if the deletion creates a ‘hole’ in the
string that must be filled.
Examples

1.

STRING LENGTH = 204¢ (3210)
STARTING INDEX = 194¢ (2510)

166

Assembly language subroutines for the 6809

NUMBER OF BYTES TO DELETE = 08
Since there are exactly 8 bytes left in the string starting at index 1946,
all the routine must do is truncate it (i.e. cut off the end of the string).
This takes

17 x 0 + 120 = 120 cycles

2.

STRING LENGTH = 4046 (6410)

STARTING INDEX = 1946 (2510)

NUMBER OF BYTES TO DELETE = 08
Since there are 2016 (3219) bytes above the truncated area, the routine
must move them down eight positions to fill the ‘hole’. Thus NUMBER
OF BYTES MOVED DOWN

= 3219 and the execution time is

17 xX 32 + 120 = 544 + 120 = 664 cycles

Program size

80 bytes

Data memory required

None

Special cases
1. If the number of bytes to delete is 0, the program exits with Carry
flag cleared (no errors) and the string unchanged.

2. Ifthe string does not even extend to the specified starting index, the
program exits with the Carry flag set to 1 (indicating an error) and the
string unchanged.
3. Ifthe number of bytes to delete exceeds the number available, the
program deletes all bytes from the starting index to the end of the string
and exits with the Carry flag set to 1 (indicating an error).
a Substring

Title

Delete

Name:

DELETE

Purpose:

Delete a substring
starting index and

Entry:

TOP

from

a String

*

HF
F+
+

OF

from a string
a length.

given

STACK

High byte of return address
Low byte of return address
Number of bytes to delete (count)
Starting index to delete from Cindex)

a

5E

Delete a substring from a string (DELETE)

167

High byte of string address
Low byte of string address

The string consists of a length byte
followed by a maximum of 255 characters.
Exit:

Registers

Substring deleted.
If no errors then
Carry := 0
else
begin
the following conditions cause an
error with Carry flag = 1.
if Cindex = 0) or (index > length(string))
then do not change string
if count is too large then
delete only the characters from
index to end of string
end
used:

All

Time:

Approximately 17 * (LENGTH(CSTRG) -~INDEX-COUNT+1)
plus 120 cycles overhead

Size:

Program

80

bytes

SAVE

RETURN

HF
FF
+
FH
H

DELETE:
LDU

79

ADDRESS

*

*INITIALIZE
*
CLR
*

ERROR
rs

*EXIT IF COUNT IS
*
STARTING INDEX
*
LDB
BEQ
LDA
BEQ

2,8
OKEXIT
3,8
EREXIT

LDX
CMPA
BHI

4,58
7X
EREXIT

*

INDICATOR
INDICATE

(DELERR)
NO

TO

O

ERRORS

ZERO, STARTING INDEX
IS BEYOND THE END OF

IS ZERO, OR
THE STRING

CHECK NUMBER OF BYTES TO DELETE
BRANCH (GOOD EXIT) IF NOTHING TO DELETE
CHECK STARTING INDEX
BRANCH CERROR EXIT) IF STARTING INDEX IS
* ZERO - THAT IS, IN LENGTH BYTE
GET BASE ADDRESS OF STRING
CHECK IF STARTING INDEX IS WITHIN STRING
BRANCH CERROR EXIT) IF STARTING INDEX
* IS BEYOND END OF STRING

*CHECK WHETHER NUMBER OF CHARACTERS REQUESTED
*
DELETED ARE PRESENT
*THEY ARE IF STARTING INDEX + NUMBER OF BYTES
*
IS LESS THAN OR EQUAL TO STRING LENGTH
*IF NOT, THEN DELETE ONLY TO END OF STRING
*

TO

BE

TO

DELETE

ADDA

COUNT

2,58

COMPUTE

STARTING

INDEX

+

-

1

168

Assembly language subroutines for the 6809
BCS
DECA

TRUNC

CMPA
BCS
BEQ

7X
CNTOK
TRUNC

COM

79

TRUNCATE IF INDEX + COUNT > 255
END OF DELETED AREA IS AT INDEX GIVEN BY
* STARTING INDEX + COUNT - 1
COMPARE TO LENGTH OF SUBSTRING
BRANCH IF MORE THAN ENOUGH CHARACTERS
TRUNCATE BUT NO ERROR CEXACTLY ENOUGH
* CHARACTERS)
INDICATE ERROR - NOT ENOUGH CHARACTERS
* TO DELETE

*

*TRUNCATE THE STRING - NO
*SIMPLY REDUCE ITS LENGTH
*

COMPACTING NECESSARY
TO STARTING INDEX - 1

TRUNC:
LDA
DECA
STA

3,8

STRING

LENGTH

=

STARTING

INDEX

-

1

7X

*

*TEST
*
LDA
BEQ
BNE

ERROR

INDICATOR

7s
OKEXIT
EREXIT

AND

EXIT

ACCORDINGLY

TEST ERROR INDICATOR
NO ERROR, TAKE GOOD EXIT
OTHERWISE, TAKE ERROR EXIT

*

*DELETE SUBSTRING BY
*MOVE ALL CHARACTERS
*

COMPACTING THE STRING
ABOVE THE DELETED AREA

STA
LDB
SUBB
INCA

1,$
7X
1,8

LEAY

A,X

LDA
LEAX

3,8
A,X

SAVE INDEX TO END OF AREA TO BE DELETED
NUMBER OF CHARACTERS TO MOVE = STRING
LENGTH - INDEX AT END OF AREA
ADD 1 TO INDEX AT END OF DELETED AREA
* THUS GIVING FIRST BYTE TO MOVE DOWN
POINT TO FIRST CHARACTER TO BE
* MOVED DOWN
GET STARTING INDEX
POINT TO FIRST BYTE IN AREA TO BE DELETED

LDA
STA
DECB
BNE

7Yt+
Xt

DOWN

CNTOK:

MVLP:
GET CHARACTER FROM ABOVE DELETED
MOVE IT DOWN TO COMPACT STRING
CONTINUE THROUGH END OF STRING

MVLP

*

*COMPUTE
*
LDX
LDA
SUBA
STA

AND

SAVE

4,8
7X
2,8
7X

LENGTH

OF

STRING

AFTER

DELETION

POINT TO STRING LENGTH
GET ORIGINAL LENGTH
SUBTRACT NUMBER OF BYTES
DIFFERENCE IS NEW LENGTH

*

*CLEAR
*

CARRY,

INDICATING

NO

ERRORS

OKEXIT:
CLC
BRA
*

CLEAR
EXITDE

CARRY,

NO

ERRORS

TO

DELETE

AREA

5E

Deletea substring froma string (DELETE)

*SET
*

CARRY,

INDICATING

AN

169

ERROR

EREXIT:
SEC

SET

CARRY,

FROM

STACK

INDICATING

ERROR

*

*REMOVE

PARAMETERS

AND

EXIT

*

EXITDE:

LEAS

6,S

REMOVE

JMP

,U

EXIT

PARAMETERS
TO

RETURN

FROM

STACK

ADDRESS

*

*

SAMPLE

EXECUTION:

LDX
LDB

#SSTG
IDX

GET
GET

*

SC5E:

BASE ADDRESS OF STRING
STARTING
INDEX FOR DELETION

LDA

CNT

PSHS

A,B,X

GET NUMBER
OF CHARACTERS
SAVE
PARAMETERS
IN STACK

JSR

DELETE

DELETE

BRA

*DELETING 4 CHARACTERS STARTING AT INDEX
* FROM "JOE HANDOVER" LEAVES "HANDOVER"
SC5E
LOOP THROUGH TEST

TO

DELETE

CHARACTERS

*

*DATA
*
IOX:
CNT:
SSTG:

SECTION
FCB
FCB
FCB
FCC
END

1
4
12
/JOE

STARTING INDEX FOR DELETION
NUMBER OF CHARACTERS TO DELETE
LENGTH OF STRING IN BYTES
HANDOVER/

1

170

Assembly language subroutines for the 6809

5F Insert a substring into a string
(INSERT)
Inserts a substring into a string, given a starting index. The string and
substring each consist of at most 256 bytes, including an initial byte
containing the length. The Carry flag is cleared if the insertion can be
accomplished with no problems. The Carry flag is set if the starting
index is 0 or beyond the length of the string. In the second case, the
substring is concatenated to the end of the string. The Carry flag is also
set if the insertion would make the string exceed a specified maximum
length; in that case, the program inserts only enough of the substring to
reach the maximum length.

Procedure The program exits immediately if the starting index or the
length of the substring is 0. If neither is 0, the program checks whether
the insertion would make the string longer than the specified maximum.
If it would, the program truncates the substring. The program then
checks whether the starting index is within the string. If not, the program simply concatenates the substring at the end of the string. If the
starting index is within the string, the program must make room for the
insertion by moving the remaining characters up in memory. This move
must start at the highest address to avoid writing over any data. Finally,
the program can move the substring into the open area. The program
then determines the new string length. It exits with the Carry flag set to
0 if no problems occurred and to 1 if the starting index was 0, the
substring had to be truncated, or the starting index was beyond the
length of the string.

Entry conditions

Order in stack (starting from the top)
More significant byte of base address
Less significant byte of return address
Maximum length of string
Starting index at which to insert the substring
More significant byte of base address of substring
Less significant byte of base address of substring

More significant byte of base address of string

5F

Insert a substring into a string (INSERT)

171

Less significant byte of base address of string

Exit conditions

Substring inserted into string. If no errors occur, the Carry flag is
cleared. If the starting index or the length of the substring is 0, the Carry
flag is set and the string is not changed. If the starting index is beyond
the length of the string, the Carry flag is set and the substring is
concatenated to the end of the string. If the insertion would make the
string exceed its specified maximum length, the Carry flag is set and only
enough of the substring is inserted to reach maximum length.

Examples

1.

Data:

String = ODA‘SJOHN SMITH’ (0Aj6 = 10j0 is the length of
the string)
Substring = 08°WILLIAM ’ (08 is the length of the substring)
Maximum length of string = 1446 = 2010

Starting index = 06
Result:

String = 12‘SJOHN WILLIAM SMITH’ (1216 = 180 is the

length of the string with the substring inserted)
Carry = 0, since no problems occurred in the insertion

2.

Data:

String = OA‘JOHN SMITH?’ (0Aj6 = 1010 is the length of
the string)
Substring = OC'ROCKEFELLER’ (0Cig = 12i0 is the
length of the substring)
Maximum length of string = 1446 = 2010

Result:

Starting index = 06
String = 14°JOHN ROCKEFELLESMITHW’ (1446 = 2010
is the length of the string with as much of the substring
inserted as the maximum length would allow)
Carry = 1, since some of the substring could not be
inserted without exceeding the maximum length of the
string

Registers used

All

172

Assembly language subroutines for the 6809

Execution time

Approximately

17 X NUMBER OF BYTES MOVED
INSERTED + 180 cycles

+ 17 X NUMBER OF BYTES

NUMBER OF BYTES MOVED is the number of bytes that must be
moved to make room for the insertion. If the starting index is beyond
the end of the string, this is 0 since the substring is simply placed at the
end. Otherwise, this is STRING LENGTH — STARTING INDEX +
1, since the bytes at or above the starting index must be moved.
NUMBER OF BYTES INSERTED 1s the length of the substring if
no truncation occurs. It is the maximum length of the string minus its
current length if inserting the substring would produce a string longer
than the maximum.
Examples

1.

STRING LENGTH = 2016 (3210)
STARTING INDEX = 1946 (2510)
MAXIMUM LENGTH = 3046 (4810)
SUBSTRING LENGTH = 06

That is, we want to insert a substring 6 bytes long, starting at the 25th
character. Since 8 bytes must be moved up (NUMBER OF BYTES
MOVED = 32 — 25 + 1) and 6 bytes must be inserted, the execution
time is approximately
17 X 8+ 17 X 6+ 180 = 136 + 102 + 180 = 418 cycles

2. STRING LENGTH = 2046 (3210)
STARTING INDEX = 194¢ (2530)
MAXIMUM LENGTH = 2446 (3610)
SUBSTRING LENGTH = 06
As opposed to Example 1, here we can insert only 4 bytes the
substring without exceeding the string’s maximum length. Thus
NUMBER OF BYTES MOVED = 8 and NUMBER OF BYTES
INSERTED = 4. The execution time is approximately
17 X¥8+17
X 4+ 180 = 136 + 68 + 180 = 384 cycles

Program size

115 bytes

Data memory required

None

5F

Inserta substring into a string (INSERT)

173

Special cases

1. Ifthe length of the substring (the insertion) is 0, the program exits
with the Carry flag cleared (no errors) and the string unchanged.

2. If the starting index for the insertion is 0 (i.e. the insertion would
start in the length byte), the program exits with the Carry flag set to 1
(indicating an error) and the string unchanged.
3. If the insertion makes the string exceed the specified maximum
length, the program inserts only enough characters to reach the
maximum length. The Carry flag is set to 1 to indicate that the insertion
has been truncated.

4. If the starting index of the insertion is beyond the end of the string,
the program concatenates the insertion at the end of the string and
indicates an error by setting the Carry flag to 1.
5. If the original length of the string exceeds its specified maximum
length, the program exits with the Carry flag set to 1 (indicating an
error) and the string unchanged.
Title
Name:

Insert
INSERT

a Substring

into

a String

Purpose:

Insert a substring
starting index.

into

a string

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
Maximum length of (source) string
Starting index to insert the substring
High byte of substring address
Low byte of substring address
High byte of (source) string address
Low byte of (source) string address

+

Each string
followed by

Exit:

HH
FF
He
+£
KF
HF
+
F

given

a

consists of a length byte
a maximum of 255 characters.

Substring inserted into string.
If no errors then
Carry = 0
else
begin
the following conditions cause the
Carry flag to be set.
if index = 0 then
do not insert the substring
if length(string) > maximum Length

then

174

Assembly language subroutines for the 6809

*
*
*
*
*
*
*
*

do not insert the substring
index > lLength(string) then
concatenate substring onto the end of the
source string
if length(string)+lLength(substring)
> maxlen
then insert only enough of the substring
to reach maximum Length
end

if

*

*

Registers

Used:

ALL

*

*
*
*
*

Time:

Approximately
17 * (LENGTHCSTRING)
- INDEX
17 * CLENGTHCSUBSTRING))
+
180 cycles overhead

+

1)

+

*

*

Size:

Program

115

bytes

INSERT:
*

*

START

*

POINTERS

WITH

INITIALIZED

ERROR

INDICATOR
TO

CLEARED

LDU
CLR
LDX
LDY
*
*EXIT IF
x ZERO

rs
78
6,8
4,8

SAVE RETURN ADDRESS
CLEAR ERROR INDICATOR (NO ERRORS)
GET BASE ADDRESS OF STRING
GET BASE ADDRESS OF SUBSTRING

SUBSTRING

LENGTH

BASE

ADDRESSES

OF

STRING,

SUBSTRING

*

IS

ZERO

OR

STARTING

INDEX

IS

*

LDA
BEQ

3,8
EREXIT

LDB

7Y

BEQ

OKEXIT

GET STARTING
INDEX
EXIT,
INDICATING
ERROR,

IF

STARTING

* INDEX IS ZERO CLENGTH BYTE)
GET LENGTH OF SUBSTRING (NUMBER OF
* CHARACTERS TO INSERT
EXIT IF NOTHING TO INSERT (NO ERROR)

*

*CHECK WHETHER THE STRING WITH THE INSERTION FITS
* SOURCE STRING (I.E., IF ITS LENGTH IS LESS THAN
* TO THE MAXIMUM).
*IF NOT, TRUNCATE THE SUBSTRING AND SET THE ERROR

IN
OR

THE
EQUAL

FLAG

*

LDA
ADDA
BCS
CMPA
BLS

7X
7x
TRUNC
2,8
IDXLEN

GET SUBSTRING LENGTH
SUBSTRING LENGTH + STRING LENGTH
TRUNCATE SUBSTRING IF NEW LENGTH >
COMPARE TO MAXIMUM STRING LENGTH
BRANCH IF NEW LENGTH <= MAX LENGTH

255

*

*SUBSTRING

DOES

NOT

FIT,

SO

TRUNCATE

IT

*

TRUNC:
LDB
SUBB
BLS

2,8
C6,S]
EREXIT

NUMBER OF CHARACTERS TO INSERT =
MAXIMUM LENGTH ~- STRING LENGTH
TAKE ERROR EXIT IF MAXIMUM LENGTH

<

=

5F

Inserta substring into a string (INSERT)

COM
a)
*
*CHECK WHETHER
*
CONCATENATE
*

* STRING
INDICATE

LENGTH
SUBSTRING

STARTING INDEX
SUBSTRING ONTO

WAS

175

TRUNCATED

IS WITHIN THE STRING.
THE END OF THE STRING

IF

NOT,

IDXLEN:
STB
LDA
CMPA
BCC
INCA
STA
LDA
STA
BRA

1,8
7X
3,58
LENOK

SAVE NUMBER OF CHARACTERS TO INSERT
GET STRING LENGTH
COMPARE TO STARTING INDEX
BRANCH IF STARTING INDEX IS WITHIN STRING
ELSE SET STARTING INDEX TO END OF STRING

3,8
#3 FF
79
MVESUB

INDICATE
JUST

ERROR

PERFORM

IN

MOVE,

INSERT
NOTHING

TO

OPEN

UP

*

*OPEN UP A SPACE IN SOURCE STRING FOR THE SUBSTRING
*
THE CHARACTERS FROM THE END OF THE SOURCE STRING
*
INDEX, UP BY THE SIZE OF THE SUBSTRING
*

BY MOVING
DOWN TO

LENOK:
*
*CALCULATE NUMBER OF CHARACTERS TO MOVE
*
COUNT := STRING LENGTH - STARTING INDEX +
*
LDB
7X
GET STRING LENGTH
SUBB
2,58
SUBTRACT STARTING INDEX
INCB
ADD 1

1

*

*SET
*
LEAX
LEAX
LDA
LEAY

SOURCE

AND

DESTINATION

A,X
1,X
1,8
A,X

POINTERS

POINT TO END OF STRING
POINT JUST PAST END OF STRING
ADD NUMBER OF CHARACTERS TO INSERT
POINT JUST PAST END OF DESTINATION

AREA

*

*MOVE
*

CHARACTERS

LDA
STA
DECB
BNE

77K
77Y

UP

IN

MEMORY

TO

MAKE

ROOM

FOR

SUBSTRING

OF

CHARACTERS

OPNLP:
GET NEXT CHARACTER
MOVE IT UP IN MEMORY
DECREMENT COUNTER
CONTINUE THROUGH NUMBER
* TO MOVE

OPNLP

*

*MOVE
*

SUBSTRING

INTO

THE

OPEN

AREA

MVESUB:
LDX
LDA
LEAX
LDY
LDB
LEAY
*

6,S
3,8
A,X
4,8
1,8
1,Y

GET STRING ADDRESS
GET STARTING INDEX
POINT TO START OF OPEN AREA
GET SUBSTRING ADDRESS
GET NUMBER OF CHARACTERS TO
POINT TO START OF SUBSTRING

INSERT

176

Assembly language subroutines for the 6809
*MOVE
*

SUBSTRING

BYTE

AT

A TIME

MVELP:

LDA
7Y¥+
GET CHARACTER FROM SUBSTRING
STA
7Xt+
MOVE IT INTO OPEN AREA
DECB
DECREMENT COUNTER
BNE
MVELP
CONTINUE UNTIL COUNTER = QO
*
*CALCULATE NEW STRING LENGTH
*NEW LENGTH = OLD LENGTH PLUS NUMBER OF CHARACTERS
* TO INSERT
*
LDX
6,S8
POINT TO STRING LENGTH
LDA
7X
GET STRING LENGTH
ADDA
1,8
ADD NUMBER OF CHARACTERS TO INSERT
STA
7X
SAVE SUM AS NEW STRING LENGTH
*

*CHECK ERROR FLAG
*
LDA
Ps)
CHECK ERROR FLAG
BNE
EREXIT
BRANCH IF ERROR OCCURRED
*
*SET CARRY FROM ERROR FLAG OR TEST
*CARRY = O IF NO ERRORS, 1 IF ERRORS
*
OKEXIT:

CLC
BRA

NO

ERRORS

EXITIN

EREXIT:

SEC

ERROR

EXIT

*

*REMOVE
*

PARAMETERS

FROM

STACK

AND

EXIT

EXITIN:
LEAS
JMP

SAMPLE

8,S
,U

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

EXECUTION:

SCSF:
LDY
LDX
LDB
LDA
PSHS
JSR

JMP

#STG
BASE ADDRESS OF STRING
#SSTG
BASE ADDRESS OF SUBSTRING
IDX
STARTING INDEX
MXLEN
MAXIMUM LENGTH OF STRING
D,X,Y
SAVE PARAMETERS IN STACK
INSERT
INSERT SUBSTRING
*RESULT OF INSERTING
'-' INTO '123456'
* INDEX 1 IS '-123456'
SC5F
LOOP THROUGH TEST

*

*DATA
IDX:

SECTION
FCB

1

STARTING

INDEX

FOR

INSERTION

AT

5F
MXLEN:
STG:

SSTG

FCB
FCB
FCC
FCB
FCC

Inserta substring into a string (INSERT)
$20
6
1123456
1
/-

MAXIMUM LENGTH OF
LENGTH OF STRING
LENGTH

OF

177

DESTINATION
/ 32

BYTE

MAX

/ 32

BYTE

MAX

SUBSTRING

178

Assembly language subroutines for the 6809

5G Remove excess spaces from a string
(SPACES)
Removes excess spaces from a string, including leading spaces, trailing
spaces, and extra spaces within the string itself. The string consists of at
most 256 bytes, including an initial byte containing the length.

Procedure The program exits immediately if the length of the string 1s
0. Otherwise, it first removes all leading spaces. It then sets a flag
whenever it finds a space and deletes all subsequent spaces. If it reaches
the end of the string with that flag set, it deletes the final trailing space as
well. Finally, it adjusts the string’s length.

Entry conditions

Base address of string in register X

Exit conditions

Excess spaces removed from string. The string is left with no leading or
trailing spaces and no groups of consecutive spaces inside it.

Examples

1.

Data:
Result:

String = OF‘ JOHN SMITH ’ (0Fi6 = 1510 is the length
of the string)
String = OA‘SJOHN SMITH’ (OAi6 = 1040 is the length of
the string with the extra spaces removed)

2.

Data:
Result:

String = 1B‘ PORTLAND,
OREGON
’(1Bi6 = 2710
is the length of the string)
String = 10°PORTLAND, OREGON’ (1016 = 1640 is the
length of the string with the extra spaces removed)

Registers used

All

5G

Remove excess spaces from a string (SPACES)

Execution time

Approximately

35 X LENGTH OF STRING IN BYTES + 65
If, for example, the string is 1C hex (28 decimal) bytes long, this is

35 X 28 + 65 = 980 + 65 = 1045 cycles

Program size

61 bytes

Data memory required
Title

Remove
SPACES

Name:

2 stack bytes

Extra

Spaces

from

a String

+

Purpose:

Remove
leading,
internal spaces

Entry:

Register

X =

trailing, and
from a string

Base

address

of

extra

string

The string consists of a Length byte
followed by a maximum of 255 characters.
Exit:

Leading, trailing,
spaces removed

Registers

Used:

Time:

excess

+

65

internal

ALL
Approximately
35 * (LENGTHCSTRG)
Program
Data

Size:

and

61 bytes
2 stack

.
cycles

overhead

bytes

HH
HF
FF
$F
+
F

SPACES:
*

*SAVE BASE ADDRESS OF STRING
*START COMPACTED STRING'S LENGTH AT ZERO
*INDICATE INITIALLY LAST CHARACTER WAS NOT

A SPACE

*

TFR
CLRA
CLRB
PSHS

X,U

A,B

SAVE BASE ADDRESS OF STRING
INDICATE LAST CHARACTER WAS NOT A SPACE
COMPACTED STRING'S LENGTH = ZERO
SAVE INDICATOR, LENGTH IN STACK

*

*EXIT

IF

STRING

LENGTH

IS

ZERO

*

LDB

Xt

GET

STRING

LENGTH

179

180

Assembly language subroutines for the 6809
BEQ
*
*REMOVE

BRANCH

EXITRE
ALL

LEADING

CEXIT)

IF

STRING

LENGTH

IS

ZERO

SPACES

*

TFR

START POINTERS TO BOTH ORIGINAL, COMPACTED
* STRINGS AT FIRST CHARACTER IN STRING

X,Y

LEADSP:

LDA
CMPA
BNE
DECB
BNE
CLR

Xt
#SPACE
MARKCH

BRA

EXITRE

GET NEXT CHARACTER
IS IT A SPACE?
BRANCH IF CHARACTER IS NOT A SPACE
DECREMENT CHARACTER COUNT
BRANCH IF NOT DONE WITH STRING
STRING CONSISTED ENTIRELY OF SPACES
* MAKE ITS LENGTH ZERO
EXIT

LEADSP
7U

*

*WORK THROUGH MAIN PART OF STRING, OMITTING
* THAT OCCUR IMMEDIATELY AFTER OTHER SPACES

SPACES

*

*CHECK IF CURRENT CHARACTER IS A SPACE
*IF SO, CHECK IF PREVIOUS CHARACTER WAS A SPACE
*IF SO, OMIT CHARACTER FROM COMPACTED STRING
*IF NOT, MARK CHARACTER AS A SPACE
*

MVCHAR:

LDA
CMPA
BNE
TST
BEQ
COM
BRA
*
* INDICATE
*

GET NEXT CHARACTER
IS IT A SPACE?
BRANCH IF CHARACTER IS NOT A SPACE
CHECK IF LAST CHARACTER WAS A SPACE
BRANCH IF IT WAS
INDICATE CURRENT CHARACTER IS A SPACE

#SPACE
MARKCH
79
CNTCHR
rs
SVCHR
CURRENT

CHARACTER

MARKCH:

CLR
*
*SAVE

INDICATE

79
CURRENT

CHARACTER

IN

IS

NOT

A SPACE

CURRENT
COMPACTED

CHARACTER

NOT

A SPACE

STRING

*

SVCHR:

STA
INC
*
*COUNT

SAVE CHARACTER IN COMPACTED STRING
ADD 1 TO LENGTH OF COMPACTED STRING
CHARACTERS

*

CNTCHR:
DECB
BNE
*
kOMIT
*
TST
BEQ
DEC
*

MVCHAR

LAST

CHARACTER
7°

SETLEN
1,8

COUNT CHARACTERS
BRANCH IF ANY CHARACTERS

IF

IT

WAS

LEFT

A SPACE

CHECK IF FINAL CHARACTER WAS A SPACE
BRANCH IF IT WAS NOT
OMIT FINAL CHARACTER IF IT WAS A SPACE

5G

Remove excess spaces from a string (SPACES)

*SET

LENGTH

OF

COMPACTED

STRING

*

SETLEN:
LDA
STA
*
*REMOVE
*

1,8,U

GET LENGTH OF COMPACTED STRING
SAVE AS LENGTH BYTE IN STRING

TEMPORARIES

FROM

STACK

AND

EXIT

EXITRE:
LEAS
RTS

2,8

REMOVE

TEMPORARY

ASCII

SPACE

DATA

FROM

STACK

*

*CHARACTER DEFINITION
*
SPACE
EQU
$20

*

SAMPLE

CHARACTER

EXECUTION:

SC5G:

LDX

#STG

JSR

SPACES

*

*DATA
*
STG:

GET BASE ADDRESS OF STRING
REMOVE SPACES
*RESULT OF REMOVING SPACES FROM
* ' JOHN
SMITH
' IS "JOHN SMITH!

SECTION
FCB
FCC
END

SOE
/ JOHN

LENGTH OF STRING
SMITH
/
STRING

IN

BYTES

181

6 Array operations

6A. 8-bit array summation
(ASUMS8)
Adds the elements of an array, producing a 16-bit sum. The array
consists of up to 255 byte-length elements.

Procedure The program starts the sum at 0. It then adds elements one
at a time to the sum’s less significant byte. It also adds the carries to the
sum’s more significant byte.

Entry conditions

Base address of array in register X
Size of array in bytes in register A

Exit conditions

Sum in register D

Example

Data:
182

Size of array in bytes = (A) = 08

6A _ 8-bit array summation (ASUM8)

183

Array elements
F716 = 24710

2316 = 3510

3116 = 4910
71046 =

11210

SA16 = 9010
1616 = 2240
CBi6 = 20340
Elie =

Result:

22510

Sum = (D) = 03D716 = 98310

Registers used

A,B, CC, X, Y

Execution time

Approximately

16 cycles per byte-length element

plus 26 cycles overhead. If, for example, the array consists of 1C1¢ (2810)

elements, the execution time is approximately

16 X 28 + 26 = 448 + 26 = 474 cycles

Program size

18 bytes

Data memory required

Special case

None

An array size of 0 causes an immediate exit with a sum

of0

Title
Name:

8-Bit
ASUM8

Array

Summation

Purpose:

Sum the elements of an array, yielding a
result. Maximum size is 255 byte-length
elements.

Entry:

Register
Register

X =
A =

Base
Size

Exit:

Register

D =

Sum

+

HF
+

address of array
of array in bytes

16

bit

184
*

Assembly language subroutines for the 6809
Registers

Used:

A,B,CC,X,Y

*

*
*

Time:

Approximately 16 cycles
26 cycles overhead

Size:

Program

element

per

plus

*

*

18

bytes

*

*

*TEST
*EXIT

ARRAY LENGTH
WITH SUM = O

IF

ARRAY

HAS

ZERO

ELEMENTS

*

ASUM8:
TFR

A,B

CLRA
TSTB
BEQ

EXITAS

SAVE ARRAY LENGTH
IN B
EXTEND ARRAY LENGTH TO 16 BITS
IS ZERO
CHECK IF ARRAY LENGTH
IS
IF ARRAY LENGTH
(EXIT)
BRANCH

* ZERO - SUM IS ZERO

IN THIS

CASE

*

*ADD
*ADD

ELEMENTS
BYTE-LENGTH
CARRIES TO HIGH BYTE

TO
OF

LOW
SUM

BYTE

OF

SUM

ONE

A TIME

AT

*

TFR
CLRB

D,Y

ADDB

Xt

SAVE 16-BIT ARRAY
START SUM AT ZERO
* ALREADY ZERO)

IN
LENGTH
CREMEMBER

Y
A

SUMLP:
ADD

NEXT

ELEMENT

TO

LOW

BYTE

IS

OF

* SUM
ADD CARRY TO HIGH BYTE OF SUM
CONTINUE THROUGH ALL ELEMENTS

#0
-1,Y
SUMLP

ADCA
LEAY
BNE
EXITAS:
RTS

*

*

SAMPLE

EXECUTION

*
*

SC6A:
#BUF
BUFSZ
ASUM8

GET
GET
SUM

BRA

SC6A

SUM OF TEST DATA IS O7F8
* REGISTER D = O7F8H
LOOP FOR ANOTHER TEST

*TEST DATA, CHANGE
EQU
SIZE
FCB
BUFSZ:

BUF:

BASE ADDRESS OF BUFFER
BUFFER SIZE IN BYTES
IN BUFFER
ELEMENTS

LDX
LDA
JSR

FCB
FCB
FCB
FCB
FCB

FOR OTHER
$10
SIZE

0
$11
$22
$33
$44

HEX,

VALUES

SIZE
SIZE

OF
OF

BUFFER
BUFFER

IN BYTES
IN BYTES

BUFFER
DECIMAL ELEMENTS ARE 0,17,34,51,68
85,102,119,135,153,170,187,204
221,238,255

6A _ 8-bit array summation (ASUMS8)
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB

$55
$66
$77
$88
$99
SAA
$BB
$CC
$DD
SEE
$F F

SUM

185

=

O7F8

(2040

DECIMAL)

186

Assembly language subroutines for the 6809

6B 16-bit array summation
(ASUM16)
Adds the elements of an array, producing a 24-bit sum. The array
consists of up to 255 word-length (16-bit) elements arranged in the usual
6809 format with the more significant byte first.

Procedure The program starts the sum at 0. It then adds elements to
the sum’s less significant bytes one at a time, beginning at the base
address. Whenever an addition produces a carry, the program adds 1 to
the sum’s most significant byte.

Entry conditions

Base address of array in X
Size of array in 16-bit words in A

Exit conditions

Most significant byte of sum in A
Middle and least significant bytes of sum in X

Example

Data:

Size of array (in 16-bit words) = (A) = 08
Array elements
F7A]lie

=

239Bi6

=9

63 39340
11546

31D5i6

=

12 75710

T0OF216 = 2891410
5A3616 = 2309410
166C 16 =5 74010

Result:

CBF5i6

=

52 21310

E1071¢6

=

57 60710

Sum

= O3DBA1i6

= 252 83310

(A) = most significant byte of sum = 0316
(X) = middle and least significant bytes of sum = DBA1i¢6

6B

16-bit array summation (ASUM16)

187

Registers used

A,B, CC, X, Y

Execution time

Approximately 20 cycles per 16-bit element plus 44

cycles overhead. If, for example, the array consists of 1216 (1810) ele-

ments, the execution time is approximately
20 X 18 + 44 = 360 + 44 = 404 cycles

This approximation assumes no carries to the most significant byte of
the sum; each carry increases execution time by 6 cycles.
Program size

27 bytes

Data memory required

Specialcase

1 stack byte

An array size of 0 causes an immediate exit with a sum of 0

Title
Name:

16-Bit
ASUM16

Array

Summation

Purpose:

Sum the
result.

elements of an array, yielding a 24 bit
Maximum size is 255 16-bit elements.

Entry:

Register
Register

X =
A =

Base
Size

Register
Register

A =
X =

High byte of sum
Middle and low bytes

+

Exit:

Registers

Used:

address of array
of array (in 16-bit

Approximately 20 cycles
44 cycles overhead

Size:

Program
Data

27 bytes
1 stack

per

element

byte

HHF
HK
HF
+
H
F
€

ASUM16:
*

ARRAY LENGTH
WITH SUM = 0 IF

ARRAY

HAS

NO

ELEMENTS

ARRAY

LENGTH

*

TFR

A,B

sum

A,B,CC,X,Y

Time:

*TEST
*EXIT

of

words)

MOVE

TO

B

plus

188

Assembly language subroutines for the 6809
CLR A
STA
TST
BEQ

EXTEND ARRAY LENGTH TO 16 BITS
MAKE MSB OF SUM ZERO
CHECK ARRAY LENGTH
BRANCH CEXIT) IF ARRAY LENGTH IS
* SUM IS ZERO IN THIS CASE

78
EXITS1

ZERO

*

*ADD
*ADD

WORD-LENGTH ELEMENTS TO LOW BYTES OF SUM ONE AT
1 TO HIGH BYTE OF SUM WHENEVER A CARRY OCCURS

A TIME

*

TFR
CLR B
SUMLP:

MOVE 16-BIT ARRAY LENGTH TO Y
START SUM AT ZERO CREMEMBER A IS
* ALREADY ZERO)
ADD ELEMENT TO LOW BYTES OF SUM
BRANCH IF NO CARRY
ELSE ADD 1 TO HIGH BYTE OF SUM

,X++
DECCNT
,S

ADD D
BCC
INC

DECCNT:
LEA Y
BNE
*
*MOVE SUM
*
BYTES)
*

CONTINUE

THROUGH

ALL

ELEMENTS

BYTE)

AND

X (LESS

LOW BYTES
HIGH BYTE

OF
OF

SUM
SUM

SUMLP
TO

A (MOST

SIGNIFICANT

SIGNIFICANT

EXITS1:
TFR
LDA
RTS

+

SAMPLE

SAVE
MOVE

pot

IN X
TO A

EXECUTION

SC6B:
LDA
JSR

#BUF
BUFSZ
ASUM16

BRA

$C6B

LDX

*TEST DATA, CHANGE
SIZE
EQU
BUFSZ:
FCB

FOR OTHER
$10
SIZE

BUF:

0
$111
$222
$333
$444
$555
$666
$777
$888
$999
SAAA

FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB

FDB
FDB

GET BASE ADDRESS OF BUFFER
GET SIZE OF BUFFER IN WORDS
SUM WORD-LENGTH ELEMENTS IN
* SUM OF TEST DATA IS 31FF8
* REGISTER X = 1FF8H
* REGISTER A = 3
LOOP FOR ANOTHER TEST

BUFFER
HEX,

VALUES
SIZE
SIZE

OF
OF

BUFFER
BUFFER

IN
IN

WORDS
WORDS

BUFFER
DECIMAL ELEMENTS ARE 0,273,546,819,1092
1365 ,1638,1911,2184,2457,2730,3003
,3276
56797 ,61166,65535

6B
FDB
FDB
FDB
FDB
FDB
END

16-bit array summation (ASUM16)
$BBB
$CCC
$DDDD
SEEEE
SFFFF

SUM

=

31FF8

(204792

189

DECIMAL)

190

Assembly language subroutines for the 6809

6C Find maximum byte-length element
(MAXELM)
Finds the maximum element in an array. The array consists of up to 255
unsigned byte-length elements.

Procedure The program exits immediately (setting Carry to 1) if the
array has no elements. Otherwise, the program assumes that the element at the base address is the maximum. It then works through the
array, Comparing the supposed maximum with each element and
retaining the larger value and its address. Finally, the program clears
Carry to indicate a valid result.

Entry conditions

Base address of array in register X
Size of array in bytes in register A

Exit conditions

Largest unsigned element in register A
Address of largest unsigned element in register X
Carry = Oif result is valid, 1 if size of array is 0 and result is meaningless

Example

Data:

Size of array (in bytes) = (A) = 08
Array elements
3516 =5310
4416 = 6810
Abie =

Result:

16640

5916 = 8910

D216 = 21010

TA.

=

12210

1Bie6 =

CFi¢ =

20710

2710

The largest unsigned element is element #2
(D2i6 =

21010)

(B) = largest element (D216)
(X) = BASE + 2 (lowest address containing D2.)
Carry = 0, indicating that array size is non-zero and the
result is valid

6C

Find maximum byte-length element (MAXELM)

Registers used

191

A,B, CC, X, Y

Execution time Approximately 14 to 26 cycles per element plus 27
cycles overhead. The larger number applies when the program must
replace the previous maximum and its address with the current element
and its address. If, on the average, that replacement is necessary in half
of the iterations, the time is approximately

(14+26)/2 x ARRAY SIZE/2 + 27 cycles
If, for example, ARRAY SIZE = 1816 = 2410 bytes, the approximate
execution time is

40/2 X 12 + 27 = 240 + 27 = 267 cycles

Program size

25 bytes

Data memory required

None

Special cases

1. An array size of 0 causes an immediate exit with the Carry flag set to
1 to indicate an invalid result.
2. If the largest unsigned value occurs more than once, the program
returns with the lowest possible address. That is, it returns with the
address closest to the base address that contains the maximum value.

Title

Find

Name:

MAXELM

Maximum

Byte-Length

Element

Purpose:

Given the base address and
find the largest element.

Entry:

Register
Register

Exit:

If

H+
+

$$e
+£+
FF
HF
+
F

X =
A =

Base
Size

size

of

an

array,

address of array
of array in bytes

size of array not zero then
Carry flag = 0
Register A = Largest element
Register X = Address of that element
If there are duplicate values of the

largest

192

Assembly language subroutines for the 6809
element,
register X contains
nearest to the base address.

else
Carry
Registers

Used:

flag

=

the

address

1

A,B,CC,X,Y

Time:

Approximately 14 to 26 cycles
plus 27 cycles overhead

Size:

Program

25

bytes

IF

NO

per

byte

HEH
HF
HE
FE
+
&

MAXELM:
*

*EXIT
*
SEC
TSTA
BEQ

WITH

CARRY

EXITMX

SET

ELEMENTS

IN

ARRAY

SET CARRY IN CASE ARRAY HAS NO ELEMENTS
CHECK NUMBER OF ELEMENTS
BRANCH CEXIT) WITH CARRY SET IF NO
* ELEMENTS - INDICATES INVALID RESULT

*
*EXAMINE ELEMENTS ONE AT A TIME, COMPARING EACH ONE'S VALUE
* WITH CURRENT MAXIMUM AND ALWAYS KEEPING LARGER VALUE AND
* ITS ADDRESS.
IN THE FIRST ITERATION, TAKE THE FIRST
* ELEMENT AS THE CURRENT MAXIMUM.
*
TFR
A,B
SAVE NUMBER OF ELEMENTS IN B
LEAY
1,X
SET POINTER AS IF PROGRAM HAD JUST
* EXAMINED THE FIRST ELEMENT AND FOUND
* IT TO BE LARGER THAN PREVIOUS MAXIMUM
MAXLP:

LEAX

-1,Y

LDA

7X

SAVE
* AS
SAVE

ADDRESS
ADDRESS
ELEMENT

OF ELEMENT JUST EXAMINED
OF MAXIMUM
JUST EXAMINED AS MAXIMUM

*

*COMPARE CURRENT ELEMENT TO MAXIMUM
*KEEP LOOKING UNLESS CURRENT ELEMENT
*

IS

LARGER

MAXLP1:
DECB
BEQ
CMPA
BCC
BCS
*
*CLEAR

EXITLP
7Y¥t+
MAXLP1
MAXLP
CARRY

TO

COUNT ELEMENTS
BRANCH (EXIT) IF ALL ELEMENTS EXAMINED
COMPARE CURRENT ELEMENT TO MAXIMUM
* ALSO MOVE POINTER TO NEXT ELEMENT
CONTINUE UNLESS CURRENT ELEMENT LARGER
ELSE CHANGE MAXIMUM
INDICATE

VALID

RESULT

-

MAXIMUM

FOUND

EXITLP:
CLC
EXITMX:

CLEAR

CARRY

TO

INDICATE

VALID

RESULT

6C

Find maximum byte-length element (MAXELM)

SAMPLE

193

EXECUTION:

SC6C:

LDX
LDA
JSR

SZARY
ARY:

#ARY
#SZARY
MAXELM

BRA

SCé6C

EQU
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB

$10
8
7
6
5
4
3
2
1
$FF
$FE
$FD
SFC
$FB
SFA
$F9
$F8

GET BASE ADDRESS OF ARRAY
GET SIZE OF ARRAY IN BYTES
FIND LARGEST UNSIGNED ELEMENT
*RESULT FOR TEST DATA IS
* A = FF HEX (MAXIMUM), X = ADDRESS
* FF IN ARY.
LOOP FOR MORE TESTING

SIZE

OF

ARRAY

IN

BYTES

OF

194

Assembly language subroutines for the 6809

6D Find minimum byte-length element
(MINELM)
Finds the minimum element in an array. The array consists of up to 255
unsigned byte-length elements.

Procedure The program exits immediately (setting Carry to 1) if the
array has no elements. Otherwise, the program assumes that the element at the base address is the minimum. It then works through the
array, comparing the current minimum to each element and retaining
the smaller value and its address. Finally, the program clears Carry to
indicate a valid result.

Entry conditions

Base address of array in register X
Size of array in bytes in register A

Exit conditions

Smallest unsigned element in register A
Address of smallest unsigned element in register X

Carry = 0 if result is valid, 1 if size of array is 0 and result is meaningless

Example

Data:

Size of array (in bytes) = (A) = 08
Array elements
3516 =5310
4416 = 6810
Abie =

16640

5916 =

D216

21010

7A

=

12210

2/10

CF i6 =

20710

=

1Bie6 =

Result:

8940

The smallest unsigned element is element #3
(1Bi6 = 2710)
(A) = smallest element (1Bj¢)
(X) = BASE + 3 (lowest address containing 1B4.)
Carry flag = 0, indicating that array size is non-zero and
the result is valid

6D

Find minimum byte-length element (MINELM)

Registers used

195

A,B,CC, X,Y

Execution time Approximately 14 to 26 cycles per element plus 27
cycles overhead. The larger number of cycles applies when the program
must replace the previous minimum and its address with the current

element and its address. If, on the average, that replacement is neces-

sary in half of the iterations, the execution time is approximately

(14 + 26)/2 x ARRAY SIZE/2 + 27 cycles
If, for example,
execution time is

ARRAY

SIZE

=

14,6 = 2010, the approximate

40/2 x 10 + 27 = 200 + 27 = 227 cycles

Program size

25 bytes

Data memory required

None

Special cases

1. An array size of 0 causes an immediate exit with the Carry flag set to
1 to indicate an invalid result.
2. If the smallest unsigned value occurs more than once, the program
returns with the lowest possible address. That is, it returns with the
address closest to the base address that contains the minimum value.

Title

Find

Name:

MINELM

Minimum

Byte-Length

Element

Purpose:

Given

the

base

find

the

smallest

element

X =
A =

address of array
of array in bytes

+

HR
FH
HF
eH
+
F&

Entry:

Register
Register

Exit:

If

address

Base
Size

and

size

of

an

array,

size of array not zero then
Carry flag = 0
Register A = Smallest element
Register X = Address of that element
If there are duplicate values of the

smallest

Assembly language subroutines for the 6809
element, register X contains the
nearest to the base address.
else
Carry flag = 1
Registers

Used:

address

A,B,CC,X,Y

Time:

Approximately 14 to 26 cycles
plus 27 cycles overhead

Size:

Program

25

bytes

IF

ARRAY

per

byte

INELM:
*

*EXIT
*
SEC
TSTA
BEQ

WITH

CARRY

EXITMN

SET

CONTAINS

NO

ELEMENTS

SET CARRY IN CASE ARRAY HAS NO ELEMENTS
CHECK NUMBER OF ELEMENTS
BRANCH C(CEXIT) WITH CARRY SET IF NO
* ELEMENTS - INDICATES INVALID RESULT

*
*EXAMINE ELEMENTS ONE AT A TIME, COMPARING EACH VALUE WITH
* THE CURRENT MINIMUM AND ALWAYS KEEPING THE SMALLER VALUE
* AND ITS ADDRESS.
IN THE FIRST ITERATION, TAKE THE FIRST
* ELEMENT AS THE CURRENT MINIMUM.
*
TFR
A,B
SAVE NUMBER OF ELEMENTS IN B
LEAY
1,X
SET POINTER AS IF PROGRAM HAD JUST
* EXAMINED THE FIRST ELEMENT
MINLP:

LEAX

-1,Y

LDA

7X

SAVE
* AS
SAVE

ADDRESS
ADDRESS
ELEMENT

OF ELEMENT JUST EXAMINED
OF MINIMUM
JUST EXAMINED AS MINIMUM

*

*COMPARE CURRENT ELEMENT TO SMALLEST
*KEEP LOOKING UNLESS CURRENT ELEMENT
*

IS

SMALLER

MINLP1:

DECB
BEQ
CMPA
BLS
BHI

EXITLP
eYt+
MINLP1
MINLP

COUNT ELEMENTS
BRANCH CEXIT) IF ALL ELEMENTS EXAMINED
COMPARE CURRENT ELEMENT TO MINIMUM
CONTINUE UNLESS CURRENT ELEMENT SMALLER
ELSE CHANGE MINIMUM

*

*CLEAR
*

CARRY

TO

INDICATE

VALID

RESULT

-

MINIMUM

FOUND

EXITLP:
CLC

CLEAR

EXITMN:

RTS

*

SAMPLE

EXECUTION:

CARRY

TO

INDICATE

VALID

RESULT

6D

Find minimum byte-length element (MINELM)

197

SC6D:

SZARY
ARY:

LDX
LDA
JSR

#ARY
#SZARY
MINELM

BRA

SC6D

EQU
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
END

—_=oS

UIA
CO
~1
=-—
NWN
&%
WE

$FF
SFE
$FD
SFC
$FB
SFA
$F9
$F8

GET BASE ADDRESS OF ARRAY
GET SIZE OF ARRAY IN BYTES
FIND MINIMUM VALUE IN ARRAY
*RESULT FOR TEST DATA IS
* A = 1 HEX (MINIMUM), X = ADDRESS
* 1 IN ARY.
LOOP FOR ANOTHER TEST

SIZE

OF

ARRAY

IN

BYTES

OF

198

Assembly language subroutines for the 6809

6E Binary search
(BINSCH)
Searches an array of unsigned byte-length elements for a particular
value. The elements are assumed to be arranged in increasing order.
Clears Carry if it finds the value and sets Carry to 1 if it does not.
Returns the address of the value if found. The size of the array is
specified and is a maximum of 255 bytes.

Procedure The program performs a binary search, repeatedly comparing the value with the middle remaining element. After each comparison, the program discards the part of the array that cannot contain
the value (because of the ordering). The program retains upper and
lower bounds for the part still being searched. If the value is larger than
the middle element, the program discards that element and everything
below it. The new lower bound is the address of the middle element plus
1. If the value is smaller than the middle element, the program discards
that element and everything above it. The new upper bound is the
address of the middle element minus 1. The program exits if it finds a
match or if there is nothing left to search.
For example, assume that the array is

0146, 0216, 0516, 0716, 9916, 0916, OD 16, 1016, 2E16, 3716, SD16, 7E16, Alie,
B416, D716, E0i6
and the value being sought is 0D1.. The procedure works as follows.
In the first iteration, the lower bound is the base address and the

upper bound is the address of the last element. So we have

LOWER BOUND = BASE
UPPER BOUND = BASE + LENGTH — 1 = BASE +OF 1¢
GUESS = (UPPER BOUND + LOWER BOUND)/2
= BASE + 7 (the result is truncated)
(GUESS) = ARRAY(7) = 1016 = 1610
Since the value (ODj.6) is less than ARRAY(7), we can discard the
elements beyond #6. So we have

LOWER BOUND = BASE
UPPER BOUND = GUESS — 1 = BASE + 6
GUESS = (UPPER BOUND + LOWER BOUND)? = BASE + 3
(GUESS) = ARRAY(3) = 07
Since the value (0Dj¢) is greater than ARRAY(3), we can discard the

6E

Binary search (BINSCH)

199

elements below #4. So we have

LOWER BOUND = GUESS + 1 = BASE + 4
UPPER BOUND = BASE + 6
GUESS = (UPPER BOUND + LOWER BOUND)/2 = BASE + 5
(GUESS) = ARRAY(5) = 09
Since the value (0D4¢) is greater than ARRAY(5), we can discard the
elements below #6. So we have
LOWER BOUND = GUESS + 1 = BASE + 6
UPPER BOUND = BASE + 6
GUESS = (UPPER BOUND + LOWER BOUND)/2 = BASE + 6

Since the value (0Dj.) is equal to ARRAY(6), we have found the

element. If, on the other hand, the value were 0E;., the new lower

bound would be BASE + 7 and there would be nothing left to search.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

Value to find

Size of the array in bytes
More significant byte of base address of array (address of smallest
unsigned element)
Less significant byte of base address of array (address of smallest unsigned element)

Exit conditions

Carry = 0 if the value is found, 1 if it is not found. If the value is found,

(X) = its address.

eee

Examples
Length of array = 1016 = 164
Elements of array are 0116, 0216, 0516, 0716, 0916, 0916, ODi6, 1046, 2E16,

200

Assembly language subroutines for the 6809

3716, 5Di6, TE16, Ali6, B416, D716, E016
1.

2.

Data:

Value to find = 0Di6

Result:

Carry = 0, indicating value found
(X) = BASE + 6 (address containing 0D16)

Data:

Value to find = 9Bi¢

Result:

Carry = 1, indicating value not found

Registers used

All

Execution time Approximately 50 cycles per iteration plus 50 cycles
overhead. A binary search will require on the order of log, N iterations,
where N is the number of elements in the array.
If, for example, N = 32, the binary search will require approximately
logs 32 = 5 iterations. The execution time will then be approximately
50 x 5 + 50 = 250 + 50 = 300 cycles

Program size

64 bytes

Data memory required

None

Special case Asize of 0 causes an immediate exit with the Carry flag
set to 1. That is, the array contains no elements and the value surely
cannot be found.

Title

Binary

Name:

BINSCH

Purpose:

Search

Search

+

with

Entry:

OFOH+FF
e

an
a

ordered

maximum

array

size

of

of

unsigned

255

elements.

TOP OF STACK
High byte of return address
Low byte of return address
Value to find

Length (size) of array
High byte of base address

of

array

bytes,

6E

Binary search (BINSCH)

*

Low

byte

of

201
base

address

of

array

*

*
*
*
*
*

If

Exit:

the value
Carry flag
Register X
Else
Carry flag

is found then
= 0
= Address of value
1

=

*

*
*
*
*

Registers

Used:

ALL

Time:

Approximately 50 cycles
the search loop plus 50

for each iteration
cycles overhead

A binary

the

of

*

*
*
*

search

takes

on

base 2 of N searches, where
elements in the array.

order
N is

of
the

log
number

of

*

*

64

Program

Size:

bytes

*

*

BINSCH:
*

*EXIT

WITH

CARRY

SET

IF

ARRAY

CONTAINS

NO

ELEMENTS

*

LDU
SEC
LDB

3,8

BEQ

EXITBS

SAVE RETURN ADDRESS
SET CARRY IN CASE ARRAY HAS
CHECK NUMBER OF ELEMENTS

78

BRANCH
CEXIT)
WITH
* ELEMENTS
- VALUE

NO

ELEMENTS

CARRY SET IF NO
SURELY
CANNOT BE

*

*INITIALIZE INDEXES OF UPPER BOUND, LOWER
*LOWER BOUND = BASE ADDRESS
x*UPPER BOUND = ADDRESS OF LAST ELEMENT =
* BASE ADDRESS + SIZE - 1

BOUND

*

DECB
STB
CLR
LDX

INDEX

OF

UPPER

BOUND

=

NUMBER

OF

ELEMENTS
- 1
INDEX OF LOWER BOUND = O INITIALLY
GET BASE ADDRESS
OF ARRAY

1,8
9
4,8

*

*ITERATION OF BINARY SEARCH
*1) COMPARE VALUE TO MIDDLE ELEMENT
*2) IF THEY ARE NOT EQUAL, DISCARD HALF THAT
*
CANNOT POSSIBLY CONTAIN VALUE (BECAUSE OF
*3)

CONTINUE

IF

THERE

IS

ANYTHING

LEFT

TO

LOWER

UPPER

BOUND

ORDERING)

SEARCH

*

SRLOOP:
LDA

79

ADDA

1,58

RORA

ADD

DIVIDE

BY

AND
2,

TRUNCATING

INDEXES
FRACTION

*

*IF INDEX OF MIDDLE ELEMENT IS GREATER THAN
* THEN ELEMENT IS NOT IN ARRAY
*
CMPA
1,8
COMPARE INDEX OF MIDDLE

UPPER

BOUND,

ELEMENT

TO

FOUND

202

Assembly language subroutines for the 6809

BHI
*
*IF INDEX
* ELEMENT
*
CMPA

NOTFND

* UPPER BOUND
BRANCH (NOT FOUND)
* THAN UPPER BOUND

OF
IS

ELEMENT
ARRAY

MIDDLE
NOT IN

79

BLO

IF

MIDDLE

LESS

THAN

INDEX

GREATER

LOWER

BOUND,

THEN

COMPARE INDEX OF MIDDLE ELEMENT TO
* LOWER BOUND
BRANCH (NOT FOUND) IF INDEX LESS
* THAN LOWER BOUND

NOTFND

*
*CHECK
*
LDB
CMPB
BLO
BEQ

IS

IF

ELEMENT

A,X
2,Ss
RPLCLW
FOUND

IS

THE

VALUE

BEING

SOUGHT

GET ELEMENT WITH MIDDLE INDEX
COMPARE ELEMENT WITH VALUE SOUGHT
BRANCH IF VALUE LARGER THAN ELEMENT
BRANCH IF VALUE FOUND

*

*VALUE IS SMALLER THAN ELEMENT WITH MIDDLE INDEX
*MAKE MIDDLE INDEX - 1 INTO NEW UPPER BOUND
*
DECA
SUBTRACT 1 SINCE VALUE CAN ONLY BE
* FURTHER DOWN
STA
1,8
SAVE DIFFERENCE AS NEW UPPER BOUND
CMPA
#3 FF
CONTINUE SEARCHING IF UPPER BOUND DOES
BNE
SRLOOP
NOT UNDERFLOW
BEQ
NOTFND
EXIT IF UPPER BOUND UNDERFLOWED
*

*VALUE IS LARGER THAN ELEMENT WITH MIDDLE INDEX
*MAKE MIDDLE INDEX + 1 INTO NEW LOWER BOUND
*

RPLCLW:
INCA
STA
BNE

79
SRLOOP

BEQ

NOTFND

ADD 1 SINCE VALUE CAN ONLY BE FURTHER UP
SAVE SUM AS NEW LOWER BOUND
CONTINUE SEARCHING IF LOWER BOUND DOES
* NOT OVERFLOW
EXIT IF LOWER BOUND OVERFLOWED

*

*FOUND
*

THE

VALUE

-

GET

ITS

ADDRESS

AND

CLEAR

CARRY

FOUND:
LEAX
CLC
BRA

A,X

GET ADDRESS OF VALUE
CLEAR CARRY, INDICATING

VALUE

FOUND

EXITBS

*

*DID
*

NOT

FIND

THE

VALUE

-

SET

CARRY

TO

INDICATE

FAILURE

NOTFND:
SEC
*
*REMOVE
*

PARAMETERS

SET

CARRY,

FROM

STACK

INDICATING
AND

VALUE

EXIT

EXITBS:

LEAS
JMP

6,S
,U

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

NOT

FOUND

6E

by

Binary search (BINSCH)

SAMPLE

203

EXECUTION

SC6E:
*SEARCH
LDX
LDB
LDA
PSHS
JSR

FOR A VALUE
#BF
BFSZ
#7
D,X
BINSCH

THAT

IS

IN THE ARRAY
GET BASE ADDRESS
OF BUFFER
GET ARRAY SIZE IN BYTES
GET VALUE TO FIND
SAVE PARAMETERS
IN STACK
BINARY
SEARCH
*CARRY
FLAG = O CVALUE
FOUND)
*X = ADDRESS OF 7 IN ARRAY

*SEARCH
LDX
LDB
LDA
PSHS
JSR

FOR A VALUE
#BF
BFSZ
#0
D,X
BINSCH

THAT

IS

BRA

SC6E

EQU
FCB

$10
SIZE

NOT IN THE ARRAY
GET BASE ADDRESS
OF BUFFER
GET ARRAY SIZE IN BYTES
GET VALUE TO FIND
SAVE PARAMETERS
IN STACK
BINARY SEARCH
*CARRY
FLAG = 1 (VALUE NOT FOUND)
LOOP FOR MORE TESTS

*

*DATA
*

SIZE
BFSZ:
BF:

FCB

1

FCB
FCB
FCB
FCB
FCB

2
4
5
7
9

FCB
FCB
FCB
FCB

10
11
23
50

FCB

81

FCB
FCB
FCB
FCB
FCB

123
191
199
250
255

END

SIZE OF
SIZE OF
*BUFFER

BUFFER

IN

BYTES

BUFFER

IN

BYTES

204

6F

Assembly language subroutines for the 6809

Quicksort

(QSORT)
Arranges an array of unsigned word-length elements into ascending
order using a quicksort algorithm. Each iteration selects an element and
divides the array into two parts, one containing all elements larger than
the selected element and the other containing all elements smaller than
the selected element. Elements equal to the selected element may end
up in either part. The parts are then sorted recursively in the same way.
The algorithm continues until all parts contain either no elements or
only one element. An alternative is to stop recursion when a part
contains few enough elements (say, less than 20) to make a bubble sort
practical.
The parameters are the array’s base address, the address of its last
element, and the lowest available stack address. The array can thus
occupy all available memory, as long as there is room for the stack.
Since the procedures that obtain the selected element, compare elements, move forward and backward in the array, and swap elements are
all subroutines, they could be changed readily to handle other types of
elements.
Ideally, quicksort should divide the array in half during each iteration. How closely the procedure approaches this ideal depends on how
well the selected element is chosen. Since this element serves as a
midpoint or pivot, the best choice would be the central value (or
median). Of course, the true median is unknown. A simple but reasonable approximation is to select the median of the first, middle, and last
elements.

Procedure
median

The program first deals with the entire array. It selects the

of the current first, middle,

and last elements

as a central

element. It moves that element to the first position and divides the array
into two parts or partitions. It then operates recursively on the parts,
dividing them into parts and stopping when a part contains no elements
or only one element. Since each recursion places 6 bytes on the stack,
the program must guard against overflow by checking whether the stack
has reached to within a small buffer of its lowest available position.
Note that the selected element always ends up in the correct position
after an iteration. Therefore, it need not be included in either partition.
Our rule for choosing the middle element is as follows, assuming that
the first element is #1:
1.

If the array has an odd number of elements, take the centre one.

6F

Quicksort (QSORT)

205

For example, if the array has 11 elements, take #6.
2. Ifthe array has an even number of elements and its base address is
even, take the element on the lower (base address) side of the centre.
for example, if the array starts in 0300; and has 12 elements, take #6.

3. Ifthe array has an even number of elements and its base address is
odd, take the element on the upper side of the centre. For example, if
the array starts in 03011. and has 12 elements, take #7.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of base address of array
Less significant byte of base address of array
More significant byte of address of last word in array
Less significant byte of address of last word in array
More significant byte of lowest possible stack address
Less significant byte of lowest possible stack address

Exit conditions

Array sorted into ascending order, considering the elements as unsigned
words. Thus, the smallest unsigned word ends up stored starting at the
base address. Carry = 0 if the stack did not overflow and the result is
proper. Carry = 1 if the stack overflowed and the final array is not sorted.

Example

Data:

Length (size) of array = 0Ci6 = 1219
Elements

= 2Bi6, 57165 1Di6, 26165

2216, 2E16, OCi6, 4416,
Result:

1716, 4Bi6, 3716, 2716.
In the first iteration, we have:
Selected element = median of the first (#1 = 2Bi6),
middle (#6 = 2Ej6), and last (#12 = 27,6) elements. The

206

Assembly language subroutines for the 6809

selected element is therefore #1 (2B), and no swapping
is necessary since it is already in the first position.
At the end of the iteration, the array is

2716, 1716, 1D16, 2616,
2216, OCi6, 2Bie; 4446,
2E 16, 4Bie, 3716; 5716.

The first partition, consisting of elements less than 2By6, is
2716; 1716, 1D46,

2616; 22165 and OCy6.

The second partition, consisting of elements greater than
2Bie, 1S 44165 2E16,

4Bi6, 3716; and 5716:

Note that the selected element (2B,¢) is now in the correct

position and need not be included in either partition.
We may now sort the first partition recursively in the same
way:
Selected element = median of the first (#41 = 2746),

middle (#3 = 1Dy¢), and last (#6 = OCj¢) elements.
Here, #3 is the median and must be exchanged initially
with #1.
The final order of the elements in the first partition is:

OCi6, 1716, 1D 16, 2616, 2216, 2716.
The first partition of the first partition (consisting of elements less than 1D46) is OCj6, 1716. We will call this the
(1,1) partition for short.
The second partition of the first partition (consisting of

elements greater than 1Dj4¢) is 2616, 2216, and 2746.
As in the first iteration, the selected element (1Dj¢) is in

the correct position and need not be considered further.
We may now sort the (1,1) partition recursively as follows:

Selected element = median of the first (#1 = OCi¢),
middle (#1 = 0Ci¢), and last (#2 = 1716) elements. Thus

the selected element is the first element (#1 = 0Cj¢), and
no initial swap is necessary.
The final order is obviously the same as the initial order,
and the two resulting partitions contain 0 and 1 element,
respectively. Thus the next iteration concludes the recursion, and we then sort the other partitions by the same
method. Obviously, quicksort’s overhead becomes a
major factor when an array contains only a few elements.
This is why one might use a bubble sort once quicksort has
created small enough partitions.

6F

Quicksort (QSORT)

207

Note that the example array does not contain any identical
elements. During an iteration, elements that are the same
as the selected element are never moved. Thus they may
end up in either partition. Strictly speaking, then, the two
partitions consist of elements ‘less than or possibly equal
to the selected element’ and elements ‘greater than or
possibly equal to the selected element.’

References

M. J. Augenstein and A. M. Tenenbaum, Data Structures and PL/I
Programming, Prentice-Hall, Englewood Cliffs, NJ, 1979, pp. 460471. There is also a Pascal version of this book entitled Data Structures Using Pascal (Prentice-Hall, Englewood Cliffs, NJ, 1982) and a
BASIC version entitled Data Structures for Personal Computers (Y.
Langsam, co-author, Prentice-Hall, Englewood Cliffs, NJ, 1985).
N. Dale and S. C. Lilly, Pascal Plus Data Structures, D. C. Heath,

Lexington, MA, 1985, pp. 300-307.
D. E. Knuth, The Art of Computer Programming. Vol. 3: Searching and
Sorting, Addison-Wesley, Reading, MA, 1973, pp. 114-123.

Registers used

All

Execution time Approximately N Xx log.N loops through PARTLP
plus 2 x N + 1 overhead calls to SORT. Each iteration of PARTLP
takes approximately 60 or 120 cycles (depending on whether an
exchange is necessary), and each overhead call to SORT takes approximately 200 cycles. Thus the total execution time is of the order of

90 x N x log,N + 200 x (2 x N + 1) cycles
If, for example, N = 16384 (21%), the total execution time should be
around

90 x 16384 x 14 + 200 x 32769 = 20600000 + 6600000
= about 27 200 000 cycles
This is about 27 s at a typical 6809 clock rate of 1 MHz.

208

Assembly language subroutines for the 6809

Program size

179 bytes

Data memory required 8 bytes anywhere in RAM for pointers to the
first and last element of a partition (2 bytes starting at addresses FIRST
and LAST, respectively), a pointer to the bottom of the stack (2 bytes
starting at address STKBTM). and the original value of the stack pointer (2 bytes starting at address OLDSP). Each recursion level requires 6
bytes of stack space, and the routines themselves require another 4
bytes.

Special case If the stack overflows (i.e. comes too close to its boundary), the program exits with the Carry flag set to 1.
Quicksort
QSORT

Title
Name:
+

Arrange an array of unsigned words
ascending order using a quicksort,
maximum size of 32767 words.

Purpose:

HHt
He
HN
*€
HF
+H
Fe
F
+

a

Entry:

TOP OF STACK
High byte of return address
Low byte of return address
High byte of address of first word in array
Low byte of address of first word in array
High byte of address of last word in array
Low byte of address of last word in array
High byte of lowest available stack address
Low byte of lowest available stack address

Exit:

If

Registers
Time:

HF
+€

into
with

the stack did not overflow then
The array is sorted into ascending
Carry = 0
Else
Carry = 1
Used:

order.

ALL
The timing is highly data-dependent but the
quicksort algorithm takes approximately
N * log (N) Loops through PARTLP. There will be
2
2 * N+1 calls to Sort. The number of recursions
will probably be a fraction of N but if all
data is the same, the recursion could be up to
N. Therefore, the amount of stack space should
be maximized.
NOTE: Each recursion
Level takes
6 bytes of stack space.

6F

Quicksort (QSORT)

209

In the above discussion,
array elements.

$i ze:

Program
Data

179 bytes
8 bytes

plus

N is

the

4 stack

number

of

bytes

£€
+

QSORT:
PULS
PSHS

D,X,Y,U
D

REMOVE
PARAMETERS
FROM STACK
PUT RETURN
ADDRESS
BACK IN STACK

*

*WATCH FOR STACK OVERFLOW
*CALCULATE A THRESHOLD TO WARN OF OVERFLOW
* (10 BYTES FROM THE END OF THE STACK)
*SAVE THIS THRESHOLD FOR LATER COMPARISONS
*ALSO SAVE THE POSITION OF THIS ROUTINE'S RETURN ADDRESS
* IN THE EVENT WE MUST ABORT BECAUSE OF STACK OVERFLOW
*

STS

OLDSP

LEAU

10,U

STU

STKBTM

SAVE POINTER TO RETURN ADDRESS IN
* CASE WE MUST ABORT
ADD SMALL BUFFER (10 BYTES) TO
* LOWEST STACK ADDRESS
SAVE SUM AS BOTTOM OF STACK FOR
* FIGURING WHEN TO ABORT

*
*WORK RECURSIVELY THROUGH THE QUICKSORT ALGORITHM AS
* FOLLOWS:
1. CHECK IF THE PARTITION CONTAINS O OR 1 ELEMENT.
MOVE UP A RECURSION LEVEL IF IT DOES.
2. USE MEDIAN TO OBTAIN A REASONABLE CENTRAL VALUE
FOR DIVIDING THE CURRENT PARTITION INTO TWO
PARTS.
3. MOVE THROUGH THE ARRAY SWAPPING ELEMENTS THAT
ARE OUT OF ORDER UNTIL ALL ELEMENTS BELOW THE
CENTRAL VALUE ARE AHEAD OF ALL ELEMENTS ABOVE
THE CENTRAL VALUE.
SUBROUTINE COMPARE
COMPARES ELEMENTS, SWAP EXCHANGES ELEMENTS,
PREV MOVES UPPER BOUNDARY DOWN ONE ELEMENT,
AND NEXT MOVES LOWER BOUNDARY UP ONE ELEMENT.
4. CHECK IF THE STACK IS ABOUT TO OVERFLOW.
IF IT
IS, ABORT AND EXIT.
>. ESTABLISH THE BOUNDARIES FOR THE FIRST PARTITION
(CONSISTING OF ELEMENTS LESS THAN THE CENTRAL VALUE)
AND SORT IT RECURSIVELY.
6. ESTABLISH THE BOUNDARIES FOR THE SECOND PARTITION
(CONSISTING OF ELEMENTS GREATER THAN THE CENTRAL
VALUE) AND SORT IT RECURSIVELY.
*

HHH
te
+t
HK
HF
He
+e
+
H
F

SORT:
*®

*SAVE BASE ADDRESS AND
* IN CURRENT PARTITION
*

ADDRESS

OF

LAST

ELEMENT

210

Assembly language subroutines for the 6809
STX
FIRST
SAVE BASE ADDRESS
STY
LAST
SAVE ADDRESS OF LAST ELEMENT
*
*CHECK IF PARTITION CONTAINS O OR 1 ELEMENTS
* IT DOES IF FIRST IS EITHER LARGER THAN (0)
* OR EQUAL TO (1) LAST.
*
*STOP WHEN FIRST >= LAST
*
CMPX
LAST
CALCULATE FIRST - LAST
BCC
EXITPR
BRANCH (RETURN) IF DIFFERENCE IS
* POSITIVE - THIS PART IS SORTED
*
*START ANOTHER ITERATION ON THIS PARTITION
*USE MEDIAN TO FIND A REASONABLE CENTRAL ELEMENT
*MOVE CENTRAL ELEMENT TO FIRST POSITION
*
BSR
MEDIAN
SELECT CENTRAL ELEMENT, MOVE IT
* TO FIRST POSITION
LDU
#0
BIT O OF REGISTER U = DIRECTION

* IF IT'S O THEN DIRECTION
* ELSE DIRECTION IS DOWN

IS UP

*

*REORDER ARRAY BY COMPARING OTHER ELEMENTS WITH THE
CENTRAL ELEMENT.
START BY COMPARING THAT ELEMENT WITH
LAST ELEMENT.
EACH TIME WE FIND AN ELEMENT THAT
BELONGS IN THE FIRST PART (THAT IS, IT IS LESS THAN
THE CENTRAL ELEMENT), SWAP IT INTO THE FIRST PART IF IT
IS NOT ALREADY THERE AND MOVE THE BOUNDARY OF THE
FIRST PART DOWN ONE ELEMENT.
SIMILARLY, EACH TIME WE
FIND AN ELEMENT THAT BELONGS IN THE SECOND PART (THAT
IS, IT IS GREATER THAN THE CENTRAL ELEMENT), SWAP IT
INTO THE SECOND PART IF IT IS NOT ALREADY THERE AND MOVE
HF THE
F+
BOUNDARY OF THE SECOND PART UP ONE ELEMENT.
*ULTIMATELY, THE BOUNDARIES COME TOGETHER
* AND THE DIVISION OF THE ARRAY IS THEN COMPLETE
*NOTE THAT ELEMENTS EQUAL TO THE CENTRAL ELEMENT ARE NEVER
* SWAPPED
*

AND

SO

MAY

END

UP

IN

EITHER

PART

PARTLP:
*

*LOOP SORTING UNEXAMINED
* UNTIL THERE IS NOTHING
*
TFR
X,D
PSHS
Y
CMPD
yott
BCC
DONE

PART
LEFT

OF
IN

PARTITION
IT

LOWER

BOUNDARY

LOWER BOUNDARY-UPPER
EXIT WHEN EVERYTHING

BOUNDARY
EXAMINED

*

*COMPARE NEXT 2 ELEMENTS.
IF OUT OF ORDER,
SWAP THEM
*AND CHANGE DIRECTION OF SEARCH
* IF FIRST > LAST THEN SWAP
*
LDD
7X
COMPARE ELEMENTS
CMPD
rv
BLS
REDPRT
BRANCH IF ALREADY IN ORDER

6F

Quicksort (QSORT)

211

*

*ELEMENTS
*

OUT

TFR
COMB
TFR
JSR

U,D

OF

D,U
SWAP

ORDER,

SWAP

THEM

AND

CHANGE

DIRECTION

GET DIRECTION
CHANGE DIRECTION
SAVE NEW DIRECTION
SWAP ELEMENTS

*

*REDUCE SIZE OF UNEXAMINED AREA
*IF NEW ELEMENT LESS THAN CENTRAL ELEMENT, MOVE
* TOP BOUNDARY DOWN
*IF NEW ELEMENT GREATER THAN CENTRAL ELEMENT, MOVE
* BOTTOM BOUNDARY UP
*IF ELEMENTS EQUAL, CONTINUE IN LATEST DIRECTION
*
REDPRT:

CMPU
BEQ
LEAX

#0
UP
2,X

BRA

PARTLP

LEAY
JMP

-2,Y
PARTLP

CHECK DIRECTION
BRANCH IF MOVING UP
ELSE MOVE TOP BOUNDARY
* ONE ELEMENT

DOWN

BY

BY

ONE

TOO

LARGE

UP:

MOVE
ONE

BOTTOM BOUNDARY
ELEMENT

UP

*

*THIS PARTITION HAS NOW BEEN SUBDIVIDED INTO TWO
PARTITIONS. ONE STARTS AT THE TOP AND ENDS JUST
ABOVE THE CENTRAL ELEMENT.
THE OTHER STARTS
JUST BELOW THE CENTRAL ELEMENT AND CONTINUES
TO THE BOTTOM.
THE CENTRAL ELEMENT IS NOW IN
ITS PROPER SORTED POSITION AND NEED NOT BE
INCLUDED IN EITHER PARTITION
HF
+e
Fe
+

DONE:
*®

*FIRST CHECK WHETHER STACK MIGHT OVERFLOW
*IF IT IS GETTING TOO CLOSE TO THE BOTTOM, ABORT
* THE PROGRAM AND EXIT
*
TFR
S,D
CALCULATE SP - STKBTM
SUBD
STKBTM
BLS
ABORT
BRANCH CABORT) IF STACK
*

*ESTABLISH BOUNDARIES FOR FIRST (LOWER) PARTITION
*LOWER BOUNDARY IS SAME AS BEFORE
*UPPER BOUNDARY IS ELEMENT JUST BELOW CENTRAL ELEMENT
*THEN RECURSIVELY QUICKSORT FIRST PARTITION
*
LDY
LAST
GET ADDRESS OF LAST ELEMENT
PSHS
X,Y
SAVE CENTRAL, LAST ADDRESSES
LEAY
-2,X
CALCULATE LAST FOR FIRST PART
LDX
FIRST
FIRST IS SAME AS BEFORE
BSR
SORT
QUICKSORT FIRST PART
*

*ESTABLISH BOUNDARIES FOR SECOND (UPPER)
*UPPER BOUNDARY IS SAME AS BEFORE

PARTITION

212

Assembly language subroutines for the 6809
*LOWER BOUNDARY IS ELEMENT JUST ABOVE CENTRAL
*THEN RECURSIVELY QUICKSORT SECOND PARTITION
*
PULS
LEAX
BSR
CLC

X,Y
2,X
SORT

ELEMENT

GET FIRST, LAST FOR SECOND
CALCULATE FIRST FOR SECOND
QUICKSORT SECOND PART
CLEAR CARRY, INDICATING NO

PART
PART
ERRORS

EXITPR:

RTS

GOOD

EXIT

*

*ERROR
*

EXIT,

SET

CARRY

TO

1

ABORT:
LDS
SEC
RTS

OLDSP

GET ORIGINAL STACK POINTER
INDICATE ERROR
RETURN WITH ERROR INDICATOR
* ORIGINAL CALLER

TO

KRKEKKEKEKKEKKKKKKKKKKKKKRKRKK
KKK KKK

*ROUTINE: MEDIAN
*PURPOSE:
DETERMINE WHICH ELEMENT IN A PARTITION
*
SHOULD BE USED AS THE CENTRAL ELEMENT OR
*ENTRY: ADDRESS OF FIRST ELEMENT IN REGISTER X
*
ADDRESS OF LAST ELEMENT IN REGISTER Y
*EXIT:
CENTRAL ELEMENT IN FIRST POSITION
*
X,Y UNCHANGED
*REGISTERS USED: D,U
HK KKK KKK KKK KKK
REE KRE

PIVOT

MEDIAN:
*
*DETERMINE ADDRESS OF MIDDLE ELEMENT
* MIDDLE := ALIGNEDCFIRST + LAST) DIV
*
|

PSHS
TFR
ADDD
LSRA
RORB
ANDB
PSHS
TFR
CLRA
ANDB
ADDD
TFR

Y
X,D
79

SAVE ADDRESS OF LAST IN
ADD ADDRESSES OF FIRST,
DIVIDE

#%11111110
D
X,D
#%00000001
pott
D,U

2

SUM

BY

STACK
LAST

2

ALIGN CENTRAL ADDRESS
SAVE CENTRAL ADDRESS ON STACK
ALIGN MIDDLE TO BOUNDARY OF FIRST
MAKE BIT 0 OF MIDDLE SAME AS BIT
O OF FIRST
SAVE

MIDDLE

ADDRESS

IN

U

*

*DETERMINE MEDIAN OF FIRST, MIDDLE, LAST ELEMENTS
*COMPARE FIRST AND MIDDLE
*
LDD
7U
GET MIDDLE ELEMENT
CMPD
7X
MIDDLE - FIRST
BLS
MIDD1
BRANCH IF FIRST >= MIDDLE
*
.

6F

Quicksort (QSORT)

*WE KNOW (MIDDLE > FIRST)
* SO COMPARE MIDDLE AND LAST
*
LDD
7Y
GET LAST ELEMENT
CMPD
7U
LAST - MIDDLE
BCC
SWAPMF
BRANCH IF LAST >= MIDDLE
* MIDDLE IS MEDIAN
*
*WE KNOW (MIDDLE > FIRST) AND (MIDDLE > LAST)
* SO COMPARE FIRST AND LAST (MEDIAN IS LARGER ONE)
*
CMPD
BHI

7X
SWAPLF

BRA

MEXIT

*
*WE
*SO
*

LAST - FIRST
BRANCH IF LAST > FIRST
* LAST IS MEDIAN
EXIT IF FIRST >= LAST
* FIRST IS MEDIAN

KNOW FIRST >= MIDDLE
COMPARE FIRST AND LAST

MIDD1:
LOD
CMPD
BCC

7

GET

LAST

x
MEXIT

LAST
EXIT

-

*

IF

FIRST

FIRST
LAST > =
IS MEDIAN

FIRST

*

*WE KNOW
(FIRST >=
* SO COMPARE
MIDDLE

MIDDLE)
AND
CFIRST > LAST)
AND LAST
(MEDIAN
IS LARGER

ONE)

*

CMPD
BHI

,U
SWAPLF

LAST

-

MIDDLE

BRANCH

IF

LAST

*

IS

MEDIAN

LAST

>

MIDDLE

*

*MIDDLE

IS

MEDIAN,

MOVE

ITS

POINTER

TO

LAST

*

SWAPMF:
TFR

U,Y

*
*LAST

IS

MEDIAN,

SWAP

IT

MOVE

MIDDLE'S

WITH

FIRST

SWAP

LAST,

POINTER

TO

LAST

*

SWAPLF:
BSR

SWAP

FIRST

*

*RESTORE

LAST

AND

EXIT

*

MEXIT:
PULS
RTS

Y

RESTORE

KA KKKKKEKKKKEKEREKREKKKEKEEK
KKK
*ROUTINE: SWAP
*PURPOSE: SWAP ELEMENTS POINTED TO BY
*ENTRY: X = ADDRESS OF ELEMENT 1
*
Y = ADDRESS OF ELEMENT 2
*EXIT:
ELEMENTS SWAPPED

X,Y

ADDRESS

OF

LAST

ELEMENT

214

Assembly language subroutines for the 6809

*REGISTERS
HK KKK

USED: D
ERK KEKE EEE

KERR

EE

SWAP:
LDD
PSHS
LDD
STD
PULS
STD
RTS

7X
D
7Y
7X
D
7Y

GET FIRST ELEMENT
SAVE FIRST ELEMENT
GET SECOND ELEMENT
STORE SECOND IN FIRST
GET SAVED FIRST ELEMENT
STORE FIRST IN SECOND ADDRESS

2
2
2
2

POINTER TO FIRST ELEMENT OF PART
POINTER TO LAST ELEMENT OF PART
THRESHOLD FOR STACK OVERFLOW
POINTER TO ORIGINAL RETURN ADDRESS

*

*DATA SECTION
*
FIRST:
RMB
LAST:
RMB
STKBTM:
RMB
OLDSP:
RMB
*
*

SAMPLE

EXECUTION

*
*

*PROGRAM
SC6F:

SECTION
*
*SORT
* AND

AN ARRAY BETWEEN
BEGBUF
ENDBUF
(LAST ELEMENT)

*LET
*
LEAU
LDX
LDY
PSHS
JSR

STACK

BRA

EXPAND
-$100,S
#BEGBUF
#ENDBUF
U,X,Y
QSORT

SC6F

*

*DATA SECTION
*
BEGBUF:
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB
FDB

15
14
13
12
11
10
9

8
lf
6
5

100

HEX

CFIRST

ELEMENT)

BYTES
BOUNDARY FOR STACK OVERFLOW
ADDRESS OF FIRST ELEMENT
ADDRESS OF LAST ELEMENT
SAVE PARAMETERS IN STACK
SORT USING QUICKSORT
*RESULT FOR TEST DATA IS
* 0,1,2,3, «-- ,14,15
LOOP TO REPEAT TEST

6F
FDB
FDB
FDB
FDB
ENDBUF:
FDB
END

Quicksort (QSORT)

&
=a
NW

215

216

Assembly language subroutines for the 6809

6G RAM test
(RAMTST)
Tests a RAM area specified by a base address and a length in bytes.
Writes the values 0, FFi¢, 101010102 (AAj.), and 010101012 (5546) into
each byte and checks whether they can be read back correctly. Places 1
in each bit position of each byte and checks whether it can be read back
correctly with all other bits cleared. Clears the Carry flag if all tests run
correctly; if it finds an error, it exits immediately, setting the Carry flag
and returning the test value and the address at which the error occurred.

Procedure The program performs the single value tests (with 0, FFi6,
AAjo, and 5546) by first filling the memory area and then comparing
each byte with the specified value. Filling the entire area first should
provide enough delay between writing and reading to detect a failure to
retain data (perhaps caused by improperly designed refresh circuitry).
The program then performs the walking bit test, starting with bit 7; here
it writes the data into memory and reads it back immediately for a
comparison.

Entry conditions

Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

More significant byte of size (length) of test area in bytes
Less significant byte of size (length) of test area in bytes
More significant byte of base address of test area
Less significant byte of base address of test area

Exit conditions
1.

Ifanerror is found:

Carry = 1
Address containing error in register X
Test value in A
2.

Ifnoerror is found:

6G

RAM test (RAMTST)

217

Carry = 0
All bytes in test area contain 0

Example
Data:

Base address = 038016

Result:

Length (size) of area = 020046
Area tested is the 02006 bytes starting at address 038046,
1.€. 0380;¢-057Fj¢. The order of the tests is:

1.

Write and read 0

2.

Write and read FFj¢

3.

Write and read AAj¢ (101010102)

4.

Write and read 5516 (01010101,)

5.

Walking bit test, starting with 1 in bit 7. That is, start

with 10000000, (8016) and move the 1 one position right

for each subsequent test of a byte.

Registers used

All

Execution time Approximately 268 cycles per byte tested plus 231
cycles overhead. Thus, for example, to test an area of size 0400. =
1024, would take
268 X 1024 + 231 = 274432 + 231 = 274 663 cycles
This is about 275 ms at a standard 6809 clock rate of 1 MHz.

Program size

97 bytes

Data memory required

None

Special cases
1.

An area size of 0000;¢ causes an immediate exit with no memory

tested. The Carry flag is cleared to indicate no errors.
2.

Since the routine changes all bytes in the tested area, using it to test

218

Assembly language subroutines for the 6809

an area that includes itself will have unpredictable results.
Note that Case 1 means you cannot ask this routine to test the entire
memory, but such a request would be meaningless anyway since it
would require the routine to test itself.

3. Testing a ROM causes a return with an error indication after the
first occasion on which the test value differs from the memory’s
contents.
*

*
*

Title

RAM

*

Name:

RAMTST

Purpose:

Test
1)
2)
3)
4)
5)

Test

*

*
*
*
*
*
*
*

a RAM
Write
Write
Write
Write
Shift
while

(read/write memory) area as follows:
all O and test
all 11111111 binary and test
all 10101010 binary and test
all 01010101 binary and test
a single 1 through each bit,
clearing all other bits

*

*
*
*
*

If the program finds an error, it exits
immediately with the Carry flag set and
indicates the test value and where the
error occurred.

*

*

Entry:

TOP

*
*
*
*
*
*

OF

STACK

High byte of return address
Low byte of return address
High byte of area size in bytes
Low byte of area size in bytes
High byte of base address of area
Low byte of base address of area

*

*
*
*
*
*
*
*

Exit:

If

there are no errors then
Carry flag equals Q
test area contains OQ in all bytes
else
Carry flag equals 1
Register X = Address of error
Register A = Test value

*

*
*
*
*

Registers

Used:

All

Time:

Approximately 268 cycles
231 cycles overhead

Size:

Program

*

*

RAMTST:

97

bytes

per

byte

plus

6G

RAM test (RAMTST)

*EXIT

INDICATING

PULS
CLC
LDX
BEQ

U

*
*FILL
*
CLRA
BSR
BCS

NO

WITH

ERRORS

IF

AREA

SIZE

IS

ZERO

SAVE RETURN ADDRESS
INDICATE NO ERRORS
GET AREA SIZE
BRANCH C(CEXIT) IF AREA SIZE
* CARRY = O IN THIS CASE

7s
EXITRT

MEMORY

219

O AND

ZERO

TEST

GET ZERO VALUE
FILL AND TEST MEMORY
BRANCH CEXIT) IF ERROR

FILCMP
EXITRT

IS

FOUND

*

*FILL
*
LDA
BSR
BCS

MEMORY

WITH

FF

#$F F
FILCMP
EXITRT

HEX

CALL

1'S)

AND

TEST

GET ALL 1'S VALUE
FILL AND TEST MEMORY
BRANCH CEXIT) IF ERROR

FOUND

*

*FILL
*
LDA
BSR
BCS

MEMORY

WITH

ALTERNATING

1'S

AND

O'S

AND

TEST

#%410101010
GET ALTERNATING 1'S AND O'S
FILCMP
FILL AND TEST MEMORY
EXITRT
BRANCH CEXIT) IF ERROR FOUND

PATTERN

*

*FILL
*
LDA
BSR
BCS

MEMORY

WITH

ALTERNATING

O'S

AND

1'S

AND

TEST

#%401010101 GET ALTERNATING O'S AND 1'S
FILCMP
FILL AND TEST MEMORY
EXITRT
BRANCH CEXIT) IF ERROR FOUND

PATTERN

*

*PERFORM WALKING BIT TEST. PLACE A 1 IN BIT 7 AND
* SEE IF IT CAN BE READ BACK.
THEN MOVE THE 1 TO
* BITS 6, 5, 4, 3, 2, 1, AND O AND SEE IF IT CAN
* BE READ BACK
*
LDX
2,8
GET BASE ADDRESS OF AREA TO TEST
LDY
7s
GET AREA SIZE IN BYTES
CLRB
GET ZERO TO USE IN CLEARING AREA
WLKLP:

LDA

#%10000000

STA
CMPA
BNE
LSRA
BNE

7X
7X
EXITCS

MAKE

BIT

7 1, ALL

OTHER

BITS

0

WLKLP1:

STB
LEAY
BNE
CLC
BRA

WLKLP1

7Xt+
-1,Y
WLKLP
EXITRT

STORE TEST PATTERN IN MEMORY
TRY TO READ IT BACK
BRANCH C(CEXIT) IF ERROR FOUND
SHIFT PATTERN TO MOVE 1 BIT RIGHT
CONTINUE UNTIL PATTERN BECOMES ZERO
* THAT IS, UNTIL 1 BIT MOVES ALL THE
* WAY ACROSS THE BYTE
CLEAR BYTE JUST CHECKED
DECREMENT 16-BIT COUNTER
CONTINUE UNTIL AREA CHECKED
NO ERRORS - CLEAR CARRY

220

Assembly language subroutines for the 6809
*FOUND
*

AN

ERROR

-

SET

CARRY

TO

INDICATE

IT

EXITCS:
SEC
*
*REMOVE
*

ERROR
PARAMETERS

FROM

FOUND

STACK

-

SET

AND

EXIT

CARRY

EXITRT:
LEAS
JMP

4,8
,U

REMOVE PARAMETERS FROM
EXIT TO RETURN ADDRESS

STACK

KEKKEKEKEKEKKEKKEKKEEKEKKEKEKKKKKRKKKKKKKS

FILCMP
FILL MEMORY WITH A VALUE AND TEST
*
THAT IT CAN BE READ BACK
= TEST VALUE
*ENTRY:
STACK CONTAINS CIN ORDER STARTING AT
RETURN ADDRESS
AREA SIZE IN BYTES
BASE ADDRESS OF AREA
IF NO ERRORS THEN
CARRY FLAG EQUALS 0
ELSE
CARRY FLAG EQUALS 1
X = ADDRESS OF ERROR
A = TEST VALUE
PARAMETERS LEFT ON STACK
*REGISTERS USED: CC,X,Y
KHK KKK
KKK ERE ERR KKK EKER KEKE
KEKE

*ROUTINE:

*PURPOSE:

TOP):

FILCMP:
LDY
LDX
*
*FILL
*

2,8
4,8
MEMORY

GET
GET
WITH

TEST

SIZE
BASE

OF AREA
ADDRESS

IN
OF

BYTES
AREA

VALUE

FILLP:
STA
LEAY
BNE

Xt
-1,Y
FILLP

FILL A BYTE WITH TEST VALUE
CONTINUE UNTIL AREA FILLED

*

*COMPARE
*
LDY
LDX

MEMORY

AND

TEST

VALUE

2,8
4,8

GET
GET

SIZE
BASE

OF AREA
ADDRESS

IN
OF

BYTES
AREA

Xt+
EREXIT
-1,Y
CMPLP

COMPARE MEMORY AND TEST VALUE
BRANCH CERROR EXIT) IF NOT EQUAL
CONTINUE UNTIL AREA CHECKED

CMPLP:
CMPA
BNE
LEAY
BNE
*

*NO
*
CLC
RTS
*

ERRORS

FOUND,

CLEAR

CARRY

AND

INDICATE

EXIT
NO

ERRORS

6G
*ERROR
*

RAM test (RAMTST)
FOUND,

SET

CARRY,

221
MOVE

POINTER

BACK,

AND

EXIT

EREXIT:

+

SEC
LEAX
RTS

~1,X

SAMPLE

EXECUTION

INDICATE
POINT TO

AN ERROR
BYTE CONTAINING

ERROR

SC6G:
*

*TEST RAM FROM 2000 HEX THROUGH 300F HEX
*
SIZE OF AREA = 1010 HEX BYTES
*
LDY
#$2000
GET BASE ADDRESS OF TEST AREA
LDX
#$1010
GET SIZE OF AREA IN BYTES
PSHS
X,Y
SAVE PARAMETERS IN STACK
JSR
RAMTST
TEST MEMORY
*CARRY FLAG SHOULD BE O
END

Assembly language subroutines for the 6809

222

6H

Jump table

(JTAB)

Transfers control to an address selected from a table according to an
index. The addresses are stored in the usual 6809 format (more significant byte first), starting at address JMPTBL. The size of the table
(number of addresses) is a constant LENSUB, which must be less than
or equal to 128. If the index is greater than or equal to LENSUB, the
program returns control immediately with the Carry flag set to 1.

Procedure The program first checks if the index is greater than or
equal to the size of the table (LENSUB). If it is, the program returns
control with the Carry flag set. If it is not, the program obtains the
starting address of the appropriate subroutine from the table and jumps
to it. The result is like an indexed JSR instruction with range checking
and automatic accounting for the 16-bit length of addresses.

Entry conditions
Index in A

Exit conditions

If (A) is greater than LENSUB, an immediate return with Carry = 1.
Otherwise, control is transferred to appropriate subroutine as if an
indexed call had been performed. The return address remains at the top
of the stack.

Example

Data:

LENSUB (size of subroutine table) = 03
Table consists of addresses SUBO, SUB1, and SUB2

Result:

Index = (A) = 02
Control transferred to address SUB2 (PC = SUB2)

Registers used

A, CC, X

6H

Jump table (JTAB)

Execution time
actual subroutine.

223

17 cycles besides the time required to execute the

Program size 13 bytes plus 2 x LENSUB bytes for the table of
starting addresses, where LENSUB is the number of subroutines.

Data memory required

None

Special case Entry with an index greater than or equal to LENSUB
causes an immediate exit with the Carry flag set to 1
+

Title

Jump

Name:

JTAB

Purpose:

Given

an

index,

that

index

in

bg

Table

Entry:

Register

Exit:

If

jump
a

to

Registers

Used:

subroutine

with

A is the subroutine number (0 to
LENSUB-1, the number of subroutines)
LENSUB must be less than or equal to
128.

the routine number
execute
the routine
else

Carry

the

table

flag

is

valid

execution

time

equals

then

1

A,CC,X

Time:

17

cycles

Size:

Program

plus
13

bytes

plus

size

of

of

subroutine

table

(2*LENSUB)

OFt
HH
FF
HE
HF
FE
F
+

EXIT
THAT

WITH CARRY SET IF ROUTINE NUMBER
IS, IF IT IS TOO LARGE FOR TABLE

IS INVALID
(>LENSUB -

1)

+£ TAB:
—
+
£

CMPA
BCC

#LENSUB
EREXIT

COMPARE ROUTINE NUMBER, TABLE LENGTH
BRANCH CEXIT) IF ROUTINE NUMBER TOO
* LARGE

INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
TO IT
&€
+

CONTROL

224

Assembly language subroutines for the 6809
ASLA
LDX
JMP

*
*
*
EREXIT:

ERROR

DOUBLE INDEX FOR WORD-LENGTH ENTRIES
GET BASE ADDRESS OF JUMP TABLE
JUMP INDIRECTLY TO SUBROUTINE

#JMPTBL
[A,X]
EXIT

-

EXIT

WITH

SEC
RTS
LENSUB

CARRY

SET

INDICATE

BAD

EQU

3

NUMBER

OF

FDB
FDB
FDB

SUBO
SUB1
SUB2

ROUTINE
ROUTINE
ROUTINE

0
1
2

ROUTINE

NUMBER

SUBROUTINES

IN

TABLE

*

*JUMP TABLE
*
JMPTBL:

*

*THREE

TEST

SUBROUTINES

FOR

JUMP

TABLE

*

SUBO:
#1

TEST

ROUTINE

O SETS

(A)

Hi

—_

LDA
RTS

#2

TEST

ROUTINE

1 SETS

(CA)

I

nN

LDA
RTS

#3

TEST

ROUTINE

2 SETS

(A)

It

o|

LDA
RTS

SUB1:

SUB2:

+

*
*PROGRAM
SC6H:

SAMPLE

EXECUTION

SECTION
CLRA
JSR
LDA
JSR
LDA
JSR

JTAB
#1
JTAB
#2
J TAB

LDA

#3

JSR

JTAB

BRA

SC6H

END

EXECUTE ROUTINE 0
AFTER EXECUTION,
(CA) HI
EXECUTE ROUTINE 1
AFTER EXECUTION, (A) = 2
EXECUTE ROUTINE 2
AFTER EXECUTION, (A) = 3
EXECUTE ROUTINE 3
AFTER EXECUTION, CARRY = 1
*INDICATING BAD ROUTINE NUMBER
LOOP FOR MORE TESTS
a,

Data structure
manipulation

7A Queue manager
(INITQ, INSRTQ, REMOVQ)
Manages a queue of 16-bit words on a first-in, first-out basis. The queue
may contain up to 255 word-length elements plus an 8-byte header.
Consists of the following routines:

1. INITOQ starts the queue’s head and tail pointers at the base address
of its data area, sets the queue’s length to 0, and sets its end pointer to
just beyond the end of the data area.
2. INSRTQ inserts an element at the tail of the queue if there is room
for it.
3. REMOVQ removes an element from the head of the queue if one is
available.

These routines assume a data area of fixed length. The actual queue may
occupy any part of it. If either the head or the tail reaches the physical
end of the area, the routine simply sets it back to the base address, thus
providing wraparound.
The queue header contains the following information:
1. Length of data area in words. This is a single byte specifying the
maximum number of elements the queue can hold.
2.

Queue length (number of elements currently in the queue)

3.

Head pointer (address of oldest element in queue)
225

226

Assembly language subroutines for the 6809

4.

Tail pointer (address at which next entry will be placed)

5.

End pointer (address just beyond the end of the data area).

Note that the first two items are byte-length and the last three are
word-length.

Procedures

1. INITQ sets the head and tail pointers to the base address of the data
area, establishes the length of the data area, sets the queue’s length (a
single byte) to 0, and sets the end pointer to the address just beyond the
end of the data area.
2. INSRTQ checks whether the queue already occupies the entire data
area. If so, it sets the Carry flag to indicate an overflow. If not, it inserts
the element at the tail and increases the tail pointer. If the tail pointer
has gone beyond the end of the data area, it sets it back to the base
address.

3. REMOV0O checks whether the queue is empty. If so, it sets the
Carry flag to indicate an underflow. If not, it removes the element from
the head and increases the head pointer. If the head pointer has gone
beyond the end of the data area, it sets it back to the base address.

The net result of a sequence of INSRTQs and REMOVQs is that the
head ‘chases’ the tail across the data area. The occupied part of the data
area Starts at the head and ends just before the tail.

Entry conditions

1. INITQ
Base address of queue in register X
Length of data area in words in register A

2. INSRTQ
Base address of queue in register X
Element to be inserted in register U
3. REMOVQ
Base address of queue in register X

7A

Queue manager (INITQ, INSRTQ, REMOVQ)

227

Exit conditions

1. INITQ
Head pointer and tail pointer both set to base address of data area,
length of data area set to specified value, queue length set to 0, and end
pointer set to address just beyond the end of the data area.

2. INSRTQ
Element inserted into queue, queue length increased by 1, and tail
pointer adjusted if the data area is not full; otherwise, Carry = 1.

3. REMOVQ
Element removed from queue in register X, queue length decreased by
1, and head pointer adjusted if queue had an element: otherwise, Carry
= 1.
eee
Example

A typical sequence of queue operations would proceed as follows:

1. Initialize the queue. Call INITQ to set the head and tail pointers to
the data area’s base address, the queue length to 0, and the end pointer
to the address just beyond the end of the data area.
2. Insert an element into the queue. Call INSRTO to insert the element, increase the tail pointer by 2, and increase the queue length by 1.

3.

Insert another element into the queue. Call INSRTO again to insert

the element, increase the tail pointer by 2, and increase the queue

length by 1.

4. Remove an element from the queue. Call REMOVQ to remove an
element, increase the head pointer by 2, and decrease the queue length
by 1. Since the queue is organized on a first-in, first-out basis, the
element removed is the first one inserted.
ee
e

Registers used

1. INITQ: A, CC, U,X

2. INSRTQ: A, CC, X,Y
3. REMOVOQ:
A. CC,U, X,Y

228

Assembly language subroutines for the 6809

Execution time
1.

INITQ: 65 cycles

2. INSRTQ:
necessary
3.

REMOVO:

65 or 70 cycles, depending on whether wraparound is
66 or 71 cycles, depending on whether wraparound is

necessary

Program size

79 bytes

Data memory required
Title
Name:

None

Queue Manager
INITQ,
INSRTQ,

REMOVQ

+

Purpose:

This program consists of three
subroutines that manage a queue.
INITQ initializes the empty queue.
INSRTQ inserts a 16-bit element into
the queue.
REMOVQ removes a 16-bit element from
the queue.

Entry:

INITQ
Base
Size

address
of data

of queue in X
area in words in

A

INSRTQ

Base address of queue in X
Element to be inserted in U
REMOVQ
Base
Exit:

address

of

queue

in

X

INITQ
Head pointer = Base address of data area
Tail pointer = Base address of data area
Queue length = 0
End pointer = Base address of data area +
2 * Size of data area in words

INSRTQ
If queue Length is not buffer size,
Element added to queue
Tail pointer = Tail pointer + 2
Queue length = Queue length + 1
Carry = 0
OHHH
OF
Ot
OO
tO
ee
+

7A

Queue manager (INITQ, INSRTQ, REMOVQ)
else

Carry

=

1

REMOVQ
If queue length is not zero,
Element removed from queue in X
Head pointer = Head pointer + 2
Queue length = Queue length - 1
Carry = 0
else Carry = 1
Registers

Time:

Size:

Us ed:

INITQ
A,B,CC,U,X
INSRTQ
A,CC,X,Y
REMOVQ
A,CC,U,X,Y
INITQ
65 cycles
INSRTQ
65 or 70 cycles, depending
wraparound is necessary
REMOVQ
66 or 71 cycles, depending
wraparound is necessary

Program

79

on

whether

on

whether

bytes

OK
KH
FH
HF
+
FF
FH
F

*

*INITIALIZE AN EMPTY QUEUE
*HEADER CONTAINS:
*
1) SIZE OF DATA AREA IN WORDS
*
2) QUEUE LENGTH (1 BYTE)
*
3) HEAD POINTER (2 BYTES)
*
4) TAIL POINTER (2 BYTES)
*
5) END POINTER (2 BYTES)
*
INITQ:

(1

BYTE)

*SET SIZE OF DATA AREA TO SPECIFIED VALUE
*SET QUEUE LENGTH TO ZERO
*
LEAU
8 ,X
POINT TO START OF DATA AREA
STA
Xt
SET SIZE OF DATA AREA IN WORDS
CLR
7Xt+
QUEUE LENGTH = ZERO
*
*INITIALIZ E HEAD AND TAIL POINTERS TO START OF DATA AREA
*
STU
2Xt++
HEAD POINTER
START OF DATA AREA
STU
eXt++
TAIL POINTER = START OF DATA AREA
*
*INITIALIZ E END POINTER TO ADDRESS JUST BEYOND DATA AREA
*
TFR
A,B
EXTEND SIZE OF DATA AREA TO 16 BITS
CLRA

229

230

Assembly language subroutines for the 6809
ASLB
ROLA
LEAU
STU

MULTIPLY SIZE OF DATA AREA TIMES 2
SINCE SIZE IS IN WORDS
POINT JUST BEYOND END OF DATA AREA
END POINTER = ADDRESS JUST BEYOND
* END OF DATA AREA

D,U
7X

RTS
*

*INSERT
*
INSRTQ:

AN

ELEMENT

INTO

A QUEUE

*

*EXIT
*
LDA
CMPA
SEC
BEQ

WITH

CARRY

SET

IF

1,X
7X

DATA

AREA

IS

FULL

GET QUEUE LENGTH
COMPARE TO SIZE OF DATA AREA
INDICATE DATA AREA FULL
BRANCH CEXIT) IF DATA AREA IS

EXITIS

FULL

*

*DATA AREA NOT FULL, SO STORE ELEMENT AT TAIL
*ADD 1 TO QUEUE LENGTH
*
LDY
4,X
GET TAIL POINTER
STU
rv
INSERT ELEMENT AT TAIL
INC
1,X
ADD 1 TO QUEUE LENGTH
*
*INCREASE TAIL POINTER BY ONE 16-BIT ELEMENT (2 BYTES)
*IF TAIL POINTER HAS REACHED END OF DATA AREA, SET IT
*
BACK TO BASE ADDRESS
*
LEAY
2,Y
MOVE TAIL POINTER UP ONE ELEMENT
CMPY
6,X
COMPARE TO END OF DATA AREA
BNE
STORTP
BRANCH IF TAIL NOT AT END OF DATA
* AREA
LEAY
8 ,X
OTHERWISE, MOVE TAIL POINTER BACK
* BASE ADDRESS OF DATA AREA
STORTP:

STY
CLC

4,X

SAVE UPDATED TAIL
CLEAR CARRY (GOOD

POINTER
EXIT)

EXITIS:

RTS
*

*REMOVE
*
REMOVQ:

AN

ELEMENT

FROM

A QUEUE

*

*EXIT
*
LDA
SEC
BEQ

WITH

CARRY

SET

1,X
EXITRQ@

IF

QUEUE

IS

EMPTY

GET QUEUE LENGTH
INDICATE QUEUE EMPTY
BRANCH CEXIT) IF QUEUE

*&

*QUEUE NOT EMPTY, SO
*REMOVE ELEMENT FROM
*

SUBTRACT 1 FROM
HEAD OF QUEUE

QUEUE

LENGTH

IS

EMPTY

TO

7A

Queue manager (IN/ITQ, INSRTQ, REMOVQ)

DEC
LDU
LDY
*

,
Nm
— ,

X
X

SUBTRACT 1 FROM QUEUE
GET HEAD POINTER
GET ELEMENT FROM HEAD

,U

231

LENGTH
OF

QUEUE

*MOVE HEAD POINTER UP ONE 16-BIT ELEMENT (2 BYTES)
*IF HEAD POINTER HAS REACHED END OF DATA AREA, SET IT BACK
*
TO BASE ADDRESS OF DATA AREA
*
LEAU
2,U
MOVE HEAD POINTER UP ONE ELEMENT
CMPU
6 ,X
COMPARE TO END OF DATA AREA
BNE
STORHP
BRANCH IF NOT AT END OF DATA AREA
LEAU
8 ,X
OTHERWISE, MOVE HEAD POINTER BACK
* TO BASE ADDRESS OF DATA AREA

STORHP:
STU
TFR
CLC

SAVE NEW HEAD POINTER
MOVE ELEMENT TO X
INDICATE QUEUE NON-EMPTY,
* ELEMENT FOUND

< .~ <<
™

EXITRQ:
RTS

SAMPLE

EXIT, CARRY INDICATES WHETHER
* ELEMENT WAS FOUND (O IF SO,
* 1 IF NOT)

EXECUTION

Om CVA:
+

*

*INITIALIZE EMPTY
*
LDA
#5
LDX
JSR
*
*INSERT
*
LDU
LDX
JSR
LDU
LDX
JSR
*
*REMOVE

QUEUE
DATA AREA HAS ROOM FOR 5 WORD-LENGTH
* ELEMENTS
GET BASE ADDRESS OF QUEUE BUFFER
INITIALIZE QUEUE

#QUEUE
INITQ
ELEMENTS

INTO

QUEUE

#S$AAAA
#QUEUE
INSRTQ
#$BBBB
#QUEUE
INSRTQ
ELEMENT

ELEMENT TO BE INSERTED IS
GET BASE ADDRESS OF QUEUE
INSERT ELEMENT INTO QUEUE
ELEMENT TO BE INSERTED IS
GET BASE ADDRESS OF QUEUE
INSERT ELEMENT INTO QUEUE
FROM

AAAA

BBBB

QUEUE

*

*DATA

LDX
JSR

#QUEUE
REMOVQ

BRA

SC7A

GET BASE ADDRESS OF QUEUE
REMOVE ELEMENT FROM QUEUE
* (X) = SAAAA CFIRST ELEMENT
* INSERTED)
REPEAT TEST

232

Assembly language subroutines for the 6809

QUEUE

RMB

18

QUEUE BUFFER CONSISTS OF AN 8 BYTE
* HEADER FOLLOWED BY 10 BYTES FOR
* DATA (FIVE WORD-LENGTH ELEMENTS)

7B

Stack manager (INITST, PUSH, POP)

233

7B Stack manager
(INITST, PUSH, POP)
Manages a stack of 16-bit words on afirst-in, last-out basis. The stack
can contain up to 32 767 elements. Consists of the following routines:
1. INITST initializes the stack header, consisting of the pointer and its
upper and lower bounds.
2.

PUSH inserts an element into the stack if there is room for it.

3.

POP removes an element from the stack if one is available.

Procedures

1. INITST sets the stack pointer and its lower bound to the base
address of the stack’s data area. It sets the upper bound to the address
just beyond the end of the data area.

2. PUSH checks whether increasing the stack pointer by 2 will make it
exceed its upper bound. If so, it sets the Carry flag. If not, it inserts the
element at the stack pointer, increases the stack pointer by 2, and clears
the Carry flag.

3. POP checks whether decreasing the stack pointer by 2 will make it
less than its lower bound. If so, it sets the Carry flag. If not, it decreases
the stack pointer by 2, removes the element, and clears the Carry flag.
Note that the stack grows toward higher addresses, unlike the 6809’s
hardware and user stacks, which grow toward lower addresses. Like the
6809’s own stack pointers, this pointer always contains the next available memory address, not the last occupied address.

Entry conditions

1. INITST
Base address of stack in register X
Size of stack data area in words in register D
2. PUSH
Base address of stack in register X
Element in register D
3. POP
Base address of stack in register X

234

Assembly language subroutines for the 6809
Exit conditions

1. INITST
Stack header set up with:
Stack pointer = Base address of stack’s data area
Lower bound = Base address of stack’s data area
Upper bound = Address just beyond end of stack’s data area

2. PUSH
Element inserted into stack and stack pointer increased if there is room
in the data area; otherwise, Carry = 1, indicating an overflow.

3. POP
Element removed from stack in register X and stack pointer decreased if
stack was not empty; otherwise, Carry = 1, indicating an underflow.

Example

A typical sequence of stack operations proceeds as follows:
1. Initialize the empty stack with INITST. This involves setting the
stack pointer and the lower bound to the base address of the stack’s data
area, and the upper bound to the address immediately beyond the end
of the data area.
2. Insert an element into the stack. Call PUSH to put an element at
the top of the stack and increase the stack pointer by 2.

3. Insert another element into the stack. Call PUSH to put an element
at the top of the stack and increase the stack pointer by 2.
4.

Remove an element from the stack. Call POP to decrease the stack

pointer by 2 and remove an element from the top of the stack. Since the
stack is organized onalast-in, first-out basis, the element removed is the
latest one inserted.

Registers used

1.

INITST: A, B, CC, U, X

2.

PUSH: CC, U (D and X are unchanged)

3.

POP: CC, U, xX

7B

Stack manager (INITST, PUSH, POP)

235

Execution time:
1.

INITST: 43 cycles

2.

PUSH: 41 cycles

3.

POP: 36 cycles

Program size
1.

INITST: 13 bytes

2.

PUSH: 19 bytes

3.

POP: 14 bytes

Data memory required

None

Title

Stack

Name:

INITST,

Purpose:

This program consists of three
subroutines that manage a stack.

Manager
PUSH,

POP

+

INITST sets up the stack pointer and
its upper and Lower bounds
PUSH inserts a 16-bit element into
the stack.
POP removes a 16-bit element from
the stack.
Entry:

Exit:

INITST
Base address of stack in X
Size of stack data area in words
PUSH
Base address of stack in X
Element in D
POP
Base address of stack in X

D

INITST
Stack header set up with:
Stack pointer = base address of stack
data area
Lower bound = base address of stack
data

area

Upper bound = address
of stack data area

HH
HN
FF
HE
HF
eH
&
+
¢
FF
H
F

in

PUSH
If stack

pointer

is

below

just

beyond

upper

end

bound,

236

Assembly language subroutines for the 6809
Element added
Stack pointer
Carry = 0
else Carry = 1

to stack
= Stack pointer

+

2

POP
If

stack pointer is at or above
Element removed from stack in
Stack pointer = Stack pointer
Carry = 0
else Carry = 1
Registers

Used:

lower
X
- 2

bound,

INITST
A,B,CC,U,X
PUSH
CC ,U

POP

CC,U,X

Time:

INITST
43 cycles
PUSH
41 cycles

POP

36
Size:

cycles

Program

46

bytes

HH
KF
HF
+
&

*

*INITIALIZE AN EMPTY STACK
*HEADER CONTAINS:
*
1) STACK POINTER (2 BYTES)
*
2) LOWER BOUND (2 BYTES)
*
3) UPPER BOUND (2 BYTES)
*
*

*STACK
*LOWER
*

POINTER
BOUND =

= BASE ADDRESS OF STACK DATA AREA
BASE ADDRESS OF STACK DATA AREA

INITST:

LEAU
STU
STU

6 ,X
eXt++
eX++

GET BASE ADDRESS OF STACK DATA AREA
STORE IT AS INITIAL STACK POINTER
STORE IT AS LOWER BOUND ALSO

*

*UPPER
*
ASLB
RORA
LEAU

BOUND

=

ADDRESS

7X

A 16-BIT

ELEMENT

*

*INSERT

BEYOND

END

OF

STACK

DATA

AREA

MULTIPLY SIZE OF DATA AREA BY 2
SINCE SIZE IS IN WORDS
FIND ADDRESS JUST BEYOND END OF
* STACK DATA AREA
STORE IT AS UPPER BOUND

D,U

STU
RTS

JUST

INTO

A STACK

7B

Stack manager (INITST, PUSH, POP)

237

PUSH:
*

*EXIT
*
LDU
LEAU
CMPU
BCC

INDICATING

OVERFLOW

7X
2,U
4,X
OVRFLW

(CARRY

SET)

IF

STACK

IS

FULL

GET STACK POINTER
INCREMENT STACK POINTER BY 2
COMPARE TO UPPER BOUND
BRANCH IF STACK POINTER AT OR
* ABOVE UPPER BOUND
NOTE: THIS COMPARISON HANDLES
SITUATIONS IN WHICH THE STACK
POINTER HAS BECOME MISALIGNED OR
+ GONE
+
OUTSIDE ITS NORMAL RANGE.

*

*NO OVERFLOW - INSERT
*UPDATE STACK POINTER
*

STD
STU
CLC

ELEMENT

-2,U
7X

INTO

STACK

INSERT ELEMENT INTO STACK
SAVE INCREMENTED STACK POINTER
CLEAR CARRY TO INDICATE INSERTION
* WORKED

RTS
*

*OVERFLOW
*

-

SET

CARRY

AND

EXIT

OVRFLW:
SEC
RTS

SET

CARRY

TO

INDICATE

(CARRY

SET)

IF

OVERFLOW

*

*REMOVE
*

A 16-BIT

ELEMENT

FROM

A STACK

POP:
*

*EXIT
*
LDU
LEAU
CMPU
BCS

INDICATING

UNDERFLOW

7X
-2,U
2,X
EXITSP

UNDERFLOW
7X
7U

-

REMOVE

ELEMENT

*

SAMPLE

EXIT

EXECUTION

AND

DECREASE

SAVE UPDATED STACK
REMOVE ELEMENT

EXITSP:
RTS

IS

EMPTY

GET STACK POINTER
DECREASE STACK POINTER BY 2
COMPARE TO LOWER BOUND
BRANCH CEXIT) IF BELOW LOWER BOUND
* NOTE: THIS COMPARISON HANDLES
* SITUATIONS IN WHICH THE STACK
* POINTER HAS BECOME MISALIGNED OR
* GONE OUTSIDE ITS NORMAL RANGE.

*
*NO
*
STU
LDX

STACK

STACK
POINTER

POINTER

238

Assembly language subroutines for the 6809

SC7B:
*

*INITIALIZE

EMPTY

STACK

*

LDX
LDD
JSR

GET BASE ADDRESS OF STACK
GET SIZE OF STACK DATA AREA
INITIALIZE STACK HEADER

#STACK
#STKSZ
INITST

IN

WORDS

*

*PUT
*
LDD
LDX
JSR

ELEMENT

1 IN

STACK

ELEM1
#STACK
PUSH

GET
GET
PUT

ELEMENT 1
BASE ADDRESS
ELEMENT 1 IN

OF STACK
STACK

AREA

GET
GET
PUT

ELEMENT 2
BASE ADDRESS
ELEMENT 2 IN

OF STACK
STACK

AREA

*

*PUT
*
LDD
LDX
JSR

ELEMENT

2 IN

STACK

ELEM2
#STACK
PUSH

*

*REMOVE

ELEMENT

FROM

STACK

*

LDX
JSR

#STACK
POP

BRA

SC7B

STACK

RMB

16

ELEM1
ELEM2
STKSZ

RMB
RMB
EQU

2
2
5

GET BASE ADDRESS OF STACK
REMOVE ELEMENT FROM STACK TO X
* X NOW CONTAINS ELEMENT 2
* SINCE STACK IS ORGANIZED ON A
* LAST-IN, FIRST-OUT BASIS
LOOP FOR MORE TESTS

*DATA

END

STACK HAS ROOM FOR 6-BYTE HEADER
* AND 10 BYTES OF DATA (5 WORD* LENGTH ELEMENTS)
2 BYTE ELEMENT
2 BYTE ELEMENT
SIZE OF STACK DATA AREA IN WORDS

7C

Singly linked list manager (INLST, RMLST)

239

7C_ Singly linked list manager
(INLST, RMLST)
Manages a linked list of elements, each of which has the address of the
next element (or 0 if there is no next element) in its first two bytes.
Consists of the following routines:
1. INLST inserts an element into the list, given the element it follows.
2. RMLST removes an element from the list (if one exists), given the
element it follows.
Note that you can add or remove elements anywhere in the linked list.
All you need is the address of the preceding element to provide the
linkage.

Procedures

1.

INLST obtains the link from the preceding element, sets that ele-

ment’s link to the new element, and sets the new element’s link to the

one from the preceding element.

2. RMLST first determines if there is a following element. If not, it
sets the Carry flag. If so, it obtains that element’s link and puts it in the
current element. This unlinks the element and removes it from the list.

Entry conditions

1. INLST
Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address
More significant byte of base address of preceding element
Less significant byte of base address of preceding element
More significant byte of base address of new element
Less significant byte of base address of new element

2. RMLST
Base address of preceding element in X

240

Assembly language subroutines for the 6809
Exit conditions

1. INLST
Element inserted into list with preceding element linked to it. It is
linked to the element that had been linked to the preceding element.
2.

RMLST

If there is a following element, it is removed from the list, its base

address is placed in register X, and the Carry flag is cleared.

Otherwise, register X = 0 and Carry flag = 1.

Example

A typical sequence of operations on a linked list is:
1.

Initialize the empty list by setting the link in the header to zero.

2. Insert an element into the list by using the base address of the
header as the previous element.
3. Insert another element into the list by using the base address of the
element just inserted as the previous element.

4. Remove the first element from the linked list by using the base
address of the header as the previous element. Note that we can remove
either element from the list by supplying the proper previous element.

Registers used:

1.

INLST: All

2.

RMLST: CC, D, U, X

Execution time:

1.

INLST: 29 cycles

2.

RMLST: 35 cycles

7C

Singly linked list manager (INLST, RMLST)

241

Program size

1.

INLST: 10 bytes

2.

RMLST: 15 bytes

Data memory required
Title
Name:

Singly
INLST,

Purpose:

This
that

None
eee

Linked
RMLST

Manager

program consists of two subroutines
manage a singly linked List.

INLST inserts
list.
RMLST removes
list.
Entry:

List

an

element

into

the

Linked

an

element

from

the

Linked

INLST

TOP OF STACK
High byte of return address
Low byte of return address
High byte of previous element's address
Low byte of previous element's address
High byte of entry address
Low byte of entry address
RMLST

Base

address
register X

Exit:

of

preceding

element

INLST

Element added to List
RMLST
If following element exists,
its base address is in register
Carry = 0
else
register X = 0
Carry = 1
Registers

Time:

Used:

INLST
ALL
RMLST
CC,D,U,X
INLST
29 cycles
RMLST

35
Size:
OH
He
HE
HF
FH
t+
+
FF
FH
Fe
HH
HH
FF
H
F
H

in

|

rycles

Program

25

bytes

X

242

Assembly language subroutines for the 6809

INSERT

AN

ELEMENT

INTO

A SINGLY

LINKED

LIST

INLST:
*
*UPDATE LINKS TO INCLUDE NEW ELEMENT
*LINK PREVIOUS ELEMENT TO NEW ELEMENT
*LINK NEW ELEMENT TO ELEMENT FORMERLY LINKED TO
*
PREVIOUS ELEMENT
*
PULS
X,Y,U
GET ELEMENTS, RETURN ADDRESS
LDD
rv
GET LINK FROM PREVIOUS ELEMENT
STD
7U
STORE LINK IN NEW ELEMENT
STU
rY
STORE NEW ELEMENT AS LINK IN
* PREVIOUS ELEMENT
*
*NOTE: IF LINKS ARE NOT IN FIRST TWO BYTES OF ELEMENTS,
*
LINK OFFSET IN LAST 3 INSTRUCTIONS
*

PUT

*

*EXIT
*
JMP

REMOVE

7X

AN

ELEMENT

EXIT

FROM

TO

A SINGLY

RETURN

ADDRESS

LINKED

LIST

RMLST:
*

*EXIT INDICATING FAILURE (CARRY SET) IF NO FOLLOWING ELEMENT
*
LDU
7X
GET LINK TO FOLLOWING ELEMENT
SEC
INDICATE NO ELEMENT FOUND
BEQ
RMEXIT
BRANCH IF NO ELEMENT FOUND
*
*UNLINK REMOVED ELEMENT BY TRANSFERRING ITS LINK TO
*
PREVIOUS ELEMENT
*NOTE: IF LINKS NOT IN FIRST TWO BYTES OF ELEMENTS, PUT
*
LINK OFFSET IN STATEMENTS
*
LDD
,U
GET LINK FROM REMOVED ELEMENT
STD
7X
MOVE IT TO PREVIOUS ELEMENT
CLC
INDICATE ELEMENT FOUND
*
*EXIT
*
RMEXIT:
TFR

U,X

RTS

SAMPLE
&
+

EXECUTION

EXIT WITH BASE ADDRESS OF REMOVED
* ELEMENT OR O IN X
CARRY = O IF ELEMENT FOUND, 1
* IF NOT

7C

Singly linked list manager (INLST, RMLST)

243

SC7C:
*

*INITIALIZE EMPTY LINKED LIST
*
LDD
#0
CLEAR LINKED LIST HEADER
STD
LLHDR
O INDICATES NO NEXT ELEMENT
x
*INSERT AN ELEMENT INTO LINKED LIST
*
LDY
LDX
PSHS
JSR

#ELEM1
#LLHDR
X,Y
INLST

GET BASE ADDRESS OF ELEMENT 1
GET PREVIOUS ELEMENT CHEADER)
SAVE PARAMETERS IN STACK
INSERT ELEMENT INTO LIST

*

*INSERT
*

LDY
LDX
PSHS
JSR

ANOTHER

ELEMENT

#ELEM2
#ELEM1
X,Y
INLST

INTO

LINKED

LIST

GET BASE ADDRESS OF ELEMENT
GET PREVIOUS ELEMENT
SAVE PARAMETERS IN STACK
INSERT ELEMENT INTO LIST

2

*

*REMOVE
*
LDX
JSR
*
*
*
*
BRA

FIRST

ELEMENT

#LLHDR
RMLST

FROM

LINKED

LIST

SC7C

GET PREVIOUS ELEMENT
REMOVE ELEMENT FROM LIST
END UP WITH HEADER LINKED TO
SECOND ELEMENT
X CONTAINS BASE ADDRESS OF
FIRST ELEMENT
REPEAT TEST

2
2
2

LINKED LIST
ELEMENT 1 ELEMENT 2 -

*DATA

LLHDR
ELEM1
ELEM2

RMB
RMB
RMB
END

HEADER
HEADER
HEADER

(LINK)
(LINK)

ONLY
ONLY

244

Assembly language subroutines for the 6809

7D Doubly linked list manager
(INDLST, RMDLST)
Manages a doubly linked list of elements. Each element contains the
address of the next element (or 0 if there is no next element) in its first
two bytes. It contains the address of the preceding element (or0 if there
is no preceding element) in its next two bytes. Consists of the following
routines:

1. INDLST inserts an element into the list, linking it to the preceding
and following elements.
2. RMDLST first determines if there 1s a following element. If so, it
obtains its address and removes its links from the preceding and following elements.

As with a singly linked list, you can add or remove elements from
anywhere in the list. All you need is the address of the preceding
element to provide the proper linkage.

Procedures:

1. INDLST first obtains the forward link from the preceding element
(i.e. the address of the following element). It then changes the links as
follows:

(a) The new element becomes the forward link of the preceding
element.
(b) The preceding element becomes the backward link of the new
element.
(c) The old forward link from the preceding element becomes the
forward link of the new element.
(d) The new element becomes the backward link of the following
element.
|
2. RMDLST first determines if there is a following element. If not, it
sets the Carry flag. If so, it obtains that element’s forward link (the next
element) and makes it the forward link of the preceding element. It also
makes the preceding element into the backward link of the next element. This unlinks the element, removing it from the list.

7D

Doubly linked list manager (INDLST, RMDLST)

245

Entry conditions

1. INDLST
Order in stack (starting from the top)
More significant byte of return address
Less significant byte of return address

More significant byte of base address of preceding element
Less significant byte of base address of preceding element
More significant byte of base address of new element
Less significant byte of base address of new element

2. RMDLST
Base address of preceding element in register X

Exit conditions

1. INDLST
Element added to list with preceding and succeeding elements linked to
it.
2. RMDLST
If there is a following element, it is removed from the list, its base
address is placed in register X, and the Carry flag is cleared.
Otherwise, register 7x = 0 and Carry flag = 1.

Example

A typical sequence of operations on a doubly linked list is:
1.

Initialize the empty list by setting both links in the header to zero.

2. Insert an element into the list by using the base address of the
header as the previous element.
3. Insert another element into the list by using the base address of the
element just added as the previous element.
4. Remove the first element from the list by using the base address of
the header as the previous element. Note that we can remove either
element from the list by supplying the proper previous element.

246

Assembly language subroutines for the 6809
Registers used

1.

INDLST: All

2.

RMDLST: CC, U, X, Y

Execution time

1.

INDLST: 53 cycles

2.

RMDLST: 44 cycles

Program size

1.

INDLST: 17 bytes

2.

RMDLST: 18 bytes

Data memory required

None

Title

Doubly

Linked

Name:

INDLST,

RMDLST

List

Purpose:

This
that

Manager

+

program consists of two subroutines
manage a doubly Linked List.

INDLST inserts an element
Linked list.
RMDLST removes an element
doubly linked list.
Entry:

INDLST
TOP OF

into

the

from

the

doubly

STACK

High byte of return address
Low byte of return address
High byte of previous element's address
Low byte of previous element's address
High byte of entry address
Low byte of entry address
RMDLST

Base address
register X
Exit:

of

preceding

element

INDLST

Element

inserted

into

List

RMDLST

If

following

its
HH
HF
KF
SH
F
+H+

base

Carry

=

element

address
0

exists,

is

in

register
X

in

7D

Doubly linked list manager (INDLST, RMDLST)
else
register X =
Carry = 1

Registers

Used:

Time:

247

0

INDLST
ALL
RMDLST

INDLST

53

cycles

RMDLST

44
Size:

cycles

Program

35

bytes

HK
HF
+F

*
*

INSERT

AN

ELEMENT

INTO

A DOUBLY

LINKED

LIST

*

INDLST:
*
*UPDATE LINKS TO INCLUDE NEW ELEMENT
*LINK PREVIOUS ELEMENT TO NEW ELEMENT
*LINK NEW ELEMENT TO PREVIOUS AND FOLLOWING
*LINK FOLLOWING ELEMENT TO NEW ELEMENT
*

PULS
LDU
STY

D,X,Y
2,X
2,X

STX

7X

STU

2,Y

STY

,U

*NOTE:
*
PUT

IF LINKS ARE
LINK OFFSETS

*EXIT
*
PSHS
RTS

ELEMENTS

GET RETURN ADDRESS, ELEMENTS
GET FOLLOWING ELEMENT
MAKE NEW ELEMENT INTO PREVIOUS
* ELEMENT'S FORWARD LINK
MAKE PREVIOUS ELEMENT INTO NEW
* ELEMENT'S BACKWARD LINK
MAKE FOLLOWING ELEMENT INTO NEW
* ELEMENT'S FORWARD LINK
MAKE NEW ELEMENT INTO FOLLOWING
* ELEMENT'S BACKWARD LINK
NOT IN FIRST FOUR BYTES
IN LAST 5 INSTRUCTIONS

D

PUT RETURN
EXIT

ADDRESS

OF

ELEMENTS,

BACK

IN

STACK

*
*

REMOVE

AN

ELEMENT

FROM

A DOUBLY

LINKED

FAILURE

(CARRY

SET)

LIST

*

RMDLST:
*

*EXIT
*
LDY
SEC

INDICATING
2,X

GET LINK
INDICATE

TO
NO

IF

NO

FOLLOWING

FOLLOWING ELEMENT
ELEMENT FOUND

ELEMENT

248

Assembly language subroutines for the 6809
BEQ
RMDXIT
BRANCH IF NO ELEMENT FOUND
*
*ELEMENT EXISTS SO UNLINK IT BY TRANSFERRING ITS
*
FORWARD LINK TO PREVIOUS ELEMENT AND ITS BACKWARD
*
LINK TO FOLLOWING ELEMENT
*NOTE: IF LINKS ARE NOT IN THE FIRST FOUR BYTES OF THE
*
ELEMENTS, PUT CORRECT LINK OFFSETS IN STATEMENTS
*
LDU
STU

2,Y
2,X

STX

U

GeT FOLLOWING
ELEMENT
MAKE FOLLOWING
ELEMENT
INTO
* LINK OF PRECEDING
ELEMENT
MAKE PRECEDING
ELEMENT
INTO
* LINK OF FOLLOWING
ELEMENT
INDICATE
ELEMENT
FOUND

CLC

FORWARD
BACKWARD

*

*EXIT
*

RMDXIT:
TFR

Y,X

EXIT WITH BASE ADDRESS OF REMOVED
* ELEMENT
OR O IN X
CARRY = 0 IF ELEMENT
FOUND,
1 IF NOT

RTS

*

*

SAMPLE

EXECUTION

*
*

SC7D:
*

*INITIALIZE EMPTY
*
LDD
#0
STD
HDRFWD
STD
HDRBCK

*
*INSERT ELEMENT
*
LDY
#ELEM1
LDX
#HDRFWD
PSHS
X,Y
JSR
INDLST

DOUBLY

INTO

LINKED

LIST

CLEAR LINKED LIST HEADER
FORWARD LINK
BACKWARD LINK
* 0 INDICATES NO LINK IN
* DIRECTION
DOUBLY

LINKED

THAT

LIST

GET BASE ADDRESS OF ELEMENT 1
GET PREVIOUS ELEMENT (HEADER)
SAVE PARAMETERS IN STACK
INSERT ELEMENT INTO LIST

*

*INSERT ANOTHER
*
LDY
#ELEM2
LDX
#ELEM1
PSHS
X,Y
JSR
INDLST

ELEMENT

INTO

DOUBLY

LINKED

LIST

GET BASE ADDRESS OF ELEMENT
GET PREVIOUS ELEMENT
SAVE PARAMETERS IN STACK
INSERT ELEMENT INTO LIST

*

*REMOVE FIRST ELEMENT
*
LDX
#HDRFWD
JSR
RMDLST
*

FROM

DOUBLY

LINKED

LIST

GET PREVIOUS ELEMENT
REMOVE ELEMENT FROM LIST
END UP WITH HEADER LINKED

TO

2

7D

Doubly linked list manager (INDLST, RMDLST)
SECOND ELEMENT
X CONTAINS BASE ADDRESS
OF FIRST ELEMENT

+%

BRA

SC7D

REPEAT

TEST

*

*DATA
*
HDRFWD
HDRBCK
ELEM1
ELEM2

RMB
RMB
RMB
RMB
END

PN
NM
PO

“HEADER - FORWARD LINK
HEADER - BACKWARD LINK
ELEMENT 1 - HEADER (LINKS)
ELEMENT 2 - HEADER CLINKS)

ONLY
ONLY

249

§ Input/output

8A Read aline from a terminal
(RDLINE)
Reads a line of ASCII characters ending with a carriage return and saves
it in a buffer. Defines the control characters Control H (08 hex), which
deletes the latest character, and Control X (18 hex), which deletes the
entire line. Sends a bell character (07 hex) to the terminal if the buffer
overflows. Echoes each character placed in the buffer. Echoes nonprintable characters as an up-arrow or caret (-) followed by the printable
equivalent (see Table 8-1). Sends a new line sequence (typically carriage
return, line feed) to the terminal before exiting.
RDLINE assumes the following system-dependent subroutines:

1. RDCHAR reads a character from the terminal and puts it in register A.
2.

WRCHAR sends the character in register A to the terminal.

3. WRNEWL sends a new line sequence to the terminal.
These subroutines are assumed to change all user registers.
RDLINE is an example of a terminal input handler. The control
characters and I/O subroutines in a real system will, of course, be

computer-dependent. A specific example in the listing is for a Radio
Shack Color Computer with the following pointers to BASIC routines in
ROM:
250

8A

Read aline from a terminal (RDLINE)

251

1. A000 and A001 contain a pointer to the routine that polls the
keyboard and returns with either 0 (no key pressed) a character in
register A.
2. A002 and A003 contain a pointer to the routine that sends the
character in register A to an output device. The unit number (00 =
screen, FE = printer) is in memory location O06F.

Procedure The program starts the loop by reading a character. If it is
a Carriage return, the program sends a new line sequence to the terminal
and exits. Otherwise, it checks for the special characters Control H and
Control X. If the buffer is not empty, Control H makes the program
decrement the buffer pointer and character count by 1 and send a
backspace string (cursor left on the Color Computer) to the terminal.
Control X makes the program delete characters until the buffer is

empty.

If the character is not special, the program determines whether the
buffer is full. If it is, the program sends a bell character to the terminal.
If not, the program stores the character in the buffer, echoes it to the
terminal, and increments the character count and buffer pointer.

Table 8-1 =ASCII control characters and printable equivalents
Name

Hex value

Printable

equivalent
NUL
SOH
STX
ETX
EOT
ENQ
ACK
BEL
BS
HT
LF
VT
FF
CR
SO
SI

00
01
02
03
04
05
06
07
08
09
OA
OB
OC
0D
OE
OF

Control @
Control A
Control B
Control C
Control D
Control E
Control F
Control G
Control H
Control I
Control J
Control K
Control L
Control M
Control N
Control O

252

Assembly language subroutines for the 6809
DLE
DC1
DC2
DC3
DC4
NAK
SYN
ETB
CAN
EM
SUB

10
11
12
13
14
15
16
17
18
19
1A

ESC
FS
GS

1B
1C
1D

Control [
Control \
Control |

RS
VS

1E
1F

Control *
Control _

|

Control P
Control Q
Control R
Control S
Control T
Control U
Control V
Control W
Control X
Control Y
Control Z

Before echoing a character or deleting one from the display, the program must determine whether it is printable. If not (i.e. it is a nonprintable ASCII control code), the program must display or delete two
characters, the control indicator (up-arrow or caret) and the printable
equivalent (see Table 8-1). Note, however, that the character is stored
in its non-printable form. On the Radio Shack Color Computer, control
characters are generated by pressing the down-arrow key, followed by
another key. For example, to enter Control X, you must press downarrow, then X.

Entry conditions

Base address of buffer in register X
Length (size) of buffer in bytes in register A

Exit conditions

Number of characters in the buffer in register A

Examples

1.

Data:

Line from keyboard is ‘ENTERcr’

8A

2.

Read aline from a terminal (RDLINE)

253

Result:

Character count = 5 (line length)
Buffer contains ‘ENTER’
‘ENTER’ echoed to terminal, followed by the new line
sequence (typically either carriage return, line feed or just
carriage return)
Note that the ‘cr’ (carriage return) character does not
appear in the buffer.

Data:

Line from keyboard is ‘DMcontrolHNcontrolIXENTETcontrolHRcr’
Character count = 5 (length of final line after deletions)
Buffer contains ‘ENTER’
‘DMBackspaceStringNBackspaceStringBackspaceString
ENTETBackspaceStringR’ sent to terminal, followed by a
new line sequence. The backspace string deletes a character from the screen and moves the cursor left one space.
The sequence of operations is as follows:

Result:

Character
typed

Initial
buffer

Final
buffer

Sent to
terminal

D
M
control H
N
control X
E
N
T
E
T
control H
R
cr

empty
‘(D’
‘DM’
‘D’
‘DN’
empty
‘E>
‘EN’
‘ENT’
‘ENTE’
‘“ENTET”
‘ENTE’
‘ENTER’

‘D’
‘DM’
‘D’
‘DN’
empty
‘FE’
‘EN’
‘ENT’
‘ENTE’
‘“ENTET’
‘ENTE’
“ENTER’
‘ENTER’

D
M
backspace string
N
2 backspace strings
E
N
T
E
T
backspace string
R
New line string

What happened is the following:

(a) The operator types ‘D’, ‘M’.

(b) The operator sees that ‘M’ is wrong (it should be ‘N’), presses
Control H to delete it, and types ‘N’.
(c) The operator then sees that the initial ‘D’ is also wrong (it should

254

Assembly language subroutines for the 6809

be ‘E’). Since the error is not in the latest character, the operator
presses Control X to delete the entire line, and then types ‘ENTET”.

(d) The operator notes that the second “T’ is wrong (it should be ‘R’),
presses Control H to delete it, and types ‘R’.
(e) The operator types a carriage return to end the line.

Registers used

All

Execution time Approximately 76 cycles to put an ordinary character
in the buffer, not considering the execution time of either RDCHAR or

WRCHAR
Program size

139 bytes

Data memory required

None

Special cases

1. Typing Control H (delete one character) or Control X (delete the
entire line) when the buffer is empty has no effect.
2. The program discards an ordinary character received when the
buffer is full, and sends a bell character to the terminal (ringing the
bell).
Title

Read

Name:

RDLINE

Line

Purpose:

Read characters from an input device until
a carriage return is found. Defines the
control characters
Control H -- Delete latest character.
Control X -- Delete all characters.
Any other control character is placed in
the buffer and displayed as the equivalent
printable ASCII character preceded by an
up-~arrow or caret.

Entry:

Register
Register

+

HF
F+

X =

Base

A =

Length

address

of

of

buffer

buffer

in

bytes

8A

Readaline from a terminal (RDLINE)

Exit:

Register

Registers

Used:

A =

Number

of

255

characters

in

buffer

All

Time:

Not

applicable.

Size:

Program

139

bytes

HK
He
+e
+t
eH
HF
F
+

*EQUATES
BELL
BSKEY
CR
CRKEY
CSRLFT
CTLOFF
*
DLNKEY
DNARRW
*
LF
SPACE
*
STERM
UPARRW

EQU
EQU
EQU
EQU
EQU
EQU

$07
$08
$0D
$0OD
$08
$40

EQU
EQU

$18
SOA

EQU
EQU

$OA
$20

EQU
EQU

$24
$5E

BELL CHARACTER
BACKSPACE
KEYBOARD
CHARACTER
CARRIAGE
RETURN
FOR CONSOLE
CARRIAGE
RETURN KEYBOARD
CHARACTER
MOVE CURSOR
LEFT FOR CONSOLE
OFFSET
FROM CONTROL CHARACTER
TO PRINTED
FORM (E.G., CONTROL-X TO X)
DELETE
LINE KEYBOARD
CHARACTER
DOWN-ARROW
KEY CUSED AS CONTROL
INDICATOR
ON KEYBOARD
LINE FEED FOR CONSOLE
SPACE CHARACTER
CALSO MARKS END OF CONTROL
CHARACTERS
IN ASCII SEQUENCE)
STRING TERMINATOR
(DOLLAR SIGN)
UP-ARROW OR CARET USED AS CONTROL
INDICATOR

RDLINE:
*

*INITIALIZE
*

CHARACTER

COUNT

TO

ZERO,

SAVE

BUFFER

LENGTH

INIT:

CLRB
PSHS
*
*READ
*READ
*

CHARACTER COUNT = QO
SAVE BUFFER LENGTH IN

A
LOOP
CHARACTERS

UNTIL

A CARRIAGE

RETURN

IS

STACK

TYPED

RDLOOP:
JSR

*
*CHECK
*
CMPA
BEQ
*
*CHECK
*
CMPA
BNE
JSR
BRA

RDCHAR

FOR

READ CHARACTER
*DOES NOT ECHO

CARRIAGE

RETURN,

IF

FOUND

CHECK FOR CARRIAGE RETURN
END OF LINE IF CARRIAGE RETURN

#CR
EXITRD
FOR

EXIT

FROM KEYBOARD
CHARACTER

BACKSPACE

AND

#BSKEY
ROLP1
BACKSP
RDLOOP

DELETE

CHARACTER

IF

FOUND

CHECK FOR BACKSPACE KEY
BRANCH IF NOT BACKSPACE
IF BACKSPACE, DELETE ONE CHARACTER
THEN START READ LOOP AGAIN

*

*CHECK
*

FOR

DELETE

LINE

CHARACTER

AND

EMPTY

BUFFER

IF

FOUND

256

Assembly language subroutines for the 6809

RDLP1:

CMPA
BNE

#DLNKEY
RDLP2

CHECK FOR
BRANCH IF

DELETE LINE KEY
NOT DELETE LINE

JSR
TSTB
BNE

BACKSP

DELETE A CHARACTER
CHECK IF BUFFER EMPTY
CONTINUE UNTIL BUFFER EMPTY
*THIS ACTUALLY BACKS UP OVER
* CHARACTER RATHER THAN JUST
* UP A LINE

DEL1:

DEL1

EACH
MOVING

BRA
RDLOOP
*
*KEYBOARD ENTRY IS NOT A SPECIAL CHARACTER
*CHECK IF BUFFER IS FULL
*IF FULL, RING BELL AND CONTINUE
*IF NOT FULL, STORE CHARACTER AND ECHO
*

RDLP2:
CMPA
BCS
LDA
JSR
BRA

79
STRCH
#BELL
WRCHAR
RDLOOP

COMPARE COUNT AND BUFFER LENGTH
JUMP IF BUFFER NOT FULL
BUFFER FULL, RING THE TERMINAL'S
THEN

CONTINUE

THE

READ

LOOP

*

*BUFFER
*

NOT

FULL,

STORE

CHARACTER

STRCH:
STA
Xt
STORE CHARACTER IN BUFFER
INCB
INCREMENT CHARACTER COUNT
*
*IF CHARACTER IS CONTROL, THEN OUTPUT
* UP-ARROW FOLLOWED BY PRINTABLE EQUIVALENT
*
CMPA
#SPACE
CONTROL CHARACTER IF CODE IS
BELOW SPACE (20 HEX) IN ASCII
SEQUENCE
BCC
PRCH
JUMP IF A PRINTABLE CHARACTER
PSHS
A
SAVE NONPRINTABLE CHARACTER
LDA
#UPARRW
WRITE UP-ARROW OR CARET
JSR
WRCHAR
,
PULS
A
RECOVER NONPRINTABLE CHARACTER
ADDA
#CTLOFF
CHANGE TO PRINTABLE FORM
PRCH:

JSR
BRA
*
*EXIT
*SEND
*LINE
*

WRCHAR
RDLOOP

NEW LINE
LENGTH =

ECHO
THEN

CHARACTER TO TERMINAL
CONTINUE READ LOOP

SEQUENCE CUSUALLY
CHARACTER COUNT

CR,LF)

TO

TERMINAL

EXITRD:

JSR
TFR
LEAS
RTS

WRNEWL
B,A
1,8

ECHO NEW LINE SEQUENCE
RETURN LINE LENGTH IN A
REMOVE BUFFER LENGTH FROM

STACK

BELL

8A

Readaline from a terminal (RDLINE)

257

HHH KKK KIKI
KKK
IIIT KEKE RRR REIKI EEK
ER
*
* THE FOLLOWING SUBROUTINES ARE TYPICAL EXAMPLES USING THE
* BASIC CALLS FOR THE RADIO SHACK TRS-80 COLOR COMPUTER
*
KEKEKKKEKKEKKEEKKKEEKKEEEEEEEKEEKERKEKKRKKEKKEKKKKKKKKKKK
KKK KKK KEK

*COLOR
KBDPTR
*
*
*
OUTPTR
*
*
*

COMPUTER
EQU

EQUATES
$A000

EQU

$A002

POINTER TO KEYBOARD INPUT ROUTINE
CHARACTER ENDS UP IN REGISTER A
ZERO FLAG = 1 IF NO CHARACTER,
O IF CHARACTER
POINTER TO OUTPUT ROUTINE
UNIT NUMBER GOES IN LOCATION
SOO6F (O = SCREEN)
CHARACTER GOES IN REGISTER A

HHH KK IK III RII III II III IKKE KKK RRR RR IKEA EEE
*ROUTINE: RDCHAR
*PURPOSE: READ A CHARACTER BUT DO NOT ECHO TO OUTPUT DEVICE
*ENTRY: NONE
*EXIT:
REGISTER A = CHARACTER
*REGISTERS USED: ALL
KR IK IKI III KIKI III III
EKER ERIE IIIA
IAAI AIK
RDCHAR:
*
*WAIT
*EXIT
*
JSR
BEQ
CMPA
BNE

FOR CHARACTER FROM CONSOLE
UNLESS IT IS CONTROL INDICATOR
CKBDPTRI
RDCHAR
#DNARRW
RDCHXT

POLL KEYBOARD
LOOP UNTIL KEY PRESSED
CHECK IF CONTROL CHARACTER
EXIT IF NOT CONTROL

*IF CONTROL CHARACTER,
*THEN CONVERT NEXT KEY
*

WAIT UNTIL NEXT KEY IS READ
TO ASCII CONTROL CHARACTER

JSR
BEQ
CMPA
BLO
SUBA

POLL KEYBOARD
LOOP UNTIL KEY PRESSED
COMPARE WITH ASCII A
EXIT IF LESS THAN A
ELSE CONVERT TO CONTROL
* CHARACTER EQUIVALENT

*

CNTCHR:

*
*EXIT
*

CKBDPTR]
CNTCHR
#'A
RDCHXT
#CTLOFF

WITH

CHARACTER

IN

REGISTER

A

RETURN

ASCII

RDCHXT:
RTS

HHH KERRIER
KKK RAK
I
*ROUTINE: WRCHAR
*PURPOSE: WRITE CHARACTER TO OUTPUT DEVICE

CHARACTER

IN

REGISTER

A

258

Assembly language subroutines for the 6809

*ENTRY:
REGISTER
*EXIT:
NONE
*REGISTERS USED: ALL
KKK KKK KERR
RRR

A =

CHARACTER

ERE

WRCHAR:
*
*WRITE A CHARACTER TO OUTPUT
*LOCATION S$QO6F MUST CONTAIN
*
JSR
COUTPTRI
SEND
RTS

DEVICE
UNIT NUMBER

(0 =

SCREEN)

CHARACTER

HH HKKKH HK RIKER KERR KKK EKER KRRKRIEKKERREKKEEREEKEEERERKE
KK
*ROUTINE: WRNEWL
*PURPOSE: ISSUE NEW LINE SEQUENCE TO TERMINAL
*
NORMALLY, THIS SEQUENCE IS A CARRIAGE RETURN AND
*
LINE FEED, BUT SOME COMPUTERS REQUIRE ONLY
*
A CARRIAGE RETURN.
*ENTRY: NONE
*EXIT:
NONE
*REGISTERS USED: ALL
HHH KIKI
RIK REET IIE REE ERE EKREREREREEEEREKE
KEKE
WRNEWL:
*SEND
LDY
JSR
RTS
NLSTRG:

NEW LINE STRING
#NLSTRG
WRSTRG
FCB

TO TERMINAL
POINT TO NEW LINE STRING
SEND STRING TO TERMINAL

CR,LF,STERM

NEW

LINE

STRING

KKK KKK KEE REE RE RRA IIIT
KEE ERK KE
*ROUTINE: BACKSP
*PURPOSE: PERFORM A DESTRUCTIVE BACKSPACE
*ENTRY: A = NUMBER OF CHARACTERS IN BUFFER
*
X = NEXT AVAILABLE BUFFER ADDRESS
*EXIT:
IF NO CHARACTERS IN BUFFER
*
zZ= 1
*
ELSE
*
z= 0
*
CHARACTER REMOVED FROM BUFFER
*REGISTERS USED: ALL
KKK KEKE IRE EERE RIKI IIIT TITER EERE EK
BACKSP:
*
*CHECK FOR EMPTY BUFFER
*
TSTB
TEST NUMBER OF CHARACTERS
BEQ
EXITBS
BRANCH (EXIT) IF BUFFER EMPTY
*
*OUTPUT BACKSPACE STRING
* TO REMOVE CHARACTER FROM DISPLAY
*
LEAX
-1,X
DECREMENT BUFFER POINTER

8A
LDA
CMPA
BNE
LDX

BS1:

Read aline froma terminal (RDLINE)
7X
#SPACE
BS1
#BSSTRG

JSR
WRSTRG
LDX
#BSSTRG
JSR
WRSTRG
*DECREMENT CHARACTER
DECB

259

GET CHARACTER
IS IT A CONTROL CHARACTER?
NO, BRANCH, DELETE ONLY ONE CHARACTER
YES, DELETE 2 CHARACTERS
* (UP-ARROW AND PRINTABLE EQUIVALENT)
WRITE BACKSPACE STRING
WRITE BACKSPACE STRING
COUNT BY 1
ONE LESS CHARACTER IN BUFFER

EXITBS:
RTS
*

*DESTRUCTIVE BACKSPACE STRING FOR TERMINAL
*THE COLOR COMPUTER DOES NOT PROVIDE A FLASHING CURSOR WHEN
*
RUNNING THIS ROUTINE, SO ONLY A BACKSPACE CHARACTER IS
*
NECESSARY
*IF THE CURSOR WERE ENABLED, THE SEQUENCE BACKSPACE, SPACE,
*
BACKSPACE WOULD BE NECESSARY TO MOVE THE CURSOR LEFT,
*
PRINT A SPACE OVER THE CHARACTER, AND MOVE THE CURSOR LEFT
*
BSSTRG:
FCB
CSRLFT,STERM

KHKKKKKEKRKEKKKKE
KEE
REKRKEKKEEEKKKEKER
*ROUTINE:S WRSTRG
*PURPOSE: OUTPUT STRING TO CONSOLE
*ENTRY: X = BASE ADDRESS OF STRING
*EXIT:
NONE
*REGISTERS USED: ALL
KHKKKKKKK KERR KKEREREEKEKKEEEKEKE
WRSTRG:
LDA
CMPA
BEQ

7Y¥t+
#STERM
WREXIT

GET CHARACTER
FROM
CHECK
IF AT END
EXIT
IF AT END

JSR

COUTPTRI

WRITE

CHARACTER

BRA

WRSTRG

CHECK

NEXT

STRING

CHARACTER

WREXIT:
RTS
*

*

SAMPLE

EXECUTION:

k
*EQUATES
PROMPT

EQU

'9

OPERATOR

PROMPT

=

QUESTION

SC8A:
*

*READ
*
LDA
JSR
LDX
LDA
JSR
TSTA

LINE

FROM

#PROMPT
WRCHAR
#INBUFF
#LINBUF
RDLINE

TERMINAL
WRITE

PROMPT

(?)

GET INPUT BUFFER ADDRESS
GET LENGTH OF BUFFER
READ LINE
CHECK LINE LENGTH

MARK

260

Assembly language subroutines for the 6809
BEQ
*
*ECHO
*
LDX

SC8A

READ

NEXT

LINE

IF

LENGTH

#INBUFF

POINT

TO

START

OF

BUFFER

7x
WRCHAR

WRITE

NEXT

LINE

TO

IS

0

CONSOLE

WRBUFF:
LDA
JSR
INX
DECB
BNE
JSR
BRA

*DATA SECTION
LINBUF
EQU
INBUFF
RMB
END

CHARACTER

WRBUFF
WRNEWL
SC8A

INCREMENT BUFFER POINTER
DECREMENT CHARACTER COUNT
CONTINUE UNTIL ALL CHARACTERS
THEN END WITH CR,LF
READ NEXT LINE

16
LINBUF

LENGTH OF INPUT
INPUT BUFFER

BUFFER

SENT

8B

Write a line to an output device (WRLINE)

261

8B. Write a line to an output device
(WRLINE)
Writes characters until it empties a buffer with given length and base
address. Assumes the system-dependent subroutine WRCHAR, which
sends the character in register A to an output device.
WRLINE is an example of an output driver. The actual I/O subroutines will, of course, be computer-dependent. A specific example in
the listing is for a Radio Shack Color Computer with TRS-80 BASIC in
ROM.

Procedure The program exits immediately if the buffer is empty.
Otherwise, it sends characters to the output device one at a time until it
empties the buffer.

Entry conditions

Base address of buffer in register X
Number of characters in the buffer in register A

Exit conditions
None

Example
Data:

Number of characters = 5
Buffer contains ‘ENTER’

Result:

‘ENTER’ sent to the output device

Registers used

All

Execution time 16 cycles overhead plus 19 cycles per byte. This does
not, of course, include the execution time of WRCHAR.
Program size

14 bytes

262

Assembly language subroutines for the 6809

Data memory required

None

Special case

An empty buffer results in an immediate exit with nothing sent to the
output device.
*

Title

Write

*

Name:

WRLINE

Line

Purpose:

Write

Entry:

Register
Register

*

*

characters

to

output

device

*

*
*

X =
A =

Base address of buffer
Number of characters in

buffer

*

*

Exit:

None

*

*

Registers

Used:

ALl

*

*
*

Time:

Indeterminate, depends
WRCHAR routine.

Size:

Program

on

the

speed

of

the

*

*
*

14 bytes

WRLINE:
*
*EXIT
*
TSTA
BEQ
*
*LOOP
*
TFR

IMMEDIATELY

IF

BUFFER

EMPTY

TEST NUMBER OF CHARACTERS IN BUFFER
BRANCH CEXIT) IF BUFFER EMPTY
* X = BASE ADDRESS OF BUFFER

EXITWL

SENDING

IS

CHARACTERS

TO

OUTPUT

DEVICE

A,B

MOVE

CHARACTER

COUNT

Xt
WRCHAR

GET NEXT CHARACTER
SEND CHARACTER
DECREMENT COUNTER
CONTINUE UNTIL ALL

TO

B

WRLLP:
LDA
JSR
DECB
BNE

WRLLP

CHARACTERS

EXITWL:
RTS

EXIT

FRI III III IK III III III
IIE IKKE EEE KEES AIEEE ERK REEERERKEKK
*
* THE FOLLOWING SUBROUTINES ARE TYPICAL EXAMPLES USING THE
* RADIO SHACK TRS-80 COLOR COMPUTER WITH BASIC IN ROM
*
KKK KKK

KEKE

REE

KK KKK

SENT

8B

Write a line to an output device (WRLINE)

263

KIKI KKK KKK KKK EKER EEEKKEER KKK RRA
I I
*ROUTINE: WRCHAR
*PURPOSE: WRITE CHARACTER TO OUTPUT DEVICE
*ENTRY: REGISTER A = CHARACTER
*EXIT:
NONE
*REGISTERS USED: ALL
FI KI I ITI IT IIT IIIT IIR IKE
RRR ERR II I
* COLOR COMPUTER EQUATES
CLRSCN
EQU
$A928
STARTING ADDRESS FOR ROUTINE
*
THAT CLEARS SCREEN
OUTPTR
EQU
$A002
POINTER TO OUTPUT ROUTINE
*
UNIT NUMBER GOES IN LOCATION
*
SOO6F (0 = SCREEN)
*
CHARACTER GOES IN REGISTER A
WRCHAR:
*
*
*
*
*

SEND CHARACTER TO OUTPUT DEVICE FROM
LOCATION SOO6F SHOULD CONTAIN A UNIT
(DEFAULT IS SCREEN = QO)
JSR
RTS

COUTPTRI

SEND

REGISTER
NUMBER

A

CHARACTER

*
*
SAMPLE EXECUTION:
*
*CHARACTER EQUATES
CR
LF
PROMPT

EQU
EQU
EQU

$0D
SOA
'9

CARRIAGE
RETURN
FOR CONSOLE
LINE
FEED
FOR CONSOLE
OPERATOR

PROMPT

=

QUESTION

MARK

SC8B:

*
*CALL
*
JSR
*
*READ
*
LDA
JSR
LDX
JSR
PSHS
LDA
LDX
JSR

BASIC

SUBROUTINE

CLRSCN
LINE

FROM

THAT

CLEARS

SCREEN

CLEAR

SCREEN

OUTPUT

PROMPT

CONSOLE

#PROMPT
WRCHAR
#INBUFF
RDLINE
A
#2
#CRLF
WRCHAR

(?)

POINT TO INPUT BUFFER
READ LINE FROM CONSOLE
SAVE LINE LENGTH IN STACK
OUTPUT LINE FEED, CARRIAGE

RETURN

*®

*WRITE
*

LINE

TO

PULS
LDX
JSR
LDX

A
#INBUFF
WRLINE
#CRLF

CONSOLE

RESTORE LINE LENGTH FROM STACK
GET BASE ADDRESS OF BUFFER
WRITE LINE
OUTPUT CARRIAGE RETURN, LINE FEED

264

Assembly language subroutines for the 6809
LDA
JSR
BRA

*DATA SECTION
CRLF
FCB
LINBUF
EQU
INBUFF: RMB
END

#2
WRLINE
SC8B

LENGTH OF CRLF STRING
WRITE CRLF STRING
REPEAT CLEAR, READ, WRITE

CR,LF
$10
LINBUF

CARRIAGE RETURN, LINE FEED
LENGTH OF INPUT BUFFER
DATA BUFFER

SEQUENCE

8C

Parity checking and generation (CKPRTY, GEPRTY)

265

8C_ Parity checking and generation
(CKPRTY, GEPRTY)
Generates and checks parity. GEPRTY generates even parity for a 7-bit
character and places it in bit 7. An even parity bit makes the total
number of 1 bits in the byte even. CKPRTY sets the Carry flag to 0 if a
data byte has even parity and to 1 otherwise. A byte’s parity is even if it
has an even number of 1 bits and odd otherwise.

Procedures

1. GEPRTY generates even parity by counting the number of 1s in the
seven least significant bits of register A. The least significant bit of the
count is an even parity bit. The program shifts that bit to the Carry and
then to bit 7 of the data.

2. CKPRTY counts the number of 1 bits in the data by repeatedly
shifting it left logically and testing the Carry. The program quits when
the shifted data becomes zero. The least significant bit of the count is an
even parity bit; the program concludes by shifting that bit to the Carry.

Entry conditions

1. GEPRTY
Data in register A
2. CKPRTY
Data in register A

Exit conditions

1. GEPRTY
Data with even parity in bit 7 in register A
2. CKPRTY
Carry = 0 if the data has even parity, 1 if it had odd parity

Examples

1. GEPRTY
(a) Data: (A) = 4215 = 01000010) (ASCII B)

266

Assembly language subroutines for the 6809

Result: (A) = 4216 = 010000102 (ASCII B with bit 7 cleared)
Even parity is 0, since 01000010, has an even number (2) of
1 bits
(b) Data: (A) = 4316 = 010000112 (ASCII C)
Result: (A) = C346 = 110000112 (ASCII C with bit 7 set)
Even parity is 1, since 010000112 has an odd number (3) of
1 bits

2.

CKPRTY
(a) Data: (A) = 4216 = 01000010, (ASCII B)
Result: Carry = 0, since 01000010, has an even number (2) of 1 bits
(b) Data: (A) = 4316 = 010000112 (ASCII C)
Result: Carry = 1, since 01000011, has an odd number (3) of 1 bits

Registers used

1.

GEPRTY: A, B,CC

2.

CKPRTY: A,B, CC

Execution time
1.

GEPRTY: 95 cycles maximum

2.

CKPRTY: 91 cycles maximum

The execution times of both routines depend on how many 1bits the data
contains and how rapidly the logical shifting makes it zero. Both execute
faster if many of the less significant bits are zeros.
Program size
1.

GEPRTY: 15 bytes

2.

CKPRTY: 10 bytes

Data memory required

1 stack byte for GEPRTY

*

Title

Generate

and

*

Name:

GEPRTY,

CKPRTY

Check

Purpose:

GEPRTY

Parity

*

*
*

for

a

generates
7-bit

even

character.

parity

in

bit

7

8C

Parity checking and generation (CKPRTY, GEPRTY)
CKPRTY

checks

the

parity

of

Entry:

GEPRTY
CKPRTY

-

in
in

register
register

A
A

Exit:

GEPRTY - data with even parity in bit
In register A
CKPRTY - Carry = O if parity is even,
Carry = 1 1f parity is odd

Registers

Used:

data
data

GEPRTY
CKPRTY

-

A,
A,

B,
B,

Time:

GEPRTY
CKPRTY

-

95
91

cycles
cycles

Size:

Program
Data

267

a byte

7

CC
CC

maximum
maximum

25 bytes
1 stack byte

ee.
ee
i

*
*

GENERATE

EVEN

PARITY

*

GEPRTY:
CLRB
ASLA
PSHS

NUMBER OF 1 BITS = ZERO
DROP DATA BIT 7
SAVE SHIFTED DATA IN STACK

A

*

*COUNT
*

1 BITS

BPL
INCB

SHIFT

UNTIL

DATA

BECOMES

ZERO

CNTBIT:

BRANCH IF NEXT
ELSE INCREMENT

BIT (BIT 7) IS 0
NUMBER OF 1 BITS

SHIFT DATA LEFT
BRANCH IF THERE

ARE

SHIFT:
ASLA
BNE
*
*MOVE
*
LSRB

*
*
*
CKPRTY:

EVEN

PULS
RORA
RTS

A

CHECK

PARITY

CLRB
TSTA
*
*COUNT
*
BITCNT:

CNTBIT
PARITY

TO

BIT

1 BITS

LEFT

DATA

MOVE EVEN PARITY TO CARRY
*NOTE EVEN PARITY IS BIT O OF COUNT
RESTORE SHIFTED DATA FROM STACK
ROTATE TO FORM BYTE WITH EVEN PARITY

NUMBER OF
TEST DATA

1 BITS

7 OF

MORE

UNTIL

DATA

1 BITS
BYTE

=

ZERO

BECOMES

ZERO

IN

BIT

7

Assembly language subroutines for the 6809

268

BPL
INCB

CSHIFT

BRANCH IF NEXT
ELSE INCREMENT

BIT (BIT 7) IS 0
NUMBER OF 1 BITS

SHIFT DATA LEFT
BRANCH IF THERE

ARE

SHIFT:
ASLA
BNE
*
*MOVE
*
LSRB

BITCNT

PARITY

TO

MORE

1 BITS

MOVE PARITY TO CARRY
*NOTE PARITY IS BIT O OF

COUNT

LEFT

CARRY

RTS
*

SAMPLE

EXECUTION:

*

*GENERATE PARITY
*
IN BUFFER 1

FOR

VALUES

FROM

0..127

AND

STORE

THEM

*

Sc8C:
LOX
CLRA

#BUFR1

GET BASE ADDRESS OF
START DATA AT ZERO

BUFFER

GPARTS:
SAVE DATA IN STACK
PSHS
GENERATE EVEN PARITY
JSR
PULS
SAVE VALUE WITH EVEN PARITY
STA
RETURN DATA VALUE TO A
TFR
ADD 1 TO DATA VALUE
INCA
HAVE WE REACHED HIGHEST VALUE?
CMPA
BRANCH IF NOT DONE
BNE
*
*CHECK PARITY FOR ALL BYTES IN BUFFER 1
* CARRY = 1 IF ROUTINE FINDS A PARITY ERROR AND
*
X POINTS TO THE BYTE WITH THE ERROR
* CARRY = 0 IF ROUTINE FINDS NO PARITY ERRORS
*
GET BASE ADDRESS OF BUFFER
#BUFR1
LDX
CHECK 128 BYTES
LDA
#129
SAVE COUNT ON STACK
A
PSHS

REGISTER

CPARTS:

DEC
BEQ
LDA
JSR
BCC
LEAX

79
CPEXIT
7Xt+
CKPRTY
CPARTS
-1,X

DECREMENT COUNT
EXIT IF ALL BYTES CHECKED
GET NEXT DATA BYTE
CHECK PARITY
IF NO ERROR, CONTINUE THROUGH VALUES
PARITY ERROR - MAKE X POINT TO IT

LEAS
BRA

1,S
S$c8c

REMOVE
BRANCH

COUNT BYTE FROM STACK
FOR ANOTHER TEST

128

BUFFER

FOR

CPEXIT:

*

*DATA
*
BUFR1

SECTION
RMB
END

DATA

VALUES

WITH

EVEN

PARITY

8D

CRC16 checking and generation (ICRC16,CRC16,GCRC16)

269

8D CRC16 checking and generation
(ICRC16,CRC16,GCRC16)
Generates a 16-bit cyclic redundancy check (CRC) based on the IBM
Binary Synchronous Communications protocol (BSC or Bisync). Uses

the polynomial X'° + X*° + X? + 1. Entry point ICRC16 initializes the

CRC to 0 and the polynomial to its bit pattern. Entry point CRC16
combines the previous CRC with the one generated from the current
data byte. Entry point GCRC16 returns the CRC.

Procedure Subroutine ICRC16 initializes the CRC to 0 and the polynomial to a 1 in each bit position corresponding to a power of X present
in the formula. Subroutine CRC16 updates the CRC for a data byte. It
shifts both the data and the CRC left eight times; after each shift, it
exclusive-ORs the CRC with the polynomial if the exclusive-OR of the
data bit and the CRC’s most significant bit is 1. Subroutine CRC16
leaves the CRC in memory locations CRC (more significant byte) and
CRC + 1 (less significant byte). Subroutine GCRC16 loads the CRC
into register D.
:
eee

Entry conditions
1.

For ICRC16: none

2. For CRC16: data byte in register A, previous CRC in memory
locations CRC (more significant byte) and CRC + 1 (less significant
byte), CRC polynomial in memory locations PLY (more significant
byte) and PLY +1(less significant byte).

3. For GCRC16: CRC in memory locations CRC (more significant
byte) and CRC +1(less significant byte).

Exit conditions

1. ForICRC16
0 (initial CRC value) in memory locations CRC (more significant byte)
and CRC +1 (less significant byte)
CRC polynomial in memory locations PLY (more significant byte) and
PLY +1 (less significant byte)
2.

For CRC16: CRC with current data byte included in memory loca-

270

Assembly language subroutines for the 6809

tions CRC (more significant byte) and CRC +1(less significant byte)
3.

For GCRC16: CRC in register D

Examples

1. Generating a CRC
Call ICRC16 to initialize the polynomial and start the CRC at 0
Call CRC16 repeatedly to update the CRC for each data byte
Call GCRC16 to obtain the final CRC
2. Checking a CRC
Call ICRC16 to initialize the polynomial and start the CRC at 0
Call CRC16 repeatedly to update the CRC for each data byte (including
the stored CRC) for checking
Call GCRC16 to obtain the final CRC; it will be 0 if there were no errors

Note that only ICRC16 depends on the particular CRC polynomial
used. To change the polynomial, simply change the data ICRC16 loads
into memory locations PLY (more significant byte) and PLY + 1 (less
significant byte).

Reference

J. E. McNamara, Technical Aspects of Data Communications, 3rd ed..,
Digital Press, Digital Equipment Corp., 12-A Esquire Road,
Billerica, MA, 1989. This book contains explanations of CRC and
communications protocols.

Registers used

1.

ByICRC16: CC, X

2.

By CRC16: none

3.

By GCRC16: CC, D

Execution time
1.

ForICRC16: 23 cycles

2.

For CRC16: 490 cycles overhead plus an average of 34 cycles per

8D

CRC16 checking and generation (ICRC16,CRC16,GCRC16)

271

data byte, assuming that the previous CRC and the polynomial must be
EXCLUSIVE-ORed in half of the iterations
3.

For GCRC16: 11 cycles

Program size

1.

For ICRC16: 13 bytes

2.

For CRC16: 42 bytes

3.

For GCRC16: 4 bytes

Data memory required 4 bytes anywhere in RAM for the CRC (2
bytes starting at address CRC) and the polynomial (2 bytes Starting at
address PLY). CRC16 also requires 7 stack bytes to save and restore the
user registers.
eee
Title
Name:

Generate CRC-16
ICRC16, CRC16, GCRC16

Purpose:

Generate a 16 bit CRC based on IBM's
Synchronous Communications protocol.
based on the following polynomial:

+

(“ indicates

"to

generate

CRC:

Binary
The CRC

is

the power")

X"16 + X°15 + X72 + 1

To

1)
2)
3)

To

Entry:

Exit:
HH
HSH
He
HE
HF
FF
SH
SF
&
+

a

Call ICRC16 to initialize the CRC
polynomial and clear the CRC.
Call CRC16 for each data byte.
Call GCRC16 to obtain the CRC.
It should then be appended to the
high byte first.

data,

check a CRC:
1)
Call ICRC16 to initialize the CRC.
2)
Call CRC16 for each data byte and
the 2 bytes of CRC previously generated.
3)
Call GCRC16 to obtain the CRC. It will
be zero if no errors occurred.

ICRC16
CRC16
GCRC16

-

None
Register
None

ICRC16
CRC16
GCRC16

-

CRC, PLY initialized
CRC updated
Register D = CRC

A =

Data

byte

Assembly language subroutines for the 6809

272

Registers

Used:

ICRC16
CRC16
GCRC16

Time:

-

CC,X
None
CC,D

ICRC16 - 23 cycles
CRC16 - 490 cycles overhead plus an average
34 cycles per data byte.
The loop timing
assumes that half the iterations require
EXCLUSIVE-ORing the CRC and the polynomial.
GCRC16 - 11 cycles

Size:

Program
Data

59 bytes
4 bytes plus

7 stack

bytes

of

for

CRC16

15

OF

CRC

EXCLUSIVE-OR

IS

0

HH
FS
He
+e
+t
HF
SH
SE
+

CRC16:

*
*SAVE
*
PSHS
*
*LOOP
*
LDB
LDX
LDY

ALL

REGISTERS

CC,D,X,Y
THROUGH

EACH

DATA

SAVE

ALL

REGISTERS

BIT,

GENERATING

THE

CRC

#8
#PLY
#CRC

8 BITS PER BYTE
POINT TO POLYNOMIAL
POINT TO CRC VALUE

D
#%10000000
7X
ry
1,Y
rv
CRCLP1

SAVE DATA, BIT COUNT
GET BIT 7 OF DATA
EXCLUSIVE-OR BIT 7 WITH

CRCLP:
PSHS
ANDA
EORA
STA
ASL
ROL
BCC

SHIFT

16-BIT

CRC

BRANCH

IF

BIT

7 OF

WITH

POLYNOMIAL

BIT

LEFT

*

*BIT
*
LDD
EORA
EORB
STD

7 IS

1, SO

EXCLUSIVE-OR

7X
rv
1,Y
7Y

CRC

GET POLYNOMIAL
EXCLUSIVE-OR WITH HIGH BYTE OF CRC
EXCLUSIVE-OR WITH LOW BYTE OF CRC
SAVE NEW CRC VALUE

*

*SHIFT
*

DATA

LEFT

AND

COUNT

BITS

CRCLP1:
PULS
D
ASLA
DECB
BNE
CRCLP
*
*RESTORE REGISTERS
*
PULS
CC,D,X,Y
RTS

GET DATA, BIT COUNT
SHIFT DATA LEFT
DECREMENT BIT COUNT
JUMP IF NOT THROUGH
AND

EXIT
RESTORE

ALL

REGISTERS

8 BITS

8D

CRC16 checking and generation (ICRC16,CRC16,GCRC16)

RH
KKK KEKE
EE
EKEEKKKKK ARAKI
*ROUTINE: ICRC16
*PURPOSE: INITIALIZE CRC AND PLY
*ENTRY: NONE
*EXIT:
CRC AND POLYNOMIAL INITIALIZED
*REGISTERS USED: X
KKK
KIRKE REE EEE KKK
RK
IK
ICRC16:
LDX
STX
LDX
STX

#0
CRC
#$8005
PLY

CRC

=

0

PLY

=

8005H

*8005 HEX REPRESENTS X~16+X~154+X~24+1
* THERE IS A 11S IN EACH BIT
* POSITION FOR WHICH A POWER APPEARS

*

IN

THE

RTS

FORMULA

(BITS

0,

2, AND

HHH EKER KKK KEKE ERE KIER RR EKK EKER
KKK
*ROUTINE: GCRC16
*PURPOSE: GET CRC VALUE
*ENTRY: NONE
*EXIT:
REGISTER D = CRC VALUE
*REGISTERS USED: D
HHH KEKE KKK KEKEEKREKREREEKE KR
AEEERRAKEK
GCRC16:
LDD
RTS

CRC

D =

CRC

RMB
RMB

2
2

CRC VALUE
POLYNOMIAL

*DATA
CRC:
PLY:

VALUE

*
*

SAMPLE

EXECUTION:

*

*

*GENERATE

CRC

FOR

THE

NUMBER

1 AND

CHECK

IT

*

SC8D:
JSR
LDA
JSR
JSR
JSR
LDA
JSR
TFR
JSR
TFR
JSR

ICRC16
#1
CRC16
GCRC16
ICRC16
#1
CRC16
Y,D
CRC16
B,A
CRC16

JSR

GCRC16

INITIALIZE
CRC, POLYNOMIAL
GENERATE
CRC FOR 1

INITIALIZE

AGAIN

CHECK CRC BY GENERATING
AND STORED
CRC ALSO
HIGH BYTE OF CRC FIRST
THEN LOW BYTE OF CRC

CRC

SHOULD

BE

ZERO

IN

IT

D

FOR

DATA

15)

273

Assembly language subroutines for the 6809

274
*

.

*GENERATE CRC FOR
*
JSR
ICRC16
CLRB

THE

SEQUENCE

0,1,2,...,255

INITIALIZE
START DATA

AND

CHECK

CRC, POLYNOMIAL
BYTES AT 0

GENLP:
JSR
INCB
BNE

CRC16
GENLP

UPDATE CRC
ADD 1 TO PRODUCE NEXT
BRANCH IF NOT DONE

JSR
TFR

GCRC16
D,Y

GET RESULTING CRC
SAVE CRC IN Y

DATA

BYTE

*

*CHECK
*
JSR
CLRB

CRC

BY

GENERATING

IT

AGAIN

ICRC16

INITIALIZE
START DATA

JSR
INCB
BNE

CRC16

UPDATE CRC
ADD 1 TO PRODUCE NEXT
BRANCH IF NOT DONE

CRC, POLYNOMIAL
BYTES AT 0

CHKLP:

CHKLP

DATA

*

*INCLUDE
*
TFR
JSR
TFR
JSR

Y,D
CRC16
B,A
CRC16

GET OLD
INCLUDE
INCLUDE

JSR

GCRC16

BRA

$C8D

GET RESULTING
*IT SHOULD BE
REPEAT TEST

END

STORED

CRC

IN

CHECK
CRC VALUE
HIGH BYTE OF CRC
LOW BYTE OF CRC

CRC
0

BYTE

IT

8E

1//O device table handler (IOHDLR)

275

8E_ I/O device table handler
(IOHDLR)
Performs input and output in a device-independent manner using I/O
control blocks and an I/O device table. The I/O device table is a linked
list; each entry contains a link to the next entry, the device number, and
Starting addresses for routines that initialize the device, determine its
input status, read data from it, determine its output status, and write

data to it. An I/O control block is an array containing device number,
operation number, device status, and the base address and length of the
device’s buffer. The user must provide IOHDLR with the base address
of an I/O control block and the data if only one byte is to be written.
IOHDLR returns the status byte and the data (if only one byte is read).
This subroutine is an example of handling input and output in a
device-independent manner. The I/O device table must be constructed
using subroutines INITDL, which initializes the device list to empty,
and INSDL, which inserts a device into the list.

An applications program will perform input or output by obtaining or
constructing an I/O control block and then calling IOHDLR. IOHDLR
uses the I/O device table to determine how to transfer control to the I/O
driver.

Procedure The program first initializes the status byte to 0, indicating
no errors. It then searches the device table, trying to match the device
number in the I/O control block. If it does not find a match, it exits with
an error number in the status byte. If it finds a match, it checks for a

valid operation and transfers control to the appropriate routine from the
device table entry. That routine must then transfer control back to the
original caller. If the operation is invalid (the operation number is too
large or the starting address for the routine is 0), the program returns
with an error number in the status byte.
Subroutine INITDL initializes the device list, setting the initial link to
0.
Subroutine INSDL inserts an entry into the device list, making its
address the head of the list and setting its link field to the previous head
of the list.

Entry conditions

1. ForIOHDLR
Base address of input/output control block in register X

276

Assembly language subroutines for the 6809

Data byte (if the operation is to write 1 byte) in register A
2.

For INITL: none

3.

For INSDL: base address of a device table entry in register X

Exit conditions

1. ForIOHDLR
I/O control block status byte in register A if an error is found; otherwise, the routine exits to the appropriate I/O driver
Data byte in register A if the operation is to read 1 byte

2. For INITL: device list header (addresses DVLST and DVLST+1)
cleared to indicate empty list
3.

For INSDL: device table entry added to list

Example

The example in the listing uses the following structure:
Input/output operations
Operation
number

Operation

0
1
2
3
4
5
6

Initialize device
Determine input status
Read 1 byte from input device
Read N bytes (usually 1 line) from input device
Determine output status
Write 1 byte to output device
Write N bytes (usually 1 line) to output device

Input/output control block
Index

Contents

0
1
2
3
4

Device number
Operation number
Status
More significant byte of base address of buffer
Less significant byte of base address of buffer

8E

5
6

//O device table handler (IOHDLR)

277

More significant byte of buffer length
Less significant byte of buffer length

Device table entry
Index

Contents

0

More significant byte of link field (base address of next
element)
Less significant byte of link field (base address of next
element)
Device number
More significant byte of starting address of device initializ-

1
2
3

ation routine

4

5
6

7
8
9

10
11
12
13
14
15

16

Less significant byte of starting address of device initialization routine
More significant byte of starting address of input status
determination routine
Less significant byte of starting address of input status determination routine
More significant byte of starting address of input driver (read
1 byte only)
Less significant byte of starting address of input driver (read
1 byte only)
More significant byte of starting address of input driver (read
N bytes or 1 line)
Less significant byte of starting address of input driver (read
N bytes or 1 line)
More significant byte of starting address of output status
determination routine
Less significant byte of starting address of output status
determination routine
More significant byte of starting address of output driver
(write 1 byte only)
Less significant byte of starting address of output driver
(write 1 byte only)
More significant byte of starting address of output driver
(write N bytes or 1 line)
Less significant byte of starting address of output driver
(write N bytes or 1 line)

278

Assembly language subroutines for the 6809

If an operation is irrelevant or undefined (such as output status
determination for a keyboard or input driver for a printer), the corresponding starting address in the device table is 0.
Status values
Value

Description

0
1
2

No errors
Bad device number (no such device)
Bad operation number (no such operation
operation)
Input data available or output device ready

3

or invalid

Registers used

1.

ByIOHDLR: All

2.

By INITDL: CC, X

3.

By INSDL: CC, U, X

Execution time

1. For IOHDLR: 75 cycles overhead plus 23 cycles for each unsuccessful match of a device number
2.

For INITDL: 14 cycles

3.

For INSDL: 22 cycles

Program size

1.

ForIOHDLR: 62 bytes

2.

For INITL: 7 bytes

3.

ForINSDL: 9 bytes

Datamemory required 5 bytes anywhere in RAM for the base address
of the I/O control block (2 bytes starting at address IOCBA), the device
list header (2 bytes starting at address DVLST), and temporary storage
for data to be written without a buffer (1 byte at address BDATA).

8E
Title
Name:

//O device table handler (IOHDLR)
1/0 Device
IOHDLR

Table

279

Handler

+

Purpose:

Perform I/0 in a device independent manner.
This can be done by accessing all devices
in the same way using an I/0 Control Block
(I0CB) and a device table. The routines here
allow the following operations:
Operation
0

number

EWN
Ou

Description
Initialize Device
Determine input status
Read 1 byte
Read N bytes
Determine output status
Write 1 byte
Write N bytes

Adding operations such as Open, Close, Delete,
Rename, and Append would allow for more complex
devices such as floppy or hard disks.
A I0CB

is

an

array

with

the

following

I0CB
I0CB
IO0CB
I0CB
I0CB
I0CB
IOCB

+
+
+
+
+
+
+

=
=
=
=
=
=
=

O
1
2
3
4
5
6

consisting

of

elements

form:

Device Number
Operation Number
Status
High byte of buffer address
Low byte of buffer address
High byte of buffer Length
Low byte of buffer length

The device table is implemented as a linked
List. Two routines maintain the list: INITDL,
which initializes it to empty, and INSDL,
which inserts a device into it.
A device table entry has the following form:

FHF
HE
+t
KH
SF
HK
HF
+
FF

DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL
DVTBL

+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+

O =
1 =
2 =
3 =
4 =
5 =
6 =
7 =
8 =
9 =
10=
11=
12=
13=
14=
15=

High byte of Link field
Low byte of Link field
Device Number
High byte of device initialization
Low byte of device initialization
High byte of input status routine
Low byte of input status routine
High byte of input 1 byte routine
Low byte of input 1 byte routine
High byte of input N bytes routine
Low byte of input N bytes routine
High byte of output status routine
Low byte of output status routine
High byte of output 1 byte routine
Low byte of output 1 byte routine
High byte of output WN bytes routine

280

Assembly language subroutines for the 6809
DVTBL
Entry:

+

16=

Low

byte

of

output

N bytes

Register
Register

X =
A =

Base address of I0CB
For write 1 byte, contains
data (no buffer is used).

Register

A =

routine

the

Copy of the IOCB status byte
Except contains the data for
read 1 byte (no buffer is used).
Status byte of IO0CB is 0 if the operation was
completed successfully; otherwise, it contains
the error number.

Exit:

Status
0
1
2
3

value

Description
No errors
Bad device number
Bad operation number
Input data available

device
Registers

Used:

or

output

ready

ALL

Time:

75 cycles
device in
requested

overhead
the List

Size:

Program
Data

78 bytes
5 bytes

plus 23 cycles for each
which is not the one

HH
FF
HE
He
ee
+e
HF
H
F
+e

*IOCB AND DEVICE TABLE EQUATES
IOCB DEVICE NUMBER
IOCBDN
EQU
IO0CB OPERATION NUMBER
IOCBOP
EQU
I0CB STATUS
IOCBST
EQU
I0CB BUFFER BASE ADDRESS
IOCBBA
EQU
I0CB BUFFER LENGTH
IOCBBL
EQU
DEVICE TABLE LINK FIELD
DTLNK
EQU
DEVICE TABLE DEVICE NUMBER
DTDN
EQU
BEGINNING OF DEVICE TABLE SUBROUTINES
DTSR
EQU
*OPERATION NUMBE
NUMBER OF OPERATIONS
NUMOP
EQU
INITIALIZATION
INIT
EQU
INPUT STATUS
ISTAT
EQU
READ 1 BYTE
RIBYTE
EQU
READ N BYTES
RNBYTE
EQU
OUTPUT STATUS
OSTAT
EQU
WRITE 1 BYTE
WIBYTE
EQU
WRITE
N BYTES
WNBYTE
EQU
ON
RBA
O&O
=
RaVU’PWN
DWWNOUNWN
*STATUS VALUES
NO ERRORS
NOERR
EQU
BAD DEVICE NUMBER
DEVERR
EQU
BAD OPERATION NUMBER
OPERR
EQU
INPUT DATA AVAILABLE OR OUTPUT DEVICE
©
—
WN
DEVRDY
EQU
IOHDLR:
*

*SAVE

IOCB

ADDRESS

AND

DATA

(CIF

ANY)

READY

8E

1/O device table handler (IOHDLR)

281

*

STX
IOCBA
SAVE IOCB ADDRESS
STA
BDATA
SAVE DATA BYTE FOR WRITE 1 BYTE
*
*INITIALIZE STATUS BYTE TO INDICATE NO ERRORS
*
LDA
#NOERR
STATUS = NO ERRORS
STA
IOCBST,X
SAVE STATUS IN IOCB
*
*CHECK FOR VALID OPERATION NUMBER CWITHIN LIMIT)
*
LDB
IOCBOP,X
GET OPERATION NUMBER FROM IOCB
CMPB
#NUMOP
IS OPERATION NUMBER WITHIN LIMIT?
BCC
BADOP
JUMP IF OPERATION NUMBER TOO LARGE
*

*SEARCH DEVICE LIST FOR THIS DEVICE
*
LDA
IOCBDN,X
GET IOCB DEVICE
LOX
DVLST
GET FIRST ENTRY
*
*X = POINTER TO DEVICE LIST
*B = OPERATION NUMBER
*A = REQUESTED DEVICE NUMBER

NUMBER
IN DEVICE

LIST

*

SRCHLP:
*CHECK IF AT END OF DEVICE LIST (LINK FIELD = 0000)
CMPX
#0
TEST LINK FIELD
BEQ
BADDN
BRANCH IF NO MORE DEVICE ENTRIES
*
*CHECK IF CURRENT ENTRY IS DEVICE IN IOCB
*
CMPA
DTDN,X
COMPARE DEVICE NUMBER, REQUESTED
BEQ
FOUND
BRANCH IF DEVICE FOUND
*
*DEVICE NOT FOUND, SO ADVANCE TO NEXT DEVICE
* TABLE ENTRY THROUGH LINK FIELD
* MAKE CURRENT DEVICE = LINK
*
LDX
7X
CURRENT ENTRY = LINK
BRA
SRCHLP
CHECK NEXT ENTRY IN DEVICE TABLE
*
*FOUND DEVICE,
SO VECTOR TO APPROPRIATE ROUTINE IF ANY
*B = OPERATION NUMBER IN IOCB
*

DEVICE

FOUND:

*GET
ASLB

ROUTINE

ADDB

#DTSR

LDX
BEQ
PSHS
LDA
LDX
RTS

B,X
BADOP
X
BDATA
IOCBA

ADDRESS

(ZERO INDICATES INVALID OPERATION)
MULTIPLY OPERATION NUMBER TIMES 2 TO
* INDEX INTO TABLE OF 16~-BIT ADDRESSES
ADD OFFSET TO START OF SUBROUTINE
* ADDRESSES
GET SUBROUTINE ADDRESS
JUMP IF OPERATION INVALID CADDRESS = QO)
SAVE SUBROUTINE ADDRESS ON STACK
A = DATA BYTE FOR WRITE 1 BYTE
GET BASE ADDRESS OF IOCB
GOTO SUBROUTINE

282

Assembly language subroutines for the 6809

BADDN:
LDA
BRA

#DEVERR
EREXIT

ERROR

CODE

LDA

#OPERR

ERROR

LDX
STA
RTS

IOCBA
IOCBST,X

POINT TO IOCB
SET STATUS BYTE

--

NO

SUCH

DEVICE

BADOP:

CODE

--

NO

SUCH

OPERATION

EREXIT:
IN

IOCB

RHR KKK KKREEREEKREREEEKIEKIEARIIEEEE
KKK
*ROUTINE:
INITDL
*PURPOSE:
INITIALIZE DEVICE LIST TO EMPTY
*ENTRY: NONE
*EXIT:
DEVICE LIST SET TO NO ITEMS
*REGISTERS USED: X
FoI KI I IIIT II III IIA IIIS IIII III IIIA EEA ERK EE
INITDL:
*INITIALIZE DEVICE
LDX
#0
STX
DVLST
RTS

LIST

HEADER
HEADER

TO O TO INDICATE
= O (EMPTY LIST)

HH KKK KEK IIE ERE RIKKI KERIKERI
KERR
*ROUTINE:
INSDL
*PURPOSE:
INSERT DEVICE INTO DEVICE LIST
*ENTRY: REGISTER X = ADDRESS OF DEVICE TABLE
*EXIT:
DEVICE INSERTED INTO DEVICE LIST
*REGISTERS USED: U,X
FI I IKI KIKI III III KIS II ISIS IIIS IAEA AKER EKER

NO

DEVICES

ENTRY

INSDL:
LDU
STU
STX
RTS
*
*DATA SECTION
IOCBA:
RMB
DVLST:
RMB
BDATA:
RMB

DVLST
7X
DVLST

GET CURRENT HEAD OF DEVICE LIST
STORE CURRENT HEAD OF DEVICE LIST
MAKE DVLST POINT TO NEW DEVICE

2
2
1

BASE ADDRESS OF IOCB
DEVICE LIST HEADER
DATA BYTE FOR WRITE 1 BYTE

*
*
SAMPLE EXECUTION:
*
*CHARACTER EQUATES
CR
EQU
$0D
LF
EQU
$OA
SC8E:

CARRIAGE RETURN CHARACTER
LINE FEED CHARACTER

8E

1//O device table handler (IOHDLR)

*INITIALIZE DEVICE
JSR
INITDL

LIST

*SET
LDX
JSR
LDA
STA
LDA
STA
LDX
JSR

UP

CONSOLE AS
#CONDV
INSDL
#INIT
IOCBOP,X
#1
IOCBDN,X
#10CB
IOHDLR

DEVICE

*SET
LDX
JSR
LDA
STA
LDA
STA
LOX
JSR

UP

PRINTER AS
#PRTDV
INSDL
#INIT
IOCBOP,X
#2
IOCBDN,X
#I0CB
IOHDLR

DEVICE

CREATE

EMPTY

283

DEVICE

LIST

1 AND INITIALIZE IT
POINT TO CONSOLE DEVICE ENTRY
ADD CONSOLE TO DEVICE LIST
INITIALIZE OPERATION
DEVICE

NUMBER

INITIALIZE

=

1

CONSOLE

2 AND INITIALIZE IT
POINT TO PRINTER DEVICE ENTRY
ADD PRINTER TO DEVICE LIST
INITIALIZE OPERATION

DEVICE

NUMBER

INITIALIZE

=

2

PRINTER

*

*LOOP
* THE
*

READING
CONSOLE

LINES FROM CONSOLE, AND ECHOING THEM TO
AND PRINTER UNTIL A BLANK LINE IS ENTERED

TSTLP:
LDX
LDY
STY
LDA
STA
LDA
STA
LDY
STY
JSR

#I0CB
#BUFFER
IOCBBA,X
#1
IOCBDN,X
#RNBYTE
I0CBOP,X
#LENBUF
IOCBBL,X
IOHDLR

POINT TO IOCB
POINT TO BUFFER
SAVE BUFFER ADDRESS IN I0CB
DEVICE NUMBER = 1 (CONSOLE)
OPERATION

IS

READ

N BYTES

SET BUFFER LENGTH TO LENBUF
READ LINE FROM CONSOLE

*

*STOP
*
LDX
LDY
BEQ

IF

LINE

LENGTH

IS

#10CB
IOCBBL,X
SC8END

0
POINT TO IOCB
GET LINE LENGTH
BRANCH CEXIT) IF

LINE

LENGTH

*

*SEND
*
LDA
STA
LDA
JSR

CARRIAGE

RETURN

#W1IBYTE
IOCBOP,X
#CR
IOHDLR

TO

CONSOLE
OPERATION IS
SAVE IN IOCB
CHARACTER IS
WRITE 1 BYTE

*

*ECHO
*
LDX

LINE

TO

#10CB

CONSOLE
POINT

TO

IOCB

WRITE

1 BYTE

CARRIAGE RETURN
(CLINE FEED)

IS

0

284

Assembly language subroutines for the 6809
LDA
STA
LDA
STA
JSR
*
*ECHO
*
LDX
LDA
STA
LDA
STA
JSR
*
*SEND
*
LDX
LDA
STA
LDA
JSR

OPERATION = WRITE N BYTES
SAVE OPERATION NUMBER IN I0OCB
DEVICE NUMBER = CONSOLE
SAVE DEVICE NUMBER IN IOCB
WRITE N BYTES ON CONSOLE

#WNBYTE
IOCBOP,X
#1
IOCBDN,X
IOHDLR
LINE

TO

PRINTER

POINT TO IO0CB
OPERATION = WRITE N BYTES
SAVE OPERATION NUMBER IN IOCB
DEVICE NUMBER = PRINTER
SAVE DEVICE NUMBER IN IOCB
WRITE N BYTES ON PRINTER

#I10CB
#WNBYTE
IOCBOP,X

#1
IOCBDN,X
IOHDLR
LINE

FEED

TO

PRINTER

#10CB
#WIBYTE
IOCBOP,X
#LF
IOHDLR

POINT TO IOCB
OPERATION = WRITE 1 BYTE
SAVE OPERATION NUMBER IN IOCB
CHARACTER IS LINE FEED
SEND LINE FEED TO PRINTER

BRA

TSTLP

LOOP

BRA

SC8E

REPEAT

DATA

SECTION

TO

READ

NEXT

LINE

SC8END:

*
*
*
LENBUF
BUFFER

*I0CB
IOCB:

EQU
RMB

127
LENBUF

FOR PERFORMING I0
RMB
1
RMB
1
RMB
1
FDB
BUFFER
RMB
2

*DEVICE
CONDV:

TABLE
FDB
FCB
FDB
FDB
FDB
FDB
FDB
FDB
FDB

PRTDV:

FDB
FCB
FDB
FDB
FDB

I/0
I/0

TEST

BUFFER
BUFFER

LENGTH

DEVICE NUMBER
OPERATION NUMBER
STATUS
BUFFER ADDRESS
BUFFER LENGTH

ENTRIES

LINK FIELD
DEVICE 1
CONSOLE INITIALIZE
NO CONSOLE INPUT STATUS
NO CONSOLE INPUT 1 BYTE
CONSOLE INPUT N BYTES
NO CONSOLE OUTPUT STATUS
CONSOLE OUTPUT 1 BYTE
CONSOLE OUTPUT N BYTES
LINK FIELD
DEVICE 2
PRINTER INITIALIZE
NO PRINTER INPUT STATUS
NO PRINTER INPUT 1 BYTE

8E
FDB
FDB
FDB
FDB

*
*
*
BDRATE
*
B2400
CLRSCN
*
KBDPTR
*
*
*
OUTPTR
*
*
*
PRDVNO
UNITNO
*

RADIO

1//O device table handler (IOHDLR)
0
0
OUT
POUTN

SHACK

NO PRINTER INPUT N BYTES
NO PRINTER OUTPUT STATUS
PRINTER OUTPUT 1 BYTE
PRINTER OUTPUT N BYTES

TRS-80

EQU

$0096

EQU
EQU

18
$A928

EQU

$A000

EQU

$A002

EQU
EQU

SFE
$SOO6F

285

COLOR

COMPUTER

EQUATES

MEMORY LOCATION CONTAINING OUTPUT
BAUD RATE
VALUE CORRESPONDING TO 2400 BAUD
STARTING ADDRESS FOR ROUTINE
THAT CLEARS SCREEN
POINTER TO KEYBOARD INPUT ROUTINE
(CHARACTER ENDS UP IN REGIRSTER
ZERO FLAG = 1 IF NO CHARACTER,
O IF CHARACTER
POINTER TO OUTPUT ROUTINE
UNIT NUMBER GOES IN LOCATION
SOO6F (O = SCREEN)
CHARACTER GOES IN REGISTER A
PRINTER DEVICE NUMBER
MEMORY LOCATION CONTAINING UNIT
NUMBER FOR OUTPUT ROUTINE
(O = SCREEN)

*

KREKKKEKREKKKEEKEKEKKEKKEKKEKRKKKRKKRKKKEKKREK

*CONSOLE I/0 ROUTINES
KKK
KKK KEKE KEEKKERERKKKKK
*CONSOLE
CINIT:

INITIALIZE

JSR
RTS
*CONSOLE
CINN:

READ
LDU
PSHS
LDU
LDY

CLRSCN

CLEAR SCREEN
RETURN

1 BYTE
IOCBBL,X
U
IOCBBA,X
#0

GET BUFFER LENGTH
SAVE BUFFER LENGTH IN STACK
POINT TO DATA BUFFER
INITIALIZE BYTE COUNTER TO QO

*

*LOOP
*
JSR
BEQ
CMPA
BEQ
STA
LEAY
CMPY
BNE

READING

BYTES

UNTIL

CKBDPTR]I
CIN
#CR
CREXIT
,U+
1,Y
,s
CIN
STACK

AND

BUFFER

IS

FULL

POLL KEYBOARD
LOOP UNTIL A KEY IS READ
CHECK FOR CARRIAGE RETURN
BRANCH CEXIT) IF CARRIAGE RETURN
SAVE BYTE IN DATA BUFFER
INCREMENT BYTE COUNT
CHECK IF BUFFER FULL
BRANCH (LOOP) IF BUFFER NOT FULL

*

*CLEAN
*

DATA

EXIT

A)

286

Assembly language subroutines for the 6809

CREXIT:

*CONSOLE
COUT:

*CONSOLE
COUTN:

OF

BYTES

READ

SET UNIT NUMBER
WRITE BYTE

FOR

CONSOLE

(0)

UNITNO

SET

FOR

CONSOLE

(0)

LDY
LDX

IOCBBL,X
IOCBBA,X

GET NUMBER OF
POINT TO DATA

LDA
JSR
LEAY
BNE
RTS

Xt
COUTPTRI
-1,Y
CWLOOP

GET NEXT DATA BYTE
WRITE BYTE
DECREMENT BYTE COUNT
CONTINUE THROUGH N BYTES
RETURN

STY
LEAS
RTS

IOCBBL,X
2,58

WRITE

1 BYTE

CLR
JSR
RTS

UNITNO
COUTPTRI

WRITE

N BYTES

CLR

SAVE NUMBER
CLEAN STACK
EXIT

UNIT

NUMBER

OUTPUT:
BYTES TO
BUFFER

WRITE

CWLOOP:

RAEKEKEKEKKEKEKRKEKKEKKKKKKKKKKKKK
KKK

*PRINTER

ROUTINES

REEKKKEKKKKKKKKKKKKKKKKKRK
KKK KKK

*PRINTER
PINIT:

*PRINTER
POUT:

*PRINTER
POUTN:

INITIALIZE

LDB
STB
RTS

#B2400
BDRATE

OUTPUT

1 BYTE

LDB
STB
JSR
CLR
RTS

#PRDVNO
UNITNO
COUTPTRI
UNITNO

OUTPUT

N BYTES

LDB
STB
JSR
CLR
RTS

#PRDVNO
UNITNO
OUTPUT
UNITNO

END

SET PRINTER TO
SAVE BAUD RATE

2400

BAUD

GET PRINTER DEVICE NUMBER
SAVE AS UNIT NUMBER
WRITE 1 BYTE
RESTORE UNIT NUMBER TO CONSOLE

(0)

GET PRINTER DEVICE NUMBER
SAVE AS UNIT NUMBER
WRITE LINE
RESTORE UNIT NUMBER TO CONSOLE

(0)

8F

Initialize 1/O ports (IPORTS)

287

8F Initialize 1/O ports
(IPORTS)
Initializes a set of I/O ports from an array of port device addresses and
data values. Examples are given of initializing the common 6809 programmable I/O devices: 6820 or 6821 Peripheral Interface Adapter
(PIA), 6840 Programmable Timer Module (PTM), and 6850 Asynchronous Communications Interface Adapter (ACIA).
This subroutine provides a generalized method for initializing I/O
sections. The initialization may involve data ports, data direction registers that determine whether bits are inputs or outputs, control or command registers that determine the operating modes of programmable
devices, counters (in timers), priority registers, and other external registers or storage locations.
Tasks the user may perform with this routine include:
Assign bidirectional I/O lines as inputs or outputs.
Put initial values in output ports.
Enable or disable interrupts from peripheral chips.
Determine operating modes, such as whether inputs are latched,
awpm

whether strobes are produced, how priorities are assigned, whether
timers operate continuously or only on demand, etc.
5.

Load starting values into timers and counters.

6.

Select bit rates for communications.

7. Clear or reset devices that are not tied to the overall system reset
line.

8. Initialize priority registers or assign initial priorities to interrupts or
other operations.
9. Initialize vectors used in servicing interrupts, DMA requests, and
other inputs.

Procedure ‘The program loops through the specified number of ports,
obtaining each port’s memory address and initial value from the array
and storing the value in the address. This approach does not depend on
the number or type of devices in the I/O section. The user may add or
delete devices or change the initialization by changing the array rather
than the program.
Each array entry consists of the following:

288

Assembly language subroutines for the 6809

1.

More significant byte of port’s memory address.

2.

Less significant byte of port’s memory address.

3.

Initial value to be sent to port.

Entry conditions

Base address of array of port addresses and initial values in register X
Number of entries in array (number of ports to initialize) in register A

Exit conditions

All data values sent to port addresses

Example

Data:

Result:

Number of ports to initialize = 3
Array elements are:
More significant byte of port 1’s memory address
Less significant byte of port 1’s memory address
Initial value for port 1
More significant byte of port 2’s memory address
Less significant byte of port 2’s memory address
Initial value for port 2
More significant byte of port 3’s memory address
Less significant byte of port 3’s memory address
Initial value for port 3
Initial value for port 1 stored in port 1 address
Initial value for port 2 stored in port 2 address
Initial value for port 3 stored in port 3 address

Note that each element consists of 3 bytes containing:
More significant byte of port’s memory address
Less significant byte of port’s memory address
Initial value for port

Registers used

A,B,CC, U, X

8F

Initialize I/O ports (IPORTS)

Execution time

289

10 cycles overhead plus 23 x N cycles for each port

entry. If, for example, NUMBER

OF PORT ENTRIES

= 10, execu-

tion time is
10 + 10 X 23 = 10 + 230 = 240 cycles

Program size

13 bytes plus the size of the table (3 bytes per port)

Data memory required

None

Title
Name:

Initialize
IPORTS

Purpose:

Initialize I/0 ports from
addresses and values.

an

array

Entry:

Register

of

array

The

Exit:

I/0

X =

Ports

Base

address

of

port

array consists of 3 byte elements
array+0O = High byte of port 1 address
array+1 = Low byte of port 1 address
arrayt+2
Value to store in port 1 address
array+3
High byte of port 2 address
array+4 = Low byte of port 2 address
array+5 = Value to store in port 2 address

None

Registers

Used:

A,B,CC,U,X

Time:

10 cycles overhead plus 23 * N cycles for
each port, where N is the number of bytes.

Size:

Program

HH
He
HK
HF
F
H
&
+

*

13

bytes

IPORTS:
*
*EXIT
*
TSTA
BEQ
x
*LOOP
*

IMMEDIATELY

IF

NUMBER

PORTS

IS

ZERO

TEST NUMBER OF PORTS
BRANCH IF NO PORTS TO

EXITIP
INITIALIZING

OF

PORTS

INITPT:
LDU

7X+4+

GET

NEXT

PORT

ADDRESS

INITIALIZE

290

Assembly language subroutines for the 6809
LDB
STB
DECA
BNE
*
*EXIT
*

Xt
,U
INITPT

GET VALUE TO SEND THERE
SEND VALUE TO PORT ADDRESS
COUNT PORTS
CONTINUE UNTIL ALL PORTS INITIALIZED

EXITIP:
RTS
*
*
*

SAMPLE

EXECUTION:

*
*INITIALIZE
*
6820/6821 PIA (PERIPHERAL INTERFACE ADAPTER)
*
6850 ACIA CASYNCHRONOUS COMMUNICATIONS INTERFACE
*
6840 PTM (PROGRAMMABLE TIMER MODULE)
*
*ARBITRARY DEVICE MEMORY ADDRESSES
*
*
6820/6821 PIA ADDRESSES
*
PIADRA
PIACRA
PIADRB
PIACRB

EQU
EQU
EQU
EQU

$A400
$A401
$A402
$A403

PTM

ADDRESSES

EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU

$A100
$A101
$A102
$A103
$A104
$A105
$A106
$A107

ACIA

ADDRESSES

EQU
EQU
EQU

ADAPTER)

6821
6821
6821
6821

PIA
PIA
PIA
PIA

DATA REGISTER A
CONTROL REGISTER
DATA REGISTER B
CONTROL REGISTER

6840
6840
6840
6840
6840
6840
6840
6840

PTM
PTM
PTM
PTM
PTM
PTM
PTM
PTM

CONTROL
CONTROL
TIMER 1
TIMER 1
TIMER 2
TIMER 2
TIMER 3
TIMER 3

$A200
$A201
$A201

6850
6850
6850

ACIA
ACIA
ACIA

DATA REGISTER
CONTROL REGISTER
STATUS REGISTER

LDX

BEGPIN

LDA
JSR
BRA

SZINIT
IPORTS
SC8F

GET BASE ADDRESS OF INITIALIZATION
* ARRAY
GET SIZE OF ARRAY IN BYTES
INITIALIZE PORTS
REPEAT TEST

A
B

*

*
*

6840

PTMC13
PTMCR2
PTM1MS
PTMILS
PTM2MS
PTM2LS
PTM3MS
PTM3LS

REGISTERS 1,3
REGISTER 2
MSB
LSB
MSB
LSB.
MSB
LSB

*

*
6850
*
ACIADR’
ACIACR
ACIASR'
SC8F:

PINIT:
*
*INITIALIZE

6820

OR

6821

PERIPHERAL

INTERFACE

ADAPTER

(PIA)

8F

Initialize l/O ports (IPORTS)

291

*
*
PORT A = INPUT
*
CA1 = DATA AVAILABLE, SET ON LOW TO HIGH TRANSITION,
*
NO INTERRUPTS
*
CA2 = DATA ACKNOWLEDGE HANDSHAKE
*
FDB
PIACRA
PIA CONTROL REGISTER A ADDRESS
FCB
200000000
INDICATE NEXT ACCESS TO DATA
* DIRECTION REGISTER (SAME ADDRESS
* AS DATA REGISTER)
FDB
PIADRA
PIA DATA DIRECTION REGISTER A ADDRESS
FCB
200000000
ALL BITS INPUT
FDB
PIACRA
PIA CONTROL REGISTER A ADDRESS
FCB
200100110
* BITS 7,6 NOT USED
* BIT 5 = 1 TO MAKE CA2 OUTPUT
* BIT 4 = 0 TO MAKE CA2 A PULSE
* BIT 3 = 0 TO MAKE CA2 INDICATE
*
DATA REGISTER FULL
* BIT 2 = 1 TO ADDRESS DATA REGISTER
* BIT 1 = 1 TO MAKE CA1 ACTIVE
*
LOW-TO-HIGH
* BIT 0 = O TO DISABLE CA1 INTERRUPTS
*
*
PORT B = OUTPUT
*
CB1 = DATA ACKNOWLEDGE, SET ON HIGH TO LOW TRANSITION,
*
NO INTERRUPTS
*
CB2 = DATA AVAILABLE, CLEARED BY WRITING TO DATA
*
REGISTER B, SET TO 1 BY HIGH TO LOW TRANSITION ON CB1
*
FDB
PIACRB
PIA CONTROL REGISTER B ADDRESS
FCB
200000000
INDICATE NEXT ACCESS TO DATA
* DIRECTION REGISTER (SAME ADDRESS
* AS DATA REGISTER
FDB
PIADRB
PIA DATA DIRECTION REGISTER B ADDRESS
FCB
411111111
ALL BITS OUTPUT
FDB
PIACRB
PIA CONTROL REGISTER B ADDRESS
FCB
400100100
* BITS 7,6 NOT USED
BIT 5 = 1 TO MAKE CB2 OUTPUT
BIT 4 = Q TO MAKE CB2 A PULSE
BIT 3
0 TO MAKE CB2 INDICATE
DATA REGISTER FULL
BIT 2 = 1 TO ADDRESS DATA REGISTER
BIT 1 = 0 TO MAKE CB2 ACTIVE
HIGH-TO-LOW
£€ BIT
HF
+e
€
+
0 = 0 TO DISABLE CB1 INTERRUPTS
*

*INITIALIZE 6850 ASYNCHRONOUS COMMUNICATIONS
CACIA OR UART)
*
*
*
8 BIT DATA, NO PARITY
*
1 STOP BIT
*
DIVIDE MASTER CLOCK BY 16
*
NO INTERRUPTS
*

INTERFACE

ADAPTER

292

Assembly language subroutines for the 6809
FDB
FCB

ACIACR
%00000011

FDB
FCB

ACIACR
400010101

ACIA CONTROL REGISTER ADDRESS
PERFORM MASTER RESET
* 6850 HAS NO RESET INPUT
ACIA CONTROL REGISTER ADDRESS
* BIT 7 = 0 TO DISABLE
RECEIVE INTERRUPTS
BIT 6 = 0 TO MAKE RTS LOW
BIT 5 = 0 TO DISABLE
TRANSMIT INTERRUPTS
BIT 4 = 1 TO SELECT 8-BIT DATA
BIT 3 = 0 FOR NO PARITY
BIT 2 = 1 FOR 1 STOP BIT
BIT 1 = 0, BIT 0 = 1 TO
&€
+
DIVIDE MASTER CLOCK BY 16

*

*INITIALIZE
*

k
*
k
*
*
*
*

6840

PROGRAMMABLE

TIMER

MODULE

(PTM)

CLEAR ALL TIMER COUNTERS
RESET TIMERS
|
OPERATE TIMER 2 IN CONTINUOUS MODE, DECREMENTING COUNTER
AFTER EACH CLOCK CYCLE
SET TIME CONSTANT TO 12 CLOCK CYCLES
THIS GENERATES A SQUARE WAVE WITH PERIOD 2 * (12 + 1)
= 26 CYCLES

*

*
*
*
x
*

THIS INITIALIZATION PRODUCES A 2400 HZ CLOCK FOR USE
IN DIVIDE BY 16 DATA TRANSMISSION
IT ASSUMES A 1 MHZ SYSTEM CLOCK, SO A PERIOD OF
(1,000,000)/(16*2400) = 26 CYCLES WILL GENERATE
A 38,400 (16%*2400) HZ SQUARE WAVE

*

FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB
FDB
FCB

PTM1MS
0
PTM1ILS
0
PTM2MS
0
PTM2LS
0
PTM3MS
0
PTM3LS
0
PTMCR2
%00000001
PTMC13
%00000001
PTMC13
0
PTMCR2
%~10000010

PTM TIMER 1 MS BYTE
CLEAR TIMER 1 MS BYTE
PTM TIMER 1 LS BYTE
CLEAR TIMER 1 LS BYTE
PTM TIMER 2 MS BYTE
CLEAR TIMER 2 MS BYTE
PTM TIMER 2 LS BYTE
CLEAR TIMER 2 LS BYTE
PTM TIMER 3 MS BYTE
CLEAR TIMER 3 MS BYTE
PTM TIMER 3 LS BYTE
CLEAR TIMER 3 LS BYTE
PTM TIMER 2 CONTROL REGISTER
ADDRESS TIMER 1 CONTROL REGISTER
PTM TIMER 1,3 CONTROL REGISTER
RESET TIMERS
PTM TIMER 1,3 CONTROL REGISTER
REMOVE RESET
PTM TIMER 2 CONTROL REGISTER
* BIT 7 = 1 TO PUT SQUARE
*
WAVE OUTPUT ON 02
* BIT 6 = 0 TO DISABLE INTERRUPT
* BIT 5 = 0 FOR PULSE MODE
* BIT 4 = 0 TO INITIALIZE COUNTER
*
ON WRITE TO LATCHES

8F

ENDPIN:
BEGPIN:
SZINIT:

Initialize I/O ports (IPORTS)

FCB
FDB
FCB
FDB

PTM2MS
0
PTM2LS
12

FDB
FCB

PINIT
CENDPIN-PINIT)/3

* BIT 3
O FOR CONTINUOUS OPERATION
* BIT 2
0 FOR 16-BIT OPERATION
* BIT 1 = 1 TO USE CPU CLOCK
* BIT 0 = O TO ADDRESS CONTROL
*
REGISTER 3
PTM TIMER 2 MS BYTE
MS BYTE OF COUNT
PTM TIMER 2 LS BYTE
LS BYTE OF COUNT
END OF ARRAY
BASE ADDRESS OF ARRAY
NUMBER OF PORTS TO INITIALIZE

293

294

Assembly language subroutines for the 6809

8G Delay milliseconds
(DELAY)
Provides a delay of between 1 and 256 ms, depending on the parameter
supplied. A parameter value of 0is interpreted as 256) The user must
calculate the value CPMS (cycles per millisecond) ‘to fit a particular
computer. Typical values are 1000 for a 1 MHz clock“and 2000 for a 2
MHz clock.

Procedure The program simply counts down register X for the appropriate amount of time as determined by the user-supplied constant.
Extra instructions account for the call (JSR) instruction, return instruction, and routine overhead without changing anything.

Entry conditions

Number of milliseconds to delay (1 — 256) in register A

Exit conditions

Returns after the specified number of milliseconds with all registers
except the condition code register unchanged

Example
Data:
Result:

(A) = number of milliseconds = 2Ai6 = 4210
Software delay of 2Ai6 (4210) milliseconds, assuming that
user supplies the proper value of CPMS

Registers used

CC

Execution time

1 ms xX (A)

Program size

31 bytes

8G

Delay milliseconds (DELAY)

Data memory required

Special case
*
*

295

None

(A) = Ocauses a delay of 256 ms.

Title
Name:

Delay

Purpose:

Delay

Entry:

Register A = number of milliseconds
A 0 equals 256 milliseconds

Exit:

Returns to calling
specified delay.

Milliseconds

DELAY

*

*

from

1 to

256

milliseconds

*

*
*

to

*

*
*

routine

after

the

*

*

Registers

Used:

cc

*

*

Time:

1 millisecond

Size:

Program

*

Register

A

*

*

54

bytes

*

*EQUATES
*CYCLES PER
*
CPMS
EQU

MILLISECOND
1000

-

USER-SUPPLIED

*1000
*2000
*

=

1 MHZ
2 MHZ

CLOCK
CLOCK

*

MFAC

EQU

CPMS/20

MFACM

EQU

MFAC-4

MULTIPLYING FACTOR FOR ALL
* EXCEPT LAST MILLISECOND
MULTIPLYING FACTOR FOR LAST
* MILLISECOND

*
*METHOD:
* THE ROUTINE IS DIVIDED INTO 2 PARTS. THE CALL TO
* THE "DLY' ROUTINE DELAYS EXACTLY 1 LESS THAN THE
* NUMBER OF REQUIRED MILLISECONDS.
THE LAST ITERATION
* TAKES INTO ACCOUNT THE OVERHEAD TO CALL "DELAY" AND
* "DLY'.
THIS OVERHEAD IS 78 CYCLES.
*
D ELAY:
*
*DO ALL BUT THE LAST MILLISECOND
*
PSHS
D,X
SAVE REGISTERS
LDB
#MFAC
GET MULTIPLYING FACTOR
DECA
REDUCE NUMBER OF MS BY 1
MUL
MULTIPLY FACTOR TIMESCMS
TFR
D,X
TRANSFER LOOP COUNT TO X
JSR
DLY

- 1)

delay.

296

Assembly language subroutines for the 6809
*

*ACCOUNT FOR 80 MS OVERHEAD DELAY BY REDUCING
* LAST MILLISECOND'S COUNT
*
LDX
#MFAC1
GET REDUCED COUNT
JSR
DLY
DELAY LAST MILLISECOND
PULS
D,X
RESTORE REGISTERS
RTS

KHKKKKEKREKKEREKRKEKEREKREERKAK
RK
*ROUTINE: DLY
*PURPOSE: DELAY ROUTINE
*ENTRY: REGISTER X = COUNT
*EXIT:
REGISTER X = OQ
*REGISTERS USED: X
KHEKKKKKKKKKKKKEEREREKKKARRRAKKE
DLY:
DLY1:
DLY2:
DLY3:
DLY4:

BRA
BRA
BRA
BRA
LEAX
BNE
RTS

DLY1
DLY2
DLY3
DLY4
-1,X
DLY

+

SAMPLE

EXECUTION:

SC8G:
*
*DELAY 10 SECONDS
*
CALL DELAY 40 TIMES
*
LDB
#40

AT

250

MILLISECONDS

40

TIMES

MILLISECONDS

(28

EACH

HEX)

QTRSCD:
LDA
JSR
DECB
BNE

#250
DELAY

250

QTRSCD

CONTINUE

UNTIL

BRA

SC8G

REPEAT

OPERATION

END

PROGRAM

(FA HEX) -

DONE

g Interrupts

9A Unbuffered interrupt-driven input/output
using a 6850 ACIA
(SINTIO)
Performs interrupt-driven input and output using a 6850 ACIA (Asynchronous Communications Interface Adapter) and single-character input
and output buffers. Consists of the following subroutines:

1.

INCH reads a character from the input buffer.

2.

INST determines whether the input buffer is empty.

3.

OUTCH writes a character into the output buffer.

4.

OUTST determines whether the output buffer is full.

5.

INIT initializes the 6850 ACIA,

the interrupt vectors, and the

software flags. The flags indicate when data can be transferred between
the main program and the interrupt service routines.

6. IOSRVC determines which interrupt occurred and provides the
proper input or output service. In response to the input interrupt, it
reads a character from the ACIA into the input buffer. In response to
the output interrupt, it writes a character from the output buffer into the
ACIA.

297

298

Assembly language subroutines for the 6809
Procedures

1.

INCH waits for a character to become available, clears the Data

Ready flag (RECDF), and loads the character into register A.

2.

INST sets the Carry flag from the Data Ready flag (RECDF).

3. OUTCH waits for the output buffer to empty, stores the character
in the buffer, and sets the Character Available flag (TRNDF).

4. OUTST
(TRNDF).

sets the Carry flag from the Character Available flag

5. INIT clears the software flags, resets the ACIA (a master reset,
since the device has no reset input), and determines the ACIA’s operating mode by placing the appropriate value in its control register. INIT
starts the ACIA with input interrupts enabled and output interrupts
disabled. See Subroutine 8E for more details about 6850 ACIA
initialization.

6. IOSRVC determines whether the interrupt was an input interrupt
(bit 0 of the ACIA status register = 1), an output interrupt (bit 1 of the
ACIA status register = 1), or the product of some other device. If the
input interrupt occurred, the program reads the data, saves it in memory, and sets the Data Ready flag (RECDF). The lack of buffering
results in the loss of any unread data at this point.
If the output interrupt occurred, the program determines whether
data is available. If not, the program simply disables the output interrupt. If data is available, the program sends it to the ACIA, clears the
Character Available flag (TRNDF), and enables both the input and the
output interrupts.
The special problem with the output interrupt is that it may occur
when no data is available. We cannot ignore it or it will assert itself
indefinitely, creating an endless loop. Nor can we clear an ACIA output
interrupt without sending data to the device. The solution is to disable
output interrupts. But this creates a new problem when data is ready to
be sent. That is, if output interrupts are disabled, the system cannot
learn from an interrupt that the ACIA is ready to transmit. The solution
to this is to create an additional, non-interrupt-driven entry to the
routine that sends a character to the ACIA. Since this entry is not
caused by an interrupt, it must check whether the ACIA’s output
register is empty before sending it a character.
The special sequence
of operations is the following:
1.

Output interrupt occurs before new data is available (i.e. the ACIA

9A

Unbuffered interrupt-driven input/output (SINTIO)

299

becomes ready for data). The response is to disable the output interrupt, since there is no data to be sent. Note that this sequence will not
occur initially, since INIT disables the output interrupt. Otherwise, the
output interrupt would occur immediately, since the ACIA surely starts
out empty and therefore ready to transmit data.

2. Output data becomes available. That is, the system now has data to
transmit. But there is no use waiting for the output interrupt, since it
has been disabled.

3.

The main program calls the routine (OUTDAT), which sends data

to the ACIA. Checking the ACIA’s status shows that it is, in fact, ready

to transmit a character (it told us it was by causing the output interrupt).
The routine then sends the character and re-enables the interrupts.

Unserviceable interrupts occur only with output devices, since input
devices always have data ready to transfer when they request service.
Thus output devices cause more initialization and sequencing problems
in interrupt-driven systems than do input devices.
The solution shown here may, however, result in an odd situation.
Assume that the system has output data but the ACIA is not ready for
it. The system must then wait with interrupts disabled for the ACIA to
become ready. That is, an interrupt-driven system must disable its
interrupts and wait idly, polling the output device. We could solve this
problem with an extra software flag (output interrupt expected). The
service routine would change this flag if the output interrupt occurred
when no data was available. The system could then check the flag and
determine whether the output interrupt had already occurred (see Subroutine 9C).
ae

Entry conditions
1.

INCH: none

2

INST: none

3.

OUTCH: character to transmit in register A

4

OUTST: none

5.

INIT: none

300

Assembly language subroutines for the 6809

Exit conditions
1.

INCH: character in register A

2.

INST: Carry = Oif input buffer is empty, 1 if itis full —

3.

OUTCH: none

4.

OUTST: Carry = 0if output buffer is empty, 1 if it is full

5.

INIT: none

Registers used

1.

INCH: A, CC
INST: A, CC
OUTCH: A, CC

OUTST: A, CC
INIT: A
BF
YS
wr

Execution time
1.

INCH: 40 cycles if a character is available

2.

INST: 12 cycles

3. OUTCH: 87 cycles if the output buffer is empty and the ACIA is
ready to transmit
4.

OUTST: 12 cycles

5.

INIT: 76 cycles

6. IOSRVC: 63 cycles to service an input interrupt, 99 cycles to service
an output interrupt, 42 cycles to determine interrupt is from another
device. Note that it takes the processor 21 cycles to respond to an
interrupt, since it must save all user registers. The execution times given
include these cycles.

Program size

144 bytes

Data memory required

6 bytes anywhere in RAM for the received

9A

Unbuffered interrupt-driven input/output (SINTIO)

301

data (address RECDAT), receive data flag (address RECDF), transmit
data (address TRNDAT), transmit data flag (address TRNDF), and the
address of the next interrupt service routine (2 bytes starting at address

NEXTSR).

eee
Title

Simple interrupt input and output using
ACIA and single character buffers.
SINTIO

Name:

a 6850

+

Purpose:

This program consists of
perform interrupt driven
a 6850 ACIA.

5 subroutines that
input and output using

INCH
Read a character.
INST
Determine input status (whether input
buffer is empty).
OUTCH
Write a character.
OUTST
Determine output status (whether output
buffer is full).
INIT
Initialize.
Entry:

INCH
No parameters.
INST
No parameters.
OUTCH
Register A = character
OUTST
No parameters.
INIT
No

Exit:

INCH
Register A = character.
INST
Carry = 0 if input buffer is
1 if character is available.
OUTCH
No

No

used:

0 if output
is full.

parameters.

INCH
A,CC

A,CC
OUTCH

empty,

parameters

INST
OF
OH
FF
+t
SK
HN
KH
FH
HF
+
FF
FH

transmit

parameters.

OUTST
Carry =
1 if it
INIT

Registers

to

buffer

is

empty,

302

Assembly language subroutines for the 6809
A,CC
OUTST
A,CC
INIT
A
Time:

INCH
40
INST
12

cycles

if

a character

is

available

cycles

OUTCH

87 cycles if output buffer is empty and
the ACIA is ready to transmit
OUTST
12 cycles
INIT
76 cycles
IOSRVC
42 cycles minimum if the interrupt is not
63 cycles to service an input interrupt
99 cycles to service an output interrupt
These include the time required for the
processor to respond to an interrupt
(21 cycles).
Size:

Program
Data

144 bytes
6 bytes

HH
FF
HF
He
EH
KF
FH
F
+F

*ARBITRARY 6850 ACIA MEMORY ADDRESSES
ACIADR'
EQU
$A000
ACIA DATA REGISTER
ACIACR’
EQU
$A001
ACIA CONTROL REGISTER
ACIASREQU
$A001
ACIA STATUS REGISTER
*TRS-80 COLOR COMPUTER INTERRUPT VECTOR
INTVEC
EQU
$010D
VECTOR TO INTERRUPT SERVICE
*
*
*
INCH:

*
*
*
INST:

READ

A CHARACTER

JSR
BCC
CLR
LDA
RTS

INST
INCH
RECDF
RECDAT

DETERMINE

INPUT

LDA
LSRA

RECDF

FROM

INPUT

ROUTINE

BUFFER

GET INPUT STATUS
WAIT IF NO CHARACTER AVAILABLE
INDICATE INPUT BUFFER EMPTY
GET CHARACTER FROM INPUT BUFFER

STATUS

(CARRY

=

1 IF

DATA

AVAILABLE)

GET DATA READY FLAG
SET CARRY FROM DATA READY FLAG
* CARRY = 1 IF CHARACTER AVAILABLE

RTS

*

WRITE

A CHARACTER

INTO

OUTPUT

BUFFER

AND

THEN

ON

TO

ACIA

ours

9A

Unbuffered interrupt-driven input/output (SINTIO)

303

OUTCH:

PSHS

A

SAVE

*WAIT

FOR

OUTPUT

BUFFER

TO

CHARACTER

EMPTY,

STORE

TO

WRITE

NEXT

CHARACTER

WAITOC:
JSR
BCS
PULS
STA
LDA
STA
JSR
RTS

OUTST
WAITOC
A
TRNDAT
#SFF
TRNDF
OUTDAT

*
DETERMINE
*
OUTST:
LDA
LSRA
RTS

OUTPUT

GET OUTPUT STATUS
WAIT IF OUTPUT BUFFER FULL
GET CHARACTER
STORE CHARACTER IN BUFFER
INDICATE BUFFER FULL
SEND

STATUS

(CARRY

TRNDF

CHARACTER

=

1 IF

TO

OUTPUT

PORT

BUFFER

FULL)

GET TRANSMIT FLAG
SET CARRY FROM TRANSMIT FLAG
CARRY = 1 IF BUFFER FULL

*

*INITIALIZE
*
INIT:
*

INTERRUPT

SYSTEM

AND

6850

ACIA

*DISABLE INTERRUPTS DURING INITIALIZATION BUT SAVE
*
PREVIOUS STATE OF INTERRUPT FLAG
*
PSHS
CC
SAVE CURRENT FLAGS (PARTICULARLY
SEI
DISABLE INTERRUPTS DURING
* INITIALIZATION
*

*INITIALIZE
*

TRS-80

LDX
STX

INTVEC
NEXTSR

LDX
STX

#IOSRVC
INTVEC

COLOR

COMPUTER

INTERRUPT

I FLAG)

VECTOR

GET CURRENT INTERRUPT VECTOR
SAVE IT AS ADDRESS OF NEXT SERVICE
* ROUTINE
GET ADDRESS OF OUR SERVICE ROUTINE
SAVE IT AS INTERRUPT VECTOR

*

*INITIALIZE
*

CLR
CLR
CLR

SOFTWARE

RECDF
TRNDF
OIE

*
*INITIALIZE 6850 ACIA
*
LDA
#%00000011
ACIACR
STA
#%10010001
LDA

FLAGS

NO INPUT DATA AVAILABLE
OUTPUT BUFFER EMPTY
INDICATE NO OUTPUT INTERRUPT NEEDED
* 6850 READY TO TRANSMIT INITIALLY
CUART)

MASTER

RESET

ACIA

(IT

INITIALIZE ACIA MODE
*BIT 7 = 1 TO ENABLE

HAS

INPUT

NO

RESET

INPUT).

INTERRUPTS

304

Assembly language subroutines for the 6809
*BITS 6,5 = 0 TO DISABLE OUTPUT INTERRUPTS
*BITS 4,3,2 = 100 FOR 8 DATA BITS, 2 STOP
*
BITS
*BITS 1,0 = 01 FOR DIVIDE BY 16 CLOCK
STA
PULS

ACIACR
CC

RESTORE FLAGS (THIS REENABLES INTERRUPTS
* IF THEY WERE ENABLED WHEN INIT WAS
* CALLED)

RTS

*
*GENERAL
*
IOSRVC:

INTERRUPT

HANDLER

*
*GET ACIA STATUS: BIT 0 = 1 IF AN INPUT INTERRUPT,
*
BIT 1 = 1 IF AN OUTPUT INTERRUPT
*
LDA
ACIASR
GET ACIA STATUS
LSRA
EXAMINE BIT 0
BCS
RDHDLR
BRANCH IF AN INPUT INTERRUPT
LSRA
EXAMINE BIT 1
BCS
WRHDLR
BRANCH IF AN OUTPUT INTERRUPT
JMP
CNEXTSR]
NOT THIS ACIA, EXAMINE NEXT INTERRUPT
*

*INPUT CREAD)
*
RDHDLR:
LDA
STA
LDA
STA
RTI

INTERRUPT

ACIADR
RECDAT
#SFF
RECDF

HANDLER

LOAD
SAVE

DATA
DATA

INDICATE

FROM 6850 ACIA
IN INPUT BUFFER
INPUT

DATA

AVAILABLE

*

*OUTPUT
*
WRHDLR:

(WRITE)

INTERRUPT

LDA
BEQ
JSR
BRA

TRNDF
NODATA
OUTDT1
WRDONE

HANDLER

TEST DATA AVAILABLE FLAG
JUMP IF NO DATA TO TRANSMIT
ELSE SEND DATA TO 6850 ACIA
(NO NEED TO TEST STATUS)

*
*IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE,
* WE MUST DISABLE IT CIN THE 6850) TO AVOID AN ENDLESS LOOP.
LATER,
* WHEN A CHARACTER BECOMES AVAILABLE, WE CALL THE OUTPUT ROUTINE
* QUTDAT WHICH MUST TEST ACIA STATUS BEFORE SENDING THE DATA.
* THE OUTPUT ROUTINE MUST ALSO REENABLE THE OUTPUT INTERRUPT AFTER
* SENDING THE DATA.
THIS PROCEDURE OVERCOMES THE PROBLEM OF AN
* UNSERVICED OUTPUT INTERRUPT ASSERTING ITSELF REPEATEDLY, WHILE
* STILL ENSURING THAT OUTPUT INTERRUPTS ARE RECOGNIZED AND THAT
* DATA IS NEVER SENT TO AN ACIA THAT IS NOT READY FOR IT.
*THE PROBLEM IS THAT AN OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
* THE COMPUTER HAS ANYTHING TO SEND CUNLIKE AN INPUT DEVICE THAT
* HAS DATA WHEN IT REQUESTS SERVICE).

9A

Unbuffered interrupt-driven input/output (SINTIO)

*

NODATA:
LDA

#%410010001

STA

ACIACR

ESTABLISH ACIA OPERATING
* WITH OUTPUT INTERRUPTS

MODE
DISABLED

WRDONE:
RTI
KHKKKRKEKRKKKKEKKEEKEKEEERRAAKK
KKK KKK KK
*ROUTINE: OUTDAT, OUTDT1
COUTDAT IS NON-INTERRUPT
SEND A CHARACTER TO THE ACIA
*PURPOSE:
*ENTRY: TRNDAT = CHARACTER TO SEND
*EXIT:
NONE
*REGISTERS USED: A,CC
HH KKK KE REE EEE IKI
KKK KR KR RR

DRIVEN

ENTRY

POINT)

OUTDAT:
LDA
AND
BEQ

ACIASR
#%00000010
OUTDAT

CAME HERE WITH INTERRUPTS DISABLED
TEST WHETHER ACIA OUTPUT REGISTER EMPTY
BRANCH (WAIT) IF IT IS NOT EMPTY

LDA
STA
CLR
LDA
STA
RTS

TRNDAT
ACIADR
TRNDF
#%10110001
ACIACR

GET THE CHARACTER
SEND CHARACTER TO ACIA
INDICATE OUTPUT BUFFER EMPTY
ESTABLISH ACIA OPERATING MODE
OUTPUT INTERRUPTS ENABLED

*DATA SECTION
*
RECDAT
RMB
RECDF
RMB

1
1

TRNDAT
TRNDF

RMB
RMB

1
1

NEXTSR

RMB

2

RECEIVE DATA
RECEIVE DATA FLAG
*
(0 = NO DATA, FF = DATA AVAILABLE)
TRANSMIT DATA
TRANSMIT DATA FLAG
*
(0 = BUFFER EMPTY, FF = BUFFER FULL)
ADDRESS OF NEXT INTERRUPT SERVICE
*
ROUTINE

OUTDT1:

WITH

*

x
*
SAMPLE EXECUTION:
*
*CHARACTER EQUATES
ESCAPE
EQU
$1B
TESTCH
EQU
"A

ASCII ESCAPE CHARACTER
TEST CHARACTER = A

SC9A:
JSR
CLI
*

INIT

*SIMPLE
* UNTIL
*

EXAMPLE AN ESC IS

JSR

INCH

INITIALIZE 6850 ACIA,
ENABLE INTERRUPTS
READ AND
RECEIVED

ECHO

CHARACTERS

LOOP:
READ

CHARACTER

INTERRUPT

SYSTEM

305

306

Assembly language subroutines for the 6809
PSHS
A
JSR
OUTCH
ECHO CHARACTER
PULS
A
CMPA
#ESCAPE
IS CHARACTER AN ESCAPE?
BNE
LOOP
STAY IN LOOP IF NOT
*
*AN ASYNCHRONOUS EXAMPLE
* OUTPUT "A" TO CONSOLE CONTINUOUSLY BUT ALSO LOOK AT
* INPUT SIDE, READING AND ECHOING ANY INPUT CHARACTERS.
*

ASYNLP:
*

*OUTPUT
*

AN

"A"

.

IF

OUTPUT

IS

NOT

BUSY

JSR
OUTST
IS OUTPUT BUSY?
BCS
ASYNLP
JUMP IF IT IS
LDA
#TESTCH
JSR
OUTCH
OUTPUT TEST CHARACTER
*
*CHECK INPUT PORT
*ECHO CHARACTER IF ONE IS AVAILABLE
*EXIT ON ESCAPE CHARACTER
*
JSR
INST
IS INPUT DATA AVAILABLE?
BCS
ASYNLP
JUMP IF NOT (SEND ANOTHER
JSR
INCH
GET CHARACTER
CMPA
#ESCAPE
IS IT AN ESCAPE?
BEQ
DONE
BRANCH IF IT IS
JSR
OUTCH
ELSE ECHO CHARACTER
BRA
ASYNLP
AND CONTINUE
DONE:

BRA
END

SC9A

REPEAT

TEST

"A")

9B

Unbuffered interrupt-driven input/output (PINTIO)

307

9B Unbuffered interrupt-driven input/output using a 6821 PIA
(PINTIO)
Performs interrupt-driven input and output using a 6821 PIA and singlecharacter input and output buffers. Consists of the following subroutines:

1

INCH reads a character from the input buffer.

2

INST determines whether the input buffer is empty.

3.

OUTCH writes a character into the output buffer.

4.

OUTST determines whether the output buffer is full.

5 . INIT initializes the 6820 PIA and the software flags. The flags
indicate when data can be transferred between the main program and
the interrupt service routines.
6. IOSRVC determines which interrupt occurred and provides the
proper input or output service. That is, it reads a character from the PIA
into the input buffer in response to the input interrupt, and it writes a
character from the output buffer into the PIA in response to the output
interrupt.

Procedure

1.

INCH waits for a character to become available, clears the Data

Ready flag (RECDF), and loads the character into register A.

2.

INST sets the Carry flag from the Data Ready flag (RECDF).

3. OUTCH waits for the output buffer to empty, places the character
from register A in the buffer, and sets the character available flag
(TRNDF). If an unserviced output interrupt has occurred (i.e. the
Output device has requested service when no data was available),
OUTCH actually sends the data to the PIA.

4.

OUTST sets Carry from the Character Available flag (TRNDF).

5. INIT clears the software flags and initializes the 6821 PIA by
loading its control and data direction registers. It makes port A an input
port, port B an output port, control lines CA1 and CB1 active low-tohigh, control line CA2 a brief output pulse indicating input acknowledge
(active-low briefly after the CPU reads the data) and control line CB2 a
write strobe (active-low after the CPU writes the data and lasting until
the peripheral becomes ready again). INIT also enables the input inter-

308

Assembly language subroutines for the 6809

rupt on CA1 and the output interrupt on CB1. See Appendix 2 and
Subroutine 8E for more details about initializing 6821 PIAs.

6. IOSRVC determines whether the interrupt was an input interrupt
(bit 7 of PIA control register A = 1), an output interrupt (bit 7 of PIA
‘control register B = 1), or the product of some other device. If an input
interrupt occurred, the program reads the data, saves it in the input
buffer, and sets the Data Ready flag (RECDF). The lack of buffering
results in the loss of any unread data at this point.
If an output interrupt occurred, the program determines whether any
data is available. If not, the program simply clears the interrupt and
clears the flag (OIE) that indicates the output device is actually ready
(i.e. an output interrupt has occurred at a time when no data was
available). If data is available, the program sends it from the output
buffer to the PIA, clears the Character Available flag (TRNDF), sets
the Output Interrupt Expected flag (OIE), and enables both the input
and the output interrupts.
The special problem with the output interrupt is that it may occur
when no data is available to send. We cannot ignore it or it will assert
itself indefinitely, causing an endless loop. The solution is simply to
clear the 6821 interrupt by reading the data register in port B.
But now we have a new problem when output data becomes available. That is, since the interrupt has been cleared, it obviously cannot

inform the system that the output device is ready for data. The solution
is to have a flag that indicates (with a 0 value) that the output interrupt
has occurred without being serviced. We call this flag OIE (Output
Interrupt Expected).
The initialization routine clears OIE (since the output device starts
out ready for data). The output service routine clears it when an output
interrupt occurs that cannot be serviced (no data is available) and sets it
after sending data to the 6821 PIA (in case it might have been cleared).
Now the output routine OUTCH can check OIE to determine whether
an output interrupt is expected. If not, OUTCH simply sends the data
immediately.
Note that we can clear a PIA interrupt without actually sending any
data. We cannot do this with a 6850 ACIA (see Subroutines 9A and
9C), so the procedures there are somewhat different.
Unserviceable interrupts occur only with output devices, since input
devices always have data ready to transfer when they request service.
Thus output devices cause more initialization and sequencing problems
in interrupt-driven systems than do input devices.

9B

Unbuffered interrupt-driven input/output (PINTIO)

309

Entry conditions

1.

INCH : none

2

INST: none

3.

OUTCH: character to transmit in register A

4

OUTST: none

5

INIT: none

Exit conditions

1.

INCH: character in register A

2

INST: Carry = 0 if input buffer is empty, 1if it is full

3.

OUTCH: none

4

OUTST: Carry = 0 if output buffer is empty, 1if it is full

5

INIT: none

Registers used

1.

INCH: A, CC

2

INST: A, CC

3.

OUTCH: A, CC

4.

OUTST: A, CC

5

INIT: A

Execution time

A
2.
3.

INST: 12 cycles

4.

OUTST: 12 cycles

5.

INIT: 99 cycles

INCH: 40 cycles if a character is available

OUTCH: 98 cycles if the output buffer is not full and the PIA is
ready for data; 37 additional cycles to send the data to the 6821 PIA if
no output interrupt is expected.

310

Assembly language subroutines for the 6809

6. IOSRVC: 61 cycles to service an input interrupt, 97 cycles to service
an output interrupt, 45 cycles to determine that an interrupt is from
another device. These times all include the 21 cycles required by the
CPU to respond to an interrupt.

Program size

158 bytes

Data memory required 7 bytes anywhere in RAM for the received
data (address RECDAT), receive data flag (address RECDF), transmit
data (address TRNDAT), transmit data flag (address TRNDF), output
interrupt expected flag (address OIE), and the address of the next
interrupt service routine (2 bytes starting at address NEXTSR).
Title

Name:

Simple interrupt input and output using
Peripheral
Interface Adapter and single
character buffers.
PINTIO

a 6821

+

Purpose:

This program consists of
perform interrupt driven
a 6821 PIA.

5 subroutines that
input and output using

INCH

Read

a

character.

INST

Determine input status
(whether input
buffer is empty).
OUTCH
Write a character.
OUTST
Determine output status (whether output
buffer is full).
INIT

Initialize
Entry:

6821

INCH
No
INST

parameters.

No

parameters.

PIA

and

OUTCH
Register A = character
OUTST
No parameters.
INIT
No parameters.
Exit:
HH
FF
SF
He
H+
FH
HF
F
©
+

INCH
Register

A =

character.

interrupt

to

transmit

system.

9B

Unbuffered interrupt-driven input/output (PIN TIO}
INST
Carry = 0 if input buffer is
1 if character is available.
OUTCH
No

Registers

Time:

Used:

empty,

parameters

OUTST
Carry = O if output buffer
empty, 1 if it is full.
INIT
No

311

is

parameters.

INCH
A,CC
INST
A,CC
OUTCH
A,CC
OUTST
A,CC
INIT
A

INCH
40

cycles

if

a character

is

available

INST

He
FF
FE
FH
HF
+e
+
FH
H

12 cycles
OUTCH
98 cycles

if output buffer is not full and
output interrupt
is expected
OUTST
12 cycles
INIT
99 cycles
IOSRVC
45 cycles minimum if the interrupt is not ours

61 cycles to service
97 cycles to service
These include the 21
processor to respond
Size:

Program
Data

an input interrupt
an output interrupt
cycles required for
to an interrupt.

158 bytes
? bytes

HH
FF
&€
HF
YF
+£

*

*6821 PIA EQUATES
*ARBITRARY 6821 PIA MEMORY ADDRESSES
*
PIADRA
EQU
$A400
PIA DATA REGISTER A
PIADDA
EQU
$A400
PIA DATA DIRECTION REGISTER
PIACRA
EQU
$A401
PIA CONTROL REGISTER A
PIADRB
EQU
$A402
PIA DATA REGISTER B
PIADDB
EQu
$A402
PIA DATA DIRECTION REGISTER
PIACRB
EQU
$A403
PIA CONTROL REGISTER B
*
*TRS-80 COLOR COMPUTER INTERRUPT VECTOR

A

B

the

312

Assembly language subroutines for the 6809

*

$0100
EQU
INTVEC
*
*READ A CHARACTER FROM
*

TO

VECTOR

INPUT

SERVICE

INTERRUPT

ROUTINE

BUFFER

INCH:

JSR
BCC
CLR
LDA
RTS

INST
INCH
RECDF
RECDAT

GET INPUT STATUS
WAIT IF NO CHARACTER AVAILABLE
INDICATE INPUT BUFFER EMPTY
GET CHARACTER FROM INPUT BUFFER

*
*DETERMINE INPUT STATUS
*
INST:
LDA
RECDF
LSRA

(CARRY

=

1 IF

DATA

AVAILABLE)

GET DATA READY FLAG
SET CARRY FROM DATA READY FLAG
* CARRY = 1 IF CHARACTER AVAILABLE

RTS
*

*WRITE
*
OUTCH:

A CHARACTER

PSHS

A

*WAIT

FOR

INTO

OUTPUT

BUFFER

SAVE
OUTPUT

BUFFER

TO

CHARACTER

EMPTY,

STORE

TO

WRITE

NEXT

CHARACTER

WAITOC:
JSR
BCS
PULS
STA
LDA
STA
TST
BNE
JSR

OUTST
WAITOC
A
TRNDAT
#S$F F
TRNDF
OIE
EXITOT
OUTDAT

GET OUTPUT STATUS
WAIT IF OUTPUT BUFFER FULL
GET CHARACTER
STORE CHARACTER IN OUTPUT BUFFER
INDICATE OUTPUT BUFFER FULL
TEST OUTPUT INTERRUPT EXPECTED FLAG
EXIT IF OUTPUT INTERRUPT EXPECTED
SEND CHARACTER IMMEDIATELY IF
* NO OUTPUT INTERRUPT EXPECTED

EXITOT:
RTS

*

*DETERMINE OUTPUT STATUS
*
OUTST:
LDA
TRNDF
LSRA
RTS

(CARRY

=

1 IF

OUTPUT

INIT:

INTERRUPT

SYSTEM

FULL)

GET TRANSMIT FLAG
SET CARRY FROM TRANSMIT FLAG
CARRY = 1 IF BUFFER FULL

*

*INITIALIZE
*

BUFFER

AND

6821

PIA

9B

Unbuffered interrupt-driven input/output (PINTIO)

313

*

*DISABLE INTERRUPTS DURING INITIALIZATION BUT SAVE
*
PREVIOUS STATE OF INTERRUPT FLAG
*
PSHS
CC
SAVE CURRENT FLAGS (PARTICULARLY
DISABLE INTERRUPTS DURING
SEI
* INITIALIZATION
*

*INITIALIZE
*

TRS-80

LDX
STX

INTVEC
NEXTSR

LDX
STX

#IOSRVC
INTVEC

COLOR

COMPUTER

INTERRUPT

I FLAG)

VECTOR

GET CURRENT INTERRUPT VECTOR
SAVE IT AS ADDRESS OF NEXT SERVICE
* ROUTINE
GET ADDRESS OF OUR SERVICE ROUTINE
SAVE IT AS INTERRUPT VECTOR

*

*INITIALIZE SOFTWARE
*
CLRA
STA
RECDF
STA
TRNDF
STA
OIE

FLAGS

NO INPUT DATA AVAILABLE
OUTPUT BUFFER EMPTY
INDICATE NO OUTPUT INTERRUPT NEEDED
* 6821 READY TO TRANSMIT INITIALLY

*

*INITIALIZE
*

CLR
CLR
CLR
LDA
STA
LDA
STA

6821

PIACRA
PIACRB
PIADDA
#SFF
PIADDB
#%400101111
PIACRA

LDA
STA

#%00100111
PIACRB

PULS

cc

PIA

(PARALLEL

INTERFACE)

ADDRESS
MAKE
MAKE

DATA

PORT
PORT

DIRECTION

REGISTERS

A INPUT
B OUTPUT

SET PORT A AS
*BITS 7,6 NOT
*BIT 5 = 1 TO
*BIT 4 = 0 TO
*BIT 3 = 1 TO
*
ACKNOWLEDGE
*BIT 2 = 1 TO
*BIT 1 = 1 TO
*
HIGH
*BIT 0 = 1 TO

FOLLOWS:
USED
MAKE CA2
MAKE CA2
MAKE CA2

OUTPUT
A PULSE
A BRIEF

INPUT

ADDRESS DATA REGISTER
MAKE CA1 ACTIVE LOW-TOENABLE

CA1

INTERRUPTS

SET PORT B AS FOLLOWS:
*BITS 7, 6 NOT USED
*BIT 5 = 1 TO MAKE CB2 OUTPUT
*BIT 4 = 0 TO MAKE CB2 A PULSE
*BIT 3 = 0 TO MAKE CB2 A LONG OUTPUT
*
BUFFER FULL
*BIT 2 = 1 TO ADDRESS DATA REGISTER
*BIT 1 = 1 TO MAKE CB1 ACTIVE LOW-TO*
HIGH
*BIT 0 = 1 TO ENABLE CB1 INTERRUPTS
RESTORE FLAGS (THIS REENABLES INTERRUPTS
* IF THEY WERE ENABLED WHEN INIT WAS

314

Assembly language subroutines for the 6809
*

CALLED)

RTS
*
*INTERRUPT MANAGER
*DETERMINES WHETHER INPUT OR OUTPUT INTERRUPT OCCURRED
*
IOSRVC:
*
*INPUT INTERRUPT FLAG IS BIT 7 OF CONTROL REGISTER A
*OUTPUT INTERRUPT FLAG IS BIT 7 OF CONTROL REGISTER B
*
LDA
PIACRA
CHECK FOR INPUT INTERRUPT
BMI
RDHDLR >
BRANCH IF INPUT INTERRUPT
LDA
PIACRB
CHECK FOR OUTPUT INTERRUPT
BMI
WRHDLR
BRANCH IF OUTPUT INTERRUPT
JMP
CNEXTSR]
INTERRUPT IS FROM ANOTHER SOURCE
*

*INPUT
*

RDHDLR:

CREAD)

INTERRUPT

LDA
STA
LDA
STA
RTI

PIADRA
RECDAT
#$FF
RECDF

CWRITE)

INTERRUPT

LDA
BEQ
JSR
RTI

TRNDF
NODATA
OUTDAT

HANDLER

READ DATA FROM 6821 PIA
SAVE DATA IN INPUT BUFFER
INDICATE

CHARACTER AVAILABLE

*

*OUTPUT
*
WRHDLR:

HANDLER

TEST
JUMP
SEND

DATA AVAILABLE FLAG
IF NO DATA TO TRANSMIT
DATA TO 6821 PIA

*

*IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE,
* WE MUST CLEAR IT CIN THE 6821) TO AVOID AN ENDLESS LOOP.
LATER,
WHEN A CHARACTER BECOMES AVAILABLE, WE NEED TO KNOW THAT AN
OUTPUT INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED.
THE KEY
TO DOING THIS IS THE OUTPUT INTERRUPT EXPECTED FLAG OIE.
THIS FLAG
CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT BEEN
SERVICED.
IT IS ALSO CLEARED INITIALLY SINCE THE 6821 PIA STARTS
OUT READY.
OIE IS SET WHENEVER DATA IS ACTUALLY SENT TO THE PIA.
THUS THE OUTPUT ROUTINE OUTCH CAN CHECK OIE TO DETERMINE WHETHER
HH TO
HF
F
+
SEND THE DATA IMMEDIATELY OR WAIT FOR AN OUTPUT INTERRUPT.
*THE PROBLEM IS THAT AN OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
THE COMPUTER HAS ANYTHING TO SEND CUNLIKE AN INPUT DEVICE THAT
HAS DATA WHEN IT REQUESTS SERVICE).
THE OIE FLAG SOLVES THE
PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING ITSELF
REPEATEDLY, WHILE STILL ENSURING THE RECOGNITION OF OUTPUT
INTERRUPTS.
He
KH
+

NODATA:
LDA

PIADRB

READ

PORT

B DATA

REGISTER

TO

CLEAR

IS

9B

315

Unbuffered interrupt-driven input/output (PINTIO)

CLR

OIE

* INTERRUPT
DO NOT EXPECT

AN

INTERRUPT

WRDONE:
RTI

KEK
REKE
EKER
KKK IKI III KR IKKRKRKIIKKKEE
*ROUTINE: OUTDAT
*PURPOSE: SEND CHARACTER TO 6821 PIA
xENTRY: TRNDAT = CHARACTER TO SEND
*EXIT:
NONE
*REGISTERS USED: A,CC
EKER KES
HHH IKK IK IRI III IRIE
OUTDAT:
LDA
STA
CLR
LDA
STA
RTS

*DATA SECTION
RMB
RECDAT
RMB
RECDF

TRNDAT
PIADRB
TRNDF
#SF F
OIE

GET DATA FROM OUTPUT BUFFER
SEND DATA TO 6821 PIA
INDICATE OUTPUT BUFFER EMPTY
INDICATE OUTPUT INTERRUPT EXPECTED
OIE = FF HEX

1
1

RECEIVE DATA
RECEIVE DATA FLAG (0 = NO DATA,
x
FF = DATA)
TRANSMIT DATA
TRANSMIT DATA FLAG
x
(0 = BUFFER EMPTY, FF = BUFFER FULL)
OUTPUT INTERRUPT EXPECTED
* ( 0 = INTERRUPT OCCURRED WITHOUT
*
BEING SERVICED, FF = INTERRUPT
x
SERVICED)
ADDRESS OF NEXT INTERRUPT SERVICE
*
ROUTINE

TRNDAT
TRNDF

RMB
RMB

1
1

OIE

RMB

1

NEXTSR

RMB

2

*
*
SAMPLE EXECUTION:
*
*CHARACTER EQUATES
*
ESCAPE
TESTCH

EQU
EQU

$1B
"A

CHARACTER
ESCAPE
ASCII
= A
CHARACTER
TEST

JSR
CLI

INIT

PIA,
6821
INITIALIZE
INTERRUPTS
ENABLE

SC9B:

*

*SIMPLE
* UNTIL

EXAMPLE AN ESC IS

READ AND
RECEIVED

ECHO

CHARACTERS

*

LOOP:

JSR
PSHS

INCH
A

READ

CHARACTER

INTERRUPT

SYSTEM

316

Assembly language subroutines for the 6809
JSR
OUTCH
ECHO CHARACTER
PULS
A
CMPA
#ESCAPE
IS CHARACTER AN ESCAPE?
BNE
LOOP
STAY IN LOOP IF NOT
*
*AN ASYNCHRONOUS EXAMPLE
* OUTPUT "A" TO CONSOLE CONTINUOUSLY BUT ALSO LOOK AT
* INPUT SIDE, READING AND ECHOING INPUT CHARACTERS.
*

ASYNLP:
*OUTPUT AN "A" IF OUTPUT IS NOT BUSY
JSR
OUTST
IS OUTPUT BUSY?
BCS
ASYNLP
BRANCH (WAIT) IF IT IS
LDA
#TESTCH
JSR
OUTCH
OUTPUT TEST CHARACTER
*
*CHECK INPUT PORT
*ECHO CHARACTER IF ONE IS AVAILABLE
*EXIT ON ESCAPE CHARACTER
*
JSR
INST
IS INPUT DATA AVAILABLE?
BCS
ASYNLP
BRANCH IF NOT (SEND ANOTHER
JSR
GET CHARACTER
INCH
CMPA
#ESCAPE
IS IT AN ESCAPE?
BEQ
DONE
BRANCH IF IT IS
JSR
OUTCH
ELSE ECHO CHARACTER
BRA
ASYNLP
AND CONTINUE
DONE:

BRA
END

SC9B

REPEAT

TEST

"A"')

9C_

Buffered interrupt-driven input/output (SINTB)

317

9C_ Buffered interrupt-driven input/output using a 6850 ACIA
(SINTB)
Performs interrupt-driven input and output using a 6850 ACIA and
multiple-character buffers. Consists of the following subroutines:

INCH reads a character from the input buffer.
INST determines whether the input buffer is empty.

OUTCH writes a character into the output buffer. —
Pm
Fv OUTST determines whether the output buffer is full.
5. INIT initializes the buffers, the interrupt system, and the 6850
ACIA.

6. IOSRVC determines which interrupt occurred and services ACIA
input or output interrupts.

Procedures

1. INCH waits for a character to become available, gets the character
from the head of the input buffer, moves the head of the buffer up one
position, and decreases the input buffer counter by 1.

2. INST clears Carry if the input buffer counter is 0 and sets it otherwise.
3. OUTCH waits until there is space in the output buffer (i.e. until the
output buffer is not full), stores the character at the tail of the buffer,

moves the tail up one position, and increases the output buffer counter
by 1.
4. OUTST sets Carry if the output buffer counter is equal to the
buffer’s length (i.e. if the output buffer is full) and clears Carry
otherwise.
5, INIT clears the buffer counters and sets all buffer pointers to the
buffers’ base addresses. It then resets the 6850 ACIA and sets its
operating mode by storing the appropriate value in its control register.
It initializes the ACIA with input interrupts enabled and output interrupts disabled. See Subroutine 8E for more details about initializing
6850 ACIAs. INIT also clears the OIE flag, indicating that the ACIA is
ready to transmit data, although it cannot cause an output interrupt.
6. IOSRVC determines whether the interrupt was an input interrupt

318

Assembly language subroutines for the 6809

(bit 0 of the ACIA status register = 1), an output interrupt (bit 1 of the
ACIA status register = 1), or the product of some other device. If the
input interrupt occurred, the program reads a character from the 6850
ACIA. If there is room in the input buffer, it stores the character at the
tail of the buffer, moves the tail up one position, and increases the input
buffer counter by 1. If the buffer is full, it simply discards the character.
If the output interrupt occurred, the program determines whether
output data is available. If not, it simply disables the output interrupt
(so it will not interrupt repeatedly) and clears the OIE flag that indicates
the ACIA is actually ready. The flag tells the main program that the
ACIA is ready even though it cannot force an interrupt. If there is data
in the output buffer, the program obtains a character from the buffer’s
head, sends it to the ACIA, moves the head up One position, and
decreases the output buffer counter by 1. It then enables both input and
output interrupts and sets the OIE flag (in case the flag had been cleared
earlier).
The new problem with multiple-character buffers is the management
of queues. The main program must read the data in the order in which
the input interrupt service routine receives it. Similarly, the output
interrupt service routine must send the data in the order in which the
main program stores it. Thus we have the following requirements for
handling input:
1.

The main program must know whether the input buffer is empty.

2. Ifthe input buffer is not empty, the main program must know where
the oldest character is (i.e. the one that was received first).

3. The input interrupt service routine must know whether the input
buffer is full.
4. If the input buffer is not full, the input interrupt service routine
must know where the next empty place is (i.e. where it should store
the
new character).

The output interrupt service routine and the main program have
similar requirements for the output buffer, although the roles of sender
and receiver are reversed.
We meet requirements 1 and 3 by maintaining a counter ICNT. INIT
initializes ICNT to 0, the interrupt service routine adds 1 to it wheneve
r
it receives a character (assuming the buffer is not full), and the main
program subtracts 1 from it whenever it removes a character from the
buffer. Thus the main program can determine whether the input buffer
is empty by checking if ICNT is 0. Similarly, the interrupt service

9C

Buffered interrupt-driven input/output (SINTB)

319

routine can determine whether the input buffer is full by checking if
ICNT is equal to the size of the buffer.
We meet requirements 2 and 4 by maintaining two pointers, IHEAD
and ITAIL, defined as follows:

1.

ITAIL is the address of the next empty location in the input buffer.

2.

THEAD is the address of the oldest character in the input buffer.

INIT initializes IHEAD and ITAIL to the base address of the input
buffer. Whenever the interrupt service routine receives a character, it
places it in the buffer at ITAIL and moves ITAIL up one position
(assuming that the buffer is not full). Whenever the main program reads
a character, it removes it from the buffer at [HEAD and moves IHEAD

up one position. Thus IHEAD ‘chases’ ITAIL across the buffer with the
service routine entering characters at one end (the tail) while the main
program removes them from the other end (the head).
The occupied part of the buffer thus could start and end anywhere. If
either IHEAD or ITAIL reaches the physical end of the buffer, we
simply set it back to the base address. Thus we allow wraparound on the
buffer; i.e. the occupied part of the buffer could start near the end (say,
at byte #195 of a 200-byte buffer) and continue back past the beginning
(say, to byte #10). Then IHEAD would be BASE + 194, ITAIL would
be BASE + 9, and the buffer would contain 15 characters occupying
addresses BASE + 194 through BASE + 199 and BASE through BASE
+ 8.

Entry conditions

1.

INCH: none

2.

INST: none

3.

OUTCH: character to transmit in register A

4.

OUTST: none

5.

INIT: none

Exit conditions
1.

INCH: character in register A

2.

INST: Carry = 0 if input buffer is empty, 1 if a character is available

320

Assembly language subroutines for the 6809

3.

OUTCH: none

4.

OUTST: Carry = 0 if output buffer is not full, 1 if it is full

5.

INIT: none

Registers used

1. INCH: A, CC, X
2.

INST: A, CC

3.

OUTCH: A, CC, X

4.

OUTST: A, CC

5.

INIT: A

Execution time
1.

INCH: approximately 86 cycles if a character is available

2.

INST: 21 cycles

3. OUTCH: approximately 115 cycles if the output buffer is not full
and an output interrupt is expected. Approximately an additional 79
cycles if no output interrupt is expected.
4.

OUTST: 26 cycles

5.

INIT: 106 cycles

6. IOSRVC: 112 cycles to service an input interrupt, 148 cycles to
service an Output interrupt, 44 cycles to determine the interrupt is from
another device. These times all include the 21 cycles required by the
CPU to respond to an interrupt.
Note The approximations here are the result of the variable amount
of time required to update the buffer pointers with wraparound.

Program size

235 bytes

Data memory required

11 bytes anywhere in RAM for the heads and

9C

Buffered interrupt-driven input/output (SINTB)

321

tails of the input and output buffers (2 bytes starting at addresses
IHEAD, ITAIL, OHEAD,

and OTAIL, respectively), the number of

characters in the buffers (2 bytes at addresses ICNT and OCNT), and
the OIE flag (address OIE). This does not include the actual input and
output buffers. The input buffer starts at address IBUF and its size is
IBSZ; the output buffer starts at address OBUF and its size is OBSZ.
Title

Interrupt input and output using
and multiple character buffers.
SINTB

Name:

Purpose:

This program consists of
perform interrupt driven
a 6850 ACIA.

a 6850

ACIA

5 subroutines which
input and output using

INCH
Read a character.
INST
Determine input status (whether input
buffer is empty).
OUTCH
Write a character.
OUTST
Determine output status (whether output
buffer is full).
INIT
Initialize 6850 ACIA and interrupt system.
Entry:

INCH
No parameters.
INST
No parameters.
OUTCH

Register A = character
OUTST
No parameters.
INIT
No parameters.
Exit:

INCH
Register

A =

character.

0 if

input

to

transmit

INST

Carry

=

1 if character

buffer

is

empty,

is available.

OUTCH
No parameters

OUTST
Carry
full,
INIT
No

Registers
OF
K€
HR
$F
FH
HF
t+
+
FF
F

Used:

= 0 if output buffer
1 if it is full.

parameters.

INCH
A,CC,X

is

not

322

Assembly language subroutines for the 6809
INST
A,CC
OUTCH
A,CC,X
OUTST
A,CC
INIT
A,X
Time:

INCH
Approximately
available

86

cycles

if

a

character

is

INST

21 cycles
OUTCH
Approximately
115 cycles if output buffer is
not full and output interrupt is expected.
OUTST
26 cycles
INIT

106

cycles

IOSRVC

44 cycles minimum if the interrupt is not ours
112 cycles to service an input interrupt
148 cycles to service an output interrupt
These include the 21 cycles required for the
processor to respond to an interrupt.
Size:

Buffers:

Program
Data

235 bytes
11 bytes plus

size

of

buffers

The routines assume two buffers starting at
address IBUF and OBUF.
The length of the
buffers in bytes are IBSZ and OBSZ.
For the
input buffer, IHEAD is the address of the
oldest character
(the next one the main
program should read), ITAIL is the address of
the next empty element
(the next one the service
routine should fill), and ICNT is the number of
bytes currently filled with characters.
For the
output buffer, OHEAD is the address of the

character

(the

next

one

the

service

routine

should send), OTAIL is the address of the next
empty element (the next one the main program
should fill), and OCNT is the number of bytes
currently filled with characters.
Note:

OF
HR
HB
HF
+F
HF
+
FF
HHF
F
H

Wraparound

is provided on both buffers, so that
the currently filled area may start anywhere
and extend through the end of the buffer and
For example, if the
back to the beginning.
output buffer is 40 hex bytes long, the section
filled with characters could extend from OBUF
That
+32H COHEAD) through OBUF+10H C(OTAIL-1).
is, there are 19H filled bytes occupying
addresses OBUF+32H through OBUF+10H.
The buffer

9C

Buffered interrupt-driven input/output (SINTB)

323

thus looks like a television picture with the
vertical hold skewed, so that the frame starts
above the bottom of the screen,
leaves off at
the top, and continues at the bottom.

&
+

*

*6850 ACIA CUART) EQUATES
*ARBITRARY 6850 ACIA MEMORY
*
ACIADR'
EQU
$A400
ACIASR
EQU
$A401
ACIACR
EQU
$A401

ADDRESSES
ACIA
ACIA
ACIA

DATA REGISTER
STATUS REGISTER
CONTROL REGISTER

*

*TRS-80
*
INTVEC

COLOR

COMPUTER

INTERRUPT

VECTOR

EQU

$010D

CHARACTER

FROM

JSR
BCC

INST
INCH

GET INPUT STATUS
BRANCH (WAIT) IF

DEC
LDX

ICNT
IHEAD

REDUCE
INPUT BUFFER
COUNT BY 1
GET CHARACTER
FROM HEAD OF INPUT

LDA
JSR
STX
RTS

x
INCIPTR
IHEAD

MOVE

VECTOR

TO

INTERRUPT

SERVICE

ROUTINE

*

*READ
*

INPUT

BUFFER

INCH:

HEAD

POINTER

NO

UP

CHARACTER

1 WITH

AVAILABLE
BUFFER

WRAPAROUND

*

*RETURN
*

INPUT

STATUS

(CARRY

=

1 IF

INPUT

DATA

AVAILABLE)

INST:

CLC
TST
BEQ
SEC

CLEAR CARRY, INDICATING BUFFER EMPTY
TEST INPUT BUFFER COUNT
BRANCH CEXIT) IF BUFFER EMPTY
SET CARRY TO INDICATE DATA AVAILABLE

ICNT
EXINST

EXINST:
RTS

*
*WRITE
*
OUTCH:

RETURN, CARRY INDICATES
* IS AVAILABLE

A CHARACTER

PSHS

A

*WAIT

UNTIL

INTO

OUTPUT

DATA

BUFFER

SAVE
OUTPUT

WHETHER

BUFFER

NOT

CHARACTER
FULL,

TO

WRITE

STORE

NEXT

CHARACTER

WAITOC:
JSR
BCS
INC
LDX
PULS
STA
JSR

OUTST
WAITOC
OCNT
OTAIL
A
7X
INCOPTR

GET OUTPUT STATUS
BRANCH (WAIT) IF OUTPUT BUFFER FULL
INCREASE OUTPUT BUFFER COUNT BY 1
POINT AT NEXT EMPTY BYTE IN BUFFER
GET CHARACTER
STORE CHARACTER AT TAIL OF BUFFER
MOVE TAIL POINTER UP 1

324

Assembly language subroutines for the 6809
STX
TST
BNE
JSR

OTAIL
OIE
EXWAIT
OUTDAT

TEST

OUTPUT

INTERRUPT

EXPECTED

FLAG

OUTPUT CHARACTER IMMEDIATELY IF
* OUTPUT INTERRUPT NOT EXPECTED

EXWAIT:

RTS

*

*OUTPUT
*
OUTST:

STATUS

(CARRY

=

LDA
CMPA
SEC

OCNT
#S ZOBUF

BEQ
CLC

EXOUTS

1 IF

OUTPUT

BUFFER

FULL)

GET OUTPUT BUFFER COUNT
IS OUTPUT BUFFER FULL?
SET CARRY, INDICATING OUTPUT BUFFER
FULL
*
BRANCH CEXIT) IF OUTPUT BUFFER FULL
INDICATE OUTPUT BUFFER NOT FULL

EXOUTS:
RTS

CARRY

=

1 IF

BUFFER

FULL,

O IF

NOT

*

*INITIALIZE

6850

ACIA,

INTERRUPT

SYSTEM

*

INIT:
*

*DISABLE INTERRUPTS DURING INITIALIZATION BUT SAVE
PREVIOUS STATE OF INTERRUPT FLAG
*
*
PSHS
CC
SAVE CURRENT FLAGS (PARTICULARLY I FLAG)
SEI
DISABLE INTERRUPTS DURING
* INITIALIZATION
*
*INITIALIZE TRS-80 COLOR COMPUTER INTERRUPT VECTOR
*
LDX
INTVEC
GET CURRENT INTERRUPT VECTOR
STX
NEXTSR
SAVE IT AS ADDRESS OF NEXT SERVICE
* ROUTINE
LDX
#IOSRVC
GET ADDRESS OF OUR SERVICE ROUTINE
STX
INTVEC
SAVE IT AS INTERRUPT VECTOR
*

*INITIALIZE
*
CLR
CLR
CLR
LDX
STX
STX
LDX
STX
STX

BUFFER

COUNTERS

ICNT
OCNT
OIE
#IBUF
IHEAD
ITAIL
#0BUF
OHEAD
OTAIL
6850

POINTERS,

INTERRUPT

FLAG

INPUT BUFFER EMPTY
OUTPUT BUFFER EMPTY
INDICATE NO OUTPUT INTERRUPT EXPECTED
INPUT HEAD/TAIL POINT TO BASE
ADDRESS OF INPUT BUFFER

OUTPUT HEAD/TAIL POINT TO
ADDRESS OF OUTPUT BUFFER

*

*INITIALIZE
*

AND

ACIA

BASE

9C_

Buffered interrupt-driven input/output (SINTB)

LDA
STA
LDA
STA

#/400000011
ACIACR
#%10010001
ACIACR

PULS

CC

MASTER RESET 6850 ACIA
HAS NO RESET INPUT)

(NOTE

325
IT

SET ACIA OPERATING MODE
*BIT 7 = 1 TO ENABLE INPUT INTERRUPTS
*BITS 6,5 = 0 TO DISABLE OUTPUT
*
INTERRUPTS
*BITS 4,3,2 = 100 FOR 8 DATA BITS,
*
2 STOP BITS
*BITS 1,0 = 01 FOR DIVIDE BY 16 CLOCK
*
MODE
RESTORE FLAGS (THIS REENABLES INTERRUPTS
*
IF THEY WERE ENABLED WHEN INIT WAS
*
CALLED)

RTS

*

*INPUT/OUTPUT
*
IOSRVC:

INTERRUPT

SERVICE

ROUTINE

*

*GET ACIA STATUS: BIT 0 = 1 IF AN INPUT INTERRUPT,
*
BIT 1 = 1 IF AN OUTPUT INTERRUPT
*
LDA
ACIASR
LSRA
MOVE BIT O TO CARRY
BCS
RDHDLR
BRANCH IF AN INPUT INTERRUPT
LSRA
MOVE BIT 1 TO CARRY
BCS
WRHDLR
BRANCH IF AN OUTPUT INTERRUPT
*

*INTERRUPT WAS NOT
*
JMP
CNEXTSRI

OURS,

TRY

NEXT

INTERRUPT

SOURCE
IS

FROM

ANOTHER

SOURCE

*

*SERVICE
*
RDHDLR:

INPUT

LDA
LDB
CMPB
BEQ
INC
LDX
STA
JSR
STX

INTERRUPTS

ACIADR
ICNT
#SZIBUF
EXITRH
ICNT
ITAIL
7X
INCIPTR
ITAIL

READ DATA FROM ACIA
ANY ROOM IN INPUT BUFFER?
BRANCH CEXIT) IF NO ROOM IN INPUT BUFFER
INCREMENT INPUT BUFFER COUNT
STORE CHARACTER AT TAIL OF INPUT BUFFER
INCREMENT

TAIL

POINTER

WITH

EXITRH:

RTI
*

*OUTPUT
*
WRHDLR:

(WRITE)

INTERRUPT

TST
BEQ

OCNT
NODATA

HANDLER

TEST OUTPUT BUFFER COUNT
BRANCH IF NO DATA TO TRANSMIT

WRAPAROUND

326

Assembly language subroutines for the 6809
JSR
RTI

OUTDAT

ELSE

OUTPUT

DATA

TO

6850

ACIA

*
*IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE,
* WE MUST DISABLE IT TO AVOID AN ENDLESS LOOP. WHEN THE NEXT CHARACTER
* IS READY, IT MUST BE SENT IMMEDIATELY SINCE NO INTERRUPT WILL
* OCCUR.
THIS STATE IN WHICH AN OUTPUT INTERRUPT HAS OCCURRED
* BUT HAS NOT BEEN SERVICED IS INDICATED BY CLEARING OIE (OUTPUT
* INTERRUPT EXPECTED FLAG).
*
NODATA:
CLR
OIE
DO NOT EXPECT AN INTERRUPT
RTI

FH KI II II III IKI KIKI
E
*ROUTINE: OUTDAT
*PURPOSE: SEND CHARACTER TO 6850 ACIA FROM THE OUTPUT BUFFER
*ENTRY: X CONTAINS THE ADDRESS OF THE CHARACTER TO SEND
*EXIT:
NONE
*REGISTERS USED: A,X,CC
KKK III IK IIIT III III III IISA TARA ERR
IK
OUTDAT:
LDA
AND
BEQ
LDX
LDA
STA
JSR
DEC
LDA
STA

ACIASR
#%00000010
OUTDAT
OHEAD
7X
ACIADR
INCOPTR
OCNT
#%410110001
ACIACR

LDA
STA
RTS

#3
FF
OIE

IS ACIA OUTPUT REGISTER EMPTY?
BRANCH (WAIT) IF REGISTER NOT EMPTY
GET HEAD OF OUTPUT BUFFER
GET CHARACTER FROM HEAD OF BUFFER
SEND DATA TO ACIA
INCREMENT POINTER WITH WRAPAROUND
DECREMENT OUTPUT BUFFER COUNTER
ENABLE 6850 INPUT AND
* 8 DATA BITS, 2 STOP
* 16 CLOCK
INDICATE

OUTPUT

OUTPUT INTERRUPTS
BITS, DIVIDE BY

INTERRUPTS

ENABLED

FR KK IKK IKI KIRKE
KEKE
*ROUTINE:
INCIPTR
*PURPOSE:
INCREMENT POINTER INTO INPUT
*
BUFFER WITH WRAPAROUND
*ENTRY: X = POINTER
*EXIT:
X = POINTER INCREMENTED WITH WRAPAROUND
*REGISTERS USED: CC
FRI III II III IIIT ITI IIIS IITA TEER EERE
INCIPTR:
LEAX
CMPX
BNE
LDX
RETINC:

1,X
#EIBUF
RETINC
#IBUF

INCREMENT POINTER BY 1
COMPARE POINTER, END OF BUFFER
BRANCH IF NOT EQUAL
IF EQUAL, SET POINTER BACK TO BASE
* BUFFER

OF

9C

Buffered interrupt-driven input/output (SINTB)

327

RTS

KKK KKK
IIT IIIA
EER RRR
I
*ROUTINE:
INCOPTR
*PURPOSE:
INCREMENT POINTER INTO OUTPUT
*
BUFFER WITH WRAPAROUND
*ENTRY: X = POINTER
*EXIT:
X = POINTER INCREMENTED WITH WRAPAROUND
*REGISTERS USED: CC
KHKRKKKKKKKK
KKK
EKRKEKKREEEEERERKRK RRR AKI
INCOPTR:
LEAX
CMPX
BNE
LDX

1,X
#EOBUF
RETONC
#0BUF

INCREMENT POINTER BY 1
COMPARE POINTER, END OF BUFFER
BRANCH IF NOT EQUAL
IF EQUAL, SET POINTER BACK TO BASE
* BUFFER

*DATA SECTION
IHEAD:
RMB

2

ITAIL:

RMB

2

ICNT:
OHEAD:

RMB
RMB

1
2

OTAIL:

RMB

2

OCNT:
SZIBUF
IBUF:
EIBUF
SZOBUF
OBUF:
EQBUF
OIE:

RMB
EQU
RMB
EQU
EQU
RMB
EQU
RMB

1
10
SZIBUF
$
10
SZOBUF
$
1

NEXTSR:

RMB

2

POINTER TO OLDEST CHARACTER IN INPUT
* BUFFER (NEXT CHARACTER TO READ)
POINTER TO NEWEST CHARACTER IN INPUT
* BUFFER (LAST CHARACTER READ)
NUMBER OF CHARACTERS IN INPUT BUFFER
POINTER TO OLDEST CHARACTER IN OUTPUT
* BUFFER (LAST CHARACTER WRITTEN)
POINTER TO NEWEST CHARACTER IN OUTPUT
* BUFFER (NEXT CHARACTER TO SEND)
NUMBER OF CHARACTERS IN OUTPUT BUFFER
SIZE OF INPUT BUFFER
INPUT BUFFER
END OF INPUT BUFFER
SIZE OF OUTPUT BUFFER
OUTPUT BUFFER
END OF OUTPUT BUFFER
OUTPUT INTERRUPT EXPECTED
* ( 0 = NO INTERRUPT EXPECTED,
*
FF = INTERRUPT EXPECTED)
ADDRESS OF NEXT INTERRUPT SERVICE
*
ROUTINE

SAMPLE

EXECUTION:

OF

RETONC:
RTS

*
*
*

*CHARACTER EQUATES
ESCAPE
EQU
$1B
TESTCH
EQU
"A

ASCII ESCAPE CHARACTER
TEST CHARACTER = A

SC9C:
JSR

INIT

INITIALIZE

6850

ACIA,

*

*SIMPLE
* UNTIL

EXAMPLE ~AN ESC IS

READ AND
RECEIVED

ECHO

CHARACTERS

INTERRUPT

SYSTEM

328

Assembly language subroutines for the 6809

LOOP:

JSR
INCH
READ CHARACTER
PSHS
A
JSR
OUTCH
ECHO CHARACTER
PULS
A
CMPA
#ESCAPE
IS CHARACTER AN ESCAPE?
BNE
LOOP
STAY IN LOOP IF NOT
*
*AN ASYNCHRONOUS EXAMPLE
* OUTPUT "A" TO CONSOLE CONTINUOUSLY BUT ALSO LOOK AT
* INPUT SIDE, READING AND ECHOING ANY INPUT CHARACTERS.

ASYNLP:
*OUTPUT AN "A" IF OUTPUT IS NOT BUSY
JSR
OUTST
IS OUTPUT BUSY?
BCC
ASYNLP
JUMP IF IT IS
LDA
#TESTCH
JSR
OUTCH
OUTPUT CHARACTER
*
*CHECK INPUT PORT
*ECHO CHARACTER IF ONE IS AVAILABLE
*EXIT ON ESCAPE CHARACTER
*
JSR
INST
IS INPUT DATA AVAILABLE?
BCS
ASYNLP
JUMP IF NOT (SEND ANOTHER "A")
JSR
INCH
GET CHARACTER
CMPA
#ESCAPE
IS IT AN ESCAPE CHARACTER?
BEQ
DONE
BRANCH IF IT IS
JSR
OUTCH
ELSE ECHO CHARACTER
BRA
ASYNLP
AND CONTINUE
DONE:

BRA
END

SC9C

REPEAT

TEST

9D

Real-time clock and calendar (CLOCK)

329

9D _ Real-time clock and calendar
(CLOCK)
Maintains a time-of-day 24-hour clock and a calendar based onarealtime clock interrupt generated from a 6840 Programmable Timer Module
(PTM). Consists of the following subroutines:

1.

CLOCK returns the base address of the clock variables.

2.

ICLK initializes the clock interrupt and the clock variables.

3. CLKINT updates the clock after each interrupt (assumed to be
spaced one tick apart).

Procedure

1. CLOCK loads the base address of the clock variables into register X.
The clock variables are stored in the following order (lowest address
first): ticks, seconds, minutes, hours, days, months, less significant byte
of year, more significant byte of year.
2.

ICLK initializes the 6840 PIT, the interrupt system, and the clock

variables. The arbitrary starting time is 00:00.00 (12 a.m.) 1 January
1980. A real application would clearly require outside intervention to
load or change the clock.

3. CLKINT decrements the remaining tick count by 1 and updates the
rest of the clock variables if necessary. Of course, the number of seconds
and minutes must be less than 60 and the number of hours must be less
than 24. The day of the month must be less than or equal to the last day for
the current month; an array of the last days of each month begins at
address LASTDY.
If the month is February (i.e. month 2), the program checks if the
current year is a leap year. This involves determining whether the two
least significant bits of memory location YEAR are both Os. If the current
year is a leap year, the last day of February is the 29th, not the 28th.
The month number may not exceed 12 (December) or a Carry to the
year number is necessary. The program must reinitialize the variables
properly when carries occur; i.e. to DTICK; seconds, minutes, and hours

to 0; day and month to 1 (meaning the first day and January, respectively).
G. J. Lipovski has described an alternative approach using a 60 Hz
clock input and all three 6840 timers. See pp. 340-341 of his book titled
Microcomputer Interfacing (Lexington Books, Lexington, MA, 1980).

330

Assembly language subroutines for the 6809
Entry conditions

1.

CLOCK: none

2.

ICLK: none

3.

CLKINT: none

Exit conditions
1.

CLOCK: base address of clock variables in register X

2.

ICLK: none

3.

CLKINT: none

Examples

These examples assume that the tick rate is DTICK Hz (less than 256
Hz—typical values would be 60 Hz or 100 Hz) and that the clock and
calendar are saved in memory locations
TICK

SEC
MIN
HOUR
DAY
MONTH ~
YEAR and
YEAR+1_

number of ticks remaining before a carry occurs, counted
down from DTICK
seconds (0 — 59)
minutes (0 — 59)
hour of day (0-23)
day of month (1 — 28, 29, 30, or 31, depending on month)
month of year (1-12 for January through December)
current year

1. Starting values are 7 March 1986, 11:59.59 p.m. and 1tick left. That
1S:

(TICK) = 1
(SEC) = 59
(MIN) = 59
(HOUR) = 23
(DAY) = 07
(MONTH) = 03
(YEAR and YEAR +1) = 1986
Result (after the tick): 8 March 1986, 12:00.00 a.m. and DTICK ticks.
That 1s:

9D _ Real-time clock and calendar (CLOCK)

331

(TICK) = DTICK
(SEC) =0
(MIN) = 0
(HOUR) = 0
(DAY) = 08
(MONTH) = 03
(YEAR and YEAR + 1) = 1986
2. Starting values are 31 December 1986, 11:59.59 p.m. and 1 tick left.
That is:

(TICK) = 1
(SEC) = 59
(MIN) = 59
(HOUR) = 23
(DAY) = 31
(MONTH) = 12
(YEAR and YEAR+1) = 1986
Result (after the tick): 1 January 1987, 12:00.00 a.m. and DTICK
ticks. That is:

(TICK) = DTICK
(SEC) =0
(MIN) = 0
(HOUR) = 0
(DAY) =1
(MONTH) = 1
(YEAR and YEAR +1) = 1987
Registers used

1.

CLOCK: CC, X

2.

ICLK: A,B, CC, X, Y

3.

CLKINT: none

Execution time
1.

CLOCK: 8 cycles

2.

ICLK: 115 cycles

3.

CLKINT: 59 cycles if only TICK must be decremented, 244 cycles

Assembly language subroutines for the 6809

332

maximum if changing to a new year. These times include the 21 cycles
required by the CPU to respond to an interrupt.

Program size

190 bytes

Data memory required 8 bytes anywhere in RAM for the clock
variables (starting at address CLKVAR)
Title

Real

Name:

CLOCK

time

clock

and

calendar

Purpose:

This program maintains a time of day 24 hour
clock and a calendar based on a real time clock
interrupt from a 6840 programmable timer.

+

CLOCK
Returns base address of clock variables
ICLK
Initializes 6840 timer and clock interrupt
Entry:

CLOCK
None
ICLK
None

Exit:

CLOCK
Register
ICLK

X =

Base

address

of

time

variables

None

Registers

Used:

Time:

Size:

6840

HH
OH
FF
FH
HF
F
FF
H
+F

PROGRAMMABLE

A,B,CC,X,Y

CLOCK
8 cycles
ICLCK
115 cycles
CLKINT
If decrementing tick only, 59 cycles
Maximum if changing to a new year, 244
cycles
These include the 21 cycles required for
processor to respond to an interrupt.
Program
Data

TIMER

MODULE

190 bytes
8 bytes

(PTM)

INITIALIZE TIMER 2 OF 6840 PTM AS 50 HZ SQUARE
GENERATOR FOR USE IN TIME-OF-DAY CLOCK.

WAVE

the

9D

&€
+

Real-time clock and calendar (CLOCK)

333

TIMER GENERATES INTERRUPT AT END OF EACH 10 MS
INTERVAL CEVERY HALF-CYCLE)
WE ASSUME A 1 MHZ CLOCK INTO THE 6840, SO THAT A COUNTER VALUE
OF 1,000,000/100-1 = 9,999 (270F HEX) IS NEEDED TO GENERATE
A 50 HZ SQUARE WAVE

*ARBITRARY
PTMC13
PTMCR2
PTMT1H
PTMT1L
PTMT2H
PTMT2L
PTMT3H
PTMT3L
PTMSR
PTMT2C

MEMORY ADDRESSES
EQU
$A800
EQU
$A801
EQU
$A802
EQU
$A803
EQU
$A804
EQU
$A805
EQU
$A806
EQU
$A807
$A801
EQU
EQU
$A804

FOR

6840 PTM
CONTROL REGISTERS 1 AND 3
CONTROL REGISTER 2
TIMER 1, MORE SIGNIFICANT
TIMER 1, LESS SIGNIFICANT
TIMER 2, MORE SIGNIFICANT
TIMER 2, LESS SIGNIFICANT
TIMER 3, MORE SIGNIFICANT
TIMER 3, LESS SIGNIFICANT
STATUS REGISTER
TIMER 2 COUNTER

*6840 PTM
PTMMOD

MODE
EQU

BYTE, COUNTER
401000000

PTMCNT

EQU

9999

VALUE
*BIT 0 = O TO ACCESS CR3
*BIT 1
O TO USE ENABLE CLOCK
*BIT 2 = 0 FOR 16-BIT COUNT MODE
*BITS 3,5 = 00 FOR CONTINUOUS COUNTING
*BIT 4 = O FOR ACTIVATE WHEN LATCHES
*
WRITTEN
*BIT 6 = 1 TO ENABLE INTERRUPT
*BIT 7 = 0 TO DISABLE OUTPUT
COUNTER VALUE = 9999

BYTE
BYTE
BYTE
BYTE
BYTE
BYTE

*

*DEFAULT
*

TICK

VALUE

DTICK

EQU

100

*RETURN
CLOCK:

BASE
LDX
RTS

ADDRESS

(100

HZ

REAL-TIME

CLOCK)

DEFAULT

OF

#CLKVAR

CLOCK

TICK

VALUE

VARIABLES
GET

BASE

ADDRESS

OF

CLOCK

VARIABLES

*

*INITIALIZE 6840 PTM TO PRODUCE REGULAR CLOCK INTERRUPTS
*OPERATE TIMER 2 CONTINUOUSLY, PRODUCING AN INTERRUPT EVERY
*
100 MS
*
ICLK:
LDA
#%00000001
STA
PTMCR2
ADDRESS CONTROL REGISTER 1
STA
PTMC13
RESET TIMERS
CLR
PTMC13
ALLOW TIMERS TO OPERATE
LDD
#0
CLEAR COUNTERS 1,3
STD
PTMT1H
STD
PTMT3H
LDA
#PTMMOD
SET TIMER 2'S OPERATING MODE
STA
PTMCR2
LDD
#PTMCNT
PUT COUNT IN TIMER 2

334

Assembly language subroutines for the 6809
STD
PTMT2H
START TIMER 2
*
*INITIALIZE CLOCK VARIABLES TO ARBITRARY VALUE
*JANUARY 1, 1980 00:00.00 (12 A.M.)
*A REAL CLOCK WOULD NEED OUTSIDE INTERVENTION
* TO SET OR CHANGE VALUES
*
LDX
#TICK
LDA
#DTICK
STA
7X
INITIALIZE TICKS
CLRA
STA
SECOND = 0
STA
MINUTE = 0
STA
HOUR = 0
LDA
A= 1
STA
DAY = 1 (FIRST)
STA
MONTH = 1 (JANUARY)
LDY
STY
YEAR = 1980
=
HW
aH
UR
CLI
ENABLE INTERRUPTS
RTS

*SERVICE
CLKINT:

CLOCK

INTERRUPT

LDA
LDA
LDX
DEC
BNE
LDA
STA

PTMSR
PTMT2C
#CLKVAR
TICKIDX,X
EXITCLK
#DTICK
TICKIDX,X

*SAVE
CLRA

REMAINING

CLEAR
AND

READING

STATUS

SUBTRACT 1 FROM TICK COUNT
JUMP IF TICK COUNT NOT ZERO
SET TICK COUNT BACK TO DEFAULT

REGISTERS

*INCREMENT SECONDS
INC
SECIDX,X
LDA
SECIDX,X
CMPA
#60
BCS
EXITCLK
CLR
SECIDX,X
*INCREMENT MINUTES
INC
MINIDX,X
LDA
MINIDX,X
CMPA
#60
BCS
EXITCLK
CLR
MINIDX,X
*INCREMENT HOUR
INC
HRIDX,X
LDA
HRIDX,X
CMPA
#24
BCS
EXITCLK
CLR
HRIDX,X

INTERRUPT BY
THEN COUNTER

O =

DEFAULT

INCREMENT

TO

FOR

NEXT

SECONDS,

SECOND

SECONDS = 60?
EXIT IF LESS THAN
ELSE SECONDS = 0

60

INCREMENT

MINUTE

TO

NEXT

SECONDS

MINUTES = 60?
EXIT IF LESS THAN
ELSE MINUTES = 0

60

INCREMENT

HOUR

TO

NEXT

HOURS = 24?
EXIT IF LESS THAN
ELSE HOUR = Q

MINUTES,

24

MINUTES

HOURS

HOURS

9D

Real-time clock and calendar (CLOCK)

335

*INCREMENT DAY
LDA
MTHIDX,X
GET CURRENT MONTH
LDY
#LASTDY
LDA
A,Y
GET LAST DAY OF CURRENT MONTH
INC
DAYIDX,X
INCREMENT DAY
CMPA
DAYIDX,X
IS IT LAST DAY?
BCS
EXITCLK
EXIT IF NOT AT END OF MONTH
*
*DETERMINE IF THIS IS END OF FEBRUARY IN A LEAP
* YEAR (YEAR DIVISIBLE BY 4)
*
LDA
MTHIDX,X
GET MONTH
CMPA
#2
IS THIS FEBRUARY?
BNE
INCMTH
JUMP IF NOT, INCREMENT MONTH
LDA
YRIDX+1,X
IS IT A LEAP YEAR?
ANDA
#400000011
BNE
INCMTH
JUMP IF NOT
*

*FEBRUARY OF A LEAP
*
LDA
DAYIDX,X
CMPA
#29
BCS
EXITCLK
*INCREMENT MONTH

YEAR

HAS

29

GET

DAY

EXIT

IF

DAYS,

NOT

NOT

1ST

DEFAULT IS
DAY = 1

1 FOR

28

OF

DAYS

MARCH

INCMTH:
LDA
STA

#1
DAYIDX,X

LDA
INC
CMPA
BCS
LDA

MTHIDX,X
MTHIDX,X
#12
EXITCLK
#1

STA

MTHIDX,X

DAY

AND

MONTH

INCREMENT MONTH
WAS OLD MONTH DECEMBER?
EXIT IF NOT
ELSE
* CHANGE MONTH TO 1 (JANUARY)

*INCREMENT YEAR
LDD
YRIDX,X
ADDD
#1
STD
YEAR

GET YEAR
ADD 1 TO YEAR
STORE NEW YEAR

EXITCLK:

*RESTORE
RTI
*ARRAY

OF

LAST

REGISTERS

DAYS

OF

EACH

AND

EXIT
RETURN

MONTH

LASTDY:

FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB
FCB

31
28
31
30
31
30
31
31
30

JANUARY
FEBRUARY (EXCEPT
MARCH
APRIL
MAY
JUNE
JULY
AUGUST
SEPTEMBER

LEAP

YEARS)

336

Assembly language subroutines for the 6809
FCB
FCB
FCB

*CLOCK
CLKVAR:
TICK:
SEC:
MIN:
HOUR:
DAY:
MONTH:
YEAR:

31
30
31

OCTOBER
NOVEMBER
DECEMBER

RMB
RMB
RMB
RMB
RMB
RMB
RMB

1
1
1
1
1
1
2

TICKS LEFT IN CURRENT SECOND
SECONDS
MINUTES
HOURS
DAY (1 TO NUMBER OF DAYS IN A MONTH)
MONTH 1=JANUARY .. 12=DECEMBER
YEAR

SAMPLE

EXECUTION

VARIABLE
EQU
EQU
EQU
EQU
EQU
EQU
EQU

INDEXES
0
1
2
3
4
5
6

INDEX
INDEX
INDEX
INDEX
INDEX
INDEX
INDEX

ICLK

INITIALIZE

VARIABLES

*
*
*

*CLOCK
TCKIDX
SECIDX
MINIDX
HRIDX
DAYIDX
MTHIDX
YRIDX

TO
TO
TO
TO
TO
TO
TO

TICK
SECOND
MINUTE
HOUR
DAY
MONTH
YEAR

SCID:

JSR

CLOCK

*INITIALIZE CLOCK TO 2/7/86 14:00:00 (2 PM, FEB. 7, 1986)
JSR
CLOCK
X = ADDRESS OF CLOCK VARIABLES
CLR
SEC
SECONDS = 0
CLR
MIN
MINUTES = 0
LDA
#14
HOUR = 14 (2 PM)
STA
HOUR
LDA
#7
DAY = 7
STA
DAY
LDA
#2
MONTH = 2 (FEBRUARY)
STA
MONTH
LDX
#1986
STX
YEAR
*
*WAIT FOR CLOCK TO BE 2/7/86 14:01:20 (2:01.20 PM, FEB. 7, 1986)
*
*NOTE: MUST BE CAREFUL TO EXIT IF CLOCK IS ACCIDENTALLY
* SET AHEAD.
IF WE CHECK ONLY FOR EQUALITY, WE MIGHT NEVER
* FIND IT.
THUS WE HAVE >= IN TESTS BELOW, NOT JUST =.
*
*WAIT FOR YEAR >= TARGET YEAR
JSR
CLOCK
X = BASE ADDRESS OF CLOCK VARIABLES
LDY
TYEAR
Y
YEAR TO WAIT FOR
WAITYR:
*COMPARE CURRENT
CMPY
YEAR
BHI
WAITYR
*

YEAR

AND

TARGET

BRANCH

YEAR
IF

YEAR

NOT

>=

TARGET

YEAR

9D

Real-time clock and calendar (CLOCK)

*WAIT
*
TO
*
LDY
LEAX
LDB

FOR REST OF TIME
TARGET VALUES

#TARGET
MTHIDX,X
NTUNIT

UNITS

TO

BE

GREATER

337

THAN

OR

EQUAL

POINT TO TARGET VALUES
POINT TO END OF TIME VALUES
NUMBER OF TIME UNITS IN COMPARISON

*

*GET
*

NEXT

TARGET

VALUE

WITIM:
LDA
*
*WAIT
*

7Yt+

FOR

TIME

TO

BE

GET

NEXT

TARGET

GREATER

THAN

OR

VALUE

EQUAL

TO

TARGET

WTUNIT:
CMPA
BHI
LEAX
DECB
BNE
*
*DONE
*

7X
WTUNIT
-1,X
WITIM

BRANCH IF UNIT NOT >= TARGET VALUE
PROCEED TO NEXT UNIT
DECREMENT NUMBER OF TIME UNITS
CONTINUE UNTIL ALL UNITS CHECKED

BRA

HERE

IT

HERE:

x
* TARGET
*
TYEAR:
NTUNIT:
TARGET:

TIME
FDB
FCB
FCB
END

-

2/7/87,

14:01:20

1987
5
2,7,14,1,20

IS

NOW

(2:01.20
TARGET
NUMBER
TARGET

TIME

PM,

OR

FEB.

LATER

7,

1987)

YEAR
OF TIME UNITS IN COMPARISON
TIME (MONTH,DAY,HR,MIN,SEC)

6809 Instruction set
summary

X — Index Register

Y — Index Register

|
Pointer Registers

U — User Stack Pointer
S — Hardware Stack Pointer

Program Counter

PA

Accumulators

D

7

0
Direct Page Register

7
0
ePFLH{ ipNiz| vic)

Figure A-1

338

6809 programming model.

Condition Code Register

6809 Instruction set summary
7

6

5

339

43
2 #1

aEonouG

.
arry
Overfiow
Zero
Negative
IRQ Mask
Half Carry
FIRQ Mask
Entire Flag

Figure A-2

6809 condition code register.

340

Table A-1

6809 instruction set.
Addressing Modes

ee

elatolrto

Extended

|Opy ~f #{ Op] ~| F] On| - pF Set te

LSLA
LSLB
LSL

6+|

2+]

78

A

Description
___—

PHIN {Z|ViC)

— y COLL LL RE
eae
~

LSRA
LSRB

“fefifeTs

ee
NEGB
oP

as

Nop

Lt
DA

= =

= La= =
EA|
+] 2+]
FA

PLE eee

Peter
ORB
ORCC

an

CC V IMM—=CC

Push Registers on U Stack
Pull Registers from S Stack
from U Stack
Pull AST

PSHU

Bie
= 5+

ie
ir
ROLA

aa
ae

~

2

ROLB

211

ROL

6+!

2+

]~

6+!

2+

~~

itt
°|°
°

1

al

RORA
RORB
at

Pp

| +}
tate
SBCB

ee

at
C2

Ls 4+|
= a

imemuptupt
err
From
From
acm
Int
1 [Return

from Subroutine
[Returnf
39] 5 | 1 [Return
[|

ff
Late
D2

3

| [38 fet

2+] B2
4=

non

2
2 2’
5| 2
6| 3

5
5
6
7

5}
5]

6
6

2
2

3
3

tite
|

A-M-C-—A
B-M-C-—B

pepe psaree omee

~

SUBA
SUBB.
SUBD

C0
83

93

5
5
7

ele:
|
is

Software Interrupt 1
Software Interrupt 2

SWI?

Swi26

SWwi36

Psync_ [|
TST

TSTA
TSTB
TST

6+]

2+)

70

Notes:

ADDRESSING
This column gives a base cycle and byte count. To obtain total count, add the values obtained from the INDEXED
in Appendix F.
2. Rl and R2 may be any pair of 8 bit or any pair of 16 bit registers.
The 8 bit registers are: A, B, CC, DP.
The 16 bit registers are: X, Y, U, S$, D, PC

1.

EA is the effective address.
The PSH and PUL instructions require 5 cycles plus 1 cycle for each byte pushed or pulled.
5(6) means: 5 cycles if branch not taken, 6 cycles if taken (Branch instructions}.
SWI sets | and F bits. SWI2 and SWI3 do not affect | and F.
Conditions Codes set as a direct result of the instruction.

Value of half-carry flag is undefined.
W&
AAS
OONpecial Case — Carry set if b7 is SET.

MODE table,

Table A-1

6809 instruction set (continued).

341

Addressing Modes
Immediate |

ADC
ADD
AND

ASL

ADCA
89 | 2
ADCB
c9
12
ADDA
8B | 2
ADDB
CB | 2
AODDD
C3 | 4
ANDA
84 | 2
ANDB
C4 | 2
ANOCC | 1C | 3

ASLA

Direct

4
2
2
2]
2
2}
2]
2)

9B
DB
D3

Indexed

4+}
4+]
ABI 4+/
€B/ 444
€3/6+]
A4]4+]
E4144]

stalolilo
Inherent

a

Op) P~
|#

2+]
2+]
2+]
2+]
2+]
2+]
2+]

B9
F9
BB]
FB]
3]
Bal
F4]

5]
3
5-| 3
7| 3
5 [1 3
5]
3

6+] 2+]

781

7]

,

|e

~

2
Oto
PS

no
|

2+] 77{
pin
+| B5/
+1] F5]
+

BI
F4
10]

HIN]
Z}V{Cl

3

7} 3
5| 3
5] 3
7

3

5
5
8

3
3
4

B+M+C—B

A+M—A

AAM—A
BAM—6
CC A IMM—CC

48]

2|

1

47/

2]

17

QO} ¢
Oj e
7

ee} 2) 1) Ss[h{UTT
TTT
M
}

67}

4F]
SF}
F
a

Description
A+M+C—A

2]

2
2

1

A

8}

>

M
7
Bit Test
A(M A A)
Bit Test B (M A Bi

8
sealaoe

1;/O-—A
1{0-B
O-M
Compare M from A
Compare M from B
Compare M:M+ 1 from D

B3
Compare M:M+1

from §

Compare M:M +1 from U
Compare M:M +1 from X
Compare M:M +1 from Y

oO oO =

Oo m oO

oO
a

OoMm D >

|
ds es
Saas
oO

D oO

a +

nN +

~ oO

~

DN
WN

NR
RO

Ww

M

OP

~
#

Operation Code (Hexadecimal)
Number of MPU Cycles

Number of Program Bytes
+
Arithmetic Plus
Arithmetic Minus
e = Multiply

—

H
N
Z
V_
C

Complement of M
Transfer Into
Half-carry (from bit 3)

$
Test and set if true, cleared otherwise
e => Not Affected
CC
Condition Code Register

Negative (sign bit)
Zero (Reset)
Overflow, 2's complement
Carry from ALU

:
V

Concatenation
Logical or

A
~-

Logical and
Logical Exclusive or

CVE

[CNonindirect™
=|
sndirect’
Assembler
Form

Constant Offset From R

No Offset

(twos complement offset)

5 Bit Offset

8 Bit Offset

PRE

|

son, RR

Postbyte
x} + | Assembler
OP Code | ~| #
Form

tRRoo10O

Postbyte
+) +
OP Code | ~|#]|

=|
=
>

[ojo
|
rR) | 1RR10100 |3/0] &

[-OORRnnnnn |1[ 0 |

defaults to 8-bit

|

oO

1RRO1OOO |1/1] [n,R)

| 1RR11000 |4|1] &

Accumulator Offset From R
(twos complement offset)

A — Register Offset
1RROO110 {1{0|
[AR]
B — Register Offset |==B,R | 1RROO1O1 | 1{0] [B,R])

D — Register Offset |D,R | 1RRO1011

[4]0|

[D.R]

1RR10110 |4/0. =
| 1RR10101 | 4[0| @

Auto Increment/Decrement R

Increment By 1

1RROOOOO

/210 |

~———snotallowea

[111| [n, PCR

1xx11100 |4|1]| dz
10011111 J5 ]2] &
o

16 Bit Offset

iR+

Decrement By 2

TRROOOOT
1RROOOIO
1RROOO11

Constant Offset From PC

8 Bit Offset

1xx01100

Extended Indirect

16 Bit Address
R=X,Y,UorS

X=00

O-PS
rT
Y=O01

X = Don't Care

U=10

S=11

(twos complement offset)

+ and * Indicate the number

Increment By 2

1RRO1001 | 4] 2] [n,R] | 1RR11001

1R++

16 Bit Offset

1XX01101

of additional cycles and bytes for the particular variation.

[3[0 |]
[210 |.
|3}0]

[Rt]

6

1RR11011_ |7[0 | @Cu
~=—sd|ssdT Cd

©

1RR10001 |6/0 | &
not allowed
| |loa
[--R]
1RR10011 |610| &.

[n, PCR]

1XX11101

|8]2]

8

Ajquiassy
abenbue
sauljnoigns
6089
9y]
40j

6809 Instruction set summary

Table A-3

343

6809 interrupt vector locations.

Description

Reset (RESET)
Non-Maskable Interrupt (NMI)
Software Interrupt (SWI)
Interrupt Request (IRQ)
Fast Interrupt Request (FIRQ)
Software Interrupt 2 (SWI2)
Software Interrupt 3 (SWI3)
Reserved

MS Byte | LS Byte

Programming
reference for the
6821 PIA device

IROA

345
é

!

Control

Interrupt

Register A

Status

(CRA)

Control A

CAI

CA2

|
Data ata B Bus

:

Buffers

[PT TTT TTT

(DBB)

|

|

De
Irection

Output Bus

Register A
(DDRA)

|
|

|
|

Bus Input
Register
(BIR)

|
i

Output
Register A

|

(ORA)

|
|

PAO
fF—-74-

PAI
PA2

|
4

Peripheral
Interface

|

|

A

PA3

<—> PA4

:

PAS

|

PA6

|

|
|
|

CSO

CS!
CS2
RSO
RS1

|

Output

r

Register B

|
Chip

Select
and

PA7

(ORB)

PBO

-—

PBI

l

PB2

|
|

Peripheral
Interface

R/W

|

Control

|
|

PBS

Enable

!

PB6

Reset

|

PB7

R/W

B

PB3
PB4

|

|
l

Input Bus

Z

Data

|

Direction

;

Control

ORB)

Register B

NDDRB 1

|
Interrupt

—

IROB

CBI

Status

Control B

CB2

Figure B-1_ Expanded block diagram of the 6821 Peripheral Interface
Adapter (PIA).

346

Assembly language subroutines for the 6809

Table B-1_

Internal addressing for the 6821 PIA.
Control
Register Bit
Location Selected

|0 | o | 1 |X_|Peripheral RegisterA
0 | o | 0 | Xx _[Betabirection RegisterA
|X |ControtRegistera
po ft |X
1 | 0 | X | 1 |Peripherat Register8
pt fo}x
Data Direction Register B

Control Register B
X = Don’t Care

Table B-2

6821 control ——
formats.

DDRB
Access

CB1 Control

Programming reference for the 6821 PIA device

Table B-3

347

Control of interrupt inputs CA1 and CB1.

CRA-1 | CRA-0 | _ Interrupt Input
CA1 (CB1)

| Active

interrupt Flag
CRA-7 (CRB-7)

Set high on | of CA1 | Disabled—IRO
(CB1)

| Active

interrupt flag bit CRA-7
(CRB-7) goes high

Set high on ¢ of CA1 | Disabled-IRO
(CB1)

* Active

remains high

Set high on | of CA1 | Goes low when the

(CB1)

* Active

MPU interrupt
Request.
IRQA (IROQB)

remains high

Set high on ¢ of CA1 | Goes low when the
(CB1)

interrupt flag bit CRA-7
(CRB-7) goes high

Notes: 1. f indicates positive transition (low to high)

2. | indicates negative transition (high to low)
3. The interrupt flag bit CRA-7 is cleared by an MPU Read of the A Data Register,
and CRB-7 is cleared by an MPU Read of the B Data Register.
4. If CRA-0 (CRB-0) is lowwhenan interrupt occurs (interrupt disabled) and is

later brought high, IROA (IROB) occurs after CRA-O (CRB-0) is written to a
“a

one

“

348

Assembly language subroutines for the 6809

Table B-4 Control of CA2
(CRB-5) is LOW.
CRA-5 | CRA-4 | CRA-3 | Interrupt Input
(CRB-5) |(CRB-4) {CRA-3)

| Active

and CB2 as interrupt inputs. CRA-5

interrupt Flag
CRA-6 (CRB-6)

|Sethighon | of CA2 | Disabled—IRO
(CB1)

| Active

MPU Interrupt
Request
IRQA (IRQB)

remains high

Set high on | of CA2 | Goes low when the
interrupt flag bit CRA-6

(CRB-6) goes high

t Active | Sethigh on ¢ of CA2 | Disabled —IRO
(CB2)
* Active

remains high

Set high on * of CA2 | Goes low when the
interrupt flag bit CRA-6

(CRB-6) goes high
Notes: 1. + indicates positive transition (low to high)
2. | indicates negative transition (high to low)
3. The interrupt flag bit CRA-6 is cleared by an MPU Read of the A Data Register,
and CRB-6 is cleared by an MPU Read of the B Data Register.

4. If CRA-3 (CRB-3) is low when an interrupt occurs (interrupt disabled) and is
later brought high, IROQA (IRQB) occurs after CRA-3 (CRB-3) is written to a

Low on negative transition of
E after an MPU Read “A” Data
operation.

High when the interrupt flag
bit CRA-7 is set by an active
transition of the CA1 signal.

Low on negative transition of
E after an MPU Read “A” Data
operation.

High on the negative edge of
the first “E” pulse which
occurs during a deselect.

Low when CRA-3 goes low as
a result of an MPU Write to
Control Register “A”.

Always low as long as CRA-3
is low. Will go high on an
MPU Write to Control
Register “A” that changes
CRA-3 to “one”.

Always high as long as
CRA-3 is high. Will be cleared
on an MPU Write to Control
Register “A” that clears
CRA-3 to a “zero”.

High when CRA-3 goes high
as a result of an MPU Write to
Control Register “A”.

Programming reference for the 6821 PIA device
Table B-6

349

Control of CB2 as an output. CRB-5 is HIGH.
CB2
Cleared

Set

Low on positive transition of | High when the interrupt flag
the first E pulse following and | bit CRB-7 is set by an active
MPU Write “B” Data Register | transition of the CB1 signal.
operation.
Low on the positive transition
of the first E pulse after an
MPU Write “B” Data Register
operation.

High on the positive edge of

the first “E” pulse following
an “E” pulse which occured
while the part was
deselected.

Low when CRB-3 goes low as
a result of an MPU Write in
Control Register “B”.

Always low as long as CRB-3
is low. Will go high on an
MPU Write in Control
Register “B” that changes
CRB-3 to “one”.

Always high as long as
CRB-3 is high. Will be cleared
on an MPU Write Control
Register “B” results in
clearing CRB-3 to “zero”.

High when CRB-3 goes high
as a result of an MPU Write
into Control Register “B”.

C ASCII character set

cane
ong]
Be
son

wexedlouamosse

"”
ed
>

INe
GO
eR
EK
ane

trire

350

