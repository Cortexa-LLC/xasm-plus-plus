OSBORNE/McGRAW-HILL

02 ASSEMBLY LANGUAGE PROGRAMMING
LANCE A. LEVENTHAL
■ ■■

■

■

■

\ m

#
T ■

■

a

■

■
■

■

DAVID L BURKE
~
1129
1129NNBitting
BittingStSt

-.,

Wichita
Wlchll1KS
KS67203
17203

6502
nsscmsLV
ir h g u
rgc
ASSEfflBLY
LAnGUAGE
pROGRAmmmG
PROGRAfflffllnG

-

6502
RSSCfllflLV
ASSEfflBLY LRRGURGC
LAnGUAGE

pROGRnmminG
PAOGAAfflffllnG

Lance fl.
Leventhcil
A. Leventhal

OSBORNE/McGraw-Hill
OSBORNE/McGraw-Hill
Berkeley, California
California
Berkeley,

Published by
Published
OSBORNE/McGraw-Hill
OSBORNE/McGraw-Hill
630 Bancroft
Bancroft Way
Way
630
Berkeley, California
California 94710
94710
Berkeley,
U.S.A.
U.S.A.
For
For information on
on translations and book distributors outside of
the U.S.A., please write
rite O S B O R N E
/M cG raw -H ill at the above
RNE/McGraw-Hill
address.
address.
6 5022 A S S EMBLY L A N GUAGE P R O G RAMMING
M M IN G

Copyright
Inc. All rights reserved.
reserved. Printed in the
Copyright ©
® 1979 by McGraw-Hill, Inc.
be reproduced,
United States of America. No part of this publication may be
stored in a retrieval system, or transmitted
transmitted in any form or by any means,
means,
electronic, mechanical, photocopying,
photocopying, recording or otherwise
otherwise without
ithout the
proprior written
written permission of the publishers, with the exception that the pro­
gram listings may be entered, stored, and
computer system, but
and executed in
in a computer
they may not be
be reproduced for publication.
6 7 8 9 0 DODO
DODO 8 7 6 5 4 3
ISBN
8 8 -2 7 -6
ISBN 0 -9 3 1 9
31988-27-6
Cover design by K.L.T.
K.L.T. van Genderen.
Genderen.

ACKNOWLEDGMENTS
ACKNOWLEDGMENTS
The author
author would
would like to acknowledge
acknowledge the follow
ing people: Mr. Curt InIn­
following
graham and Ms. Janice Enger of OSBORNE/McGraw-Hill,
OSBORNE/McGraw-Hill, who made many
corrections, improvements,
improvements, and suggestions;
suggestions; Mr. Gary Hankins, Mr. Michael
corrections,
Lehman, Mr.
Mr. Winthrop
inthrop Saville, and Mr. Stanley St. John of Sorrento Valley
Associates, who provided
provided assistance and examples;
examples; Mr. Leo Scanlon of
Associates,
Rockwell International,
International, who
who provided constant
constant encouragement
encouragement and reference
Rockwell
materials; Mr. Charles Peddle of Commodore
Commodore International,
International, who
who provided
materials;
some reference material;
material; Ms. Marielle
Marielle Carter of Sorrento
Sorrento Valley Associates,
Associates,
material; Mr. Stanley Rogers of the Society
Society forr ComCom­
who typed some of the material;
Simulation, who has continually
continually encouraged clear and concise technitechni­
puter Simulation,
cal writing;
ritin g ; and his wife
ife Donna, forr her patience and understanding
understanding
throughout the writing
riting of this book.
throughout
Others who provided assistance and suggestions
suggestions were Mr. Colin Walsh,
Walsh, Mr.
Romeo Favreau,
Amatneek, Mr. Robert Stow,
Stow,
Favreau, Mr. Richard Deisher, Mr. Karl Amatneek,
and Mr. Irv Stafford.
Stafford. Other students
students and colleagues also helped to keep the
right track.
author on the right
The author, of course, bears responsibility
responsibility forr any remaining
remaining errors, misconmiscon­
ceptions, and misinterpretations.
misinterpretations.
ceptions,
A special note of acknowledgment
acknowledgment should go to the magazine MICRO, which
which
is entirely
entirely dedicated
dedicated to 6502-based
6502-based personal computers.
computers. Besides numerous
articles, MICRO
contains resource and reference lists related to the
articles,
MICRO also contains
6502. MICRO
published monthly
monthly by Dr. Robert Tripp,
Tripp, The Computerist
Computerist
6502.
MICRO is published
Inc., P.O.
Chelmsford, MA 01824.
01824.
P.O.. Box 3, South Chelmsford,
dedicated on behalf
behalf of Amanda Catherine (Elizabeth Bramble) to
This book is dedicated
some very special people -— Catherine Greenlee,
Greenlee, Max and Peggy Leventhal,
Al and Rose Rosen,
Rosen, and Julius
Julius and Jeanette Ross.
Ross.
author would
would like to thank Karl
Amatneek, Mel Evans,
particularly
The author
Karl Amatneek,
Evans, and particularly
Philip Hooper forr their lists of corrections
corrections to earlier printings
printings of this book.

Contents
Page
Page

Chapter
Chapter
1

Introduction
Introduction to Assembly Language Programming
Programming
Book Has
Has Been
Been Printed
How This Book
The Meaning of Instructions
Instructions
A Computer
puter Program
The Programming
Programming Problem
Using Octal or Hexadecimal
Instruction Code Mnemonics
Mnemonics
Instruction
The Assembler
Assembler Program
Additional
Additional Features of Assemblers
Disadvantages of Assembly Language
Disadvantages
High-Level
High-Level Languages
Advantages of High-Level Languages
Advantages
Disadvantages of High-Level Languages
Disadvantages
High-Level Languages for Microprocessors
Microprocessors
High-Level
Which
hich Level Should You Use?
Use?
How About
About the Future?
Why
hy This Book?
Book?
References

1-11-1
1-11-1
1-11-1
1-21-2
1-21-2
1-31-3
1-41-4
1-51-5
1-61-6
1-61-6
1-71-7
1-71-7
1-81-8
1-91-9
1-10
1-10
1-11
1-11
1-12
1-12
1-13
1-13

2

Assemblers
Assemblers
Features of Assemblers
Assembler Instructions
Instructions
Assembler
Labels
Assembler Operation
Operation Codes (Mnemonics)
Assembler
Pseudo-Operations
Pseudo-Operations
The Data Pseudo-Operation
Pseudo-Operation
Pseudo-Operation
The Equate (or Define) Pseudo-Operation
Origin Pseudo-Operation
Pseudo-Operation
The Origin
Pseudo-Operation
The Reserve
Reserve Pseudo-Operation
Linking Pseudo-Operations
Pseudo-Operations
Linking
Housekeeping Pseudo-Operations
Pseudo-Operations
Housekeeping
ith Pseudo-Operations
Pseudo-Operations
Labels with
Addresses and the Operation
Operation Field
Addresses
Conditional Assembly
Assembly
Conditional
Macros
Comments
Comments
Assemblers
Types of Assemblers
Errors
Loaders
References

2-12-1
2-12-1
2-12-1
2-22-2
2-42-4
2-42-4
2-52-5
2-62-6
2-72-7
2-72-7
2-8
2-8
2-9
2-9
2-9
2-9
2-10
2-10
2-12
2-12
2-13
2-13
2-15
2-15
2-16
2-16
2-17
2-17
2-17
2-17
2-18
2-18

vii
vii

Contents (Continued)
Chapter
Chapter
3

Page
Page
The 6502 Assembly Language Instruction
Instruction Set
CPU Registers and Status Flags
CPU
Memory Addressing
Addressing Modes
6502 Memory
Memory
Memory -— Immediate
Immediate
Memory
Memory -— Direct
Implied or Inherent
Inherent Addressing
Addressing
Implied
Accumulator
Accum
ulator Addressing
Addressing
Pre-lndexed Indirect
Indirect Addressing
Addressing
Pre-Indexed
Post-Indexed Indirect
Indirect Addressing
Addressing
Addressing
Indexed Addressing
Indirect
Indirect Addressing
Addressing
Relative Addressing
Addressing
6502
6502 Instruction
Instruction Set
Abbreviations
Abbreviations
Instruction
Instruction Mnemonics
Mnemonics
Instruction Object
Object Codes
Instruction
Instruction
Instruction Execution Times
Status
mu lat
ADC -— Add Memory, with
ith Carry, to Accu
Accum
lator
AND —
AND Memory
Memory with
ith Accum
ulator
-AND
Accumulator
Accumulator
ASL -— Shift
Shift Accum
ulator or Memory
Memory Byte Left
BCC —
- Branch if Carry Clear (C = 0)
BCC
BCS -— Branch if Carry Set (C =1)
BCS
BEG -— Branch if Equal to Zero (Z = 1)
1)
BEQ
BIT -— Bit Test
1)
BMI -— Branch if Minus
inus (S = 1)
BNE -— Branch if Not Equal to Zero (Z = 0)
BNE
BPL -— Branch if Plus (S = 0)
BPL
BRK -— Force Break (Trap
(Trap or Software
BRK
Software Interrupt)
Interrupt)
BVC -— Branch if Overflow
Overflow Clear (V = 0)
1)
BVS -— Branch if Overflow
Overflow Set (V = 1)
CLC
LC -— Clear Carry
CLO -— Clear Decimal Mode
CLD
CLI -— Clear Interrupt
(Enable Interrupts)
CLI
Interrupt Mask (Enable
Interrupts)
CLV
L V -— Clear Overflow
Overflow
CMP -— Compare Memory
Memory with
ith Accum
ulator
Accumulator
CPX -— Compare Index Register with
CPX
ith Memory
Memory
CPY -— Compare Index Register Y with
CPY
ith Memory
Memory
DEC -— Decrement
1)
DEC
Decrement Memory
Memory (by 1)
DEX -— Decrement
DEX
Decrement Index
Index Register
RegisterXX (by
(by 1)
1)
DEY -— Decrement
DEY
Decrement Index
Index Register
Register YY (by
(by 1)
1)
EOR-— Exclusive-OR Accum
Accumulator
EOR
ulator with
ith Memory
Memory
-Increment
1)
INC —
Increment Memory
Memory (by 1)
INX -— Increment
1)
INX
Increment Index Register X (by 1)
1)
INY
Y -— Increment
Increment Index Register Y (by 1)
JMP -— Jumpp via Absolute
Absolute or Indirect
Indirect Addressing
Addressing
JSR —
-Jump
JSR
Jum p to Subroutine
Subroutine
LOA -— Load Accum
Accumulator
LDA
ulator from Memory
Memory
LDX
Register XX from
from Memory
Memory
LOX -— Load Index Register
LDY
Register YY from
from Memory
Memory
LOY -— Load Index Register
LSR -— Logical Shift
ccumulator
LSR
Shift Right of A ccum
ulator or Memory
Memory

viii
viii

3-1
3-1
3-3
3-3
3-5
3-5
3-6
3-6
3-7
3-7
3-8
3-8
3-8
3-8
3-9
3-9
3-10
3-10
3-11
3-11
3-13
3-13
3-14
3-14
3-15
3-15
3-15
3-15
3-17
3-17
3-17
3-17
3-17
3-17
3-17
3-17
3-38
3-38
3-40
3-40
3-41
3-41
3-43
3-43
3-44
3-44
3-44
3-44
3-45
3-45
3-47
3-47
3-47
3-47
3-48
3-48
3-49
3-49
3-51
3-51
3-51
3-51
3-52
3-52
3-53
3-53
3-54
3-54
3-55
3-55
3-56
3-56
3-58
3-58
3-59
3-59
3-60
3-60
3-61
3-61
3-62
3-62
3-63
3-63
3-65
3-65
3-67
3-67
3-68
3-68
3-69
3-69
3-70
3-70
3-71
3-71
3-72
3-72
3-74
3-74
3-76
3-76

(Continued)
Contents (Continued)
Page
Page

Chapter
(Cont.I
3 (Cont.)

NOP -— No Operation
NOP
ORA -— Logically OR
OR Memory with Accumulator
ORA
ulator
PHA -— Push
Push Accumulator
PHA
ulator onto Stack
PHP -— Push Status Register
Register (P)
(P) onto Stack
PHP
PLA -— Pull Contents of Accum
ulator from Stack
Accumulator
Stack
PLP -— Pull Contents of Status Register (P)
(P) from
from Stack
PLP
ROL
ulator or Memory Left through Carry
AOL -— Rotate Accum
Accumulator
Carry
ROR
ulator or Memory Right,
ROA-— Rotate Accum
Accumulator
Right. through Carry
Carry
RTI -— Return from Interrupt
RTI
Interrupt
RTS
Subroutine
ATS -— Return from Subroutine
SBC
Subtract Memory from Accumulator
ulator with Borrow
SBC -— Subtract
SEC
SEC -— Set Carry
SED
SEO-— Set Decimal Mode
SEI
Interrupt Mask (Disable
SEI -— Set Interrupt
(DisableInterrupts)
Interrupts)
lator in Memory
STA -— Store Accum
mu la
STX -— Store Index Register X in Memory
STY -— Store Index Register Y in Memory
TAX -— Move from Accum
ulator to Index Register
Accumulator
Register X
TAY-Move
— Move from Accum
ulator to Index Register
Accumulator
Register Y
TSX -— Move from Stack Pointer to Index Register
Register X
ulator
TXA -— Move from Index Register X to Accumulator
TXS -— Move from Index Register
Register X to Stack Pointer
ulator
TYA -— Move from Index Register Y to A ccum
ccumulator
6800/6502 Compatibility
om patibility
6B00/6502
MOS Technology
Technology 6502 Assembler Conventions
Conventions
Assembler Field Structure
Structure
Assembler
Labels
Pseudo-Operations
Examples
Examples
Labels with
ith Pseudo-Operations
Addresses
Assembler Features
Other Assembler

ix
ix

3-7B
3-78
3-79
3-79
3-B1
3-81
3-B2
3-82
3-B3
3-83
3-B4
3-84
3-B5
3-85
3-B7
3-87
3-B9
3-89
3-90
3-90
3-91
3-91
3-93
3-93
3-94
3-94
3-95
3-95
3-96
3-96
3-97
3-97
3-9B
3-98
3-99
3-99
3-100
3-100
3-101
3-101
3-102
3-102
3-103
3-104
3-105
3-105
3-109
3-109
3-109
3-109
3-109
3-109
3-109
3-109
3-110
3-110
3-110
3-110
3-111
3-111
3-111
3-111
3-112
3-112

Contents (Continued)
Chapter
Chapter

Page
Page

4

Simple
Programs
Simple
Programs
General Format of Examples
Guidelines for Solving Problems
Program Examples
8-Bitit Data Transfer
8-Bitit Addition
ddition
Shift
Shift Left One Bit
Mask Off Most Significant
Significant Four Bits
Clear a Memory Location
Word Disassembly
Find Larger of Two Numbers
16-Bit Addition
ddition
Table of Squares
Ones Complement
Ones
Complement
Problems
16-Bit Data Transfer
8-Bitit Subtraction
Subtraction
Shift Left Two Bits
Mask Off Least Significant
Significant Four Bits
Set a Memory Location to All Ones
Word Assembly
Find Smaller of Two Numbers
24-Bit
24-Bit Addition
ddition
Sum of Squares
Twos Complement
Complement

4-1
4-1
4-1
4-1
4-2
4-2
4-4
4-4
4-4
4-4
4-5
4-5
4-6
4-6
4-7
4-7
4-8
4-8
4-9
4-9
4-10
4-10
4-12
4-12
4-13
4-13
4-16
4-16
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-18
4-18
4-18
4-18
4-18
4-18
4-19
4-19

6
5

Loops
Simple Program Loops
Examples
Examples
Sum of Data
16-Bit Sum of Data
Number of Negative Elements
Maximum
aximum Value
Justify a Binary Fraction
Justify
Post-Indexed (Indirect)
Addressing
Ondirectl Addressing
Pre-Indexed (Indirect) Addressing
Pre-lndexed
Problems
Checksum of Data
Sum of 16-Bit Data
Number
Zero. Positive,
Positive. and Negative Numbers
Number of Zero,
inimum
Find M inim
um
Count 1 Bits

5-1
5-1
5-4
5-4
5-4
5-4
5-9
5-9
5-12
5-12
5-14
5-14
5-17
5-17
5-20
5-20
5-22
5-22
5-23
5-23
5-23
5-23
5-23
5-23
5-24
5-24
5-24
5-24
5-24
5-24

x
X

Contents (Continued)
Page
Page

Chapter
Chapter

86

Character-Coded
Character-Coded Data
Examples
Length
Length of a String of Characters
Find First Non-Blank Character
Character
Replace Leading Zeros with
ith Blanks
Add
Add Even Parity to ASCII Characters
Pattern Match
Match
Problems
Length
Length of a Teletypewriter
Teletypewriter Message
Find Last Non-Blank Character
Character
Truncate
Truncate Decimal String to Integer Form
Check Even Parity in ASCII Characters
String
String Comparison
Comparison

6-16-1
6-3
6-3
6-3
6-3
6-7
6-7
6-10
6-10
6-13
6-13
6-17
6-17
6-20
6-20
6-20
6-20
6-20
6-20
6-21
6-21
6-21
6-21
6-22
6-22

7

Code Conversion
Conversion
Examples
Hex to ASCII
Decimal to Seven-Segment
Seven-Segment
Decimal
ASCII to Decimal
BCD to Binary
Convert Binary Number
Number to ASCII
Convert
ASCII String
Problems
ASCII to Hex
Seven-Segment to Decimal
Seven-Segment
Decimal to ASCII
Decimal
Binary to BCD
BCD
ASCII String
String to Binary Number
Number
References

7-17-1
7-27-2
7-2
7-2
7-4
7-4
7-7
7-7
7-9
7-9
7-11
7-11
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-14
7-14
7-15
7-15

8

A rithm
etic Problems
rithmetic
Examples
Multiple-Precision
ultiple-Precision Binary Addition
Addition
Decimal Addition
Addition
Decimal
8-Bitit Binary Multiplication
ultiplication
8-B
8-Bitit Binary Division
Self-Checking Numbers Double Add Double Mod 10
Self-Checking
Problems
Multiple-Precision Binary Subtraction
Subtraction
Multiple-Precision
Decimal Subtraction
Subtraction
Decimal
8-B
16-Bit Binary Multiplication
ultiplication
8-Bitit by 16-Bit
Division
Signed Binary Division
Self-Checking Numbers Aligned
Aligned 1,
Self-Checking
1, 3,
3. 7 Mod 10
References

8-18-1
8-2
8-2
8-2
8-2
8-4
8-4
8-7
8-7
8-12
8-12
8-17
8-17
8-23
8-23
8-23
8-23
8-23
8-23
8-24
8-24
8-24
8-24
8-25
8-25
8-26
8-26

xi
xi

Contents (Continued)
(Continued}
Chapter

Page
Page

9

Tables
Tables and
and Lists
Lists
Examples
Examples
Add
Add Entry
Entry to
to List
List
Check
Check an
an Ordered
Ordered List
Remove
Remove Element
Element from
from Queue
Queue
8-Bit Sort
Sort
8-Bit
Using
Using an
an Ordered
Ordered Jump
Jump Table
Table
Problems
Problems
Remove
Remove an
an Entry
Entry From
From aa List
Add
Add an
an Entry to an
an Ordered
Ordered List
Add an
an Element to
to a Queue
Oueue
16-Bit Sort
Sort
16-Bit
Using a Jump Table with a Key
Key
References
References

9-1
9-1
9-2
9-2
9-2
9-2
9-5
9-5
9-8
9-8
9-12
9-12
9-16
9-16
9-18
9-18
9-18
9-19
9-19
9-20
9-20
9-21
9-21

10

Subroutines
Subroutine Documentation
Documentation
Subroutine
Examples
Examples
Hex
Hex to ASCII
ASCII
Length of a String of Characters
Maximum
aximum Value
Pattern Match
Multiple-Precision Addition
Addition
Multiple-Precision
Problems
ASCII
ASCII to Hex
Hex
Teletypewriter Message
Length of a Teletypewriter
Message
M inim
um Value
inimum
String Comparison
Decimal Subtraction
Subtraction
References
References

10-1
10-1
10-2
10-2
10-3
10-4
10-7
10-11
10-11
10-15
10-21
10-21
10-25
10-25
10-25
10-25
10-26
10-27
10-28

xii
xii

Contents
Contents (Continued)
(Continued)
Chapter
Chapter

11
11

Pago
Page

Input/Output
Input/O
utput
Tim
Timing Intervals
Intervals (Delays)
(Delays)
Delay
Delay Routines
Routines
Delay
Delay Program
Program
6502
utput Chips
6502 Input/O
Input/Output
Chips
The
The 6520
6520 Peripheral
Peripheral Interface
Interface Adapter
Adapter
PIA
PIA Control
Control Register
Register
Configuring
Configuring the
the PIA
PIA
Examples
Examples of
of PIA
PIA Configuration
Configuration
Using
Using the
the PIA
PIA to Transfer
Transfer Data
Data
The
The 6522
6522 Versatile
Versatile Interface Adapter
Adapter (VIA)
(VIA)
Configuring
Configuring the VIA
VIA
CA2
CA2 Input
CA2 Output
utput
Examples
Configuration
Examples of VIA Configuration
Using the VIA to Transfer Data
Data
VIA Interrupt
Interrupt Flag
Flag Register
Register
VIA Timers
Operation of 6522 VIA Timer 2
Operation of 6522 VIA Timer 1
The 6530 and 6532 Multifunction
ultifunction Support Devices
Examples
A Pushbutton
Pushbutton Switch
Switch
A Toggle
Toggle Switch
Switch
A Single LED
LED
Seven-Segment LED
LED Display
Problems
An On-Off
On-Off Pushbutton
Pushbutton
Debouncing a Switch
Switch in Software
Software
Debouncing
Control for a Rotary Switch
Switch
Control
Record Switch
Switch Positions on Lights
Lights
Count on a Seven-Segment
Seven-Segment Display
Count
Complex 1/0
I/O Devices
More Complex
Examples
An Unencoded
Unencoded Keyboard
An
An Encoded Keyboard
An
Digital-to-Analog Converter
Converter
A Digital-to-Analog
Analog-to-Digital Converter
Converter
Analog-to-Digital
A Teletypewriter
Teletypewriter (TTY)
A
(TTY)
6850 Asynchronous
Asynchronous Communications
Communications Interface
Interface
The 6850
Adapter (ACIA)
Adapter
The 6551
6551 Asynchronous
Asynchronous Communications
Communications Interface
Interface
The
Adapter (ACIA)
(ACIA)
Adapter
Logical and
and Physical
Physical Devices
Devices
Logical
Standard Interfaces
Interfaces
Standard
Problems
Problems
Separating Closures
Closures from
from an
an Unencoded
Unencoded Keyboard
Keyboard
Separating
Read aa Sentence
Sentence from
from an
an Encoded
Encoded Keyboard
Keyboard
Read
Variable Am
plitude Square
Square Wave
Wave Generator
Generator
AA Variable
Amplitude
Averaging Analog
Analog Readings
Readings
Averaging
30 Character-per-Second
Character-per-Second Terminal
Terminal
AA 30
References
References

xlii
xiii

11-1
11-1
11-8
11-8
11-9
11-9
11-10
11-10
11-12
11-12
11-13
11-13
11-15
11-15
11-18
11-18
11-19
11-19
11-21
11-21
11-23
11-23
11-27
11-27
11-31
11-31
111-31
-31
111-32
-32
11-34
11-34
11-35
11-35
11-36
11-36
11-37
11-37
11-38
11-38
11-39
11-39
11-43
11-43
11-43
11-43
11-50
11-50
111-61
-61
11-65
11-65
11-76
11-76
11-76
11-76
11-76
11-76
111-76
-76
11-77
11-77
11-77
11-77
11-78
11-78
11-81
11-81
11-81
11-81
11-90
11-90
11-93
11-93
11-98
11-98
11-103
11-103
11-111
11-111
11-118
11-118
11-123
11-123
11-124
11-124
11-125
11-125
11-125
11-125
11-125
11-125
11-126
11-126
11-126
11-126
11-126
11-126
11-127
11-127

Contents (Continued)
Chapter
Chapter
12

Page
Page
Interrupts
Interrupts
Interrupt System
6502 Interrupt
6520 PIA Interrupts
Interrupts
6520
Interrupts
6522 VIA Interrupts
6530 and 6532
6532 Multifunction
ultifunction Device Interrupts
Interrupts
ACIA Interrupts
Interrupts
Interrupt Systems
6502 Polling Interrupt
Vectored Interrupt
Interrupt Systems
6502 Vectored
Examples
A Startup
Startup Interrupt
Interrupt
A Keyboard Interrupt
Interrupt
A Printer
Printer Interrupt
Interrupt
A Real-Time Clock Interrupt
Interrupt
A Teletypewriter
Teletypewriter Interrupt
Interrupt
More General Service Routines
Problems
A Test Interrupt
Interrupt
A Keyboard Interrupt
Interrupt
A Printer Interrupt
Interrupt
A Real-Time Clock Interrupt
Interrupt
A Teletypewriter
Teletypewriter Interrupt
Interrupt
References

xiv

12-1
12-1
12-3
12-3
12-5
12-5
12-6
12-6
12-9
12-9
12-9
12-9
12-11
12-11
12-12
12-12
12-13
12-13
12-13
12-13
12-16
12-16
12-20
12-20
12-23
12-23
12-32
12-32
12-37
12-37
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-39
12-39

Contents
Contents (Continued)
(Continued)
Chapter
Chapter

13
13

Page
Page
Problem
Problem Definition
Definition and
and Program
Program Design
Design
The
The Tasks
Tasks of
of Software
SoftwareDevelopment
Development
Definition of
of the
the Stages
Stages
Definition
Problem Definition
Definition
Problem
Defining the
the Inputs
Inputs
Defining
Defining the
the Outputs
Outputs
Defining
Processing
Processing Section
Section
Error Handling
Handling
Error
Human
Human Factors
Factors
Examples
Examples
Response
Response to
to aa Switch
Switch
AA Switch-Based
Switch-Based Memory
Memory Loader
Loader
A
A Verification
Verification Terminal
Terminal
Review
Review of
of Problem
Problem Definition
Definition
Program
Program Design
Design
Flowcharting
Flowcharting
Examples
Examples
Response
Response to
to a Switch
The Switch-Based Memory Loader
The Credit-Verification
Credit-Verification Terminal
Modular
odular Programming
Examples
Examples
Response
Switch
Response to a Switch
The Switch-Based
Switch-Based Memory Loader
The Verification
Verification Terminal
Terminal
Review of Modular
Modular Programming
Programming
Structured Programming
Programming
Structured
Examples
Response
Switch
Response to a Switch
Switch-Based Memory
Memory Loader
The Switch-Based
Credit-Verification Terminal
Terminal
The Credit-Verification
of Structured
Structured Programming
Programming
Review of
Top-Down Design
Design
Top-Down
Examples
Examples
Response to
to aa Switch
Switch
Response
The Switch-Based
Switch-Based Memory
Memory Loader
Loader
The
The Transaction
Transaction Terminal
Terminal
The
Review of
of Top-Down
Top-Down Design
Design
Review
Review of
of Problem
Problem Definition
Definition and
and Program
Program Design
Design
Review
References
References

xv
xv

13-1
13-1
13-1
13-1
13-3
13-3
13-3
13-4
13-4
13-4
13-4
13-5
13-5
13-5
13-5
13-6
13-6
13-7
13-7
13-7
13-7
13-9
13-9
13-12
13-12
13-16
13-16
13-17
13-17
13-18
13-18
13-20
13-20
13-20
13-20
13-22
13-22
13-24
13-24
13-29
13-29
13-31
13-31
13-31
13-31
13-31
13-31
13-32
13-32
13-34
13-34
13-35
13-35
13-41
13-41
13-41
13-41
13-42
13-42
13-44
13-44
13-49
13-49
13-50
13-50
13-51
13-51
13-51
13-51
13-52
13-52
13-53
13-53
13-55
13-55
13-56
13-56
13-57
13-57

Contents (Continued)
Contents
Chapter
Chapter

14

Debugging and Testing
Debugging
Debugging Tools
Simple Debugging
Advanced Debugging
Debugging Tools
More Advanced
Debugging With
ith Checklists
Debugging
Looking for Errors
Errors
Debugging
Debugging Example 1: Decimal to Seven-Segment
Conversion
Debugging
Debugging Example 2: Sort into Decreasing Order
Introduction to Testing
Testing
Introduction
Selecting Test Data
Testing Example 1: Sort Program
Testing Example 2: Self-Checking Numbers
Testing Precautions
Conclusions
References
References

Page
14-1
14-1
14-1
14-1
14-8
14-8
14-10
14-10
14-11
14-11
14-15
14-15
14-19
14-19
14-25
14-25
14-27
14-27
14-28
14-28
14-28
14-28
14-29
14-29
14-29
14-29
14-30
14-30

15

Documentation and Redesign
Documentation
Redesign
Self-Documenting Programs
Self-Documenting
Comments
Commenting Example 1:
Multiple-Precision Addition
ddition
Commenting
1: Multiple-Precision
Commenting Example 2: Teletypewriter
Teletypewriter Output
utput
Commenting
Flowcharts as
as Documentation
Documentation
Documentation
Structured Programs as
as Documentation
Memory Maps
Parameter and Definition
Definition Lists
Library Routines
Library Examples
Examples
Library Example 1:
1: Sum of Data
Library Example
Example 2: Decimal to Seven-Segment Conversion
Library Example 3: Decimal Sum
Total Documentation
Documentation
Redesign
Redesign
Reorganizing to Use
Use Less
Less Memory
Major Reorganizations
References
References

15-1
15-1
15-1
15-1
15-3
15-3
15-5
15-5
15-7
15-7
15-9
15-9
15-9
15-9
15-10
15-10
15-11
15-11
15-13
15-13
15-14
15-14
15-14
15-15
15-16
15-16
15-17
15-17
15-18
15-18
15-19
15-21
15-21
15-22
15-22

16

Sample Projects
Project #1:: A Digital Stopwatch
Stopwatch
Project #2:: A Digital Thermometer
Thermometer
References
References

16-1
16-1
16-1
16-1
16-15
16-29

xvi
xvi

Figures
Figure

Page

5-1
5-1
5-2

Flowchart of a Program Loop
Flowchart
A Program Loop that Allow
Allowss Zero Iterations

5-2
5-3

11-1
11-1
11-2
11-3
11-4
11-5
11-6
11-7
11-8
11-B
11-9
11-10
11-11
11-11
11-12
11-13
11-14
11-15
11-16
11-17
11-18
11-19
11-20
11-21
11-21
11-22
11-23
11-24
11-25
11-26
11-27
11-28
11-29
11-30

11-3
11-3
11-4
11-4
11-6
11-7
11-14
11-24
11-26
11-26
11-30
11-40
11-42
11-43
11-50
11-50
11-55
11-56
11-62
11-66
11-67
11-68
11-75
11-82
11-82
11-83
11-90
11-94
11-95

11-32
11-33
11-34
11-35
11-36
11-37
11-38
11-39
11-40

An Output
utput Demultiplexer
ultiplexer Controlled by a Counter
An Output
utput Demultiplexer
ultiplexer Controlled by a Port
An Input
Input Multiplexer
ultiplexer Controlled by a Counter
An Input Multiplexer
ultiplexer Controlled by a Port
An Input
Input Handshake
An Output
utput Handshake
Block Diagram of the 6520 Peripheral Interface Adapter
Adapter
Block Diagram of the 6522 Versatile Interface Adapter
Adapter
6522 VIA Peripheral Control Register Bit Assignments
Assignments
6522 VIA Auxiliary
Auxiliary Control Register Bit Assignments
Assignments
The 6522 VIA Interrupt
Interrupt Flag Register
Register
Block Diagram of the 6530 Multifunction
ultifunction Device
Block Diagram of the 6532 Multifunction
ultifunction Device
A Pushbutton
Pushbutton Circuit
Circuit
An Interface for a Toggle Switch
A Debounce Circuit
Circuit Based
Based on Cross-coupled NAND
NANO Gates
Gates
An Interface for a Multi-Position
ulti-Position Switch
Switch
A Multiple-Position
ultiple-Position Switch
Switch with
ith an Encoder
Interfacing an LED
Interfacing
LED
Interfacing a Seven-Segment Display
Interfacing
Seven-Segment Display Organization
Seven-Segment
Seven-Segment Representations of Decimal Digits
Interfacing Multiplexed
ultiplexed Seven-Segment Displays
Interfacing
A Small Keyboard
A Keyboard Matrix
I/O
ent for a Keyboard Scan
1/0 Arrangem
Arrangement
I/O
1/0 Interface for an Encoded Keyboard
Signetics NE5018 D/A Converter
Interface for an 8-bit
8-bit Digital-to-Analog
Digital-to-Analog Converter
General
ing Diagram for the National
General Description and Timing
5357 A/D Converter
Connection Diagram and Typical
Typical Application
Application for the
Connection
A/D Converter
National 5357 AID
Analog-to-Digital Converter
Interface for an 8-bitit Analog-to-Digital
Teletypewriter Data Format
Teletypewriter
Flowchart for Receive
Flowchart
Receive Procedure
Flowchart for Transmit
Transmit Procedure
Flowchart
Block Diagram of the 6850 ACIA
Block Diagram of the 6551 ACIA
Definition of 6551 ACIA Control Register Contents
Definition
Definition of 6551 ACIA Command Register Contents
Definition
Definition of 6551 ACIA Status Register Contents
Definition

12-1
12-1
12-2
12-3

Saving the Status of the Microprocessor
Microprocessor in the Stack
Interrupt Enable
Description of the 6522 VIA Interrupt
Enable Register
Description of the 6522 VIA Interrupt
Interrupt Flag
Description
Flag Register

12-4
12-7
12-7

11-31
11-31

xvii
xvii

11-99

11-100
11-100
11-103
11-104
11-108
11-114
11-119
11-120
11-121
11-121
11-122

Figures (Continued)
Figure

Page

13-1
13-1
13-2
13-3
13-4
13-5
13-6
13-7
13-8
13-9
13-10
13-11
13-11
13-12
13-13
13-14
13-15
13-16
13-17
13-18
13-19
13-20

Flowchart
Flowchart of Software
Software Development
Development
The Switch
Switch and Light
Light System
The Switch-Based
Switch-Based Memory
Memory Loader
Block Diagram of a Verification
Verification Terminal
Terminal
Verification Terminal
Terminal Keyboard
Verification
Verification
Verification Terminal
Terminal Display
Standard Flowchart
Flowchart Symbols
Flowchart
Response to a Switch
Flowchart of One-Second Response
Switch
Flowchart
Flowchart of Switch-Based
Switch-Based Memory
Memory Loader
Flowchart
Flowchart of Keyboard Entry
Flowchart of Keyboard Entry Process
ith Send Key
Flowchart
Process with
Flowchart
Process with
Keys
Flowchart of Keyboard Entry Process
ith Function
Function Keys
Flowchart
Flowchart of Receive Routine
Flowchart
Flowchart of an Unstructured
Unstructured Program
Flowchart
Flowchart of the If-Then-Else Structure
Structure
Flowchart
Flowchart of the Do-While
hile Structure
Structure
Flowchart
Flowchart of the Do-Until
Do-Until Structure
Structure
Flowchart
Case Structure
Flowchart of the Case
Structure
Initial
Initial Flowchart
Flowchart for Transaction
Transaction Terminal
Terminal
Flowchart
KEYBOARD Routine
Flowchart for Expanded KEYBOARD

13-2
13-8
13-10
13-13
13-13
13-14
13-19
13-21
13-23
13-24
13-25
13-26
13-27
13-36
13-36
13-37
13-37
13-38
13-53
13-54

14-1
14-1
14-2
14-3
14-4
14-5
14-6

A Simple Breakpoint
Breakpoint Routine
Flowchart of Register Dump Program
Flowchart
Results of a Typical
Typical 6502 Register Dump
Results of a Typical
Typical Memory
Memory Dump
Flowchart
Flowchart of Decimal to Seven-Segment
Seven-Segment Conversion
Flowchart
Flowchart of Sort Program

14-2
14-5
14-5
14-6
14-15
14-20

16-1
16-1
16-2
16-3
16-4
16-5

I/O
Configuration for a Digital
Digital Stopwatch
Stopwatch
1/0 Configuration
I/O
Configuration for a Digital
Digital Thermometer
Thermometer
1/0 Configuration
Digital
Digital Thermometer
Thermometer Analog
Analog Hardware
Thermistor
Bead)
Thermistor Characteristics
Characteristics (Fenwal GA51J1 Bead)
Typical
E-I Curve for Thermistor
(25°C)
Typical E-l
Thermistor (25°C)

16-2
16-16
16-17
16-18
16-18

xviii
xviii

Tables
Table

Page
Page

1-1
1-1

Hexadecimal
Hexadecimal Conversion
Conversion Table
Table

1-4
1-4

2-1
2-2
2-3

The
The Fields
Fields of
of an
an Assembly
Assembly Language
Language Instruction
Instruction
Standard
Standard 6502
6502 Assembler
Assembler Delimiters
Delimiters
Assigning
Assigning and
and Using
Using aa Label
Label

2-1
2-1
2-2
2-2
2-3
2-3

3-1
3-2
3-3
3-4
3-5
3-6
3-7

Frequently
Frequently Used
Used Instructions
Instructions ff the
the 6502
6502
Occasionally
Occasionally Used
Used Instructions
Instructions of
of the
the 6502
6502
Seldom
Seldom Used
Used Instructions
Instructions of
of the
the 6502
6502
AA Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set
6502
6502 Instruction
Instruction Object
Object Codes
Codes inin Numerical
Numerical Order
Order
Summary
ith 6800
Summary of
of 6502
6502 Object
Object Codes
Codes wwith
6800 Mnemonics
Mnemonics
Memory
Memory Addressing
Addressing Modes
Modes Available
Available on
on the
the 6800
6800and
and
6502 Microprocessors
Microprocessors
Comparison
Comparison ofof 6800
6800 and
and 6502
6502 Assembly
Assembly Language
Language
Instruction Sets
Instruction

3-2
3-2
3-2
3-2
3-3
3-3
3-19
3-19
3-31
3-31
3-34
3-34

3-8

3-106
3-106
3-107
3-107

6-1

Hex-ASCII
Hex-ASCII Table
Table

6-2
6-2

11-1
11-2
11-3
11-4
11-5
11-6
11-7
11
11-8
11-9
11-10
11-11
11-12
11-13
11-14
11-15

Addressing
Addressing 6520
6520 PIA
PIA Internal
Internal Registers
Registers
Organization
Organization ofof the
the PIA
PIA Control
Control Registers
Registers
Control
Control of
of 6520
6520 PIA
PIA Interrupt
Interrupt Inputs
Inputs CA1
CA1 and
and CB1
CB1
Control
Control ofof 6520
6520 PIA
PIAInterrupt
Interrupt Inputs
Inputs CA2
CA2 and
and CB2
CB2
Control
utput Line
Control of
of 6520
6520 PIA
PIA CB2
CB2 OOutput
Line
Control ofof 6520
6520 PIA
PIACA2
CA2 OOutput
Line
Control
utput Line
Addressing
Addressing 6522
6522 VIA
VIA Internal
Internal Registers
Registers
Configurations
Configurations for
for 6522
6522 VIA
VIA Control
Control Line
Line CA2
CA2
Configurations
Configurations for
for 6522
6522 VIA
VIA Control
Control Line
Line CB2
CB2
Internal
ultifunction Device
Internal Addressing
Addressing for
for the
the 6530
6530 MMultifunction
Device
Internal
ultifunction Device
Internal Addressing
Addressing for
for the
the6532
6532 MMultifunction
Device
Data
Data Input
Input vs.
vs.Switch
Switch Position
Position
Seven-Segment
Seven-Segment Representations
Representations ofof Decimal
Decimal Numbers
Numbers
Seven-Segment
Seven-Segment Representations
Representations ofof Letters
Letters and
and Symbols
Symbols
Comparison
Comparison Between
Between Independent
Independent Connections
Connections and
and
Matrix
atrix Connections
Connections for Keyboards
Definition
Definition ofof6850
6850 ACIA
ACIA Register
RegisterContents
Contents
Meaning
Meaning ofofthe
the 6850
6850 ACIA
ACIA Control
Control Register
RegisterBits
Bits
Addressing
Addressing 6551
6551 ACIA
ACIA Internal
Internal Registers
Registers

11-13
11-13
11-15
11-15
11-16
11-16
11-16
11-16
11-17
11-17
11-17
11-17
11-25
11-25
111-28
-28
11-29
11-29
11-41
11-41
11-42
11-42
11-56
11-56
11-66
11-66
11-69
11-69

11-16
11-17
11-18
12-1
12-1

11-81
11-81
11-112
11-112
11-113
11-113
11-119
11-119

12-2

Memory
Memory Map
Map for
for6502
6502 Addresses
Addresses Used
Used ininResponse
Responsetoto
Interrupts and Reset
Interrupts
Reset
Addressing
ultifunction Device
Addressing the
the 6532
6532 MMultifunction
Device

12-4
12-4
12-10
12-10

14-1
14-1

6502
6502 Interrupt
Interrupt Vectors
Vectors

14-2
14-2

16-1
16-1
16-2

Input
Input Connections
Connections for
for Stopwatch
Stopwatch Keyboard
Keyboard
OOutput
utput Connections
Connections for
for Stopwatch
Stopwatch Keyboard
Keyboard

16-2
16-2
16-2
16-2

xix
xix

Chapter 1
Chapter
INTRODUCTION TO ASSEMBL
ASSEMBLY
INTRODUCTION
V
PROGRAMMING
LANGUAGE PROGRAMMING
that you are
This book describes assembly language programming. It assumes that
familiar
iliar with
ith An Introduction
Introduction To Microcomputers:
Microcomputers: Volume 1 —
Concepts1
- Basic Concepts
features of
(particularly Chapters 6 and 7). This book does not discuss
discuss the general features
microcomputers, addressing methods, or instruction sets; you should
computers, microcomputers.
should
refer to An Introduction To Microcomputers:
Microcomputers: Volume 1 for that
that information.
refer

HOW THIS BOOK HAS BEEN PRINTED
that text
x t in this book has been printed in boldface type and lightface
lightface type.
Notice that
that cover
cover subject
This has been done to help you skip those parts of the book that
matter
atter with
ith which you are familiar. You can be sure that
that lightface type only exex­
pands on information presented
presented in the previous boldface type. Therefore.
Therefore, only read
boldface type
type until
until you reach a subject
subject about
about which
hich you want
want to know
know more,
which
boldface
more. at which
point start
start reading
reading the lightface
lightface type.
point

THE MEANING
MEANING OF INSTRUCTIONS
INSTRUCTIONS
set of binary inputs that
that produce
The instruction set of a microprocessor is the set
produce
instruction set is to a microprocessor
microprocessor
defined actions during an instruction cycle. An instruction
what
hat a function
function table is to a logic device.
device, such as a gate,
shift register. Of
gate. adder,
adder. or shift
course, the actions
microprocessor performs
performs in response to its instruction
instruction inin­
course.
actions that
that the microprocessor
complex than the actions
actions that
that logic devices
devices perform
perform in response to
puts are far more complex
their inputs.
their
An instruction is a binary bit pattern
pattern -— it must be available
available at BINARY
the data inputs to the microprocessor at the proper tim e in INSTRUCTIONS
INSTRUCTIONS
order to be interpreted
interpreted as an instruction. For example.
example, when
when the
6502 microprocessor
microprocessor receives the 8-bit
-b it binary
binary pattern
pattern 11101000
11101000 as the input
input during an
6502
instruction fetch
fetch operation.
operation, the pattern
pattern means:
instruction
"Increm
ent (add 1 to) the contents
contents of Register X".
"Increment
Similarly, the pattern
pattern 10101001
10101001 means:
Similarly.
"Load the Accum
ulator with
ith the contents
contents of the next word of program
program memory"
memory".
"Load
Accumulator
microprocessor (like any other
other computed
computer) recognizes
recognizes only binary
binary patterns
patterns as inin­
The microprocessor
structions or data;
data: it does not recognize
recognize words
words or octal.
octal, decimal.
decimal, or hexadecimal
hexadecimal numnum­
structions
bers.
bers.

1-1
1-1

COMPUTER PROGRAM
PROGRAM
A COMPUTER
that causes a computer
computer to perform a particular
A program is a series of instructions that
task.
Actually, a computer
puter program
program includes
includes more than instructions:
instructions; it
COMPUTER
Actually.
It
COMPUTER
PROGRAM
contains the data and m em
ory addresses
addresses that
a t the
also contains
emory
microprocessor needs to accomplish
accomplish the tasks defined
defined by the inin­
microprocessor
structions. Clearly.
Clearly, if the microprocessor
microprocessor is to perform
perform an addition.
addition, it must
have two
two
structions.
must have
numbers to add and a place to put
put the result. The com
puter program
program must
must determine
determine
numbers
computer
the sources of the data and the destination
destination of the result
result as well
well as the operation
operation to be
performed.
Allll microprocessors
microprocessors execute
execute instructions
instructions sequentially
sequentially unless one of the instructions
instructions
execution sequence or halts the computer.
computer, i.e.,.. the processor gets the next
changes the execution
instruction
instruction from the next consecutive
consecutive memory address unless the current
current instruction
instruction
specifically directs
directs it to do otherwise.
otherwise.
specifically

Ultimately
ately every
every program is translated
translated into a set
set of binary numbers. For example,
example,
this is a 6502
6502 program that
that adds the contents
contents of memory locations 0 0 6
ig and
and
006015
006115
06215:
006116 and places the result
result in memory location 0 0 6
2 ig :
10100101
01100000
01100000
01100101
01100101
01100001
01100001
10000101
01100010
01100010

program. If this program
This is a machine language, or object, program.
were entered into the memory of a 6502-based
6502-based microcomputer.
microcomputer,
the m icrocom
puter would
would be able to execute it
directly.
icrocomputer
11directly.

PROBLEM
THE PR O G RAMMING
M M ING PROBLEM
There are many difficulties
difficulties associated with creating programs
programs
programs. These are
as object, or binary machine language, programs.
some
some of the problems:

OBJECT
PROGRAM
MACHINE
MACHINE
LANGUAGE
PROGRAM

1) The programs are
are d iffic
ifficult
1)
u lt to understand
understand or debug (binary numbers all look the
same. particularly
for a few hours).
hours)
same,
particularly after you have looked at them for
2)
2)

to enter since you must determine
The programs are slow to
determine each bit individually.
individually.

3)
3)

the task which
to perform in
The programs do not describe the
which you want
ant the computer
puter to
anything
anything resembling
resembling a human readable format.

4)
4)

are long and tiresome
tiresome to write.
The programs are

5)
5)

that are
are very d ifficu
1ff1cult
to locate and
The programmer
programmer often makes careless errors that
lt to
correct.

For
For example,
example. the following version of the addition object program
program contains a single
single
b it error.
error. Try to find it:
10100101
01100000
01100000
01110101
01100001
10000101
10000101
01100010
01100010

Although
handles binary
binary numbers w
with ease,
ease. people
people do not.
not. People
People find
find
A
lthough the computer
computer handles
binary
confusing, and
programmer
binary programs
programs long,
long. tiresome,
tiresome. confusing.
and meaningless. Eventually,
Eventually. a programmer
may
remembering some of
may start remembering
of the
the binary codes,
codes. but
but such
such effort
effort should
should be
be spent
spent more
more
productively.
productively.
1 -2

USING OCTAL OR HEXADECIMAL
AL
somewhat by writingg instrucinstruc­
OCTAL OR
We can improve the situation somewhat
tions using octal or hexadecimal, rather than binary numbers.
HEXADECIMAL
numbers.
HEXADECIMAL
W e will
ill use hexadecimal
hexadecimal numbers
numbers in this book because they are
standard for the microprocessor
microprocessor industry.
industry. Table 1-1
shorter, and because they are the standard
1-1
defines the hexadecimal
hexadecimal digits
digits and their
their binary
binary equivalents.
equivalents. The 6502
6502 program
defines
program to add
twoo numbers now becomes:
A5
60
65
61
85
62
At the very least,
hexadecimal version is shorter
shorter to write
rite and not quite
quite so tiring
tiring to
least. the hexadecimal
examine.

Errors
ewhat easier to find in a sequence of hexadecimal
hexadecimal digits. The er­
Errors are somewhat
erroneous version of the addition program,
hexadecimal form, becomes:
program, in hexadecimal
A5
60
75
61
85
62

The mistake is far more obvious.
obvious.
What
hat do we do with
ith this hexadecimal
hexadecimal program?
program? The microprocessor
microprocessor understands
only binary instruction codes.
answer is that we must
must convert
convert the hexadecimal
hexadecimal
codes. The answer
numbers to binary
binary numbers. This conversion
conversion is a repetitive,
repetitive, tiresome task.
numbers
task. People who
attem
pt it make all sorts of petty
petty mistakes, such as looking
looking at the wrong
attempt
wrong line, dropping
dropping a
transposing a bit or a digit.
bit, or transposing
repetitive, grueling
grueling task is,
however, a perfect
perfect job for a comcom­
HEXADECIMAL
This repetitive,
is, however.
HEXADECIMAL
puter. The computer
computer never gets tired or bored and never makes
LOADER
makes
LOADER
silly mistakes The idea then is to write
rite a program
that accepts
program that
hexadecimal numbers and converts them into binary numbers.
hexadecimal
numbers. This is a standard
program provided with
ith many microcomputers; it is called a hexadecimal
hexadecimal loader.
loader.
Is a hexadecimal
hexadecimal loader worth
worth having? If you are willing
illing to write
rite a program
program using binary
com­
numbers, and you are prepared to enter the program in its binary form into the computer, then you will
ill not need the hexadecimal
hexadecimal loader.
If you choose the hexadecimal
hexadecimal loader, you will
ill have to pay a price for it. The hexhex­
adecimal loader is itself
itself a program that
that you must load into memory. Furthermore,
Furthermore, the
adecimal
hexadecimal loader will
ill occupy
occupy memory
memory -— memory
memory that
that you may want
want to use in some
hexadecimal
other way.
The basic tradeoff.
tradeoff, therefore.
therefore, is the cost and memory
memory requirements
requirements of the hexadecimal
hexadecimal
savings in programmer
programmer time.
loader versus the savings
A hexadecimal
hexadecimal loader is well
ell worth
worth its small cost.
A hexadecimal
hexadecimal loader certainly
certainly does not solve every programming
programming problem. The hex­
hexadecimal version of the program is still
still difficult
ifficu lt to read or understand;
understand; for example, it
adecimal
does not distinguish
distinguish instructions
instructions from data or addresses,
program listing
listing
addresses, nor does the program
provide any suggestion
suggestion as to what
what the program
program does. What
hat does 85 or DO
provide
DO mean?
Memorizing a card full
full of codes is hardly an appetizing
appetizing proposition.
proposition. Furthermore,
Furthermore, the
Memorizing
codes will
ill be entirely
entirely different
different for a different
different microprocessor.
microprocessor, and the program
program will
ill re­
reamount of documentation.
documentation.
quire a large amount
1 -3

Hexadecimal Conversion Table
Table 1-1. Hexadecimal

Hexadecimal
Hexadecimal
Digit

Binary
Equivalent

Decimal
Equivalent

0
1
2
3
4
5
6
7

0000
0000
0001
0010
0010
0011
0100
0100
0101
0110
0111
1000
1001
1001
1010
1011
1011
1100
1101
1101
1110
1111
1111

0
1
2
3
4
5
6
7

8
9
A
B
C
D
E
F

8
9
10
11
11
12
13
14
15

INSTRUCTION CODE M N E M
O N IC S
INSTRUCTION
EMONICS
An obvious programming
improvement is to assign
programming improvement
assign a name to each instruction
code.
on ic" or memory jogger.
code. The instruction code name is called a "m n em
emonic"
jogger. The
instruction mnemonic should
way what
hat the instruction does.
should describe in some
some way
does.
fact. every microprocessor
PROBLEM
In fact,
microprocessor manufacturer
anufacturer (they can't
can't remember
PROBLEM
mnemonics for the
hexadecimal codes either) provides a set of mnemonics
WITH
microprocessor instruction
instruction set.
microprocessor
set. You do not have to abide by the
MNEMONICS
MNEMONICS
nothing sacred about
about them.
manufacturer's mnemonics; there is nothing
However. they are standard for a given microprocessor
However,
microprocessor and therefore understood
understood by all
users.
instruction codes that you will
ill find in manuals,
users. These are
are the
the instruction
manuals. cards,
cards. books,
books. ar­
articles. and programs. The problem with
Is that not all
ticles,
ith selecting instruction
instruction mnemonics
mnemonics is
instructions have
"obvious” names.
instructions do (e.g
(e.g.,.. ADD,
instructions
have "obvious"
names. Some instructions
ADD. AND,
AND. OR),
OR). others
SUB for subtraction.
XOR for exclusive-OR),
exclusive-OR). while
have obvious contractions
contractions (e.g
(e.g.... SUB
subtraction, XOR
hile still
others have
have neither. The result is such mnemonics as
as WMP,
WMP. PCHL,
PCHL. and even SOB
SOB
(guess what
means!). Most manufacturers
names
(guess
hat that means!).
manufacturers come up with
ith some reasonable names
ones. However,
However. users
users who devise their own mnemonics
and some hopeless ones.
mnemonics rarely do
much better than
manufacturer.
than the manufacturer
names to
to
Along with the instruction
instruction mnemonics.
mnemonics, the manufacturer
anufacturer will
ill usually assign names
the CPU
CPU registers. As with the
the instruction
names. some
some register names
names are
are obvious (e.g
the
instruction names,
(e.g.,..
have only historical
Again. we will
A for Accumulator)
Accumulator) while others may have
historical significance.
significance. Again,
use the
the manufacturer's
to promote standardization.
standardization.
use
anufacturer's suggestions
suggestions simply to

If we use
6502 instruction and
use standard 6502
and register mnemonics,
mnemonics,
Inc., our
our 6502
proas defined by MOS Technology, Inc.,
6502 addition pro­
gram
gram becomes:
LDA
LOA
ADC
ADC
STA
STA

-----

ASSEMBLY
LANGUAGE
LANGUAGE
PROGRAM
PROGRAM

$60
$60
$61
$61
$62
$62

The program is
is still far
far from
from obvious,
obvious. but at least some
some parts are
are comprehensible. ADC
ADC
The
is a considerable improvement
provement over
over 65; LDA
LOA and
and STA
STA suggest loading and
and storing
storing the
the
contents of the
ulator. W
instructions and
contents
the Accum
Accumulator.
We now know
know w
which lines
lines are
are instructions
and which are
are
data or
or addresses
addresses. Such
Such a program
program is
Is an assembly language
language program.
program.

1-4

THE ASSEMBLER PROGRAM
PROGRAM
How do we
we get
get the
the assembly
language program
program into
into the
thecom­
comassembly language
HAND
puter? Wee have to translate
translate it,it. either
into biASSEMBLY
either into
into hexadecimal
hexadecimal or into
bi­
ASSEMBLY
nary numbers. You can translate
protranslate an assembly language pro­
gram by hand, instruction
instruction by instruction.
instruction. This is called hand assembly.
Hand assembly
be illustrated
assembly of the addition
addition program may he
illustrated as follows:
Instruction
Instruction Mnemonic
Mnemonic
LOA
LDA
ADC
STA

Addressing
Addressing Method
Method
Zero Page
Page (direct)
(direct)
Zero
Zero Page
Page (direct)
(direct)
Zero
Zero Page
Page (direct)
(direct)
Zero

Hexadecimal Equivalent
A5
65
85

As with
task which is uninith hexadecimal
hexadecimal to binary conversion.
conversion, hand assembly is a rote task
unin­
teresting,
errors. Picking the wrong line,
line.
teresting, repetitive,
repetitive, and subject
subject to numerous minor errors.
transposing
the
transposing digits,
digits, omitting
itting instructions,
instructions, and misreading
misreading the codes are only a few of the
mistakes that
make. Most microprocessors
task even further
that you may make.
microprocessors complicate
plicate the task
further by
having instructions
long
instructions with
ith different
different word lengths. Some instructions
instructions are one word long
second
while
hile others are two
two or three words
words long. Some instructions
instructions require data in the second
third words,
words, others require memory addresses,
and third
addresses. register numbers,
numbers. or who knows
what?
what?

Assembly is another
another rote task that
that we can assign to the
Assembly
ASSEMBLER
m icro
com pu ter. The
The m icro co
m p u te r never
never makes
makes any
icrocomputer.
icrocomputer
SOURCE
SOURCE
mistakes when
when translating
translating codes; it always
always knows how many
mistakes
PROGRAM
words and what
h at format
at each instruction requires. The program
words
program
OBJECT
that does this job is an "assem
bler." The assembler
assembler program
that
"assembler."
program
PROGRAM
translates a user program, or "source"
source" program written
ritte n with
translates
mnemonics, into a machine language program,
je c t"
program, or "o bject"
hich the microcomputer
microcomputer can execute.
execute. The assem­
program, which
"iis'siiinbler's input is a source program and its output
output is an object program.
bler'
program.
tradeoffs that
that wee discussed in connection with
ith the hexadecimal
hexadecimal loader are
The tradeoffs
are
magnified in the case of the assembler. Assemblers are
are more expensive, occupy
peripherals and execution
execution time than do hexadecimal
more memory, and require more peripherals
loaders. While
hile users may (and often do) write
write their own loaders,
loaders, few care to write their
their
own assemblers.
Assemblers have their
their ownn rules that
that you must learn.
include the use
Assemblers
learn. These include
use of cer­
cerappropriate places,
tain markers (such as spaces,
spaces. commas, semicolons, or colons)
colons) in appropriate
places.
correct spelling,
spelling, the proper
proper control
control information,
information, and perhaps even the correct place­
correct
placement of names and numbers. These rules are usually simple and can be learned
ment
learned quickly.

1-5

A D DITIONAL
ITIO N A L FEATURES
FEATURES OF ASSEMBLERS
Early assemblers did little
little more than translate
translate the mnemonic
mnemonic names of instructions
instructions and
their binary
binary equivalents.
equivalents. However,
provide such adad­
registers into their
However. most assemblers now provide
ditional features
features as:
ditional
as:
1)
1)

A llow
ing the user to assign names to memory locations.
locations, input
input and output
output devices,
llowing
devices.
and even sequences of instructions.
instructions.

2)

Converting data or addresses from various number
number systems (e.g.,.. decimal
decimal or hexhex­
Converting
converting characters
characters into
into their
their ASCII
adecimal) to binary and converting
ASCII or EBCDIC
EBCDIC binary
codes.
codes.

3)

Performing some arithm
etic as part of the assembly process.
Performing
arithmetic
process.
Telling the loader program
program where
where in memory
memory parts of the program
program or data should be
Telling
placed.
A llow
ing the user to assign areas of memory
memory as temporary
temporary data storage and to
llowing
place fixed data in areas of program memory.
Providing the inform
ation required to include
include standard
standard programs
programs from program li­
Providing
information
libraries,
programs written
ritten at some other
other time,
current program.
braries. or programs
time. in the current

4)
5)
6)
7)

A llow
ing the user to control
control the format
at of the program
program listing
listing and the input
input and
llowing
output devices employed.
output

involve additional
additional cost and memomemo­
All of these features,
features. of course,
course. involve
CHOOSING
AN
ry. M icrocom
puters generally
generally have much simpler
simpler assemblers than
icrocomputers
do larger computers.
computers, but the tendency
tendency always is for the size of as­
ASSEMBLER
asASSEMBLER
ill often have a choice
choice of assemblers.
semblers to increase. You will
assemblers.
The important
portant criterion
criterion is not how many offbeat
offbeat features the assembler
assembler has,
has. but rather
convenient it is to work
work with
ith in normal practice.
how convenient

DISA DVANTAGES
VA N TAG ES OF A SSEMBLY
BLY LANGUAGE
The assembler.
assembler, like the hexadecimal
hexadecimal loader, does not solve all the problems of
programming. One problem is the tremendous
tremendous gap between
between the microcomputer
microcomputer in­
inset and the tasks which the microcomputer
microcomputer is to perform. Computer
Computer inin­
struction set
structions tend to do things
things like add the contents
contents of two registers.
registers, shift
shift the contents
contents of
structions
the Accum
ulator one bit. or place a new value in the Program Counter. On the other
Accumulator
hand,
generally wants
wants a m icrocom
puter to do something
something like check if an analog
hand. a user generally
icrocomputer
threshold, look for and react to a particular
particular command
command from a
reading has exceeded a threshold.
teletypewriter, or activate
activate a relay at the proper
proper time. An assembly language
language programprogram­
teletypewriter.
mer must
must translate
translate such tasks into a sequence of simple
simple computer
puter instructions.
instructions. The
translation can be a difficult.
ifficult, time-consuming
e-consuming job.
translation
Furthermore, if you are programming in assembly language, you must have detailed
Furthermore.
knowledge of the particular microcomputer
microcomputer that
that you are using.
knowledge
using. You must know
what registers and instructions
instructions the m icrocom
puter has.
precisely how the instructions
instructions
what
icrocomputer
has. precisely
affect the various registers.
registers, what
hat addressing
addressing methods
methods the computer
puter uses,
affect
uses. and a myriad
of other
other information.
information. None of this information
information is relevant
relevant to the task which
which the
m icrocom
puter must ultim
ately perform.
icrocomputer
ultimately

In addition.
addition, assembly language programs are not portable.

I

I

| PORTABILITY
PORTABILITY |

Each m icrocom
puter has its own assembly language.
language, which
which
icrocomputer
architecture. An assembly language program
program written
ritten for the 6502 will
ill
reflects its own architecture.
6800, Z80. 8080.
8080, or 3870
3870 microprocessor.
microprocessor. For example.
example, the addition
addition propro­
not run on a 6800.
gram written
ritten for the 8080
8080 would
would be:
LDA
LOA
MOV
LDA
LOA
ADD
STA

60H
B.A
8.A
61 H
B
62H

1-6

The lack of portability
on't
portability not only means that
that you w o
n 't be able to use your
your assembly
assembly
language
on't
language program
program on another
another microcomputer.
microcomputer, but
but it also means that
that you w o
n 't be able
icrocomputer
to use any programs
programs that
that weren't
weren't specifically
specifically written
ritten for the m icrocom
puter you are
particular drawback
drawback for microcomputers.
microcomputers, since these devices
devices are new
using. This is a particular
and few assembly
assembly language
language programs
programs exist for them. The result.
result, too frequently.
frequently, is that
you are on your
your own. If you need a program
program to perform
perform a particular
particular task,
task. you are not
likely
likely to find it in the small program
program libraries
libraries that
that most
most manufacturers
manufacturers provide. Nor are
you likely
likely to find it in an archive.
archive, journal
journal article.
article, or someone's
someone's old program
program file. You will
ill
probably
probably have to write
write it yourself.

HIGH-LEVEL LANGUAGES
HIGH-LEVEL

__________

The solution to many of the difficulties
difficulties associated with
ith as| COMPILER |
!COMPILER!
-le v e l" or
sembly language programs is to use, instead, "h ig h-level"
"procedure-oriented" languages. Such languages allow
allow you to describe tasks in
"procedure-oriented"
statement
forms that
that are problem oriented rather
rather than computer
computer oriented. Each statem
ent in
high-level language performs a recognizable function;
function; it will
ill generally correscorres­
a high-level
pond to many assembly language instructions. A program called a compiler transtrans­
lates the high-level
high-level language source program into object
object code or machine
language instructions.
Many
Many different
different high-level
high-level languages
languages exist for different
different types of
| FORTRAN |
!FORTRAN!
tasks. If,
example, you can express what
hat you want
ant the comcom­
If. for example.
puter
FORTRAN (Formula
puter to do in algebraic
algebraic notation.
notation, you can write
write your
your program
program in FORTRAN
Translation
Translation Language).
Language), the oldest
oldest and most widely
idely used of the high-level
high-level languages.
Now. if you want
numbers. you just
just tell the computer:
computer:
Now,
ant to add twoo numbers,
SUM== NUMB1 +
+ NUMB2
That is a lot simpler
simpler (and a lot shorter) than either
either the equivalent
equivalent machine
machine language
language propro­
That
gram or the equivalent
equivalent assembly
assembly language
language program. Other
Other high-level
high-level languages
languages inin­
clude
clude COBOL (for business
business applications).
applications), PASCAL (another
(another algebraic
algebraic language). PL/1 (a
FORTRAN. ALGOL,
ALGOL. and COBOL),
COBOL), and APL and BASIC (languages
combination
bination of FORTRAN,
(languages that
are popular
popular for time-sharing
e-sharing systems).

VANTAGES
A D VA
NTA G ES OF HIGH-LEVEL
HIGH-LEVEL LANGUAGES
high-level languages make programs easier and faster
faster to write.. A common
Clearly, high-level
estimate
ate is that
that a programmer can write
rite a program about ten times as fast
fast in a
high-level
high-level language as compared to assembly language.1-3
language.1'3 That
That is just
just writing
riting the
program;
program: it does not include
include problem
problem definition.
definition, program
program design.
design, debugging.
debugging, testing.
testing, or
documentation.
documentation, all of which
hich become simpler
simpler and faster. The high-level
high-level language
language propro­
gram is,
is. for instance.
Even if you do not know
FORTRAN. you
instance, partly
partly self-documenting.
self-documenting. Even
know FORTRAN,
probably
probably could
could tell what
hat the statement
statement illustrated
illustrated above does.
High-level languages solve many other
other problems associassoci­
High-level
MACHINE
MACHINE
ated with
programming. The high-level
ith assembly language programming.
high-level
INDEPENDENCE
language
language has its own syntax
syntax (usually defined
defined by a national
national or
OF HIGH-LEVEL
HIGH-LEVEL
international standard). The language
language does not mention
mention the inin­
international
LANGUAGES
struction
set. registers.
struction set,
registers, or other
other features
features of a particular
particular com-­
puter. The compiler
piler takes care of all such details. Programmers
Programmers can concentrate
concentrate on their
their
detailed understanding
understanding of the underlying
underlying CPU architecarchitec­
own tasks; they do not need a detailed
ture -— for that
that matter.
matter, they do not need to know
know anything
anything about
about the computer
puter they are
programming.
programming.
Programs written
ritte n in a high-level
high-level language are portable -—
at least, in theory. They will
ill run on any computer
puter that has a
standard
standard compiler
compiler for that
that language.

1-7

PORTABILITY
PORTABILITY
OF HIGH-LEVEL
HIGH-LEVEL
LANGUAGES

Att the same time.
time, all previous
previous programs
programs written
ritten in a high-level
high-level language
language for
for prior
prior com
com-­
available to you when
when programming
programming a new computer.
computer. This can mean thouthou­
puters are available
programs in the case of a common
common language
language like FORTRAN
sands of programs
FORTRAN or BASIC.
BASIC.

D ISA D VA
N TAG ES OF HIGH-LEVEL LANGUAGES
DVANTAGES
Well.
ell, if all the good things wee have said about
about high-level
high-level languages are true, if you
can write
rite programs faster
faster and make them portable besides, why
h y bother
bother with
ith asas­
Who wants
ants to worry
orry about registers.
registers, instruction codes,
sembly languages?
languages? Who
mnemonics,
that garbagel
that balance
mnemonics. and all that
garbage! As usual,
usual, there are disadvantages that
the advantages.
One obvious
obvious problem
problem is that
that you have to learn the "rules"
le s " or
SYNTAX OF
SYNTAX
"s y n
ta x " of any high-level
high-level language
ant to use.
HIGH-LEVEL
use. A highntax"
language you want
LANGUAGES
language has a fairly
fairly complicated
complicated set of rules.
ill find
level language
rules. You will
that it takes a lot of time just
just to get a program
program that
that is syntactically
syntactically
that
correct (and even then it probably
probably will
ill not do what
hat you want). A high-level
high-levelcomputer
correct
computer
language is like a foreign
foreign language. If you have a little
little talent.
talent, you will
ill get
getused
used to the
the
language
rules and be able to turn out programs
programs that
that the compiler
compiler will
ill accept. Still.
Still, learning
learning the
rules and trying
trying to get the program accepted
accepted by the compiler
compiler does not contribute
contribute
directly to doing
doing your job.
directly
Here,
example, are some FORTRAN
Here. for example.
FORTRAN rules:
• Labels must be numbers
numbers placed in the first
first five card columns
columns
• Statements
Statements must start in column
column seven
• Integer
Integer variables
variables must start
start with
ith the letters I,I. J,
M. or N
J. K,
K. L,
L. M,

------.

COST OF
Another
nother obvious
obvious problem is that you need a compiler
compiler to translate
programs written
ritten in a high-level
high-level language. Compilers
Compilers are expenexpen­
programs
COMPILERS
sive and use a large amount
amount of memory. While
hile most assemblers
occupy 2K to 16K
compilers occupy
occupy 4K to 64K bytes.
occupy
16K bytes of memory (1K
K=
= 1024),
1024). compilers
bytes. So
the amount
amount of overhead involved
involved in using the compiler
compiler is rather large.
large.
Furthermore, only some
ill make the implementaimplementa­
Furthermore.
some compilers will
ALGEBRAIC
ALGEBRAIC
tion of your task simpler.
well-suited
FORTRAN. for example,
example. is well-suited
simpler. FORTRAN,
NOTATION
to problems
problems that can be expressed as algebraic
algebraic formulas. If,
If.
however,
controlling a printer,
editing a string of characters.
characters, or monitoronitor­
however. your problem is controlling
printer. editing
ing an alarm system,
cannot be easily expressed in algebraic
algebraic notation. In
system. your problem cannot
fact,
ulating the
solution in algebraic
algebraic notation
notation may be more awkward
awkward and more
fact. formulating
the solution
d iffic
u lt than
ulating it in assembly, language. One answer
answer is to use a more suitable
ifficult
than formulating
high-level language. Some such languages exist,
idely used and
high-level
exist. but they are far less
less widely
standardized than FORTRAN.
ill not get many of the advantages
advantages of high-level
high-level
standardized
FORTRAN. You will
languages if you use these
implementation languages.
these so-called system implementation

------

..

High-level
igh-level languages do not produce very e fficient
ie n t
INEFFICIENCY
machine
OF HIGH-LEVEL
machine language
language programs.
programs. The basic reason
reason for this is that
compilation
pilation is an automatic
atic process which
hich is riddled with
ith com-­
LANGUAGES
promises to allow for
for many
many ranges of possibilities. The com-­
OPTIMIZING
OPTIMIZING
piler works much like aa computerized
computerized language translator
translator -—
COMPILER
sometimes the words are
right
but
the
sounds
and
sentence
are
structures are
compiler cannot know when a variable is no longer
structures
are awkward.
awkward. A simple compiler
being
being used and can
can be
be discarded,
discarded. when a register should be used rather than
than a memory
memory
location,
programmer can
location. or when
when variables
variables have
have simple
simple relationships.
relationships. The experienced
experienced programmer
take
few
take advantage
advantage of shortcuts
shortcuts to
to shorten execution
execution tim e or reduce memory
memory usage.
usage A few
compilers (known as
optimizing compilers)
are
compilers
as optimizing
compilers) can also
also do
do this,
this, but such compilers
compilers are
much larger and slower
slower than
than regular compilers.

1-8

advantages and disadvantages
disadvantages of high-level
high-level languages are:
The general advantages
are:

------ ..

Advantages:
Advantages:

ADVANTAGES
ADVANTAGES
OF
HIGH-LEVEL
LANGUAGES

• More convenient
convenient descriptions
descriptions of tasks
• Less time spent writing
ritin g programs
• Easier
documentation
Easier documentation
• Standard syntax
• Independence
Independence of the structure
structure of a particular
particular computer
puter
• Portability
Portability
• Availability
vailability of library
library and other
other programs

Disadvantages:
• Special rules
• Extensive hardware and software
software support
support required

DISADVANTAGES
DISADVANTAGES
OF
HIGH-LEVEL
LANGUAGES

Orientation of common
common languages to algebraic
algebraic or
• Orientation
business problems
• Inefficient
Inefficient programs
• Difficulty
ifficu lty of optim
izing code to meet time and memory requirements
requirements
optimizing
• Inability
Inability to use special features of a computer
puter conveniently
conveniently

HIGH-LEVEL LANGUAGES
LANGUAGES FOR
HIGH-LEVEL
FOR MICROPROCESSORS
Microprocessor users will
ill encounter several
several special difficultiess when
when using
Microprocessor
using highhighlevel languages.
level
languages. Among these are:
• Few high-level
high-level languages exist
exist for microprocessors
microprocessors
• Few standard languages are widely
idely available
• Compilers usually require a large amount of memory or even a comcom­
pletely different
different computer
pletely
ost microprocessor
ell-suited to high-level
• Most
microprocessor applications are not well-suited
languages
languages
Memory costs are often critical in microprocessor applications
• Memory
The lack of high-level
high-level languages is partly a result of the fact that microprocessors
microprocessors are
quite new and are the products
products of semiconductor
semiconductor manufacturers
manufacturers rather than computer
computer
quite
manufacturers. Very few high-level
high-level languages exist for microprocessors. The most comcom­
manufacturers.
mon are BASIC,
PL/l-type languages such as PL/M,7
PL/M,7
BASIC,5 PASCAL,®
PASCAL.6 FORTRAN,
FORTRAN, and the PL/I-type
MPL,
MPL, and PLjuS.
PLJ.tS.
'
high-level languages that exist do not conform
conform to recognized standards, so
Many of the high-level
microprocessor user cannot
cannot expect
expect to gain much program portability,
portability, access to
that the microprocessor
libraries, or use of previous experience or programs. The main advantages
advantages re­
program libraries.
remaining are the reduction
reduction in programming
programming effort
effort and the smaller amount
amount of detailed
maining
understanding of the computer
puter architecture
architecture that is necessary.
understanding
necessary.
The overhead involved
involved in using a high-level
high-level language with
ith
OVERHEAD
microprocessors is considerable.
considerable. Microprocessors
Microprocessors themselves are
FOR
microprocessors
FOR
better suited to control
control and slow interactive
interactive applications
applications than they
better
HIGH-LEVEL
are to the character
character manipulation
anipulation and language analysis involved
LANGUAGES
in compilation.
compilation. Therefore.
Therefore, some compilers
compilers for microprocessors
microprocessors will
ill
microprocessor-based system. Instead, they require a much larger comcom­
not run on a microprocessor-based
cross-compilers rather than self-compilers.
self-compilers. A user must not only
puter; i.e.,.. they are cross-compilers
bear the expense of the larger computer
puter but must also physically
physically transfer
transfer the program
from the larger computer
puter to the micro.

1-9

Some self-compilers
icrocomputer
self-compilers are available.
available. These compilers
compilers run on the m icrocom
puter for which
which
they produce
produce object
object code. Unfortunately.
Unfortunately, they require
require large amounts
amounts of memory
memory (16K or
more), plus special
special supporting
supporting hardware
hardware and software.
software.
morel.

UNSUITABILITY
High-level
UNSUITABILITY
High-level languages
languages also are not
not generally
generally well-suited
well-suited to
microprocessor applications.
applications. Most
Most of the common
common languages
languages
microprocessor
OF HIGH-LEVEL
HIGH-LEVEL
LANGUAGES
were
LANGUAGES
were devised
devised either
either to help solve scientific
scientific problems
problems or to
ha
n d le la rg e
-s c a le b u s
in e s d a
ta p ro c
e s in g . Few
Few
andle
rge-scale
usiness
ata
rocessing.
microprocessor applications
applications fall in either
either of these areas. Most
Most microprocessor
microprocessor
microprocessor
applications
information
applications involve
involve sending
sending data and control
control inform
ation to output
output devices
devices and
receiving data and status
status inform
ation from input
input devices. Often
Often the control
control and status
status
receiving
information
information
consists of a few binary
hardware-related
information consists
binary digits
digits with
ith very precise hardware-related
meanings.
meanings. If you try to write
rite a typical
typical control
control program
program in a high-level
high-level language.
language, you
often
often feel like someone
someone who
ho is trying
trying to eat soup with
ith chopsticks.
chopsticks. For tasks in such
areas as test equipment.
equipment, terminals.
terminals, navigation
navigation systems.
systems, signal
signal processing.
processing, and business
equipment.
high-level
languages work
work much
than they
they do in
equipm
ent, the high-level
languages
uch better
better than
instrumentation.
automotive
instrumentation, communications,
communications, peripherals.
peripherals, and autom
otive applications.
applications.
Applications better
better suited
suited to high-level
high-level languages
languages are those which
which
Applications
APPLICATION
APPLICATION
require large memories. If,
If. as in a valve controller.
game.
AREAS FOR
controller, electronic
electronic game,
LANGUAGE
appliance
controller, or small
appliance controller.
small instrument,
instrument. the cost of a single
memory
LEVELS
LEVELS
memory chip is important.
important, then the inefficiency
inefficiency of high-level
high-level
languages
If. on the other
hand. as in a terminal
languages is intolerable.
intolerable. If,
other hand,
inal or
test equipment.
equipment, the system has many thousands
thousands of bytes of memory
memory anyway.
anyway, the ineffiineffi­
ciency
ciency of high-level
high-level languages
languages is not as important.
important. Clearly the size of the program
program and
the volume
volume of the product
product are important
portant factors as well. A large program
program will
ill greatly
greatly inin­
hand. a high-volume
apcrease the advantages
advantages of high-level
high-level languages. On the other
other hand,
high-volume ap­
plication will
ill mean that fixed software
software development
development costs are not as important
portant as
plication
memory
memory costs that are part of each system.

W HICH
H LEVEL
LEVEL SHOULD YOU USE?
USE?
That
That depends on your particular
particular application. Let us briefly note some of the factors
which may favor particular
particular levels:

Machine Language:
Machine
• Virtually
Virtually no
no one programs in machine language
because it is inefficient
inefficient and difficult
ifficu lt to document.
An assembler
assembler costs very little and greatly reduces
programming time.
Assembly Language:

• Short to moderate-sized
moderate-sized programs
programs
• Applications where memory cost is
is a factor

APPLICATIONS
APPLICATIONS
FOR MACHINE
MACHINE
LANGUAGE

APPLICATIONS
APPLICATIONS
FOR ASSEMBLY
FOR
ASSEMBLY
LANGUAGE

• Real-time
Real-time control applications
• Limited data processing
• High-volume
High-volume applications
more input/output
• Applications involving more
input/output or control than computation

11-10

High Level
Level Languages:
Languages:
• Long programs
programs
• Low-volum
pro­
Low-volumee applications requiring long programs

APPLICATIONS
APPLICATIONS
FOR HIGH-LEVEL
LANGUAGE

where the amount of memory required is already very large
• Applications where
computation than input/output
input/output or control
• Applications involving more computation
patibility with
ith similar applications using larger computers
• C om
ompatibility
bility of specific programs
high-level language which
hich can be
• A vaila
vailability
programs in a high-level
used in the application
factors are also important.
important, such as the availability
availability of a larger computer
computer for
Many other factors
use in development.
development, experience
experience with
ith particular
particular languages, and com
patibility with
ith other
other
compatibility
applications.
applications.
If hardware
hardware will
ill ultim
ately be the largest cost in your
your application,
application, or if speed is critical,
critical,
ultimately
you should favor assembly language. But be prepared to spend extra time in software
software
development in exchange
exchange for lower memory costs and higher
higher execution
execution speeds.
soft­
development
speeds. If softill be the largest cost in your application,
application, you should favor a high-level
high-level language.
ware will
supporting hardware
hardware and
But be prepared to spend the extra money required for the supporting
software.
Of course, no one except
except some theorists
theorists will
ill object
object if you use both assembly and highlevel languages. You can write
rite the program
program originally
originally in a high-level
high-level language
language and then
patch some sections
sections in assembly language.7
language. However, most users prefer
prefer not to do this
because of the havoc it creates in debugging,
debugging, testing, and documentation.
documentation.

HOW ABOUT THE FUTURE?
FUTURE?
We expect
ill favor high-level languages
ing reasons:
expect that
that the future will
languages for the follow
following
reasons:
• Programs always seem to add extra features and
grow larger
• Hardware and memory are becoming
becoming less
less expensive

FUTURE TRENDS
IN LANGUAGE
LEVELS
LEVELS

• Software
Software and programmers
programmers are becoming
becoming more ex­
expensive
• Memory
er bit" cost,
Memory chips are becoming
becoming available in larger sizes,
sizes, at lower "per
cost.
so actual savings in chips are less
less likely
• More suitable
suitable and more efficient
efficient high-level
high-level languages are being developed
• More standardization
standardization of high-level
high-level languages will occur
Assembly language programming
programming of microprocessors
microprocessors will
ill not be a dying art any more
Assembly
than it is now for
computers. But longer programs, cheaper memory, and more ex­
for large computers.
expensive programmers
programmers will make software costs a larger part of most applications.
applications. The
edge in many applications
applications will
ill therefore go to high-level
high-level languages.

111
1-11

WHY
Y THIS BOOK?
BOOK?
high-level languages,
hy have a book on as­
If the future would seem to favor high-level
languages, why
assembly language
language programming?
programming? The reasons are:
1)
1)

Most current
current m icrocom
puter users program in assembly language
language (almost two
Most
icrocomputer
thirds, according
according to one recent
recent survey).
thirds.
survey).

2)

puter users will
ill continue
continue to program
program in assembly language
language since
Many m icrocom
icrocomputer
detailed control
control that
that it provides.
they need the detailed
No suitable
suitable high-level
high-level language
language has yet become widely
idely available
available or standardized.
standardized.

3)
4)
5)

applications require the efficiency
efficiency of assembly language.
Many applications
understanding of assembly
assembly language
language can help in evaluating
evaluating high-level
high-level
An understanding
languages.

The rest of this book will
ill deal exclusively
exclusively with
ith assemblers and assembly language
language propro­
gramming. However,
want readers to know that
language is not the
gramming.
However. we do want
that assembly language
alternative. You should
should watch
watch for new developments
developments that
that may significantly
significantly reduce
only alternative.
programming costs if such costs are a major factor
factor in your
your application.
application.
programming

11-12

REFERENCES
1.
2.
3.
4.
5.
6.
7.
8.

Introduction to Microcomputers:
icrocomputers: Volume
Volume 1 -— Basic Concepts,
Concepts.
A. Osborne, An Introduction
Osborne/McGraw-Hill, Berkeley,
CA„ 1976.
Osborne/McGraw-Hill.
Berkeley, CA,
M. H.
Software Science.
Science. American
American Elsevier,
H. Halstead, Elements of Software
Elsevier. New York, 1977.
V. Schneider, "Prediction
"Prediction of Software
Software Effort and Project Duration,"
Duration," SIGPLAN
SIGPLAN
Notices. June 1978,
Notices.
1978. pp. 49-55.
M. Phister Jr.,.. Data Processing Technology
Technology and Economics.
Economics, Santa Monica
Monica PublishPublish­
Monica, CA, 1976.
ing Co.,.. Santa Monica.
1976.
Albrecht, Finkel,
Computers. Wiley.
Wiley, New York,
Albrecht.
Finkel. and Brown, BASIC
BASIC for Home Computers.
York. 1978.
1978.
K.
puter Problem Solving Using PASCAL,
Springer-Verlag, New
K. L.
L. Bowles,
Bowles. M icrocom
icrocomputer
PASCAL. Springer-Verlag.
York,
York. 1977.
D.
Programming for M icrocom
puter Applications,
Applications,
D. D.
D. McCracken. A Guide to PL'M Programming
icrocomputer
Addison-Wesley, Reading,
Mass.,.. 1978.
Addison-Wesley.
Reading. Mass
1978.
P.
Caudill, "Using
"Using Assembly
Assembly Coding to Optimize High-Level Language Programs,"
P. Caudill.
Programs."
Electronics, February 1,
Electronics.
1, 1979,
1979. pp. 121-124.

11-13

Chapter 2
ASSEMBLERS
ASSEMBLERS
This chapter
chapter discusses the functions
functions performed by assemblers,
beginning with features
assemblers, beginning
common to most assemblers and proceeding through
through more elaborate capabilities
capabilities such
as
conditional assembly.
chapter for the present
as macros and conditional
assembly. You may wish to skim this chapter
and return to it when you feel more comfortable
comfortable with
ith the material.

FEATURES OF ASSEMBLERS
ASSEMBLERS
As we mentioned previously, today's
today's assemblers do much more than translate as­
assembly language
ill describe how an as­
language mnemonics into binary codes.
codes. But w e will
assembler handles the translation of mnemonics before describing additional assemassem­
sembler
bler features. Finally, we will
ill explain how assemblers are used.
used.

ASSEMBLER INSTRUCTIONS
ASSEMBLER
Assembly language
language instructions
instructions (or "sta te
m e n ts") are divided
divided
Assembly
"statements")
into a number
number of fields,
fields, as shown
shown in Table
Table 2-1.
into

ASSEMBLY
ASSEMBLY
LANGUAGE
FIELDS

operation code
code field
field is the
the only
only field
field that
that can never
never be
The operation
empty; it always
always contains
contains either
either an instruction
instruction mnemonic
mnemonic or a
empty;
directive to the assembler,
assembler, called
called a pseudo-instruction,
pseudo-instruction, pseudo-operation,
pseudo-operation, or
directive
pseudo-op.
pseudo-op.
The operand or address field may contain an address or data, or it may be blank.

The comment
comment and label fields are optional. A programmer will
ill assign a label to a
statem
ent or add a comment
comment as a personal convenience:
convenience: namely, to make the propro­
statement
gram easier to read and use.
Assembly Language Instruction
Instruction
Table 2-1. The Fields of an Assembly

Code
Label Operation
Operation Code
Label
or Mnemonic
Mnemonic
Field
or
Field
Field

NEXT
NEXT

LDA
ADC
STA
?

VAL1
VAL2
SUM

’·=·+1
=*+1
*=
*+ 1
·=·+1
*=
*+ 1
·=·+1

START
START

Operand or
Address
Field

Comment Field
Comment

VAL1
VAL2
VAL2
SUM
?
?

;LOAD FIRST
:LOAD
FIRST NUMBER
NUMBER INTO A
;ADD SECOND
SECOND NUMBER
NUMBER TO A
iSTORE
;STORE SUM
:NEXT INSTRUCTION
INSTRUCTION

2-1
2-1

Assembler Delimiters
Delimiters
Table 2-2. Standard 6502 Assembler

'space' between label and operation code and between operation
'space'
code and address
, between operands in the address field
;: or !I before a comment
comment
Note that 6502 assemblers vary greatly
greatly and some may not use these delimiters.

course, the assembler must have some way
Of course,
ay of telling
|FORM AT!
use
where one field ends and another begins.
begins. Assemblers that use
input often require that each field start in a specific
specific card column. This is
punched card input
However. fixed formats are inconvenient
a fixed format. However,
inconvenient when
when the input
input medium is
paper tape; fixed formats
formats are also a nuisance to programmers. The alternative
alternative is a free
format where the fields may appear anywhere
anywhere on the line.
format
line.
If the assembler cannot
cannot use the position
position on the line to tell the
apart. it must use something
else. Most
fields apart,
something else.
ost assemblers use a

I

|PEUMITERS|
!DELIMITERS

special symbol or delimiter
iter at the beginning or end of each field. The most common
common
delimiter
Commas. periods,
periods. semicolons.
colons. slashes,
slashes. quesdelim
iter is the space character. Commas,
semicolons, colons,
ques­
tion marks,
other characters that would
would not otherwise
otherwise be used in assembly
marks. and other
language programs may also serve as delimiters. Table 2-2 lists standard 6502 assem­
assemdelimiters.
bler delimiters.
You will
ill have to exercise a little care with
ith delimiters. Some assemblers are fussy
ellabout extra spaces or the appearance of delimiters in comments or labels. A wellwritten
ritte n assembler
assembler will
ill handle these minor problems, but many assemblers are not
ll-written.
can.
w e ll-w
ritte n . Our recommendation is simple: avoid potential
potential problems if you can.
The following
ing rules will
ill help:
1)
1)

spaces. particularly
Do not use extra spaces,
particularly after commas that separate operands.

2)

delimiter
labels.
Do not use delim
iter characters
characters in names or labels.
Include standard delim
delimiters
iters even if your assembler does not require them. Your propro­
grams will
ill then run on any assembler.

3)

LABELS
The label field is the first field in an assembly language inin­
LABEL
LABEL
present. the assembler
struction: it may be blank. If a label is present,
struction;
FIELD
defines the label as equivalent
equivalent to the address into which
hich the first
object program resulting
resulting from that instruction
instruction is loaded.
byte of the object
loaded. You may subse­
subsequently
quently use the label as an address or as data in another
another instruction's
instruction's address field. The
assembler will
proill replace the label with
ith the assigned value when
when creating
creating an object
object pro­
gram.
gram.
Labels are most frequently
frequently used in Jump, Call, or Branch
Branch in­
in- LABELS
LABELS
structions. These instructions
instructions place a new value in the Program
JUMP
IN JUMP
Counter
Counter and so alter the normal sequential
sequential execution
execution of instrucinstruc­
INSTRUCTIONS
INSTRUCTIONS
tions. JUMP 150-|6
"place the vakje
1 0 in
15016 means "place
value 15016
In the Program
Counter".
Counter". The next instruction
instruction to be executed will
ill be the one in memory location
START means "place
"p1ace the value assigned to the label
15015.
1 6. The instruction
instruction JUMP START
START
instruction to be executed will
ill be the one at
START in the Program Counter”
Counter". . The next instruction
START. Table 2-3 contains
the address corresponding
corresponding to the label START.
contains an example.

2-2
2-

Assigning and Using a Label
Table 2-3. Assigning
ASSEMBLY LANGUAGE
LANGUAGE PROGRAM
PROGRAM
START

LOAD ACCUMULATOR 100

• (MAIN PROGRAM)
PROGRAM)

JUMP START
START
When
hen the machine language version of this program is executed.
executed, the instruction
instruction
JUMP START
instruction labeled START
START causes the address of the instruction
START to be placed
in the Program Counter. That instruction
instruction will
ill then be executed.

Why
hy use a label? Here are some reasons:
1)
1) AA label
label makes
makes aa program
program location
location easier
easier to
to find
find and
and remember.
remember.
2)
as­
2) AA label
label can
can easily
easily be
be moved,
moved. ifif required,
required. to
to change
change or
or correct
correct aa program.
program. The asill automatically
atically change all instructions
instructions that use that label when the pro­
sembler will
program is reassembled.
reassembled.
3)
3) The
The assembler
assembler or
or loader
loader can
can relocate
relocate the
the whole
whole program
program by
by
RELOCATION
constant (a relocation constant) to each address for
CONSTANT
adding a constant
CONSTANT
which a label was used.
which
used. Thus we can move the program to
allow for the insertion of other programs or simply
ply to rearrange memory.
memory.
4) The
i.e.,.. itit is
The program
program is
is easier
easier to
to use
use as
as aa library
library program:
program; i.e
is easier
easierfor
forsomeone
someoneelse
else
to take your program and add it to some totally
totally different
different program.
5)
5)

You do not have to figure out memory addresses.
addresses. Figuring out memory addresses
addresses is
particularly
ifficu lt with
ith microprocessors which
hich have instructions
particularly difficult
instructions that vary in
length.

You should assign a label to any instruction
instruction that you might
ight want
ant to refer to later.
later.

The next
next question is how to choose
choose a label. The assembler
CHOOSING
often places some
LABELS
some restrictions on the number of characters
LABELS
(usually 5 or 6),
character (often must be a letter),
6). the leading character
letter). and
the trailing
trailing characters (often must be
be letters,
letters. numbers,
numbers. or one of a few special charac­
characters).
restrictions, the choice is up to you.
ters). Beyond these restrictions.
you.
Our own preference is to
to use
use labels that suggest their purpose,
purpose, i.e.,
i.e.. mnemonic labels.
labels.
Typical examples are
are ADDW in a routine that adds one word into a sum,
sum. SRETX
SRETX in a
routine that searches
searches for
for the ASCII
ASCII character ETX,
ETX. or NKEYS
NKEYS for a location in data
memory that contains the
Meaningful labels
the number of key entries.
entries. Meaningful
labels are
are easier
easier to
to
remember and contribute
contribute to
documentation. Some
to program documentation.
Some programmers
programmers use
use a stan­
standard form
self-sequencing
format for
for labels,
labels. such as
as starting
starting with L0000. These labels
labels are
are self-sequencing
(you
document the
(you can
can skip a few
few numbers to permit insertions),
insertions). but they
they do not help document
the
program.
program.

22-3

Some label selection rules will
ill keep you out of trouble. We
recommend the following:
ing:

RULES OF
LABELING

1)
1)

Do not use labels that
that are the same as operation
operation codes or
other mnemonics.
mnemonics. Most
Most assemblers will
ill not allow
allow this usage; others will.
will, but it is
very confusing.
confusing.

2)

Do not use labels that
that are longer
longer than the assembler
assembler permits. Assemblers
Assemblers have
truncation rules.
various truncation
rules.

3)

Avoid
Avoid special characters
characters (non-alphabetic
(non-alphabetic and non-numeric)
non-numeric) and lower-case
lower-case letters.
permitit them:
ones. The simplest
Some assemblers will
ill not perm
them; others allow only certain
certain ones.
simplest
practice is to stick to capital
capital letters and numbers.
practice
Start each label with
ith a letter. Such labels are always
always acceptable.
acceptable.
Start

4)
5)

I. 0 and
Do not use labels that
that could
could be confused
confused with
ith each other. Avoid
Avoid the letters
letters I,
Z. and the numbers
0. 1,
1. and 2. Also avoid things
Z,
numbers 0,
things like XXXX and XXXXX. There's
no sense tempting
pting fate and Murphy's
urphy's laws.

6)

legal. do not use it. You will
When
hen you are not sure if a label is legal,
ill not get any real
benefit
benefit from discovering
discovering exactly
exactly what
hat the assembler will
ill accept.

rules. You do not have to follow
them. but don't
These are recommendations.
recommendations, not rules.
follow them,
on't blame
us if you waste
waste time on silly
silly problems.

ASSEMBLER OPERATION CODES (M N EM
O N IC S)
EMONICS)
assembler is the translation of mnemonic operation codes
The main task of the assembler
into their
their binary equivalents.
equivalents. The assembler performs
performs this task using a fixed table
much as you would
would if you were doing
doing the assembly by hand.
assembler must,
translate the operation
operation codes. It must
The assembler
must. however,
however. do more than just
Just translate
also somehow
somehow determine
determine how many operands the instruction requires and what
hat
type they
they are. This may be rather complex
complex -— some instructions
instructions (like a Halt) have no
operands.
one. while
operands, others (like an Addition
ddition or a Jump
Jump instruction)
instruction) have one,
hile still
still others
(like a transfer
transfer between
between registers or a multiple-bit
ultiple-bit shift) require two. Some instructions
instructions
Oike Shift
Clear)
may even allow
allow alternatives;
alternatives; e.g.,.. some computers
computers have instructions
instructions (like
Shift or Clear)
that
Accumulator
that can apply
apply either
either to the Accum
ulator or to a memory
memory location. We will
ill not discuss
so.
how the assembler
assembler makes these distinctions;
distinctions; we will
ill just
just note that
that it must do so.

PSEUDO-OPERATIONS
PSEUDO-OPERATIONS
directly transtrans­
Some assembly language instructions are not directly
PSEUDOPSEUDO­
lated into machine language instructions. These instructions
OPERATIONS
OPERATIONS
are directives
directives to the assembler; they assign the program
program to cercer­
tain areas in memory.
memory, define
define symbols, designate
designate areas of RAM for temporary
temporary data
storage,
other fixed data in memory.
memory, allow
allow references to other
other programs,
storage. place tables or other
programs.
and perform minor
inor housekeeping
housekeeping functions.
functions.
To use these assembler
assembler directives
directives or pseudo-operatrons
pseudo-operations a programmer
programmer places the
pseudo-operation's
field. and,
and. if the specified
pseudo-operation's mnemonic
mnemonic in the operation
operation code field,
specified pseudopseudo­
operation
it. an address or data in the address field.
operation requires it,

The most common
common pseudo-operations
pseudo-operations are:
DATA
EQUATE (=) or DEFINE
DEFINE
EQUATE
ORIGIN
ORIGIN
RESERVE
RESERVE

Linking
Linking pseudo-operations
pseudo-operations (used to connect
connect separate programs) are:
ENTRY
ENTRY
EXTERNAL
EXTERNAL

2 -4

Different
operations. but their functions
are
Different assemblers use different
different names for these operations,
functions are
the same. Housekeeping
Housekeeping pseudo-operations
pseudo-operations include:
END
END
LIST
LIST
NAME
PAGE
PAGE
SPACE
SPACE
TITLE
TITLE
PUNCH
PUNCH
are usually
We will
ill discuss
discuss these pseudo-operations
pseudo-operations briefly.
briefly, although
although their functions
functions are
obvious.

THE DATA
DATA PSEUDO-OPERATION
PSEUDO-OPERATION
The D A
ATA
llowss the programmer to e nter
proT A pseudo-operation a llo
ter fixed data into pro­
gram m emory. This data may include:
• Lookup tables
• Code conversion
conversion tables
• Messages
• Synchronization
Synchronization patterns
patterns
• Thresholds
Thresholds
• Names
• Coefficients
Coefficients for equations
equations
• Commands
Commands
Conversion factors
• Conversion
eighting factors
• Weighting
Characteristic times or frequencies
frequencies
• Characteristic
Subroutine addresses
• Subroutine
identifications
• Key identifications
Test patterns
patterns
• Test
Character generation
generation patterns
patterns
• Character
Identification patterns
patterns
• Identification
• Tax tables
Standard forms
• Standard
Masking patterns
patterns
• Masking
State transition
transition tables
• State
DATA pseudo-operation
pseudo-operation treats the data as a permanent
permanent part of the program.
The DATA
program.
a t of a D ATA
A pseudo-operation is usually q uite sim
ple. An in stru
ctio n
The format
simple.
struction
like :
DZCON

DATA
DATA

12

12

will
ill place the number 12 in the n ext
x t available m emory lo cation and assign
assign that
location the name DZCON. Usually every DATA pseudo-operation
pseudo-operation has
has a label,
label. unless it
pseudo-operations. The data and label may take any form
is one of a series of DATA pseudo-operations.
form
that the assembler permits.
that
Most
ost assemblers allow
allow more elaborate DATA instructions
instructions that handle a large amount
amount of
data at one time.
time, e.g.:
EMESS
EMESS
SQRS
SORS

DATA
DATA
DATA
DATA

22-5

'ERROR'
'ERROR'
1,4,9,16,25
1.4.9.16.25

instruction may fill
fill many words
words of program memory.
memory, limited
limited only by the length
length
A single instruction
that if you cannot
cannot get all the data on one line.
line, you can always
always follow
follow one
of a line. Note that
instruction with
ith another.
another, e.g.,
DATA instruction
e.g.,
MESSG
MESSG

DATA
DATA
DATA
DATA
DATA
DATA

'NOW
'NOW IS
ISTHE
THE'
'TIME
FORALL
ALL ' '
TIM
E FOR
'GOODMEN
MEN'
'GOOD
'TOCOME
COMETO
TOTHE
THE' '
'TO
'AID OF
OFTHEIR
THEIR' '
'AID
'COUNTRY'
'COUNTRY'

Microprocessor assemblers typically
typically have some variations
variations of standard DATA
DATA
Microprocessor
pseudo-operations. DEFINE
DEFINE BYTE
BYTE or FORM
FORM CONSTANT BYTE handles B-bit
8-bit numbers;
DEFINE WORD or FORM
FORM CONSTANT WORD handles 16-bit
addresses.
DEFINE
16-bit numbers or addresses.
pseudo-operations may handle character-coded
character-coded data.
Other special pseudo-operations
data.

THE EQUATE (or DEFINE) PSEUDO-OPERATION
DEFINING
pseudo-operation allows
allows the programmer to
The EQUATE pseudo-operation
DEFINING
NAMES
NAMES
ith addresses or data. This pseudo-operation
equate names with
is almost
almost always
always given the mnemonic EQU or =.
=. The names
addresses, numeric
data. starting
addresses. fixed addresses,
addresses. etc.
etc.
may refer to device addresses,
numeric data,
starting addresses,

pseudo-operation assigns the numeric value in its operand field to
The EQUATE pseudo-operation
the label in its label field. Here are two examples:
TTY
LAST

EQU
EOU
EQU
EOU

55
5000
5000

ill allow you to define one label in terms of another,
Most assemblers will
another. e.g.,..
LAST
ST1
ST1

EQU
EOU
EQU
EOU

FINAL
FINAL
START+1
START+1

must. of course,
course. have been previously
Often. the
The label in the operand field must,
previously defined. Often,
expressions. as we shall see
see later.
later. Double
operand field may contain more complex expressions,
address) may be useful in patching
name assignments
assignments (two names for the same data or address)
patching
together
names for the same variable (or different
together programs that use different
different names
different spellings
of what
hat was supposed to be the same name).
namel.

Note that an EQU pseudo-operation does not cause
cause the as­
asSYMBOL
SYMBOL
sembler to place anything in memory. The assembler simply
TABLE
TABLE
enters an additional name into a table (called a symbol table)
table. unlike the mnemonic
table. must be in
which the assembler maintains. This table,
mnemonic table,
RAM since it varies with each program. The assembler always needs
needs some RAM to hold
hold
RAM
table: the
the more RAM it has,
has. the
the more symbols it11can accept. This RAM is in
the symbol table;
addition to any w
addition
which the
the assembler needs
needs as
as temporary
temporary storage.
storage.
use a name?
name7 The answer is:
Is: whenever
have a
When do you use
whenever you have
USE OF
parameter that has
has some
some meaning besides
besides its ordinary numeric
numeric
NAMES
NAMES
value or the
the numeric value of the
the parameter might be changed.
value
names to
to tim
time constants,
constants. device addresses,
addresses. masking patterns,
patterns. con­
conWe typically
typically assign names
version
version factors,
factors. and the
the like.
like. A name like
like DELAY,
DELAY. TTY,
TTY. KBD,
KBD. KROW,
KROW. or OPEN
OPEN not only
makes the
the parameter easier
easier to
to change,
change. but itIt also
also adds to program documentation.
makes
documentation. We
also
also assign names
names to
to memory locations that
that have
have special purposes;
purposes; they may
may hold
hold data,
data.
mark the start of the
the program,
program. or be available for
for intermediate
storage.
mark
intermediate storage.

What
hat name
CHOICE
name do you
you use?
use? The best rules
rules are
are much
much the same as
CHOICE
in
eaningful names
in the case
case of labels,
labels, except that
that here
here m
meaningful
names really
really
OF OF
count. W
Why not call the
the teletypewriter
TTY instead of
of X15,
X15. a bit
count.
teletypewriter TTY
NAMES
NAMES
tim
BTDLY
time delay
delay BTIME
BTIME or
or BTDL
Y rather
rather than
than W
WW, the
the number
number of
of the
the
"GO"
straightfor­
"GO" key
key on
on aa keyboard GOKEY
GOKEY rather
rather than HORSE?
HORSE?This
This advice
advice seems
seems straightforward. but a surprising number of programmers do
do not follow
follow it.
it
ward,

2-6
2-

PLACEMENT
PLACEMENT
Where do you place the EQUATE pseudo-operations? The
Where
start of the program, under appropriate
appropriate
best place is at the start
OF
DEFINITIONS
comment headings
headings such as I/O
comment
1/0 ADDRESSES,
ADDRESSES. TEMPORARY
TEMPORARY
DEFINITIONS
STORAGE,
LOCATIONS. This
STORAGE. TIME CONSTANTS,
CONSTANTS. or PROGRAM
PROGRAM LOCATIONS
makes the definitions
definitions easy to find if you want
want to change
change them. Furthermore.
Furthermore, another
another
ill be able to look up all the definitions
definitions in one centralized
centralized place. Clearly this pracprac­
user will
improves documentation
documentation and makes the program easier to use.
tice improves
use.
Definitions used only in a speoific
specific subroutine
subroutine should appear at the start of the
Definitions
subroutine.
subroutine.

THE ORIGIN PSEUDO-OPERATION
The ORIGIN pseudo-operation
pseudo-operation (almost always
always abbreviated
abbreviated ORG) allowss the propro­
grammer to locate programs, subroutines, or data anywhere
anywhere in memory. Programs
and data may be located in different
different areas of memory depending
depending on the memory concon­
figuration. Startup
Startup routines.
routines, interrupt
interrupt service routines.
routines, and other required programs
figuration.
may be scattered
scattered around memory at fixed or convenient
convenient addresses.
addresses.
LOCATION
The assembler
assembler maintains a Location Counter (comparable to
the computer's
puter's Program Counter) which contains the location
COUNTER
in memory of the next
next instruction or data item being pro­
processed. An ORG
pseudo-operation causes the assembler
assembler to place a new value in the
ORG pseudo-operation
Location Counter.
Counter, much as a Jump
instruction causes the CPU
CPU to place a new value in
Location
Jump instruction
the Program Counter. The output
output from the assembler
assembler must not only contain
contain instructions
instructions
and data,
indicate to the loader program where
where in memory
memory it should place
data. but must also indicate
instructions and data.
the instructions
Microprocessor programs
programs often contain
contain several ORIGIN
statements for the following
following
Microprocessor
ORIGIN statements
purposes:
Reset (startup) address
Interrupt service addresses
Interrupt
Trap addresses
RAM storage
Memory stack
Memory
Subroutines
Subroutines
Memory addresses for in put/output
u t/o u tp u t devices or
Memory
functions
special functions
Still other
other ORIGIN
statements may allow
allow room for later insertions.
insertions, place tables or data in
Still
ORIGIN statements
memory, or assign vacant
vacant RAM space for data buffers. Program and data memory in
memory.
microcomputers may occupy
occupy widely
widely scattered
scattered addresses to simplify
plify the hardware.
microcomputers

Typical ORIGIN statem
ents are:
Typical
statements
ORG
ORG
ORG
ORG
ORG
ORG

RESET
RESET
1000
1000
INT3
INT3

Some assemblers assume an origin of zero if the programmer
programmer does not put an ORG
ORG
statement at the start
start of the program. The convenience
convenience is slight;
slight; we recommend
recommend the inin­
statement
clusion of an ORG
statement to avoid confusion.
clusion
ORG statement

THE RESERVE
RESERVE PSEUDO-OPERATION
allows the programmer to
The RESERVE
RESERVE pseudo-operation allows
allocate RAM for various purposes such as data tables, tem-­
porary storage, indirect addresses, a Stack, etc.

2-7
7

ALLOCATING
ALLOCATING
RAM

Using the RESERVE
RESERVE pseudo-operation, you assign a name to the memory area and
declare the number of locations to be assigned.
assigned. Here are some examples:
NOKEY
NOKEY
TEMP
VOLTG
BUFR
BUFR

RESERVE
RESERVE
RESERVE
RESERVE
RESERVE
RESERVE
RESERVE
RESERVE

11
50
50
80
BO
100
100

pseudo-operation to reserve memory
memory locations
locations in program
You can use the RESERVE
RESERVEpseudo-operation
memory
RESERVE pseudo-operation
memory or in data memory; however.
however, the RESERVE
pseudo-operation is more
meaningful when
when applied
applied to data memory.
meaningful
In reality.
reality, all the RESERVE
pseudo-operation does is increase the assembler's
assembler's Location
RESERVEpseudo-operation
Counter
Counter by the amount
amount declared
declared in the operand field. The assembler does not actually
actually
object code.
produce any object

ing features
features of RESERVE:
Note the following
RESERVE:
1)
1)

RESERVEpseudo-operation
adThe label of the RESERVE
pseudo-operation is assigned the value of the first
first ad­
dress reserved.
pseudo-operation:
reserved. For example,
example. the pseudo-operation:
TEMP
TEMP

RESERVE
RESERVE

20
20

TEMP to the address of the first
reserves 20 bytes of RAM and assigns the name TEMP
byte.
2)
2)

reserved. There is no default
case.
You must specify the number
number of locations to be reserved.
default case.

3)

that. by chance,
chance. may be in
No data is placed in the reserved locations. Any data that,
these locations will
ill be left there.
there.

Some assemblers allow the programmer to place initial
INITIALIZING
INITIALIZING
values in RAM. We strongly recommend that you do not
RAM
use this feature -— it assumes that the program (along with
use
ith
values) will
disk)
the initial
initial values)
ill be loaded from an external device (e.g
(e.g.,.. paper tape or floppy disk)
programs. on the
the other hand,
hand. reside in non­
noneach time it is run. Most microprocessor
microprocessor programs,
volatile ROM
ROM and start when power comes on.
on. The RAM in such situations
resituations does not re­
tain its contents.
contents, nor is it reloaded.
Always include instructions
instructions to initialize
initialize the RAM in
reloaded. Always
your program.

LINKING PSEUDO-OPERATIONS
nt statements
statements in one
We often w ant
one program
program or subroutine to
EXTERNAL
use
elsewhere. Such names are called
use names that are defined elsewhere.
REFERENCES
REFERENCES
to ac­
acexternal
external references;
references; a special linking program is necessary to
names are
are undefined
tually fill in the values and determine
determine if any names
undefined or doubly defined.
The pseudo-operation EXTERNAL, usually
abbreviated EXT, signifies that the
usually abbreviated
name is defined elsewhere.
elsewhere.

usually abbreviated
name is
is
The pseudo-operation ENTRY, usually
abbreviated ENT, signifies that the name
available for use
elsewhere; i.e
i.e.... it is
in this program.
is defined in
use elsewhere;
are implemented
The precise way in which
hich linking pseudo-operations
pseudo-operations are
plemented varies greatly
from
ill not refer to
again. but
from assembler to
to assembler.
assembler. W
We will
to such pseudo-operations again,
they
they are very useful in
in actual applications.
applications.

2-8
2-

HOUSEKEEPING PSEUDO-OPERATIONS
pseudo-operations that
that affect
affect the operation of
There are various housekeeping pseudo-operations
the assembler
assembler and its program listing rather
rather than the output
output program itself. ComCom­
mon housekeeping pseudo-operations
pseudo-operations include:
• END,
hich marks the end of the assembly language
language source program.
END. which
• LIST,
hich tells the assembler to print
print the source program. Some assemblers allow
LIST, which
variations as NO LIST or LIST SYMBOL TABLE to avoid long,
repetitive listings.
such variations
long. repetitive
• NAME or TITLE,
hich prints
prints a name at the top of each page of the listing.
TITLE. which
• PAGE
which skips to the next page or next line,
respectively, and imim­
PAGE or SPACE,
SPACE. which
line. respectively,
appearance of the listing.
listing, making
making it easier to read.
proves the appearance
read.
• PUNCH,
hich transfers
transfers subsequent
subsequent object
object code to the paper tape punch. This
PUNCH. which
pseudo-operation may in some cases be the default
default option
option and therefore
therefore unnecesunneces­
pseudo-operation
sary.
sary.

LABELS
IT H PSEUDO-OPERATIONS
LABELS WITH
Users often wonder
wonder if or when
when they
they can assign a label to a pseudo-operation.
recommendations:
These are our recommendations:
• All EQUATE
pseudo-operations must have labels; they are useless otherwise.
otherwise, since
EQUATE pseudo-operations
the purpose of an EOUA
EQUATE
define its label.
TE is to define
label
• DATA and RESERVE
pseudo-operations usually
usually have labels. The label identifies
identifies the
RESERVEpseudo-operations
first memory
memory location
location used or assigned..
first
• Other
Other pseudo-operations
pseudo-operations should not have labels. Some assemblers allow
allow such
labels, but we recommend
recommend against
against their
their use because there is no standard
standard way to inin­
terpret them.
terpret

2-9

AND THE OPERAND FIELD
ADDRESSES AND
Most
ost assemblers
assemblers allow the programmer
programmer a lot of freedom in describing
describing the con­
contents of the Operand
Operand or Address
Address field. But remember thatt the assembler has builtin names for registers and instructions
instructions and may have other built-in names.
names.
Some common
common options
options for the operand
operand field are:
1)
11 Decimal numbers
numbers

DECIMAL
DATA OR
ADDRESSES
ADDRESSES

Most
ost assemblers assume all numbers to be decimal
decimal unless they
are marked otherwise. So:
ADD

100

means "add
"add the contents
contents of memory location
location 10010
100-)o to the contents
contents of the Acc­
cumulator."
ulator."

2)
21 Other number systems
ill also accept binary, octal,
Most assemblers will
octal. or hexadecimal
entries. But you must identify
identify these number
number systems in some
way,
preceding or follow
ing the number with
ith an ideniden­
way. e.g.,.. by preceding
following
tifying
character or letter. Here are some common identifiers:
tifying character
identifiers:

NON-DECIMAL
NON-DECIMAL
NUMBER
SYSTEMS

B or % for binary
0,
Q, or C for octal (the letter O should be avoided because of the confuconfu­
0. @. 0.
sion with
ith zero).
zero).
H or $ for hexadecimal (or
(or standard BCD).
BCD).
D for decimal. D may be omitted;
omitted: it is the default
default case.
case.
Assemblers generally require hexadecimal numbers to start with
ith a digitit (e.g
(e.g.,.. 0A36
instead of A36) in order to distinguish
distinguish between numbers and names or labels.
labels. It is
good practice
practice to enter numbers in the base
hich their meaning is the
base in which
clearest: i.e.,.. decimal constants
constants in decimal;
decimal: addresses
addresses and BCD
BCD numbers in hex­
hexoutputs in binary if they are short and in hex­
adecimal; masking patterns or bit outputs
hexadecimal if they are long.
long.

3)
31 Names
Names
Names can appear in the operand field:
field: they will be
be treated
treated as the
the data that they
represent. But remember.
remember,there is a difference
between data
difference between
data and
and addresses.
addresses. The
sequence:
FIVE
FIVE

EQU
EOU
ADD

5
FIVE
FIVE

will add the contents
contents of memory location 0005 (not necessarily the
the number 5)
5) to the
the
contents of the Accumulator.
Accumulator.
contents

22-10

4)
41 The current value of the location counter (usually
(usually referred to as *• or $).
mainly in Jump
Jump instructions:
instructions; for example:
This is useful mainly
JUMP

*+66

causes a Jump
that contains
Jump to the memory location
location six words beyond the word that
contains the
first byte of the JUMP instruction:
instruction:
first
Memory

} JUMP * +
"+6 code
code stored
stored here
here
6 locations <

- Jump here
!4---Jumphere

microprocessors have many two- and three-word
three-word instructions.
instructions. Thus,
ill
Most microprocessors
Thus. you will
have d ifficu
lty determ
ining exactly
exactly how far apart two assembly language statements
statements
ifficulty
determining
are.
Counter frequently
frequently results in errors
are. Therefore,
Therefore. using offsets from the Location Counter
labels.
that you can avoid if you use labels

5)
51 Character codes
text to be entered as ASCII
Most assemblers allow text
ASCII strings. Such
strings may be surrounded
surrounded either
either with
ith single or double quotaquota­
strings
tion marks:
marks; strings
strings may also use a beginning
beginning or ending symbol
such as A or C.
C. A few assemblers also permitit EBCDIC
EBCDIC strings.

ASCII
CHARACTERS

We recommend that
that you use character
character strings for all text. It improves the clarity
clarity and
readability of the program.
readability

6)

Combinations of 11
1) through 5)
etic, logical,
51 w ith arithmetic,
logical, or special operators.
operators.
ARITHMETIC
Almost
ost all assemblers allow
allow simple
simple arithm
etic combinations
combinations
arithmetic
ARITHMETIC
such as START+1. Some assemblers also permit
permit multiplication.
ultiplication,
AND LOGICAL
EXPRESSIONS
division, logical functions.
functions, shifts.
shifts, etc. These are referred to as
division.
expressions. Note that
that the assembler evaluates expressions at
though an expression in the operand field may involve
assembly time. Even
Even though
multiplication,
ultiplication, you may not be able to use multiplication
ultiplication in the logic of your own pro­
prog ra
m -— unless you write
rite a subroutine
subroutine for that specific
specific purpose.
ram
hat expressions they accept and how they interpret
interpret them. ComCom­
Assemblers vary in what
plex expressions make a program difficult
ifficu lt to read and understand.

recommendations during
during this section but will
ill repeat them and
We have made some recommendations
add others here. In general, the user should
should strive for clarity and simplicity. There is
no payoff for being an expert in the intricacies
intricacies of an assembler or in having the most
complex expression on the block. We suggest the following approach:
complex
approach:
1)
1)

Use the clearest number
number system or character
character code for data.
Masks and BCD
decimal, ASCII
characters in octal,
ordinary numerieri­
BCD numbers in decimal.
ASCII characters
octal. or ordinary
cal constants
constants in hexadecimal
hexadecimal serve no purpose and therefore
therefore should not be used.
used.

2)
3)
4)

Remember to distinguish
distinguish data from addresses.
addresses.
Don't use offsets from the Location Counter.
Keep
simple and obvious. Don't rely on obscure features of the assem­
Keep expressions simple
assembler.
bler.
2 -11

CONDITIONAL ASSEMBLY
CONDITIONAL
Some assemblers allow you to include
de­
include or exclude parts of the source
source program,
program, depending on conditions existing at assembly time. This is called conditional assemassem­
bly; it gives the assembler some of the flexibility
flexibility of a compiler. Most
ost microcomputer
assemblers have limited capabilities for conditional assembly. A typical
typical form is:
is:
IF COND
COND
.(CONDITIONAL
.(CONDITIONAL PROGRAM)
PROGRAM)

ENDIF
ENDIF
If the expression COND
instructions between IF and ENDIF
COND is true at assembly time,
time. the instructions
ENDIF
pseudo-operations) are included
included in the program.
(two pseudo-operations)

Typical uses of conditional assembly are:
1)
1)

To include
include or exclude
exclude extra variables.

2)

To place diagnostics
diagnostics or special conditions
conditions in test runs.
runs.

3)

To allow data of various bit lengths.

4)

To create specialized versions of a common
common program.

Unfortunately, conditional
conditional assembly tends to clutter
clutter programs
programs and make them difficult
ifficu lt
Unfortunately,
to read. Use conditional
conditional assembly only if it is necessary.
necessary.

2 -12
2

MACROS
You will
ill often find that
that particular
particular sequences of instructions
instructions ococ­
DEFINING A
DEFINING
instruction se­
SEQUENCE OF
cur many times in a source program. Repeated instruction
seINSTRUCTIONS
reflect the needs of your
your program logic, or they
quences may reflect
INSTRUCTIONS
may be compensating
compensating for deficiencies
deficiencies in your microprocessor's
microprocessor's
instruction set.
repeatedly writing
ritin g out the same instruction
instruction sequence b·{
by
instruction
set. You can avoid repeatedly
using a macro.
macro.

Macros allow you to assign a name to an instruction sequence. You then use the
macro name in your source
repeated instruction sequence.
source program
program instead of the repeated
sequence.
The assembler will
ill replace the macro name with
ith the appropriate sequence of in­
instructions. This may be illustrated
illustrated as follows:
follows:
Object Program
Object
Program

Source Program
Program
MACl

definition)
(macro definition)

MACRO
MACRO

instruction M 1 \
instruction
instruction M2
instruction
M2 > --------------------------------

}

instruction M3
instruction
M3 /

ENDM

(end
of macro definition)
definition)
(end .of

instruction P11
instruction

(main program)
program) }
(main

{
{

instruction P2
instruction
instruction P3
instruction
P3

MACl
instruction P4
instruction PS
instruction P6
instruction P7

instruction P11
instruction
instruction
instructtOn P2
instruction P3
instruction
instruction
instructtOn M11
instruction
instruct.On M2
M2
instruction Ml
M3
instruction
instruction P4
instruction
P4
instruction P5
instruction
P5

}

{

instruction P6
instruction

instruction P7
instruction
P7

I..

MAC1

{

instruction M11
instruction
instruction M2
instructtOn
instruction M3
instruction
instruction P8
instruction

1

instruction P8
instruction
PS

instruction P9
instruction

instruction P9
instruction
P9

instruction M11
instruction

{

instruction M2
instruction
M2

MACl

instruction M3
instruction
M3

{

instruction P1°
instruction
P10 }|
instruction P11
11 f "
instruction

instruction
P10
instructK>OPlO
instruction P11
11
instruction

subroutine occurs once in a program.
program, and
Macros are not the same as subroutines. A subroutine
execution branches to the subroutine.
subroutine. A macro is expanded to an actual inin­
program execution
struction sequence each time the macro occurs; thus a macro does not cause any
struction
branching.

22-133

Macros have the following
ing advantages:
Macros
1) Shorter
1)
Shorter source
source programs.
programs.

ADVANTAGES
ADVANTAGES
OF MACROS

2) Better
Better program
program documentation.
documentation.
3) Use
Use of
of debugged
debugged instruction
instruction sequences
sequences -— once
once the
the macro
macro has
has been
been debugged,
debugged.
you are sure of an error-free instruction
instruction sequence every time you use the
the macro.
macro.
4)

Easier
Easier changes.
changes. Change
Change the
the macro
macro definition
definition and
and the
the assembler
assembler makes
makes the
the change
change
for you every time the macro is used.
used.

5) Inclusion
in­
Inclusion of
of commands,
commands. keywords,
keywords. or
or other
other com
computer instructions
instructions inthe
the basic instruction set. You can use macros to extend or clarify
clarify the
struction
theinstruction
instruction set.
set.

The disadvantages of macros are:
1)
1) Repetition
Repetition of
of the
the same
same instruction
instruction sequences
sequences since
since the
the
macro is expanded every time it is used.
used.

DISADVANTAGES
DISADVANTAGES
OF MACROS

2)
2) AA single
single macro
macro may
may create
create aa lot
lot of
of instructions.
instructions.
3)
4)

Lack of standardization
standardization makes programs difficult
ifficu lt to read and understand.
Possible effects on registers and flags that may not be clearly described.

One problem is that
that variables used in a macro are only known
within
ith in it (i.e.,.. they are local rather than global). This can often
create a great deal of confusion
confusion w ith
o u t any gain in return. You
ithout
when using macros.
should be aware of this problem when
macros.1^

2 -14
14

----- ..
LOCAL OR
GLOBAL
VARIABLES

COMMENTS
COMMENTS
All assemblers allow you to place comments in a source
Comments have
source program.
program. Comments
no effect
ffect on the object
object code, but they
they help you to read, understand, and document
document
the program.
commenting is an essential
essential part of writing
ritin g assembly language
program. Good commenting
ithout
programs; programs w ith
o u t comments
comments are very
very difficult
ifficu lt to understand.
We will
ill discuss commenting
commenting along with
ith documentation
documentation in a later
later chapter, but here
We
are some guidelines.:
1)
1)

Use comments
comments to tell what
hat application
application task the program is
performing, not how the m icrocom
puter executes the inin­
performing,
icrocomputer
structions.
structions.

COMMENTING
COMMENTING
TECHNIQUES
TECHNIQUES

Comments
TEMPERATUREABOVE LIMIT?",
FEED
Comments should say things
things like "IS TEMPERATURE
LIMIT?". "LINE FEED
TO TTY".
TTY", or "EXAMINE LOAD SWITCH".
Comments
Comments should not say things
things like "ADD
"ADD 1 TO ACCUMULATOR".
ACCUMULATOR". "JUMP TO
START", or "LOOK AT CARRY”
affecting
CARRY". You should describe how the program is affecting
the system: internal
internal effects on the CPU
CPU are seldom of any interest.
2)

Keep comments
comments brief and to the point. Details should be available elsewhere in
the documentation.
documentation.

3)

Comment
Comment all key points.

4)

Do not comm
ent standard instructions
instructions or sequences that change counters
counters or
comment
pointers;
meanpointers; pay special attention
attention to instructions
instructions that may not have an obvious mean­
ing.
'
ing.

5)
5)

Do not use obscure abbreviations.

6)

Make the comments
comments neat and readable.
readable.

7)

Comment
Comment all definitions,
definitions, describing
oescribing their purposes. Also mark all tables and data
storage areas.
areas.

8)

Comment
Comment sections of the program as well as individual
individual instructions
instructions.

9)

Be consistent
consistent in your
your terminology.
terminology. You can and should be repetitive:
repetitive; you need not
consult
consult a thesaurus.

10)
10)

e.g., "REMEMBER
"REMEMBER CAR­
CARLeave yourself
yourself notes at points which
hich you find confusing:
confusing: e.g.,
RY WAS SET
SET BY LAST INSTRUCTION".
INSTRUCTION". You may drop these in the final documenRY
documen­
tation.

A well-comm
ented program is easy to use.
ill recover the time spent in comm
ent­
well-commented
use. You will
commenting many times over.
ill try to show good com m
enting style in the programming
programming
over. We will
menting
examples, although
although we often over-comment
over-comment for instructional
instructional purposes.
purposes.

2 -15
5

ASSEMBLERS
TYPES OF ASSEMBLERS
Although all
all assemblers
assemblers perform
perform the
the same
same tasks,
tasks, their
their implementations
implementations vary
vary
Although
greatly. We
We willill not
not try
try to describe
describe all the
the existing
existing types
types of assemblers;
assemblers; wee willill
greatly.
merely define
define the
the terms
terms and indicate
indicate some
some of
of the
the choices.
choices.
merely
A cross-assembler
cross-assembler is an assembler
assembler that
that runs
runs on a computer
computer
other than
than the
the one for
for which
hich it assembles
assembles object
object programs.
programs.
other

CROSSASSEMBLER
ASSEMBLER

The com
puter on which
which the cross-assembler
cross-assembler runs is typically
typically a
computer
large computer
computer with
ith extensive software
software support
support and fast peripherals
peripherals -— such as an IBM
360 or 370, a Univac 1108, or a Burroughs
puter for which
hich the cross-ascross-as­
Burroughs 6700. The computer
typically a micro like the 6502
6502 or 8080. Most cross-as­
sembler assembles programs is typically
cross-asritten in FORTRAN
semblers are written
FORTRAN so that they are portable.

self-assembler or resident
resident assembler
assembler is an assembler
assembler that
that
A self-assembler
the computer
computer for
for which
hich it assembles
assembles programs.
programs. The
runs on the
self-assembler will
ill require some memory and peripherals.
peripherals, and it
self-assembler
may run quite
quite slowly.

RESIDENT
ASSEMBLER
ASSEMBLER

macro assembler
assembler is an assembler
assembler that
that allows
allows you to define
define
A macro
sequences of instructions
instructions as macros.
sequences

MACRO
ASSEMBLER

A microassembler
microassembler is an assembler
assembler used to write
rite the
microprograms that
that define
define the instruction
instruction set
set of a computer.
computer.
microprograms
M icroprogram
m ing has nothing
nothing specifically
specifically to do with
ith
icroprogramming
microcomputers.2,3
microcomputers.2,3

MICROMICROASSEMBLER

meta-assembler is an assembler
assembler that
that can handle
handle many
A meta-assembler
different instruction
instruction sets.
sets. The user must define the particular
particular in­
different
instruction set being used.
struction
used.

METAMETA­
ASSEMBLER

A one-pass
one-pass assembler
assembler is an assembler
assembler that
that goes through
through the
assembly language
language program
program only
only once. Such an assembler must
assembly
have some way of resolving forward references,
references. e.g.,.. Jumpp in­
instructions which
hich use labels that
structions
that have
have not yet been defined.

ONE-PASS
ASSEMBLER

A two-pass
two-pass assembler
assembler is an assembler
assembler that
that goes through
through the
TWO-PASS
TWO-PASS
assembly language
language source
source program
program twice.
ice. The firs
assembly
firstt timee the
ASSEMBLER
ASSEMBLER
assembler simply
simply collects
collects and defines
defines all the symbols;
symbols; the
assembler
second time
time it replaces
replaces the references
references with
ith the actual
actual definitions.
definitions. A two-pass
two-pass as­
second
assembler has no problems
problems with
ith forward
forward references
references but
but may be quite
quite slow
slow if no
sembler
backup storage
storage (like a floppy
floppy disk) is available;
available; then
then the assembler
assembler must
must
backup
physically read the program
program twice
ic e from a slow
slow input
input medium
medium !like
(like a tele
typew riter
physically
teletypewriter
reader). Most
ost microprocessor-based
microprocessor-based assemblers
assemblers require
require twoo passes.
paper tape reader).
passes.

22-16

ERRORS
Assemblers normally provide error messages, often consisting of a single coded
Assemblers
letter. Some typical
typical errors are:
letter.
Undefined name (often a misspelling
misspelling or an omitted
itted definition)
definition)
,• Undefined
character (e.g.,
binary number)
,• Illegal character
(e.g., a 2 in a binary
•, Illegal
Illegal form
at (wrong delim
iter or incorrect
incorrect operands)
format
delimiter

,■ Invalid expression (e.g.,.. two operators in a row)
• Illegal value (usually too large)
large)
• Missing
Missing operand
Double definition
definition (i.e.,.. twoo different
different values assigned to one name)
• Double
name)
• Illegal
Illegal label (e.g.,
pseudo-operation that
that cannot
cannot have one)
(e.g., a label on a pseudo-operation
one)
• Missing
Missing label
• Undefined
Undefined operation
operation code
In interpreting
interpreting assembler
assembler errors, you must remember
remember that the assembler
assembler may get on the
wrong track if it finds a stray letter, an extra space,
incorrect punctuation.
punctuation. Many as­
wrong
space. or incorrect
asill then proceed to misinterpret
misinterpret the succeeding
succeeding instructions
instructions and produce
produce
semblers will
meaningless error messages.
Always look at the first error very carefully:
carefully; subsequent
subsequent
meaningless
messages. Always
ones may depend on it. Caution
Caution and consistent
consistent adherence
adherence to standard formats will
ill
eliminate many annoying
annoying mistakes.
eliminate

LOADERS
LOADERS
The loader is the program
program which
which actually
actually takes the output
output (object code) from the as­
assembler and places it in memory
memory Loaders range from the very simple
simple to the very comcom­
sembler
plex. We will
ill describe
describe a few different
different types.
types.

BOOTSTRAP
A bootstrap loader is a program that
that uses its own first few
w inin­
itself or another loader program
LOADER
structions to load the rest of itself
LOADER
into memory. The bootstrap
bootstrap loader may be in ROM,
ROM, or you may
have to enter it into the computer
computer memory using front
front panel switches. The assembler
may place a bootstrap
bootstrap loader at the start of the object
object program
program that
that it produces.
A relocating loader can load programs anywhere
anywhere in memory. It
RELOCATING
LOADER
typically loads each program into the memory space immediately
mediately
typically
follow
ing that
that used by the previous program. The programs,
following
however, must
must themselves
themselves be capable of being moved around in this way:
way; i.e.... they
however.
ill always
always place the propro­
must be relocatable. An absolute loader, in contrast, will
grams in the same area of memory.
A linking loader loads programs and subroutines that
that have
LINKING
been assembled separately;
separately; it resolves cross references
references -—
LOADERS
that is,
instructions in one program that refer to a label in another
another
that
is, instructions
Object programs
programs loaded by a linking
linking loader must be created by an assembler
program. Object
that allows
allows external
external references.
that
alternative approach
approach is to separate the linking
linking and loading
An alternative
functions and have the linking
linking performed by a program called a
functions
link editor.

2 -17
17

LINK
EDITOR

REFERENCES
1.
1.

complete monograph
monograph on macros is M. Campbell-Kelly,
Campbell-Kelly, "Ann Introduction
Introduction to
A complete
Macros." American
American Elsevier. New York,
Macros."
York. 1973.
1973.

2.

A. Osborne. An Introduction
Introduction to Microcomputers:
icrocomputers: Volume
Volume 1 - Basic Concepts.
OSBORNE/McGraw-Hill,
OSBORNE/McGraw-Hill. Berkeley.
Berkeley, CA,
CA. 1977.
1977.

3.

A.
Agrawala and T. G.
icroprogramming. Academic
Academic
A. K.
K. Agrawala
G. Rauscher.
Rauscher. Foundations of Microprogramming.
Press,
Press. New York,
York. 1976.
1976.

4.

D. W. Barron,
"Assemblers and Loaders." American
American Elsevier.
Barron. "Assemblers
Elsevier. New York,
York. 1972

5.

C.W. Gear,
Computer Organization and Programming.
Programming, McGraw-Hill.
McGraw-Hill, New York,
Gear. Computer
York.
1974.
~

2 -18

Chapter 3
THE 6502
6502 ASSEMBLY
V LANGUAGE
INSTRUCTION SET
We are now ready to start w riting assembly language
language programs.
programs. We begin
begin in this
chapter by defining the individual instructions of the 6602
6502 assembly language
language in­
instruction set, plus
plus the syntax rules of the MOS Technology assembler.
assembler.
interfaces. or
We do not discuss
discuss any aspects of microcomputer hardware, signals, interfaces,
CPU
architecture in this book.
ation is described in detail in An Introduction
Introduction
CPU architecture
book. This information
to Microcomputers:
Microcomputers: Volumee 2 -— Some Real
Microprocessors and Volume 3 —
Some
Real Microprocessors
-Some
Real Support
Devices.
Real
Support Devices.
In this book,
book, we look at programming
programming techniques from the assembly language
language pro­
programmer's viewpoint,
point, where pins
pins and signals
signals are irrelevant
irrelevant and there are no im-­
portant differences
differences between
between a minicomputer and a microcomputer.
Interrupts, direct
direct memory access,
architecture for the 6502 will
ill be dede­
Interrupts,
access, and the Stack architecture
scribed in later chapters
chapters of this book,
conjunction with
ith assembly language programprogram­
book. in conjunction
ming discussions
discussions of the same subjects.
This chapter
chapter contains
contains a detailed definition
definition of each assembly language instruction.
instruction.
The detailed
detailed description
description of individual
individual instructions
instructions is preceded by a general discussion
of the 6502 instruction
instruction set that divides
divides instructions
instructions into those which
hich are frequently
frequently
used (Table 3-1),
occasionally used (Table 3-2),
). occasionally
3-2). and seldom used (Table 3-3). If you are
experienced assembly language programmer, this categorization
categorization is not particularly
particularly
an experienced
important
portant -— and.
depending on your own programming
programming prejudices, it may not even be
and, depending
accurate. If you are a novice assembly language programmer,
programmer, we recommend that you
ritin g programs
programs using only instructions
instructions in the "frequently
"frequently used"
used” category.
begin by writing
concepts of assembly language programming,
programming, you may
Once you have mastered the concepts
other instructions
instructions and use them where
where appropriate.
appropriate.
examine other

33-1

Frequently Used Instructions
Instructions of the 6502
6502
Table 3-1. Frequently

Instruction
Code
ADC
AND
ASL
BCC
BCC
BCS
BEQ
BEO
BMI
BNE
BNE
BPL
CMP
DEC
DEC
DEX (DEY)
(DEY)
INC
INX (INY)
(INY)
JMP
JSR
LDA
LOA
LDX
LOX (LDY)
(LOY)
LSR
LSR
PHA
PLA
ROL
ROL
ROR
ROR
RTS
RTS
SBC
SBC
STA
STX (STY)
(STY)

Meaning
Meaning
Add with
ith Carry
Add
Logical AND
Logical
A rithm
etic Shift
Shift Left
rithmetic
Branch if Carry Clear
Branch
Branch if Carry Set
Branch
Branch if Equal to Zero (Z = 1)
Branch
1)
Branch if Minus
Minus (S = 1)
Branch
1)
Branch iiif Not Equal to Zero (Z = 0)
Branch
Branch
Pius (S = 0)
Branch if Plus
Compare Accum
ulator to Memory
Memory
Compare
Accumulator
Decrement (by 1)
Decrement
1)
Decrement Index
Index Register
Register X (Y)
Decrement
(Y) by 1
Increment
1)
Increment (by 1)
Increment Index Register
Register X (Y)
Increment
(Y) by 1
Jumpp to New Location
Location
Jump to Subroutine
Subroutine
Jump
ulator
Load Accum
Accumulator
Index Register
Register X (Y)
Load Index
(Y)
Logical Shift
Shift Right
Right
Logical
ulator onto
onto Stack
Push Accum
Accumulator
ulator from Stack
Pull Accum
Accumulator
Left through
through Carry
Rotate Left
Right through
through Carry
Rotate Right
Return from Subroutine
Subroutine
Subtract with
ith Borrow
Borrow
Subtract
Store Accum
ulator
Store
Accumulator
Store
(Y)
Store Index
Index Register
Register X (Y)

Table 3-2. Occasionally
Occasionally Used Instructions
Instructions of the 6502
6502
Table

Instruction
Code

Meaning
Meaning

BIT
BRK
BRK
CLC
CLD
CLO
CLI
CLI
CPX (CPY)
(CPY)
EOR
EOR
NOP
ORA
RTI
RTI
SEC
SEC
SED
SEO
SEI
SEI
TAX (TAY)
(TAY)
TXA (TYA)
(TYA)

Bit Test
Break
Clear Carry
Decimal Mode
Mode
Clear Decimal
Interrupt Mask (Enable Interrupts)
Interrupts)
Clear Interrupt
Compare with
ith Index Register
Register X (Y)
Compare
(Y)
Logical Exclusive-OR
Exclusive-OR
Logical
No Operation
Operation
Logical (inclusive)
(Inclusive) OR
Logical
Interrupt
Return from Interrupt
Set Carry
Set Decimal
Decimal Mode
Mode
Interrupt Mask (Disable Interrupts)
Interrupts)
Set Interrupt
Transfer Accum
ulator to Index Register
Register X (Y)
(Y)
Transfer
Accumulator
Transfer Index Register
Register X (Y)
ulator
Transfer
(Y) to Accum
Accumulator

3-2

Table 3-3. Seldom Used
Used Instructions
Instructions of the 6502

Instruction
Code

Meaning
Branch if Overflow
Overflow Clear
Branch if Overflow
Overflow Set
Clear Overflow
Overflow
Push Status Register onto Stack
Push
Pull Status Register from Stack
Transfer Stack Pointer to Index Register X
Transfer Index Register X to Stack Pointer

BVC
BVS
BVS
CLV
PHP
PHP
PLP
PLP
TSX
TXS

CPU REGISTERS
STATUS FLAGS
REGISTERS AND STATUS
FLAGS
6502 microprocessor
The 6502
microprocessor has an Accumulator, a Status (or P)
Pl register, twoo index
Program Counter. These registers may be illustrated
registers, a Stack Pointer, and a Program
illustrated
as follows:
follows:
n
7
0
15
8
Accumulator A
Accumulator
Index.Register
Index
.Register X
X
Index
Register Y
Index Register
Y
Program
PC
Program Counter
Counter PC

t--------1

I

.-----------------1

-------r-------"1

Stack
Stack Pointer
Pointer SP
SP
_, Status
Status Register
Register P
P

t--------1._ ______

The 6502's
6502's Status register
register contains six status flags and an interrupt
interrupt control bit.
These are the six status
status flags:

(C)
Carry (C)
(Z)
Zero (Z)
Overflow
(V)
Overflow (V)
(S)
Sign (S)
Decimal Mode (D)
(D)
(B)
Break (B)
Flags are assigned bit positions
Flags
positions within
ith in the Status register as follows:
follows:
7 6 5 4 3 2 1 0 ~8;1
~6502

-B it Number
. 6 5 0 2 Status
Status (P)
register
(Pl reg,ster

The Accumulator (A)
(Al is a primary accumulator as described in An Introduction to
Microcomputers:
icrocomputers: Volume 1.

long, unlike the typical
The Index Registers IX
(X and YI
Y) are only eight bits long,
typical microcomicrocom­
puter index registers described in An Introduction
Introduction to Microcomputers:
icrocomputers: Volume 1. They
puter
are more like classical computer
computer index registers that are used to hold indexes,
indexes. short
offsets. or counters.
offsets,

3 -3

The 6502
6502 has a Stack implemented
plemented in memory and indexed by the Stack Pointer
Pointer as de­
deVolume 1.
difference from that
that description
description is that the 6502
6502 Stack
scribed in Volume
1. The only difference
wide, which
which means that maximum
maximum Stack length is 256
Pointer is only eight bits wide,
bytes. The CPU
1 6 as the high-order
high-order byte of any Stack address,
which
CPU always inserts 0 1
115
address, which
means that memory locations O lO
Oig through 01FF16
O1FF-|0 are permanently
permanently assigned
010015

to the Stack:
01
01

*

x,.x
___

____

t_4 __

—

ti

)

l

SPI ------ XX-----------------I s p

f —

011 XX is the Stack address

significant about the shorter 6502
6502 Stack Pointer if you are
There is nothing very significant
using this CPU as a stand-alone product. A 256-byte
256-byte Stack is usually
usually sufficient
sufficient for
any typical
typical m icrocom
puter application:
application; and its location
location in early memory
memory simply
simply means
icrocomputer
that low memory addresses must be implemented
implemented as read/write
read/write memory. 6502
literature represents the Stack Pointer
Pointer .by
prevent
literature
,by the letter S;
S: we use the letters SP
SP to prevent
confusion with
ith the Sign status.
confusion
The 6502
6502 Program Counter
Counter is a typical
typical program counter
counter as described in Volume 1.
The Carry status flag holds carries out of the most significant
significant bit in any arithmetic
etic
operation. The Carry flag is also included
included in Shift
Shift and Rotate instructions.
instructions. The only
unusual feature
feature of the 6502
6502 Carry flag is
inverted meaning in subtracunusual
Is that it has an inverted
tjon
ion operations. After
After an SBC
instruction, the Carry is cleared if a borrow
borrow was required
SBC instruction,
and set if no borrow
borrow was required. Note also that
that the SBC
(Subtract with
ith Carry)
instruc­
SBC (Subtract
Carry) instrucother operand. This usage is
tion results in (A)
(A) =
= (A)
(Al - (M)
(M) - (1
(1 - C)
C) where M is the other
different from most microprocessors
microprocessors or other computers
computers of recent vintage
vintage and the user
different
should take heed of it.
when any arithm
etic or logical operation
The Zero status flag is standard. It is set to 1 when
arithmetic
when any arithm
etic or logical
logical operation
operation produces a
arithmetic
produces a zero result. It is set toOO when
It.
non-zero result.
ill acquire
acquire the value of the high-order
high-order (Sign)
The Sign status flag is standard. It will
(Sign) bit of
etic or logical
logical result. Thus, a Sign status value of 1 identifies
identifies a negative result
any arithm
arithmetic
and a Sign value of 0
identifies a positive
positive result. The Sign status will
ill be set or reset on
O identifies
the assumption
assumption that
that you are using signed binary arithmetic.
arithmetic. If you are not using signed
arithmetic, you can ignore the Sign status, or you can use it to identify
identify the value
binary arithmetic,
high-order bit of the result.
of the high-order
It.

The Decimal Mode status, when
when set, causes the Add-with-Carry
SubtractAdd-with-Carry and Subtractwith-Carry instructions to perform BCD operations.
when the Decimal
Decimal Mode
with-Carry
operations, Thus, when
Add-with-Carry or Subtract-with-Carry
Subtract-with-Carry instruction
instruction is executed, CPU
status is set and an Add-with-Carry
CPU
logic assumes that
that both source 8-bit
-b it values are valid BCD numbers
numbers —
and the result
-and
generated will
ill also be a valid BCD
6502 CPU
CPU performs
performs decimal
BCD number. Because the 6502
decimal
addition
subtraction, there is no need for an intermediate
intermediate or Half-Carry
Half-Carry status. This
add1t1onand subtraction,
described in Volume
Volume 1.
problem with
ith the 6502
6502 approach
approach is that
that the same
status is described
1. One problem
instruction sequence will
ill produce
produce different
different results, depending
depending on whether
hether the Decimal
instruction
status has been set or cleared. Thus, confusion
confusion and errors can occur
occur ,f
if the
Mode status
accidentally been given the wrong
wrong value.
Decimal Mode status has accidentally
value.
The Break status pertains
pertains to software
software interrupts.
interrupts. When
When a software
are interrupt
interrupt (BRK in­
in-

struction) is executed,
executed, 6502
6502 CPU logic will
ill set the Break status flag.
master interrupt
interrupt enable/disable
enable/disable or interrupt
interrupt mask flag. When I
I is a standard master
equals 1, interrupts are disabled:
when I equals 0, interrupts are enabled.
disabled; when

3-4

verflow status is a typical overflow
except that
that it can be used as a control
The Overflow
overflow,, except
input on the 6502
6502 microprocessor.
during signed binary
binary arithmetic.
arithmetic, OverOver­
Recall that,
that. during
microprocessor. Recall
magnitude too great to be represented in the given word
flow status flags a result of magnitude
size.
Overflow status has been discussed in detail
detail in Volume
Volume 1 of An Introduction
Introduction to
size. The Overflow
M icrocom
puters; it equals the exclusive-OR of carries out of bits 6 and 7 during
during
icrocomputers;
arithm
etic operations. The 6502 microprocessor
microprocessor allows external
external logic to set the Over­
arithmetic
Overwhich case it can be used subsequently
subsequently as a general logic indicator;
indicator; you
flow status,
status. in which
must be very careful when
when using the Overflow
Overflow status in this way.
way, since the same status
flag will
ill be modified
modified by arithm
etic instructions.
instructions. It is up to you,
programmer, to
arithmetic
you. as a programmer.
make sure that an instruction
instruction which
which modifies the Overflow
Overflow status is not executed in
external logic sets this status and subsequent
subsequent program logic tests it.
between the time external
literature refers to the Sign bit as a negative bit. given the
DIFFERENCES
6502 literature
DIFFERENCES
IN NOTATION
symbol N,
N. Statuses (except for Carry)
Carry) are nevertheless set and
reset as described for our hypothetical
hypothetical m icrocom
puter in An InIn­
icrocomputer
troduction to M icrocom
puters; Volume
Volume 1. Henceforth.
Henceforth, we will
ill use the standard symsym­
troduction
icrocomputers:
bols S for Sign bit,
remember these
bit. as well as SP
SP for the Stack Pointer; you should
Id remember
differences when using the 6502 literature
literature and instruction
instruction set summary cards.
minor differences
cards.

6 502
0 2 M EMORY
R Y ADDRESSING MODES
The 6502 offers eleven basic addressing methods:
1)
1)

Memory
mediate
Memory- — immediate

2)

Memory -— absolute or direct.
direct, non-zero-page
Memory
Memory
Memory -— zero page (direct)

3)
4)

inherent
Implied or inherent
Accum ulator
Accumulator
6) Pre-indexed indirect
indirect
7) Post-indexed
Post-indexed indirect
indirect
8) Zero page,
page. indexed (also called base page,
page. indexed)
9) Absolute
Absolute indexed
10)
10) Relative
11) Indirect
Indirect
5)

There are tremendous
tremendous variations
variations in terms of which
hich methods are allowed
allowed with
ith which
which inin­
structions. See Table 3-4 for the addressing options
options available
available with
ith each instruction.
instruction.
structions.

33-5

M emory
ory -— Im mediate
In this form
form of addressing.
addressing, one of the operands is present in the byte immediately
immediately
following
follow
ing the first
first byte of object
object code. An immediate
mediate operand is specified by prefacing
the operand
# symbol. For example,
example.
operand with
ith the #
AND

# $08
08

requests the Assembler
Assembler to generate the instruction
instruction that
that will
ill logically
logically AND the value
0815
08-|6 with
ith the contents
contents of the Accumulator.
Accumulator.
Data

SVBDIZC

Plxi i i i ixi i

A

KX

X
Program

y

SP
PC

Memory
mm

mm

29
t-----:0-=s--1
t------1

AND

mmmm
mmmm + l
mmmm + 2

# $08
08

~~
76543210

76543210

1stBvtejojoj
1 oj, jojoj, f
1st Byte

2nd

--.,,----

These bits
select the AND
operation

These bits select
select
immediate addressing
immed,ate
addressing
with one operand in
in A

33-6

Byte
!olololo(1lo(olol

M emory -— Direct
addressing uses the second -— or second and third (if not on zero,
This form of addressing
zero. or base,
base,
page) -— bytes of the instruction
instruction to identify
identify the address of an operand in memory. The
zero page version
version is specified
specified when
when the expression
expression used as the operand
operand in the instrucinstruc­
value between
between 00-]
FF-|g. For example.
example,
tion reduces to a value
0015g and FF15
AND

$30

Assembler to generate
generate an AND instruction
instruction which
hich will
ill logically
logically AND the
requests the Assembler
memory location
location 003015
OO3O-]0 with
ith the contents
contents of the Accumulator.
Accumulator.
value in memory
Data
Data

s V

B D

I

Memory

z C

Pjxj I I I Ixj I
yy

A

0030

xx

X

Program

y

Memory

SP
PC

mm

25
30

mmmm
mmmm + 1
mmmm + 2

The non-zero-page
non-zero-page (absolute) version is similar
similar except
except that
that the address of the operand
occupies twoo bytes. For example,
occupies

AND

$31F6
$31

Assembler to generate
generate an AND instruction
instruction that
that will
ill logically
logically AND the
requests the Assembler
memory location
location 31F615
31F6-]g with
ith the contents
contents of the Accumulator.
Accumulator.
value in memory
Data

s V B D I z C

p

Memory

!xi I I I jx I I
yy

A

xx

X
y

Program
Memory

SP

PC

31 F6

mm

2D

mmmm

F6

mmmm

31

+ 1
mmmm + 2
mmmm + 3

should note that
that 16-bit
16-bit addresses are stored with
ith the eight
eight
STORING
You should
STORING
least significant
significant bits first
first (at the lower
lower address) followed
followed by the
ADDRESSES
ADDRESSES
eight most significant
significant bits (at the higher
higher address). This is the same
eight
technique that
that is used in the 8080,
8080, 8085,
8085, and Z80 microprocessors,
microprocessors, but
but the opposite
opposite of
technique
that used in the 6800
6800 microprocessor.
microprocessor.
that
3 -7

Implied or Inherent Addressing
that no addresses are required
required to execute
execute the instruction.
instruction. Typical
Typical exex­
This mode means that
inherent addressing
addressing are CLC (Clear Carry) and TAX (Transfer Register A to
amples of inherent
Register X).
X).

Accumulator
ulator Addressing
This mode means that
that the instruction
instruction operates on the data in the Accumulator.
Accumulator. On the
microprocessor, the only Accum
ulator instructions
instructions are the shifts
shifts ASL (Arithm
etic
6502 microprocessor.
Accumulator
(Arithmetic
Shift Left),
Shift Right),
through Carry),
Shift
Left). LSR
LSR (Logical Shift
Right). ROL
ROL (Rotate Left through
Carry). and ROR
ROR (Rotate
(Rotate
through Carry).
Right through
Carry).

33-8

Pre-lndexed Indirect Addressing
Pre-Indexed
Addressing
This mode means that
that the second byte of the instruction
instruction is added to the contents
contents of the·
X Index register
register to access a memory location
location in the first
first 256 bytes of memory, where
the indirect
indirect address will
ill be found. Wraparound
raparound addition
addition is used,
hich means that any
used. which
carry formed in address addition
example.
addition will
ill be discarded. For example,
AND

($20.X)
($20,X)

requests the Assembler
Assembler to generate the instruction
instruction which
which will
ill logically
logically AND the concon­
tents of the A ccum
ccumulator
ulator with
ith the contents
contents of the byte addressed by the zero-page
register.
memory location
location given by the sum of 2 016
1 6 and the contents
contents of the X Index register.
Note the use of parentheses in the address field to indicate
indicate indirection
indirection or "contents
"contents of'
of"
Data
Data

Memory

SVBOIZC

PlXi I I I iXi I

qq
pp

00rr+20
00rr+21

yy

ppqq

Program
Memory

21
20

mmmm
mmmm + 1
mmmm ◄ • 2

Remember that the carry from the address addition
addition is ignored.
ignored, i.e.,.. the address of the
first
first address byte is a number
number in mod 256. Note that the indirect
indirect address is stored with
ith
address); note also that an address occupies
its least significant
significant bits first
first (at the lower address);
two bytes of memory.
Only the X Index register can be used for pre-indexed
pre-indexed indirect
indirect addressing.

3 -9

Post-Indexed
Addressing
Post-Indexed Indirect Addressing
This mode means that
that the second byte of the instruction
instruction contains an address in the first
256 bytes of memory. That
is
That address and the next location contain an address which is
added to the contents
address.
contents of the Y Index register to obtain the effective
effective address.
Note the differences
differences between
between this method and pre-indexed
pre-indexed indirect
indirect addressing:
1) In pre-indexed
pre-indexed indirect
indirect addressing the indexing is performed before the indirection.while
tion.w
hile in post-indexed
post-indexed indirect
indirect addressing the indirection
indirection is performed before
the indexing.
indexing.
2) Pre-indexed
inPre-indexed indirect
indirect addressing
addressing uses the X Index register, while
hile post-indexed
post-indexed in­
direct
direct addressing uses the Y Index register.
ad3) Pre-indexed indirect
indirect addressing is useful for choosing one of a set of indirect
indirect ad­
dresses to use.
use. while
elehile post-indexed
post-indexed indirect
indirect addressing is useful for accessing ele­
ments
been obtained indirectly.
ments in an array or table for which
hich the base address has been
An example
example of post-indexed
post-indexed indirect
indirect addressing is
AND

($20).Y
($20),Y

which
the
which requests the Assembler
Assembler to generate the instruction
instruction which
hich will
ill logically
logically AND the
contents
Accumulator
the Y
contents of the Accum
ulator with
ith the contents
contents of the byte addressed by adding the
Index register
002015.
the $20 is
is
register to the address at memory location 0020-|
6- Note that here only the
inside the parentheses.
used indirectly.
parentheses, since only that part of the address is used
Data
Data

S V B D

I

Memory

Z C

P!X(I I I IxI I

A

qq

0020
0021

VY

PPQQ+rr

xx

X
y
SP
PC

pp

Program

Memorv
mm

mm

31
20

mmmm
mmmm + 1
mmmm + 2

Here again the indirect
indirect address is stored with
ith its least significant
significant byte first (at
(at the lower
address).
Unlike that in pre-indexed
pre-indexed indirection,
indirection, this address addition
addition is a full 16-bit ad­
address). Unlike
addition; however.
however, it
wraparound so any carry from bit 15 is ignored. Only the Y Index
dition:
It is wraparound
register can be used with
ith post-indexed
post-indexed indirect
indirect addressing.
register

3 -10
0

Indexed Addressing
This form of addressing uses the second -— or second and third (if not on zero page)
page) -—
address. That base address is then added to
bytes of the instruction
instruction to specify
specify the base address.
address. X and Y are not inthe contents
contents of Index Register X or Y to get the effective
effective address.
in­
terchangeable
terchangeable since no instructions
instructions have both forms of simple indexing
indexing with
ith both X
LOX
and Y. In fact.
fact, the only instructions
instructions which
which allow zero-page indexing
indexing with
ith Y are LDX
(Load
consult Table 3-4
(Load Index Register X) and STX (Store Index Register X).
X). You should consult
to determine
determine which
hich addressing options
options are available with
ith each instruction.
instruction.
A typical
typical example of zero-page indexed addressing is
AND

$20.X

which requests the Assembler
Assembler to generate the instruction
instruction that will
ill logically
logically AND the
which
contents
Accumulator
contents of the Accum
ulator with
ith the contents
contents of the byte at the address given by the
sum of 2015
20-)g and the contents
contents of the X Index register. This is a two-byte
two-byte instruction
instruction
because the address is within
ith in the first 256 bytes of memory. Note that
that there is no twobyte form of AND $20.Y
$20.Y although
although there is a more general three-byte
three-byte form of this inin­
struction.
struction.
Data
Memory

SVBOIZC

pix!

I I I lxl I
,.,...,_---'--YY'---.1

A
X

xx
Program

y

Memory

SP
PC

0020+rr

mm

35
20

mmmm

rnmmm + 1
mmmm + 2

A typical
typical example of absolute
absolute indexed addressing is
AND

$31FE.Y
FE.Y

which
hich requests the Assembler
Assembler to generate the instruction
instruction that will
ill logically
logically AND the
contents of the Accum
ulator with
ith the contents
contents of the byte at the address given by the
contents
Accumulator
sum of 31FE-|6
FE15 and
3-byte instruction
instruction
ancl the contents
contents of the Y Index register. This is a 3-byte
ith in the first
first 256 bytes of memory.
since the base address is not within

3-11

Data
Memory

s V 8 D I z C
PjX!

I I I jxj I
VY

A

31FE+rr

XK

X

y

Program
Memory

rr

SP
PC

mm

39
FE
31

mmmm
mmmm + l
mmmm + 2
mmmm + 3

Either Index Register X or Index Register Y could be used here. However,
instruc­
Either
However. some instructions
DEC. INC,
INC, LSR,
LSR. ROL,
ROL. and ROR)
ROR) only allow Index Register X in this
this
tions (such as ASL.
ASL, DEC.
mode. This is
,s also the case (more logically)
LOY (Load
(Load Index
logically) with
ith the instructions
instructions LDY
Register Y) and STY (Store Index Register Y).
Y).

33-12
-12

Indirect Addressing
Indirect addressing
addressing only applies
applies to the JMP (Jump to New Location) instruction.
instruction. In this
Indirect
mode,
third bytes of the instruction
instruction contain
contain the address at which
which the
mode. the second and third
effective address is located. Note that
that the indirect
indirect address can have any value and can
effective
be located anywhere
anywhere in memory. Obviously,
Obviously, this mode can be regarded as a special
case of either
either post-indexed
post-indexed indirect
indirect addressing
addressing or pre-indexed
pre-indexed indirect
indirect addressing in
which the Index register
register contains
contains zero.
typical example
example is:
which
zero. A typical
is:
JMP

($31FE)
($31
FE)

which requests the Assembler
Assembler to generate
generate a JMP instruction
instruction that will
ill load the Program
which
Counter from the memory
memory locations
locations addressed by the contents
contents of memory locations
Counter
31
q and 31 FFi
6- Remember that
that absolute
absolute addresses are 16 bits long and occupy
occupy
31 FE
FE15
FF15.
two memory
memory bytes;
bytes: however, the data located at an address is eight
eight bits long. This concon­
applies to all 8-bit
-b it processors, but is a particular
particular problem
problem with
ith the 6502 because
fusion applies
of its numerous
numerous indirect
indirect and indexed addressing
addressing modes.
Indirect addressing is de­
modes. Indirect
defully in Volume
Volume 1 of An Introduction
Introduction to Microcomputers,
Microcomputers. Chapter
Chapter 6.
scribed more fully
6.
that all addresses are stored with
ith their
their least significant
significant byte first
first (at the
Remember that
lower address).
address).
Data
Data
Memory
Memory

s vV 8b d
D iI z c
C
PJ

IIIIIII

qq
pp

31 FE
31 FF

A

X
Program

y

SP
PC

Memory
mm

mm

6C
FE
31

mmmm
mmmm + i1

+2
mmmm ·t-

The final
final value of the Program Counter
Counter is ppqq.
Never let an indirect
indirect address cross a page boundary,
boundary, as in JMP ($31FF).
Although the
FF). Although
high-order byte of the indirect
indirect address is in the first
first location
location of the next page (in this
high-order
memory location
location 3 2 0
0ig), the CPU
ill fetch the high-order
high-order byte from the
example, memory
0015),
CPU will
first location
location of the same page (location 3 1 0
0 1 g in our example).
first
0015

3 -13
3

Relative
Relative Addressing
Addressing
Branch-on-Condition
Branch-on-Condition instructions
instructions use
use program
program relative
relative addressing:
addressing; a single
single byte disdis­
placement
placement is
is treated
treated as
as aa signed
signed binary
binary number
number which
hich is added
added to the Program Counter.
Counter,
after
after the
the Program
Program Counter
Counter contents
contents have
have been incremented
incremented to address the next sese­
quential
126,o
bytes.
quential instruction.
instruction. This
This allows
allows displacements
displacements in the
the range + 1291
129-|o to - 1 2
6 iq bytes.
A typical
typical example
example is
is
A
BCC

*+55
'+

which
hich requests
requests the Assembler
Assembler to generate
generate a BCC (Branch on Carry Clear:
Clear; i.e.,.. branch if
Carry== 0)
Carry
0) instruction
instruction that
that will
ill load the Program Counter
Counter with
ith its current
current value plus five
ifif the
the Carry
Carry is,
is, in
in fact.
fact, zero. If the Carry is one.
one, the instruction
instruction does nothing.
nothing. Note that
the
the instruction
instruction itself
itself occupies
occupies two
two bytes
bytes of memory
memory and the offset is measured from the
end of
of the
the instruction.
instruction. Thus
Thus the offset
offset should be 3 to generate
generate a branch to the location
five
five beyond
beyond the one in which
hich the first
first byte of the instruction
instruction is located. Note that the
symbol* * is used for
symbol
for the current
current value of the Program Counter
Counter (actually.
(actually, the Assembler's
Location
2).
Location Counter
Counter as described
described in Chapter
Chapter 2).
The execution
•+55 instruction
execution of the BCC *+
instruction may be described
described as shown below. Note that
the entire
entire instruction
instruction is fetched
fetched from memory before the destination
destination address is calcucalcu­
lated. Note also that
that there are no other
other addressing modes available with
ith Branch-onCondition instructions.
instructions.
Condition
Data
S V B D

p

I

Z C

Memory

IIIIIIII

At----f
X
----t

v.._ __

SP t----+----./

Pc __ m_m
___

Program

--1

Memory

m_m
_ _,,.

----90

03

7--=-=-----t

33-14
-14

mmmm
mmmm + 1
mmmm + 2

6502 INSTRUCTION
INSTRUCTION SET
6502
Instructions often frighten microcomputer users who are new to programming.
programming.
execution of a single
Taken in isolation, the operations involved in the execution
single instruction
are usually easy to follow.. The purpose
purpose of this chapter is to isolate and explain
those operations.
operations.
icrocomputer
Why
hy are the instructions
instructions of a m icrocom
puter referred to as an instruction
instruction "set"?
"set"?
icrocomputer
Because the m icrocom
puter designer
designer selects (or at least should
should select) the instructions
instructions
with
ith great care; it must
must be easy to execute
execute complex
complex operations
operations as a sequence
sequence of simple
events, each of which
which is represented
represented by one instruction
instruction from a well-designed
well-designed instrucinstruc­
tion "set".
"set".

Remaining consistent
consistent with
ith An Introduction to Microcomputers:
icrocomputers: Volume 2, Table
6502 microcomputer instruction set,
set. with
ith similar instructions
3-4 summarizes the 6602
grouped
together. Individual instructions are listed numerically by object
object code in
grouped together.
Table 3-6
3-5 and in alphabetical
alphabetical order by instruction mnemonic in Table 3-6. Table 3-6
also compares
compares the 6800
6800 instruction
instruction set with
ith that
that of the 6502. We will
ill discuss the 6800
and 6502
6502 much
much later in this chapter.
chapter, after detailing
detailing the 6502
6502 instruction
instruction set.
set.
In addition
addition to simply
simply stating
stating what
hat each instruction
instruction does,
individual instruction
instruction
does. the individual
descriptions discuss the purpose of the instruction
instruction within
ith in normal programming
programming logic.
descriptions

ABBREVIATIONS
ABBREVIATIONS
These are the abbreviations
abbreviations used in this chapter:
The registers:
A
X
yY
PC
PC
SP
SP
p
P

Accum
ulator
Accumulator
Index Register X
Index Register Y
Counter
Program Counter
Stack Pointer
Status register.
register, with
ith bits assigned as follows:
follows:
Status
7

6 5 4 3

! vj
S!

2

1 00 ^
...-0;1

Bit Numb••
Number

!

! B ! DI I! Z C .,.._Status

t

~-------Reserved

■Reserved for expans,on
expansion

(unused
(unused at this
this time)
time)

Statuses:

ss
V
B
D
I

Z
z

c
C

,eg,s1e, (Pl

Sign or Negative
Negative status
Overflow status
Overflow
Break status
Decimal
Decimal Mode status
Interrupt Disable status
Interrupt
status
Zero status
Carry status

3 -15
15

Symbols in the column
STATUS:
column labeled STATUS:
(blank)
(blank)
X
0
1

66

7
addr
[addr+1,addr]
[addr+
1.addrl

addrl
addr166
data
disp
label

PC(HI)
PC(HI)
PC(LO)
PC(LO)
pp
PP
qq
[[]

[[
[[ ]]]

+

A
V

V-¥-

Operation
Operation does not affect
affect status
Operation affects
affects status
Operation
Operation clears status
Operation
Operation sets status
Operation
Operation
Operation reflects bit 6 of memory location
Operation reflects bit 7 of memory location
8 bits of absolute
absolute or base address
The address constructed
constructed from the contents
contents of memory
memory locations
addr and a ddr+
d r+ 11. This address is used in post-indexed
post-indexed indirect
indirect adad­
dressing.
16 bits of absolute or base address
8 bits of immediate
mediate data
An 8-bit.
8-bit. signed address displacement
displacement
16-bit absolute
absolute address,
destination of Jumpp or Jump-top-to16-bit
address. destination
Subroutine
Subroutine
The high-order
high-order 8 bits of the Program Counter
The low-order
low-order 8 bits of the Program Counter
The second byte of a two- or three-byte
three-byte instruction
instruction object
object code
The third byte of a three-byte
three-byte object
object code
Contents
Contents of the memory location
location designated
designated inside the brackets.
For example,
example. [FFFE]
[FFFE] represents the contents
contents of memory location
FFFE15; [addrl
adFFFE-|6:
(addrl 6+X]] represents the contents
contents of the location ad­
ddr16;
[SP] repredressed by adding
adding the contents
contents of register
register X to a ddrl
6: [SP]
repre­
sents the value at the top of the Stack (contents
(contents of the memory
location addressed by the Stack Pointer).
location
Indirect
Indirect addressing: the contents
contents of the memory byte addressed
by the contents
contents of the memory location designated
designated within
ith in the inin­
example. [[addr+X
[[addr+Xll]] represents the contents
ner brackets. For example,
contents of a
memory location
location addressed via pre-indexed
pre-indexed indirect
indirect addressing.
Addition
ddition -— either
either unsigned binary
binary addition
addition or BCD addition.
addition, dede­
pending on the condition
condition of the Decimal
Decimal Mode status.
pending
Binary or BCD
BCD subtraction.
subtraction, performed
performed by adding
adding the twos complecomple­
ment of the subtrahend
subtrahend to the minuend.
The ones complement
complement of the quantity
quantity denoted beneath the bar;
bar:
for example. A
complement
A_represents the complem
ent of the contents
contents of the
C represents the complem
complement
Accumulator;
Accum
ulator; C
ent of the value of the
Carry status.
Logical AND
Logical OR
OR
Logical Exclusive-OR
Exclusive-OR
Data is transferred in the direction
direction of the arrow.

3-166
3-

INSTRUCTION M N E M
O N IC S
MONICS
6502 instruction set. The INSTRUCTION
INSTRUCTION column shows
Table 3-4 summarizes the 6502
the instruction mnemonic (LDA,
ith the
(LOA, STA, CLC)
CLC) and the operands, if any, used with
instruction mnemonic.
mnemonic.
The fixed part of an assembly language
language instruction is shown in UPPER
UPPER CASE. The
er case.
variable part (immediate data, address, or label)
label) is shown in lower
case.
If a mnemonic
mnemonic has more than one type of operand.
operand, each type is listed separately withith ­
repeating the mnemonic.
mnemonic. For instance.
instance, some examples
examples of the format
at entry
out repeating
STX

addr
addr.Y
addrl
addr166
STX $75
STX $60,Y
STX $4276
$4276

are:

INSTRUCTION OBJECT CODES
CODES
For instruction bytes w ith
o u t variations, object codes are represented
represented as two
o
ithout
hexadecimal digits (e.g.,.. 8A).
ith variations.
variations, the object
hexadecimal
SA). For instruction bytes with
code is shown as eight binary digits (e.g., 101aaa01).
101aaa01).
The object
object code and instruction length in bytes is shown in Table 3-4 for each inin­
struction variation. Table 3-5 lists the object codes in numerical order, and Table
alphabeti­
3-6 shows the corresponding
corresponding object codes for the mnemonics, listed in alphabetical order.
order.

INSTRUCTION EXECUTION TIMES
Table 3-4
3-4 lists the instruction execution
execution times in numbers of clock periods.
Actual
periods. Actual
execution timee can be derived by dividing
dividing the given number
number of clock periods by the
execution
example, for an instruction
instruction that
that requires 5 clock periods,
clock speed. For example.
periods. a 2 MHz clock
will
ill result
result in a 2.5 microsecond
microsecond execution
execution time.

STATUS
The status
status flags are stored in the Status register
register (P)
follows:
(P) as follows:

ECU1

7 6
5 4
65432

3

2

1 0 .

-CCarry
arry status
status (carry
(carry out of bit
bit 7)

~---Zero
'------Interrupt

-Z e ro status
status (1
(1 for
for zero, 0 for
for nonzero)
nonzero)
-Interrupt disable
disable status
status
(1
means interrupts
(1 means
interrupts are disabled)
disabled)

'-------Decimal

~------Break

-D ecim al Mode
Mode status
status (1 for decimal
decimal mode)
mode)
-B reak status (1
(1 means
means a Break
Break instruction
instruction
has been executed)
executed)

L--------This

~--------Overflow
'-----------Sign

-T h is bit
bit is not used
-O v erflo w status
-S ig n status
status (value o f bit 7)

3 -17

In the individual instruction descriptions, the effect
on
ffect of instruction execution on
status is illustrated
illustrated as follows:
s:
SVDIZC
V D

I

Z C

Modified
of execution
Modified to reflect
reflect results of
execution

-------._ _____
'------'--------

Unchanged
Unconditionally
Unconditionally reset to 0
Unconditionally
set to
to 11
Unconditionally set

Bit 66 of tested
tested byte
byte
Bit 7 of tested byte

An X identifies
reset. AO0 identifies
identifies a status that
that is set or reset.
identifies a
status
status that
that is always
always cleared. A 1 identifies
identifies a status that is
always
always set. A blank means the status does not change. The
numbers
numbers 7 and 6 show that
that the flag contains
contains the value of
bit
bit 7 or bit
bit 6 of the byte tested by the instruction.
instruction.

318
3-18

STATUS CHANGES
WITH
WITH INSTRUCTION
INSTRUCTION
EXECUTION

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set

*X. 2^ .£
3
■8 ■§ s
•E •§ 3

<

TJ T3

Zero page direct
Zero page indexed
Pre-indexed indirect
Post-indexed direct

Exnmded direct
Absolute indexed

—

Ol O
) 'D
to 0)

a

Zero page indexed

a -a

X

i l l

X

X

X-(addr+Y]
X-laddr16l
X-(addrl 6+Y]

to

X

X

"O "O "O "O

T

X

T3 T3 T3 TJ
to CO co to

Load Index Register X from memory. Index through Register Y only.
X-(addr]
Zer~ page direct
ro x

X

X
X
X
X

N N Q. Q.

iV

= 1 ZZ

LO

X
X
X
X

Zero page indexed
Pre-indexed indirect
Post-indexed indirect
Extended direct
Absolute indexed
J, c o
w ® CO
o >< -9

O J°

l(addr+ 1,addr]+ Y]-A
(addr16]-A
(addr16+X]-A
or (addr16+Y]-A

Extended direct
Absolute indexed
w 05
Q) (0

" a
w _
™ P

Store Index Register X to memory. Index through Register Y only.
(addr]-X
Zero page direct
_ c
P ®

2 O) OS T5
05 tO tO CD
a> Q. a -o

= „ + 2 2
5 t5 ■& "O T>

■n T3 TJ T ) T5
^ co co co co

X

X
X
X
X

^s T> T> T1
> >

X

a a cr o'
Q a Q Q

T3 TJ T3 T3
TJ T5 T! T3

X
X
X
X

Zero page indexed
Extended direct
05 TJ
CO ®
a. t >

n

(addr+Y]-X
(addr16]-X

Load Index Register Y from memory. Index through Register X only.
Y-(addr]
Zero page direct

Y-(addr+XI
Y-(addr16]
Y-(addrl 6+X]

• Add
Add one
one clock
clock period
period ifif page
page boundary
boundary iss crossed.
crossed. Inn the
the object
object code,
code, "x"
"x" designates
designates the
the Index
Index register:
register: x = 0 for
for Register
Register X.
Register Y,
Y, x = 1 for
Register

6+Y]

Zero page direct

CL UJ <

CO CD

X
,—, +

A-(addr+X]
A-((addr+Xll
A-((addr+ 1,addr]+Y]
A-(addr16]
A-(addrl 6+X] or A-(addrl

Store Accumulator to memory.
(addr]-A
(addr+X]-A
((addr+X]]-A

3
4
6
6
4
5

4

Load Accumulator from memory.
A-(addr]

i 1 1 1 1 I

X

X

X
X
X
X
X
X

C

< < < < < <

X

X

X

X

4

X

3
4

2
2
3
3

X

A4 pp
B4 pp
AC ppqq
BC ppqq

X

LOY
addr
addr,X
addr16
addr16,X

X
X
X
X

X

3
4
4

X

X

2
2
3

z

X

86 pp
96 pp
BE ppqq

I

X

STX
addr
addr,Y
addr16

0

X

3
4
4
4•

s·

4
4•

V

X

CO «* CO CD

2
2
3
3

3
4
6

'I

g

A6 pp
B6 pp
AE ppqq
BE ppqq

{*) » t ID If l

..

"O
C

LDX
addr
addr,Y
addr16
addr16,Y
CO CO CO

ii:

2
2
2
2
3
3

CO

..
~

Jg

85 PP
95 pp
81 pp
91 pp
8D ppqq
10011x01 ppqq

CM CM CO CO

~

STA
addr
addr,X
(addr,X)
(addr),Y
addr16
addrl 6,X or Y

CM CM CO CO

eCl

2
2
2
2
3
3

CM CM CM CM CO CO

~

CM CM CM CM CO CO

3 -19

cc

Operation Performed

s

Q a. a a
Q a. Q Q

Cl

oc

Status

q
a a a cr
a. a a a q ;

!

~

Clock
Periods

AS pp
B5 pp
Al pp
B1 pp
AD ppqq
11011x01 ppqq
Q -Q .Q -Q .C T
Q q Q- '

C

Bytes

LOA
addr
addr,X
(addr,X)
(addrl,Y
addr16
addr16,X or Y

a. a

u

Object Code

T3 "O "O "O
T3 T3 T> -O

a o u eje jea Ajotueyy Ajeiuud pue o /l

..

Instruction

o ■=
O ®

1ype

Zero page indexed
Extended direct
Absolute indexed

Table
Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)

Type

Object

Code

Status

Clock

Periods

Operation Performed

s

V

z

C

05 05 "O
(0 CO ©

UJ

a. -o

N

1a5> <
E
d T3

a

N
N
Qu Q.

9

a
a.

n

a>

XI £ |
; 5 1

.£ -o J

a . Q. u j <

<

■Sa) S
T « S 8
® c o >< -9

• N

X

< <

X

X

< <

X

X

4•

X

<

X

X

4

X
X
X

X
X

c <<<<<<
O < < < < < <
“ 1 1 1 1 1 1

X

X

X

X

X

a. cr
a o. '

X
X

AND contents of Accumulator with those of memory location. Only the status
bits are affected.
AA(addr]
Zero page direct
Extended direct
Ai\[addr16]

X

a a
o. a

X
X
X

X
X

X

o o i
x

X

X

Add contents of memory location, with carry, to those of Accumulator.
A-A+{addr}+C
Zero page direct
Zero page indexed
A-A+[addr+X]+C
Pre-indexed indirect
A-A+lladdr+X]]+C
Post-indexed indirect
A-A+lladdr+
1, addr]+Y]+C
Extended direct
A-A+[addr16l+C
A-A+[addr16+X)+C
or A-A+[addr16+Y)+C
Absolute indexed
{Zero flag is not valid in Decimal Mode).
AND contents of Accumulator with those of memory location.
A-AA{addr]
Zero page direct
Zero page indexed
A-Ai\[addr+XI
Pre-indexed indirect
A-AAl[addr+XII
Post-indexed indirect
A-AAl[addr+1,
addr]+Y]
Extended direct
A-Ai\[addr16]
A-Ai\]addr16+X]
or A-Ai\[addr16+Y]
Absolute indexed

CO ■<* CD 10 ■<*

a
a.

2
2
2
2
3
3

, a> a)

X

X

X
X
X

1N

X

X

X
X
X

X
X
X

4-

X

X

X

3
4
6
5•

X
X
X
X
X
X

>

X

X

X

X

X

X

X

X

X

X

cr

4·

CM CM CM CM CO CO

Q. Q. Q.

O'

Q. Q. Q. Q. '
a c

ifl <- >-

CM CM CM CM CO CO

Q.

Q.

in

co r-- co

5•
4

X
X
X
X
X
X

>

25 pp
35 pp
21 pp
31 pp
2D ppqq
001 11 x01 ppqq

X
X
X

3
4
6

05

AND
addr
addr.X
laddr,X)
(addr),Y
addr16
addr16.X or Y

4

< < < < <
111 11 f a
< < < < < <

X

“
II
5 I X to
? i t .
2 'O 'O -o

X

X

— T3 -O "0

2
2
2
2
3
3

X

laddrl.Y
addr16
addr1 6,X or Y

65 pp
75 pp
61 pp
71 pp
6D ppqq
0111 h01 ppqq

ADC
addr
addr,X
(addr,X)

BC ppqq

D

Store Index Register Y to memory. Index through Register X only.
[addr)-Y
Zero page direct
[addr+X]-Y
Zero page indexed
Extended direct
[addr16I-Y

3
4

X

84 pp
94 pp

Bytes

2
2
3

CO -12

..
"
..

STY
addr
addr,X
addr16

CD (0 -is •

(e;eJ9do A-iouieyy) e o u e je je y Ajoweyy Ajepuooes

N
0

(penuiiuoQ) e o u sje jey

Ajoiueyy Ajeuiud pue o /l

3-20

w

Instruction

i!'

BIT

u

(I)

addr
addr16

24 pp

2C ppqq

2
3

3
4

7
7

6
6

o a> ro ra

C
0

• Add
Add one
one clock
clock period
period ifif page
page boundary
boundary iss crossed.
crossed. Inn the
the object
object code,
code, "x"
"x" designates
designates the
the Index
Index register:
register: xx == 0 for
for
Register
for Register
Register X.
X.
Register Y,
Y. xx == 1 for

Table
Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction Set
Set (Continued)
Instruction

Object

Code

Bytes

* -o
OI
O ®

Type

Status

Clock

Periods

Operation Performed

s

V

D

I

z

C
Compare contents of Accumulator with those of memory location. Only the

CMP

X

X

X

X

X

3

co

X

X

4
6

X

X

X

X

s·

X

X

3
3

4
4•

X

X

05 PP
15 pp
01 pp

CM CM CM CM CO CO

3

4

6

Zero page direct
Zero page indexed
Pre-indexed indirect

A-((addr+1. addr]+Y]
A-(addr16]
A-[addr16+X]
or A-(addr16+

Q . CL

X

X

X

2
2
2
2

status bits are affected.
A-(addr]
A-laddr+X]
A-[[addr+X]]

N

X

X

X

4
4•

CM CM CM CM CO CO

X
X
X
X
X
X

CO CO

X
X
X
X
X
X

N

X

X

X

X
X
X
X
X
X

6

2
2
2
2

jo
“ JS J5,
T T T i i i
< < < < < <

X

X

s·

4

N

X

45 PP
55 pp

X

3
3

N

C1 PP
01 pp
CD ppqq
11011x01 ppqq

3

N

0

05 pp

X
X
X
X
X
X

N

~C

(addrl,Y
addr16
addr16,X or Y

cs pp

a a a a c
a
a a. o. a ;

:,

a a a a. c
a a a o. a *
in in r- r-

(penuj^uoQ) (e ie je d o Ajoiueyv) e o u e je je y Ajoiuey\| Ajepuooes

..

'o

addr
addr,X
(addr,X)

Post-indexed indirect
Extended direct
Absolute indexed

YI

2

CL CL i

■O .E •
©) Q
))
O
CT

N

X

X

X

X

X

X

X

s·

X

X

4
4•

Exclusive-OR contents of Accumulator with those of memory location.
Zero page direct
A-A.\1-{addr]
Zero page indexed
A-A.\1-!addr+X]
Pre-indexed indirect
Post-indexed indirect

X

X

X

X

A-A.\1-!(addr+Xll
A-A.\l-{(addr+1,
addr]+Y]
A-A.\l-{addr1 61
A-A.\l-!addr16+X]
or A-A.\l-!addr16+Y]

Extended direct
Absolute indexed

<
I
<

X

X
X
X
X
X
X

to ^ to in

~

41 PP
51 pp
40 ppqq
01D11x01 ppqq

co in

E

X

..
..
..
li
0

CD CD

3-21

a.
0
~

EOR
addr
addr,X
(addr,X)
(addrl.Y
addr16
addr16,X or Y

N

..
f

< < < < < <
: I 1 I i 1 i
< < < < < <

]

u

2

3
3

X
X
X
X
X
X

A-AV[[addr+1,
addr)+Y]
A-AV(addr1 61
A-AV(addr16+X]
or A-AV(addr16+Y)

C

0

u

"'

•* Add
Add one
one clock
clock period
period ifif page
page boundary
boundary iss crossed.
crossed. Inn the
the object
object code,
code. "x"
"x" designates
designates the
the Index
Index register:
register: x =
= 0 for
Register Y. x

= 1 for Register X.

N

2

X
X
X
X
X
X

>• N

OR contents of Accumulator with those of memory location.
Zero page direct
A-AV[addr]
Zero page indexed
A-AV(addr+X]
Pre-indexed indirect
A-AV[[addr+Xll

O

a
a
a . q. ;

11 PP
OD ppqq
00011 x01 ppqq

2
2

> > > > > >
< < < < < <
i I 1 I 1 1
< < < < < <

a
a a

~

q

:I;

•~-S (Dro

..
..
.,,
..
0

q

~

E

ORA
addr
addr.X
(addr,X)
(addr),Y
addr16
addr16,X or Y

a

a:

E

C

;;

Post-indexed indirect
Extended direct
Absolute indexed

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Instruction
Instruction

Object
Object Code

Bytes

Status

Clock
Clock

Operation
Operation P erformed

z

O

I

N

0

-

V

Q

s

>

Periods

</)

1
*

Type

C
Subtract
f AcSubtract contents
contents of
of memory
memory location,
location, with
with borrow,
borrow, from
from contents
contents of

SBC

11111x01
xO 1 ppqq

4
4·

X

X

X

X

X

X

X

X

X
X
X
X
X

A -— A-[addr+X]-C
—[addr+X ]—(T
A —
—[[addr+X]]—C
- A-[[addr+XIJ-C
A —
A -[[a d d r+ 1 ,ad d r]+ Y ]-C
-A-[[addr+1.addr]+Y]-C
A -— A -[ad
d r16 ]-C
-(addr16]-C

X

pp

X

X

addrl
6,X or
addr16,X
or Y

FI
Fl

EDD ppqq
DPQQ

X

X

X

addrl
addr166

"
.!:
E

X

X

(addr),Y

"

(penui)uoQ) (e jB jedo Aj o iu o w ) e o u e je je u Ajoiueyv Ajepuooes

'a

X
X
X
X
X
X

X

El
1 pp
PP

3
4
6
5•

X

(addr.X)

2
2
2
2
3
3

X X X X X X

F55 pp

co^tcoiftTtTt

E55 pp
PP

addr.X
addr,X

(N CM CM CM CO 00

addr

A -— A -[a d d
r1 6 + X ]-C or
-(addr16+X]-C
A -— A-(addrl
—[addrl 6+Y]-C
]-C

X

0

g
]

C

F66 pp
PP
EEE ppqq
FEE ppqq

addrl
addr166

CEE ppqq

•
:E

addrl
6.X
addr16,X

DEE ppqq

t
.,,
"

X
X
X
X

addr
addr

2
2
3
3

5

6
6
7

X X X X

l:i
E

5
6
6
7

[addr]*—[addr]+11
(addr]-(addr]+

X

[addr+X
]— [a d d r+ X ]+ 1
(addr+X]-[addr+Xl+1

Zero
page indexed
Zero page

X

[addrl 6 ]—
[addrl 6]+1
(addr16l-(addr16]+1

Extended direct
Extended

[addrl 6 + X
]— [addrl 6+X ]+1 1
(addr16+X]-(addr16+X]+

Absolute
Absolute indexed

X

X
X
X
X

[addr]—
[addr]—1
(addr]-(addr]-1
[addr+X
]— [a d d r + X ]-1
laddr+X)-(addr+X]-1

Zero
Zero page
page indexed
indexed

X

[addrl 6
]— [addrl 6 ]-1
laddr16]-(addr16]-1

Extended
Extended direct

X

[addrl 6 + X ]
— [addrl 6 + X ] —1
(addr16+X]-(addr16+X]-1

Absolute indexed
indexed
Absolute

Compare
contents of
of X register
of memory
memory location.
the status
Compare contents
register with
with those
those of
location. Only
Only the

CPX

2
3

3
4

X
X

X
X

X X

E44 pp
ECC ppqq

X X

addr
addrl
addr166

co

"

CMCO

u
en

X
X

flags
flags are
are affected.
X-(addr]
-[addr]

Zero
Zero page
page direct

X-laddr16]
-[a d d r1 6 ]

Extended
Extended direct

Compare
of Y register
with those
the status
Compare contents
contents of
register with
those of
of memory
memory location.
location. Only
Only the

CPY

X
X

X
X

X X

3
4

X X

2
3

co^f r

C4
4 pp

cc ppqq

CC

(MOO

addr
addrl
addr166

Zero
Zero page
page direct

X
X

C

0

Zero
Zero page
page direct

X

DEC
OEC
C6
6 pp
D6
6 pp

►

Extended
Extended direct

Absolute
Absolute indexed

Decrement contents
Index through
through Register
Register X only,
only .
Decrement
contents of
of memory
memory location.
location. Index

addr.X
addr,X

a:

2
2
3
3

m co co

•

E66 pp
PP

CMCMOOCO

•
•
u
•
~

!

addr
addr.X
addr,X
addrl
addr166
addrl
6,X
addr16.X

X X X X

E

Zero
Zero page
page indexed
Pre-indexed indirect
Pre-indexed
Post-indexed
Post-indexed indirect

Increment
lnde)( through
through Register
Register X only,
only.
Increment contents
contents of
of memory
memory location.
location. Index

INC
INC
i n co co r -

3 -22

N
N

t0

CM CM CO 00

•
0.

0

Zero
Zero page
page direct

(Note
(Note that
that Carry
Carry value
value is
is the
the complement
complement of
of the
the borrow.)

t!

w

cumultor.
A-A-[addr]-c
— A —[addr] —(T

X
X

flags
flags are
are affected.
Y-(addr]
-[addr]

Zero
Zero page
page direct

Y -[a d
d r1 6 ]
-[addr16]

Extended
Extended direct

Add one
s crossed.
• Add
one clock
clock period
period if1f page
page boundary
boundary iIs
crossed. Inn the
the object
obJect code,
code, "x"
"x" designates
designates the
the Index
Index register:
register: x = 0 for
Register Y.
for Register
Register X.
Register
Y. x = 1 for

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
(Continued)
Type

Instruction

Object Code

Bytes

Status

Clock
Periods

Operation Performed

s

V

D

I

z

C
Rotate contents of memory location one bit left through Carry. Index through

AOL

Register X only.

6
6
7

X

X

X

X

X

X

[addr16)

X

X

X

iaddr16+X)

0

~

!

..

e
0.

a a o. a

X

6
6
7

X

X

X

X

X

X

X

3
3

X

X

6E PP
7E ppqq

X

X

addr16
addr16,X

5

X

2
2

X

X

lo cd co r*

66 pp
76 pp

o. o. Q. O’

"i'!

4

X

(addr)
(addr+Xl
(addr161
(addrl 6+X)

C

E

06 PP
16 pp
OE ppqq
1E ppqq

2
2
3
3

in cd to r**

a a a a
a. a a a

X

addr
addr,X
addr16
addr16,X

co co'

..
"

(I)

U T3 T) T!
TJ T3 TJ -D

"'
C
0

0

Arithmetic shift left contents of memory location. Index through Register X
only,

ASL

>

:;

o

4iH1

~

..

~

..~

A

~
a:
~

0

Register X only.

addr
addr.X

T3 -a -O T3
T5 -D "D T5

3-23

..
!
..
E

7

Rotate contents of memory location one bit right. through Carry. Index through

ROA

0

~

r*»

I

lttH

c

□L

.5

(addr+X)
<0 +

addr16,X

(addr)

X

- X

2
3
3

X

w <°

36 PP
2E ppqq
3E ppqq

X

t

addr,X
addr16

5

’ ■2^5

2

>

26 pp

in co cd r»

(panujiuoo) (eiejedQ Ajouioj/vj) e o u e je je y Ajouiey\j Ajepuooes

~

"D
"O "O "O
■D -O TD T3

..

-.;

addr

5

6
6
7

X
X

X

X

X

X

X

X

X

X

X

X

(addr)
(addr+X)
(addr16)
(addr16+X)

~o

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Bytes

Clock
Periods

Status

Operation Performed

s

V

D

I

z

C

X
X

X
X
X
X

Logical shift right contents of memory location. Index through Register X only .

LSR

C

0
0
0
0

X

X

[addr]
[addr+X]
[addr16]
[addr16,X]
<° * -

5
6
6
7

X

1::0
1::

2
2
3
3

in co co

E !

::E0.
•

46 pp
56 pp
4E ppqq
5E ppqq

OJ CM CO CO

~~

addr
addr,X
addr16
addr16,X

S g

..
0

■D -D -O TJ

j o y A jo u ia ^ i A j e p u o a e s

•

"'

Object Code

O -o + ^ <o

( l u o o ) ( e i s j e d o Ajo u i » w )

..,:';:!

Instruction

11

Type

.,,
•
E
"••
"'!
0

C
0

0~

2

CM

<M

LOY data

AO pp

CM

CM

Load Accumulator with immediate data.

X

A-data
Load Index Register X with immediate data.

x

X

2

X

x

3-24
E

.5

2

X

X

X-data
Load Index Register Y with immediate data.
Y-data
(0

.
..

!

~

2

«J T5

CM

A2 pp

X

CO 'O

CM

LOX data

2

o

2

<re T< -re TX -re 7>•

A9 pp

x

LOA data

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Type

Instruction

Coda

2

Clock
Periods
CM

69 PP

Bytes

CM

ADC data

Object

2

Status

Operation Performed

s

V

X

X

0

I

z

C

X

X

Add immediate with Carry, to Accumulator. The Zero flag is not valid in

5 TJ c® ^T>

.i 1

Decimal Mode.
<

X

X

CMP data

C9 pp

2

CM

2

CM

X

X

X

a.

EOR data

49 pp

2

CM

2

CM

X

X

X

:!

ORA data

09 pp

2

CM

2

CM

X

X

SBC data

E9 pp

CM

CM

X

0

:;;

E

A-A¥data

2

2

X
X

X

X

OR immediate with Accumulator.
A-AV
data
Subtract immediate, with borrow. from Accumulator.

X

X

A-A-data-C
(Note that Carry value is the complement of the borrow.)
Compare immediate with Index Register X. Only the status flags are affected.

X

X

X-data
Compare immediate with Index Register Y. Only the status flags are affected.

X

CM

X

Y-data

dum p

a.

E

...
:,

4C ppqq
6C ppqq

3
3

3

5

Jump to new location, using extended or indirect addressing.

IE a.^

JMP label
(label}

PC-label

or PC-[labell

(A

X

>
—r o
«o
5 =
tf>
to 3
5 2

2

2

Ex

co pp

2

X

CPY data

2

X

EO pp

CM

CPX data

CM

N

(11

CM

3-25

w

I

.§

A-AAdata
Compare immediate with Accumulator. Only the status flags are affected.
A-data
Exclusive-OR immediate with Accumulator.

® I
E S

eiejedo eiBjpeuiuii
~

X

c w
.h "O
I
£ <
£ i
3 <

.
.•

:!

ANO immediate with Accumulator.

i }
><

CM

X

— i -j i
E
< o <

CM

2

E

2

E

29 pp

J.

A-A+data+C
AND data

Table
the 6502
Instruction Set
Set (Continued)
Table 3-4. A Summary
Summary of
of the
6502 Instruction
I

Status

Operation Performed

J

Bytes

i

Co
de
Code

D

I

z

o

V

-

>

s

1

Clock
Periods

I

Ob
jec t
Object

i

Instruction

■

Ty
pe
Type

C
Note the
the following
following for
for all
all Branch-on-Condition
Branch-on-Condition instructions:
Note
instructions:
Program
the condition
condition is
the displacement
displacement sis added
added to
to the
the Program
IfIf the
s satisfied, the
Counter after
after the
the Program
Program Counter
Counter has
has been
been incremented
incremented to
to point
point to
to the
the in­
inCounter

struction following
following the
the Branch
Branch instruction.
instruction.
struction
BC
C disp
disp
BCC

90
90 pp

2

2··

Branch relative
relative ifif Carry
Carry flag
flag is1s cleared.
cleareo.
Branch

BC
S disp
disp
BCS

BO
BO pp

2

2--

Branch relative
relative ifif Carry
Carry flag
flag isis set.
set.
Branch

BE
Q disp
disp
BEQ

F-0
0 pp

2

2--

Branch relative
relative ifif result
result isis equal
equal to
to zero.
zero.
Branch

BMI
disp
BMI disp

30
30 pp
PP

2

2--

Branch
Branch relative
relative ifif result
result is1s negative.
negative.

BN
E disp
disp
BNE

DOO pp

2

2--

Branch
Branch relative
relative ifif result
result isis not
not zero.
zero.

BP
L disp
disp
BPL

10
0 pp

2

2--

Branch relative
relative ifif result
result isis positive.
positive.
Branch

B
VC disp
disp
BVC

50
0 pp

2

2--

Branch
Branch relative
relative ifif Overflow
Overflow flag
flag isis cleared.
cleared.

BVS
disp
BVS disp

7
0 pp
70
PP

2

2--

Branch
Branch relative
relative ifif Overflow
Overflow flag
flag isis set.
set.

j

C=0. then
then PC—
PC-PC+disp
IfIf C=0,
PC+disp
C=1. then
then P C—
PC-PC+disp
IfIf C=1,
PC+disp
IfIf Z 1 then
PC+disp
2=1.
then PC—
PC-PC+disp
IfIf S=1.
=1, then
PC+disp
then PC—
PC-PC+disp
UOjljpUOQ u o i p u e j g
C

0

·;:

'ti
C

0

IfIf Z =
PC+disp
Z=0., then
then PC—
PC-PC+disp
IfIf S
=0, then
PC+disp
S=0.
then PC—
PC-PC+disp

CJ
C

0

iiC

..
m

0
•

IfIf V == 0,
PC+disp
0. then
then PC—
PC-PC
+disp
IfIf V
=1 ,1. then
PC+disp
V=
then PC—
PC-PC+d1sp

Add one clock period if branch occurs to locat,on in same page; add two clock periods if branch to another page
occurs.

j

Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Table
Instruction

Bytes

Clock
Periods
6

60

1

6

D

I

z

C
Jump to subroutine beginning at address given in bytes 2 and 3 of the instruction. Note that the stored Program Counter points to the last byte of the JSR instruction.
[SP]-PC[HI)
[SP-1 ]-PC[LO)
SP-SP-2
PC-label
Return from subroutine, incrementing Program Counter to point to the instruc-

2 ° .2 ±1 I "1 1

3

Operation Performed

V

z
d

20 ppqq

Status

s

a
E

JSR label

Object Code

£
o

&
>
H

Type

ATS

C

<v Hi05 «n *£ IT + +
T
JL
I
q.
o
S .
o Q- o X
© o=
Qo >- O C/> O I
c J I I 1 < < 8 x < < a)
I
o) I a> ffi
I
®
I
0
3
I
>i >v >
o < o > o «*• o x o
5
5
5

•

0 | QI_

C

iii
<.>

CL r L

.,,
"'•.,

i 1 (N

r , c l a.
3 w w

u j n j e y p u e ||e o e u u n o j q n s

E

a

ro o a

C Q .fl.W Q .

tion after the JSR which called the routine
PC(LO)-[SP+ 1]
PC(Hl)-[SP+2]
SP-SP+2
PC-PC+l

"
~

0

.a

cl

~

Cl)

o

TAX

AA

1

2

X

X

TXA

BA

1

2

X

X

•

TAY

AB

1

2

X

X

::E

TVA

98

1

2

X

X

!·;;.
"'•

TSX

BA

1

2

X

X

TXS

9A

1

2

Move Accumulator contents to Index Register X.
S X

N
-.J

5

3 -27

w

X-A

in

Move contents of Index Register X to Accumulator.

A-X

oaow JOisiBey-JOisiBoy

>

Y-A

0

!
..
"'•

Move Accumulator contents to Index Register Y.

Move contents of Index Register Y to Accumulator.

A-Y

Move contents of Stack Pointer to Index Register X.
X-SP
Move contents of Index Register X to Stack Pointer.
SP-X

Table
(Continued)
Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction Set
Set (Continued)
Object Code

1
o 1e

Instruction

•* TJ

Type

Status

Clock

Bytes

Periods

Operation Performed

s

V

0

I

z

C

CA

1

2

CNJ

X

X

X

DEY

88

1

2

CN

X

X

X

INX

ES

1

2

CM

X

X

X

Decrement contents of Index Register X.
x-x-1
Decrement contents of Index Register V.
Y-Y-1
Increment contents of Index Register X.

INY

ca

1

2

CN

X

X

X

X-X+l
Increment contents of Index Register Y.

AOL A

2A

1

CN

X

X

Y-Y+l

2

X

X

^ T- C

» i 55 1 S + «= V+ °8
E >- g x E | 8
E? ?I 2
2
I I I
x a >■ b x £ >- 2

DEX

Rotate contents of Accumulator

left through Carry.

7

N

~
a.

0

A

ROA A

6A

1

2

X

X

X

Rotate contents of Accumulator

0

right. through Carry.

~

!
...
..
a:

ASL A

OA

1

2

X

X

X

Arithmetic

7

shift left contents of Accumulator.

A

4A

1

2

0

X

X

Logical shift right contents of Accumulator.

0~
A

..i.J
0

A

~o

LSR A

~

r x

(XI

eiBJedQ jejSjOey

3-28

Cf

..

!

n

4iH ..

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Instruction

Object

Code

Bytes

O X
O
©

£
■
I->

Type

Status

Clock

Periods

Operation Performed

s

V

D

I

z

C
Push Accumulator contents onto Stack.
[SP)-A

1

3

PLA

68

1

4

PHP

08

1

3

PLP

28

1

4

CLI

58

1

2

0

Enable interrupts by clearing interrupt disable bit of Status register.

SEI

78

1

2

1

RTI

40

1

6

Disable interrupts
1-1
Return from interrupt; restore Status
P-[SP+l)

CO

48

to <
(/)

SP-SP+l
Push Status register contents onto Stack.
[SP)-P
w

H081S

.,,
!!"
.,

SP-SP-1
Load Accumulator from top of Stack ("Pull").
A-[SP+l)

X

X

! < Q.
I w
:i i

PHA

C/)

X

X

X

X

X

SP-SP-1
Load Status register from top of Stack ("Pull .. l.
P-[SP+l)
ro Q. w

X

SP-SP+l

X

X

X

X

!

BAK

00

1

7

1

X

X

PC[LO)-[SP+2J
PC(Hl)-[SP+3)
SP-SP+3
PC-PC+l
Programmed interrupt. BAK cannot be disabled. The Program Counter is incremented twice before it is saved on the Stack.
[SP)--PC(HI)
[SP-11-PCILO)
[SP-2)-P

£

;dnjje;u|

a.
E

E

.:

“ ~o
®
5
a
a.
n
C/3
5 oO. i I- iT- Q.1
|
. 1 a! 1
I »- (N (/> Ti
■ ss (/) I
- O
S -CL CL1 CL1 i 1
S
a a>
w w w S;
s I -s 1 1 1a. au . oa. cl
co a . o c

3-29

,-o

SP-SP-3
PC(Hl)-[FFFF)
PCILO)-[FFFE)
1-1
8-1

Table
Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Type

..

a
0

Instruction

Object Code

Bytes

Clock
Periods

Status
Operation Performed

s

V

0

I

z

C

CLC

18

1

2

0

SEC

38

1

2

1

CLO

DB

1

2

0

Clear Decimal Mode
D-0

SEO

FB

1

2

1

CLV

BB

1

2

Set Decimal Mode
0-1
Clear Overflow flag

EA

I

0

Clear Carry flag
c-o
Set Carry flag
c-1

v-o
NOP

w

<,J
0

2

No Operation

Table 3-5.
3-5. 6502 Instruction
Instruction Object Codes
Codes in Numerical
Numerical Order
Instruction
Instruction

O
Object Code
Code
000

\

;

O
Object Code
Code

BRK
BAK

Instruction
Instruction

68
68

PLA
PLA

01
01 pp
pp

ORA
ORA

(addr.X)
laddr,X)

669 pp
pp

ADC
ADC

005 pp
pp

ORA
ORA

addr
addr

6A
6A

ROR
ROA

06 pp
pp

ASL
ASL

addr
addr

6C
6C ppqq

JMP
JMP

(label)
!label)

08

PHP
PHP

6D
60 ppqq
ppqq

ADC
ADC

addrl
addr16

data
data
A
A

09 pp
pp

ORA
ORA

data
data

6E
6E ppqq
ppqq

ROR
ROA

addrl
addr16

OA
OA

ASL
ASL

A
A

770 pp
PP

BVS
BVS

OD
OD ppqq

ORA
ORA

addrl
addr16

71
71 pp
pp

ADC
ADC

disp
disp
(addr),Y
laddrl,Y

OE
OE ppqq

ASL
ASL

addrl
addr16

75 pp

ADC
ADC

addr.X
addr,X

10 pp
PP

BPL
BPL

disp
d,sp

76
76 pp
PP

ROR
ROA

addr.X
addr,X

11 pp
11

ORA
ORA

(addr),Y
laddrl,Y

78

SEI
SEI

15
15 pp
pp

ORA
ORA

addr.X
addr,X

79 ppqq

ADC
ADC

a ddrlrl66,Y
.Y

16 pp

ASL
ASL

addr.X
addr,X

7D ppqq

ADC

addrl
6.X
addr16,X

18
18

CLC
CLC

7E
7E ppqq

ROR
ROA

addr16,X
16.X

19 ppqq

ORA
ORA

addrl
6.Y
addr16,Y

81 pp
pp

STA
STA

(addr.X)
laddr,X)

1D
10 ppqq

ORA
ORA

a ddrl
6.X
ddr16,X

8
84 pp
PP

STY

1E ppqq

ASL
ASL

addrl
6.X
addr16,X

85
85 pp
pp

STA

addr
addr
addr
addr

20 ppqq

JSR
JSR

label
label

86 pp
pp

STX

addr
addr

21 PP
pp
21
24 pp
pp

AND
ANO

(addr.X)
laddr.Xl
addr
addr

88

DEY
DEY

8A
BA

TXA
TXA

25 pp

AND
ANO

26 pp
PP

ROL
AOL

28

PLP
PLP

29 pp
2A

AND
ANO

2C ppqq
2D ppqq
20
2E
2E ppqq
30 pp
pp
31 PP
35 pp
36 pp
38
39 ppqq
3D ppqq
30
3E ppqq
40
41 pp
45 pp
46 pp
48
49 pp
4A
4C ppqq
4D ppqq
40
4E ppqq
50 pp
51 pp
55 pp
56 pp
58
59 ppqq
5D ppqq
50
5E ppqq
60
61 pp
PP
65 pp
PP
66 pp

BIT
BIT

addr
addr
addr

8C
SC ppqq

STY

ad
d r l6
addrl6

8D
80 ppqq

STA
STA

a ddrl6
d r l6

8E
SE ppqq

STX

addrl
addr16

data
data

90 pp
pp

BCC
BCC

ROL
AOL

A

91 pp

STA
STA

disp
(addr).Y
(addrl,Y

BIT
BIT

addrl
addr166

94 pp

STY

addr.X
addr,X

AND
ANO

addrl
addr166

95 pp

STA

ROL
AOL

ad
d r l6
addrl6

96 pp

STX
STX

addr.X
addr,X
addr.Y
addr,Y

BMI
BMI

disp
d1sp

98
98

TYA
TVA

AND

(addr).Y
laddrl,Y

9
99 ppqq
ppqq

STA

AND

addr.X
addr,X

9A

TXS

ROL
AOL

addr.X
addr,X

SEC
SEC
AND

add
rl6 .Y
dr16,Y

AND

a ddrl
d rl66,X
.X

ROL
AOL

addrl 6.X
addrl
6,X

RTI
RTI
EOR
EOR

(addr.X)
laddr.XI

EOR
EOR

addr
addr

LSR
PHA
PHA
LSR

data
A

JMP

label

EOR
EOR

ad
d r l6
ddrl

LSR

addrl
addr166

BVC
ave

disp
(addr),Y
laddr),Y

EOR
EOR

EOR
EOR
EOR
EOR
LSR

addr.X
addr,X
addr.X
addr,X

CLI

LSR

addrl 6,Y
,Y
addrl
addrl
6.X
addr16,X
addrl 6.X
addrl
6,X

RTS
ATS
ADC
ADC
ROR
ROA

(addr.X)
laddr.XI
addr
addr

EOR
EOR
EOR
EOR

3-31

addrl 6.Y
addrl
6,Y

9D ppqq
90
ppqq

STA
STA

addrl
6.X
addr16,X

AO pp

LDY
LOY

A1 pp
Al
A2 pp
A2
A4 pp
A5 pp
A6 pp
A8
AB
A9 pp
AA
AC ppqq
AD ppqq
AE ppqq
BO pp
B1 pp
81
B4 pp
B5 pp
B6 pp
86
B8
BB
B9 ppqq
89
BA
BC ppqq
BD
BO ppqq
BE ppqq
CO pp
co
Cll pp
PP
C4 pp

LDA
LOA

data
(addr.X)
laddr,X)

LDX
LOX
LDY
LOY

data
addr
addr

LDA
LOA

addr
addr

LDX
LOX

addr
addr

TAY
LDA
LOA

data

TAX
LDY
LOY

addrl6
ddrl 6

LDA
LOA

addrl
addr166

LDX
LOX

a ddr16
d r l6

BCS
BCS
LDA
LOA

disp
(addr),Y
laddr),Y

LDY
LOY

addr.X
addr,X

LDA
LOA

addr.X
addr,X
addr.Y
addr,Y

LDX
LOX
CLV
LDA
LOA
TSX
LDY
LOY
LDA
LOA
LDX
LOX
CPY
CPY
CMP
CPY

addrl
6 .Y
addr16,Y
addrl 6,X
6.X
addrl
a ddrl
d rl66,X
.X
addrl 6,Y
6.Y
addrl
data
data
(addr.X)
laddr,X)
addr
addr

Table 3-5. 6502
6502 Instruction
Instruction Object
Object Codes in
in Numerical
Numerical Order (Continued)
(Continued)
Table
O bject Code
Code
Object
pp
C5 pp
C6 pp
pp
C6
C8
ca
C9 pp
pp
C9
CA
CA
CC ppqq
cc
CD
ppqq
CD ppqq
CE
ppqq
CE ppqq
DO
pp
DO pp
D1 pp
D5 pp
D6 pp
D8
D9
ppqq
D9 ppqq
DD ppqq
DE
ppqq
DE ppqq
EO
EO pp
E1
PP
E1 pp

Instruction
Instruction
CMP
CMP
DEC
INY
CMP
CMP
DEX
DEX
CPY
CMP
DEC
DEC
BNE
BNE
CMP
CMP
CMP
DEC
DEC
CLD
CLO
CMP
CMP
CMP
DEC
DEC
CPX
SBC
SBC

Instruction
lnatruction

O bjec t Code
Code
Object

addr
addr

E4 pp
pp
E4
E5 pp
pp
E5
E6 pp
pp
E6
E8
EB
E9 pp
EA
EC ppqq
ppqq
ED ppqq
EE ppqq
FO pp
F1
I pp
F5 pp
F6 pp
F8
FB
F9 ppqq
F9
FD ppqq
FE ppqq

data
data
addrl
addr166
addrl
addr166
ad
d r l6
ddr16

disp
(addr),Y
addr.X
addr,X
addr.X
addr,X
addrl
6 ,Y
addr16,Y
addrl
6 ,X
addr16,X
add
rl6 ,X
dr16,X
data
(addr.X)
(addr,X)

33-32

CPX
CPX
SBC
SBC
INC
INC
INX
SBC
NOP
CPX
SBC
INC
BEQ
SBC
SBC
INC
SED
SEO
SBC
SBC
INC
INC

addr
addr
addr
addr
data

addr166
addrl
addr166
addrl
addr166
addrl
disp
(addrl,Y
(addr),Y
addr,X
addr.X
addr,X
addr.X
addr16,Y
addrl
6 ,Y
dr16,X
add
rl6 .X
addrl
6,X
addr16,X

The follow
ing symbols are used in the object
object codes in Table 3-6.
following
Address-mode Selection:
Selection:
Address-mode
aaa

000
001
010
011
100
101
110
111
111

pre-indexed indirect
indirect - (addr.X)
pre-indexed
(addr,X)
direct
direct -- addr
addr
immediate
immediate -- data
data
direct - addrl
extended direct
addr166
post-indexed indirect
indirect - (addri.Y
post-indexed
(addrl.Y
base
base page
page indexed
indexed - - addr.X
addr.X
absolute
6,YY
absolute indexed
indexed -- addrl
addr16,
absolute
6,X
absotute indexed
indexed -- addrl
addr16.X

00
01
10
11
11

direct
direct -- addr
addr
extended
direct -- a d
d rl6
extended direct
addr16
base
base page
page indexed
indexed - -addr.X
addr.X
absolute
6.X
absolute indexed
indexed -- addrl
addr16,X

001
010
011
101
101
111
111

direct
direct -- addr
addr
accum
ulator -- AA
accumulator
extended direct
direct - ad dr16
rl
extended
base
base page
page indexed
indexed -- addr.X;
addr,X; addr.Y
addr,Y in
in STX
STX
absolute
absolute indexed
indexed -- addr16,X;
addr16.X: addr16,Y
addr16,Y in
in STX
STX

00
01
I11
I

im
mediate -- data
immediate
data
direct -- addr
addr
direct
extended
direct -- a d
d rl6
extended direct
ddr16

000
001
011
101
101
II
I
111

im
mediate -- data
immediate
data
direct -- addr
addr
direct
extended direct
direct - addrl
extended
addr166
base
base page
page indexed
indexed -- addr.Y
addr.Y inin LDX;
LOX; addr.X
addr,X inin LDY
LOY
absolute
in LOY
LDY
absolute indexed
indexed -- addr16,Y
addr16,Y inin LDX;
LOX; addr16,X
addr16,X in

bb

bbb

cc

ddd

pp

the
two- or
or three-byte
three-byte instruction
instruction
the second
second byte
byte of
of aa two-

qq

the
the third
third byte
byte of
of aa three-byte
three-byte instruction
instruction

x
X

one
one bit
bit choosing
choosing the
the address mode: address mode:
0
direct
direct -- addr
addr
1
extended
direct -- addrl
extended direct
addr166

y

one
JMPmode:
address mode:
one bit
bit choosing
choosing the
the JMP address
0
extended
direct -- label
extended direct
label
1
indirect
indirect - - (label)
Uabel)

33-33

Table
Table 3-6.
3-6. Summary of
ot 6502 Object Codes
Codes with 6800 Mnemonics
M nem
nemonic

Operand
Operand

ADC
ADC

O bjectt Code
Code

Bytes

Clock

M
C 6800
MC6800

Periods
Periods

Instruction
Instruction

0 11aaa01
1aaa01

ADCA
ADCA

data
data

pp
PP

22

22

data8

addr
addr

pp
PP

22

33

addr8
addr8

addr.X
addr,X

pp
PP

22

44

index
index

(addr.X)
(addr,X)

pp
PP

22

66

s·

(addr).Y
(addr).Y

PP
PP

2

5*

addrl
6
addr16

ppqq

3

4

addr16,X
ddrl 6.X

ppqq

3

4*
4•

ppqq

33

4'

addr16,Y
ddrl 6 ,Y
AND
AND

0 01aaa01
aaa01

addrl
addr166

ANDA

data

pp
PP

2

2

data8
data8

addr
addr

pp
PP

2

3

addr8

addr.X
addr,X

pp
PP

2
2

4

index
index

(addr.X)
(addr,X)

pp
PP

2

6

(addr).Y
(addr),Y

pp
PP

2
2

5*
5'

addrl
addr166

ppqq
PPqq

3

4

addrl
6.X
addr16.X

ppqq

3

4*
4'

addrl
addrl 6.Y
6,Y

a ddr16
d r l6

ppqq

3

4*
4'

OOObbblO

11

2

PP
PP

1

5
5

addr.X
addr,X

PP
PP

2

6

ASL index
index

addrl
addr166

ppqq

3

66

ASL addrl
addr166

addr16,X
ddrl 6.X

ppqq

3

7

BCC
BCC

disp

9
0 pp
90
PP

2
2

2 "..
2

BCC
BCC disp

BCS
BCS

disp

BO
BO pp

2
2

2 "..
2

BCS
BCS disp

BEQ
BEQ

disp

FO
FO pp

2
2

2 ”..

BEQ
SEQ disp

2

3

addr8

ASL

A
addr

BIT
BIT

0 010x100
10x100
addr

ASLA

BITA

addr16
ddrl 6

pp
ppqq

3

4

addrl 6
addr16

BMI
BMI

disp

3 0 pp
30
PP

2
2

2··
"

BMI disp

BNE
BNE

disp

DO pp

2
2

2 ”..

BNE disp
8NE

BPL
8PL

disp

10
10 pp
PP

BPL disp

BRK
8RK

2

2

2
2"..

00

(SWI)
ISWI)
BVC disp

1

7

BVC

disp

5 0 pp

2
2

..
2”

BVS

disp

70
0 pp

2
2

..
2"

BVS disp
disp

CLC

18

1

2
2

CLC

CLD
CLO

D8

1

2
2

CLI

cu

58

1

2
2

CLI

CLV

B8

1

2
2

CLV

crossed..
•'Add one clock period if page boundary is crossed
"A d
d one clock period if branch occurs to location in same page; add two clock periods if branch to another
..
Add
another
page occurs.
occurs.

334
-34

Summary of 6502
6502 Object
Object Codes with
ith 6800
6800 Mnemonics
Mnemonics (Continued)
Table 3-6. Summary
M nemonic
onic

Operand
Operand

CMP
CMP

Objectt Code

Bytes

Clock

MC
6800
C6800

Periods

Instruction

110aaa01

CMPA
CMPA

data

pp
PP

2

addr

pp
PP
pp
PP
pp
PP
pp
PP
ppqq
PPqq
ppqq
ppqq
ppqq
ppqq

2

3

data8
addr8

2

4

index

2

6

addr.X
addr,X
(addr.X)
(addr,X)
(addr).Y
(addr),Y
addr16
ddrl 6
addr16,X
ddrl 6.X
addrl
ddrl 6.Y
6,Y
CPX

2

s·

2

5*

3

4

3
3

4•
4*
4•
4*

2

2

111
0ccOO
10cc00
data
addr
a ddrl
ddr166

pp
PP
pp
PP
ppqq
ppqq

2

3

3

4

2

a ddrl
ddr186

CPX
data8
addr8
a ddrl
ddr166

nooccoo
1100cc00

CPY
CPY
data

p
p
PP

2

addr

pp
p

2

3

add
r l6
dr16

ppqq
ppqq

3

4

DEC
DEC

1 10b
b 1 10
0bb110

DEC
DEC

addr

pp
PP

2

5

addr.X
addr,X

pp
PP
ppqq
ppqq
ppqq
ppqq

2

6

index

3

6

a ddr16
d r l6

3

7

DEX
DEX

CA

1

2

DEY
DEY

88

1

2

2

2

2

3

data8
addr8

2

4

index

2

6

2
3

5'
4

3

4•'

3

4·'

addrl
addr166
addrl
ddrl 6.X
6,X

EOR
EOR

010aaa01
10aaa01
data
data
addr
addr.X
addr,X
(addr.X)
(addr,X)
(addr).Y
(addr),Y
addrl
ddrl 6
addrl
ddrl 6.X
6,X
a ddrl
d rl66,Y
.Y

INC
INC

pp
PP
pp
PP
pp
PP
pp
PP
pp
PP
ppqq
ppqq
ppqq
PPqq
ppqq
ppqq

DEX
DEX

EORA
EORA

s·

11 1lbbl
b b 1 110

a ddrl
ddr166

INC
INC

addr

pp
PP

2

5

addr.X
addr,X

pp
PP
ppqq
ppqq
ppqq
ppqq

2

6

index

3

6

a ddrl
ddr166

3

7

INX

E8
EB

1

2

INY

C8
CB

1

2

3

3

(label)
(label)

ppqq
ppqq
ppqq
ppqq

3

5

label
label

20 ppqq

3

6

a ddrl
ddr166
a ddrl
6.X
ddr16,X

01y0
1 100
y01100

JMP
label
label

JSR

INX

JMP
a ddrl
ddr166

JSR addrl
addr166

'Add
•Add one clock period if page boundary is crossed..
"..AAdd
d d one clock period if branch occurs to location in same page; add two
o clock periods if branch to another
page occurs.

3 -3 5

Object Codes with
ith 6800
6800 Mnemonics
Mnemonics (Continued)
Table 3-6. Summary of 6502 Object
M nemonic
onic

Operand

LDA
data

101aaa01
aaa01
pp
PP
pp
PP
pp
PP

Bytes

Clock

M C6800
6800

Periods
Periods

Instruction

PP
PP
pp
PP
ppqq
ppqq
ppqq

2
2
2
2
2
3
3
3

4
4·
4*
4•
4*

data

101ddd10
dd10
pp
PP

2

2

addr

PP
PP

2

3

pp
PP
ppqq
ppqq
PPqq

2

4

addr
addr.X
addr,X
(addr.X)
(addr,X}
(addr).Y
(addr),Y
addrl
addr166
addrl
6.X
addr16,X
addrl 6.Y
addrl
6,Y
LDX

addr.Y
addr,Y
a ddr16
d r l6
addrl 6.Y
addrl
6,Y
LDY

2
3
4
6

LDAA
data8
addr8
index
index

s·
5*

3

4

3

4•
4*

2

addr166
addrl

LDX
(data8}
(data8)
addr8
(index}
(index)
addrl
addr16

pp
PP

2

pp
PP

2

3

addr.X
addr,X

pp
PP

2

4

ppqq
PPqq

3

4

addrl
6.X
addr16,X

ppqq

3

4•
4*

A
A

0 1 0 bbb10
bb10

1

2

addr
addr

pp
PP

2

5

addr.X
addr,X

pp
PP
ppqq
PPqq
ppqq
PPqq

2

6

LSR
LSR index
index

3

6

LSR
LSR addrl
addr16

3

7

NOP
NOP

EA
EA

1

2

NOP
NOP

ORA
ORA

OOOaaaOl
000aaa01

add
r l6
dr16
addrl 66,X
.X
addrl

LSRA
LSRA

ORAA
DRAA

data
data
addr
addr

pp
PP

2

2

data8

pp
PP

2

3

addr8
addr8

addr.X
addr,X

44

index
index

(addr.X)
(addr,X}

66

pp
PP

2

pp
PP

2

(addr).Y
laddrl,Y

pp
PP

2

addrl
addr16

ppqq

3

4

ppqq
PPqq

3

4•
4*

addrl 66,X
addrl
6.Y
addr16,Y

s·

5*

3

4•
4*

PHA
PHA

48

1

3

PHP
PHP

08

11

3

PLA
PLA

668
8

11

4

PLP
PLP

28

11

4

ROL
ROL

{

101d dd00
d00
data
addr
addr
addrl
addr16

LSR
LSR

!

O bject
jec t Code
Coda

ppqq

A
A

001
bbb10
1bbb10

addr
addr

addr16
addrl

PSHA
PSHA

PULA
PULA

11

22

pp
PP

22

55

addr.X
addr,X

pp
PP

2

ROLA
ROLA

66

ROL
ROL index
index

addrl
6
addr16

ppqq
PPqq

33

6

ROL
AOL addrl
addrl 66

aaddrl
ddrl 6.X
6,X

ppqq

33

77

*Add
"Add one
one clock
clock period
period ifif page
page boundary
boundary is
is crossed.
crossed.
"..A d
d one
Add
one clock
clock period
period ifif branch
branch occurs
occurs to
to location
location in
in same
same page;
page; add
add two
two clock
clock periods
periods ifif branch
branch to
to another
another
page
page occurs.
occurs.

33-36

j

Table 3-6. Summary of 6502 Object Codes
ith 6800 Mnemonics (Continued)
Codes with
(Continued)
M nemonic

ROR
ROA

Operand
Operand

Object Code
Code

Bytes

Clock

M C6800
6800

Periods
Periods

Instruction

01
1bbb10
11bbb10

1

2

pp
PP
pp
PP
ppqq
PPQQ
ppqq
ppqq

2

5

2

6

ROR
ROA index

3

6

ROR
ROA addrl
addr166

3

7

RTI
RTI

40

1

6

RTI
RTI

RTS
ATS

60

1

6

RTS
ATS

SBC
SBC

111
1 aaa01
aaa01

pp
PP
pp
PP
pp
PP
pp
PP

2

2

data8

2

3

addr8

2

4

index
index

2

6

A
addr
addr.X
addr,X
a ddrl
ddr166
a ddrl
6.X
ddr16,X

data

addr
addr.X
addr,X
(addr.X)
laddr,XI
(addr).Y
laddrl.Y
addrl
addr166
addrl
6 .X
addr16,X
addrl
6 .Y
addr16,Y

RORA
RORA

SBCA
SBCA

PP
PP

2

s·

ppqq
ppqq
ppqq
ppqq
ppqq
ppqq

3

4

3

4•
4*

3

4•
4*

SEC
SEC

3B
8

1

2

SED
SEO

F8
FS

1

2

SEI
SEI

78

1

2

SEI
SEI

STA

100aaa01
OOaaaOl

STAA
addr8
index
index

5*

addrl
ddrl 6

SEC
SEC

addr

pp
PP

2

3

addr.X
addr,X

pp
PP

2

4

(addr.X)
laddr,XI
(addr).Y
laddrl,Y
a ddr16
d r l6
addrl
ddrl 6.X
6,X
a ddrl
6 .Y
ddr16,Y

PP
PP

2

6

PP
PP

2

6

ppqq
ppqq
ppqq
ppqq
ppqq
PPqq

3

4

3

5

3

5

2

3

2

4

(index)

3

4

addrl
addr166

STX

100b
b 1 10
bb110
addr
addr.Y
addr,Y
addrl
addr166

pp
PP
pp
PP
ppqq
ppqq

add
r l6
dr16

STX
addr8

1 0 0 bb100
b100

STY
addr
addr

pp
PP

2

3

addr.X
addr,X

pp
PP

2

4

addrl
ddrl 6

ppqq
ppqq

3

4

TAX

AA

1

2

TAY

A8
AS

1

2

TSX

BA

1

2

TXA

8A
SA

1

2

TXS

9A

1

2

TYA
TVA

98

1

2

TSX

TXS

'A
·Add one clock period
period if page boundary
boundary is crossed.
crossed.
"A
••Add one clock period
period if branch
branch occurs
occurs to location in same page;
page; add two clock periods
periods if branch
branch to another
another
page occurs.

3 -37
7

ADC-ADD
— ADD MEMORY,
MEMORY, WITH CARRY,
ACCUMULATOR
CARRY, TO ACCUMULATOR
This instruction
instruction uses
uses eight methods of addressing data memory and allows the con­
contents of data memory and the carry status to be
ulator. The eight
be added to the Accumulator.
methods of addressing memory are:
are:
1)
1)

Immediate - ADC data
Immediate
Absolute (direct)
rl6
Absolute
(direct) - ADC a d d
dr16
3)
3) Zero page (direct)
(directl - ADC addr
4)
ith Index Register X - ADC (addr.X)
4) Pre-indexed with
(addr.X)
5)
ith Index Register Y - ADC (addri.Y
5) Post-indexed with
(addr).Y
2)
2)

6)
6)

Zero-page indexed with
ith Index Register X - ADC addr.X

7)
7)

Absolute indexed with
ith Index Register X - ADC addr16,X
Absolute
addr16.X
Absolute indexed with
ith Index Register Y - ADC a d d
rl6,Y
Absolute
ddr16.Y

8)
8)

The first byte of object code determines
determines which
hich addressing mode is selected as follows:
7 6 5 44

3 2 1 0 ^
~Bit

i l l l al al al l

| 0O| l1| l 1| a | a | a | 0O| l 1 .,._

Bit Number
Object
Ob1ect Code
Code

Bit Value
for aaa
aaa

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
of bytes

000
001
010
011
100
101
101
110
111
111

61
61
65
69
6D
71
71
75
79
7D

Indirect, pre-indexed
pre-indexed with
ith X
Indirect.
Zero page (direct)
Immediate
Immediate
Absolute (direct)
Absolute
Indirect, post-indexed
post-indexed with
ith Y
Indirect.
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

2
2
2
3
2
2
3
3

We may illustrate
illustrate the ADC instruction
instruction with
ith immediate
mediate addressing
addressing as shown below. For
consult either
either the discussion
discussion of addressing modes or the
other addressing modes,
modes. consult
description of other arithm
etic or logical instructions
instructions since other illustrations
illustrations show
description
arithmetic
different addressing modes.
different
modes.
SVBOIZC

A

X

Program

V

Memory

SP
PC

mm

mm

l--6"'9'----t

mmmm
_____YY_--1 mmmm + 1
mmmm ♦ 2

___...,

338
-38

"

Add the contents
contents of the next
next program
program memory
memory byte (addressing
(addressing mode selected
selected by bits
Add
instruction register) and the Carry status
status to the Accum
ula­
2. 3. and 4 of the byte in the instruction
Accumulator. Suppose
Suppose xx = 3 A
-|6 . yy = 7 C
ie C = 1. After
fter the instruction
instruction
3A15.
7C15.

ADC

#$7C
#$7C

has been executed.
executed, the Accum
ulator will
ill contain
contain B715.
B7-|g.
Accumulator

3A =
7C =
Carry =

000 1 11 1 0
101 1 00
0 1 1 11 11 1 0
1000
___________ 1
0 1 1101 1 1111
101

LNonzero
Nonzero result
result sets Z to 0
L

r

No carry,
carry. set C to 0-*
1 sets S to 1-*

O ¥-V-11 =
0
=11., Set V to 1
ADC is the only 6502 addition
addition instruction.
instruction. To use it in single-byte
single-byte operations
operations or to add
the low-order
low-order bytes of two multibyte
ultibyte numbers.
numbers, a previous
previous instruction
instruction must explicitly
explicitly set
Carry to zero so that
that it does not affect
affect the operation. Note that the 6502
6502 microprocessor
microprocessor
has no addition
addition instruction
instruction that
that does not include
include the Carry. ADC will
ill perform
perform either
either bibi­
nary or decimal
decimal (BCD)
addition, depending
depending on whether
whether the Decimal
Decimal Mode status is
(BCD) addition.
Is 0 or
1.

3.399
3-

-AND
MEMORYWITH
WITH ACCUMULATOR
ACCUMULATOR
AND —
AND MEMORY
of a memory location
location w
with the
the contents
contents of
of
This instruction
instruction logically
logically ANDs the contents of
Accumulator.
the same
same memory addressing
addressing options
options as
as the
the
the Accum
ulator. This instruction
instruction offers the
the addressing
addressing mode
mode as
as follows:
follows:
ADC instruction.
instruction. The first byte of object code selects the
7 6 5 4

4---e;, Bit Number
Number
3 2 11 00 ^

~Obiecl
|0
|0 | 1 | a | a | a | o | 1

Code
Object Code

Bit Value
for aaa
aaa

Hexadecimal
Object
Object Code

Addressing
Addressing Mode

Number
Number
of
of Bytes
Bytes

000
001
010
011
100
101
101
110
111
111

21
21
25
29
2D
2D
31
31
35
39
3D

Indirect. pre-indexed with X
Indirect,
(directl
Zero page (direct)
Immediate
Immediate
Absolute
(directl
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with Y
Zero page indexed with X
Absolute indexed with Y
Absolute
Absolute indexed with X
Absolute

22
22
22
33
22
22
33
33

ill illustrate
illustrate the AND instruction
instruction with zero
We will
zero page (direct)
(directl addressing. See
See the
the dis­
disaddressing methods
methods and other arithm
etic and logical instructions
instructions for
cussion of addressing
arithmetic
for exam­
examples of the other
other addressing modes.
modes.
Data
Data

SVBDIZC

p

Memory

jxj I I I Ixj I

-------{_-_-_-~v~v::jo0qq

Program

Memory

25
qq

mmmm

mmmm+ 1
mmmm + 2

Logically AND the contents
contents of the selected memory byte with
ith the Accum
ulator and
Logically
Accumulator
result in the Accum
ulator. Suppose xx== FC-|6
ar|d yy
VY = 1315.
16- After
fte r the in­
store the result
Accumulator.
FC15 and
instruction
struction

AND

$40

that yy is in memory
memory location
location 0040).
0040), the Accum
ulator will
ill contain
contain 1015:
1q:
(assuming that
Accumulator
FC =
13 =

1 1 11 11 111100 0
000
100 1 1
0010011

000
10000
0010000

_J

u

in bit
bit 7 sets S to O__J
0
00 in

Nonzero result sets Z to 0
LNonzero

AND is
is a frequently
frequently used logical
logical instruction.
instruction.
AND

3-40
3-40

LEFT
ASL -— SHIFT A C CU MULATOR
ULA TO R OR M E MORY
O R Y BYTE LEFT
one-bit arithm
etic left shift
shift of the contents
contents of the Accum
ulator or the concon­
Perform a one-bit
arithmetic
Accumulator
memory byte.
tents of the selected memory
First,
consider shifting
shifting the Accum
ulator:
First. consider
Accumulator:
Data

s v

b

d i z c

Memory

0

x,_ __

_.

YL-.----1
SPL,__
__

_.. ____

PCL.., ___

_._m~m---.J,-

Program

_,

Memory

OA

mmmm
mmmm -+ l

Suppose that the Accum
ulator contains
contains 7A-|g.
Performing an
Accumulator
7A15. Performing
ASL

A

instruction
1, the Zero status to 0,
0, and
instruction will
ill set the Carry status to 0, the Sign status to 1,
will
ill store F415
F4-JQ in the Accumulator.
Accumulator.
Carry

Accumulator
Accum
ulator

x-01111010-0
1 1 1 0 1 0->— 0
X-«------0

0

1111111 0
1 0
10100

_j

L _
Nonzero
sets Z to 0
Nonzero result sets

Sets S to 1-*------1

uses four
four data memory addressing options:
The ASL instruction
instruction uses
1) Zero page (direct)
(directl - ASL addr
1)
2)
2)

Absolute
(direct) - ASL addr16
Absolute (direct)

3)
3)

Zero page indexed with Index Register X - ASL addr.X

4)
4)

Absolute
dr16.X
Absolute indexed with Index Register X - ASL a d d
rl6,X

The first byte of object code determines which
follows:
hich addressing mode is selected as follows:
..---0,1
77 66 55 44 33 22 11 0 ^

Number
Bit Number

IOl
OTO] b I b T 1 I 1 | 0 M ----- Obiect Code
~Ob1ect
Code

3 -4
1
3-41

Bit Value
for bb

Hexadecimal
Hexadecimal
Object
Object Code

Addressing Mode
Addressing

Number
Number
of Bytes

00
01
10
11
11

06
0E
OE
16
E
1E

Zero page (direct)
Absolute
Absolute (directl
(direct)
Zero page indexed with
ith X
Absolute indexed with
ith X
Absolute

2
3
2
3

addressing. The other addresWe will
ill show the ASL instruction
instruction with
ith absolute
absolute (direct) addressing
addres­
sing modes are shown
shown in other
other instruction
instruction descriptions.
descriptions.
Data
Memory
Memory

o
0

'H4TTTTw
'ppqq

A._ __

__.

.___ __.

xl-----.1
y

SP 1---~.._

Program

____

Memory
Memory

.,,.--T
mmmm + 3

PCL..,_..m~m-..1..--m=m-...,_

OE

mmmm

qq

mmmm + 1
mmmm

pp

mmmm + 2
mmmm
mmmm + 3
mmmm

3F86-|g and the contents
contents of ppqq are CB-|g.
fte r executing
executing an
Suppose ppqq = 3FB615
CB15. After
ASL

$3F86
$3FB6

instruction, the contents
contents of location
location 3FB6,e
3F86-|g will
ill be altered to 9615
96-|g and Carry will
ill be
InstructIon.
1:
set to 1:
Carry

(3F86-]g)
(3F8615)

x--11001011-0
X - ------1
1 0 0 1 0 1 1 -— 0
100 0 1
101
1
1
0 1 10

__J

Sets
t sS
S tto l -1* ------- 1

LNonzero
I----*- Nonzero result
result sets
sets Z to
to 00

instruction is often used in multiplication
ultiplication routines
routines and as a standard
standard logical
logical inin­
The ASL instruction
struction.
2.
struction. Note that
that a single ASL instruction
instruction multiplies
ultiplies its operand by 2.

3 -42
2

BCC -— BRANCH IF CARRY CLEAR
CLEAR (C = 0)
instruction is a branch
branch with
ith relative addressing
addressing in which
hich the branch is only exex­
This instruction
status equals 0; otherwise,
otherwise, the next
next instruction
instruction is executed.
ecuted if the Carry status

sec
..__,
90
In the follow
ing instruction
instruction sequence:
following

.-------i,~C

NEXT
NEXT
C=1
#$7F
A D
#$7F

$40
the ADC $40 instruction
instruction is executed right
right after the BCC
instruction if the Carry status
SCC instruction
equals 0. The AND #$7F
#$7F instruction
instruction is executed if the Carry status equals 1.
1. The rela­
relaillustration and as shown in the discusdiscus­
tive addressing operates as shown in the next illustration
sion of addressing methods
methods presented earlier. No statuses and no registers -— except
the Program Counter
Counter -— are affected.
Data

s v
b oi
SVBDIZC

z c

Memory

III
I IL IJI
-L
ii.lI.E

p

A._

__

°"

x._ __

""

YL-

_,

__

Program
Memory

SPl---4---,./
PC L,..,.;.;m;.;,m_.i.._m_m_.,..._

___

___,

,__

''

'

.....,mmmm + 1
mmmm + 2

'

Hmmmm+ro m m m m + ri

If the Carry is
instruction adds the
is zero,
zero, this instruction
the contents of the second object code byte
(taken
contents of the
(taken as
as a signed 88-bitit displacement) to
to the
the contents
the Program Counter plus 2;
2;
this becomes
instruction to
becomes the
the memory address for
for the
the next instruction
to be
be executed. The previous
Counter are lost.
contents of the Program
Program Counter
lost.

33-43
-4 3

=

BCS -— BRANCH IF CARRY SET (C
<C = 1)
This instruction
instruction operates like the BCC
instruction except
except that the branch is only ex·
ex­
BCC instruction
instruction is executed.
ecuted if the Carry status equals 1;
1: otherwise, the next instruction

BCS
___,

BO
In the follow
ing instruction
instruction sequence:
following

C=1
,_----~S

NEXT
NEXT
=0
C =0
#$7F
A D
#$7F
I•

$40
the ADC $40 instruction
instruction is executed right
right after the BCS
instruction if the Carry status
BCS instruction
equals 1.
1. The AND #$7F
instruction is executed if the Carry status equals 0.
#$7F instruction
0.

BEQ -— BRANCH IF EQUAL TO ZERO (Z =
= 1)
This instruction
instruction is just
just like the BCC
instruction except that the branch is executed if the
BCC instruction
Zero status equals 1;
instruction is executed.
1: otherwise, the next instruction

BEO
___,

FO
In the follow
ing sequence:
following

Z =1
.-----t~O

NEXT
NEXT

Z =0
A D

#$7F
#$7F

$40
the ADC $40 instruction
instruction is executed right
right after the BEQ
instruction if the Zero status
BEO instruction
equals 1.
#$7F instruction
instruction is executed if the Zero status equals 0.
1. The AND #$7F

344
-44

BIT -— BIT TEST
instruction logically
logically ANDs
ANDs the contents
contents of the Accum
ulator with
ith the contents
contents of a
This instruction
Accumulator
memory location.
location, sets the condition
condition flags accordingly,
accordingly, but
but does not alter
alter the
selected memory
contents of the A ccum
ulator or memory byte. The only addressing
addressing modes allowed
allowed are
contents
ccumulator
absolute (direct) and zero page (direct). The first
first byte of object
object code determines
determines the adad­
absolute
follows:
dressing mode as follows:
7 6
6 5
4 3
3 2
2 1
1 0
Bit m 0
7
5 4
0 ^
.,_Bit
No.
I 0 1 0 | 1 j Q |X f 1 1 o l 'o V ^ -------- O bject Code
~Object
Code

Bit Value
for x

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
Number
of Bytes

0
0
1
1

24
2C

Zero page (direct)
Absolute
Absolute (direct)

C
M CO

2
3

W e will
ill illustrate
illustrate the BIT instruction
instruction using absolute (direct) addressing. For the zero
page mode,
instruction and the discussion
discussion of addressing modes.
mode, see the AND instruction
modes. We
should note that BIT has
effect on the status flags,
has a rather unusual effect
flags. since it sets the Z
flag according
according to the result of the logical AND operation but sets the Sand
and V flags ac­
accontents of the memory location being tested: that is,
cording to bits 7 and 66 of the contents
is.
Z = 1 if A A (M)
0
(M) = 0:
0; Z = 0 if A A (M)
(M) £;bO
S=
= bit 7 of (M)
(M)
V =
= bit 66 of (M)
(M)
Data
ata

S V B D

p

Memory

I Z C

I11 I I I IX I I
6

--------{_~

A
X
y

xx
Program
Memorv

SP

PC

_-_-__
v~vC:]ppqq

mm

mm

mmmm + 3

2C

mmmm

qq

mmmm + 1
mmmm + 2

PP

mmmm + 3

33-45

Logically AND
AND the
the contents
contents of
of the
the Accumulator
Accum ulator with
w ith the
the contents
contents of
of the
the specified
specified
Logically
memory location
location and
and set
set the
the Zero
Zero condition
condition flag
flag accordingly.
accordingly. Set the
the Sign
Sign and Overflow
Overflow
memory
condition flags
flags according
according to
to bits
bits 7 and
and 66., respectively.
respectively, of the
the selected
selected memory
memory location.
location.
condition
Suppose xx
xx = A 6
-|0 , yy = E015.
EOig, and
and ppqq
ppqq == 1641
ig A
fte r the
the instruction
instruction
Suppose
A615.
164115.
After
BIT
BIT

$1641
$1641

executed, the
the Accum
ulator w
still contain
contain A 6615.
-|g, and location
location 1641
ig will
ill still
still
has executed.
Accumulator
willill still
164115
contain E015.
E0-|g. but
but the
the statuses
statuses w
modified as follows:
follows:
contain
willill be modified
A66 =
EO
EOJ-

1 0 11 00 0 11 1100
1 f

0 0 0
1 11 0 0
00000
10 1
0 000
0100000

L

Sets S
S to
to 1
1Sets

Set V to 1

It sets Z to 0
- Nonzero resu
result
BIT instructions
instructions frequently
frequently precede conditional
conditional Branch instructions.
instructions. BIT instructions
instructions are
functions on data.
also used to perform masking functions

33-46

BMI -— BRANCH
BRANCH IF
IF M IN
MINUS
(S == 1)
1)
B
S (S
BMI
SMI

..._,-,
30
30
This
instruction works
instruction except
This instruction
works like
like the
the BCC
SCC instruction
except that
that the
the branch
branch is
is executed
executed only
only
ifif the
instruction is
the Sign
Sign status
status is
is 1:
1; otherwise,
otherwise. the
the next
next instruction
is executed.
executed.

In the
the follow
following
sequence:
In
ing instruction
instruction sequence:

S= 1
NEXT
NEXT

.----t,Hj/11

S =0)
A D

....._MAH--ADC

#$7F

$40

the ADC
instruction is executed right after the
instruction if the
ADC $40 instruction
the BMI
SMI instruction
the Sign status is
is
1.
#$7F instruction
instruction is
1. The AND #$7F
Is executed if the
the Sign status is
Is 0.
0.

BNE -— BRANCH IF NOT EQUAL TO ZERO (Z = 0)
BNE
SNE
_,,,_,

DO
instruction is
identical to the BCC
instruction except
except that the branch
branch is executed
This instruction
Is identical
SCC instruction
otherwise, the next instruction
instruction in sequence is executed.
only if the Zero status is
Is 0; otherwise.

following
In the follow
ing instruction
instruction sequence:

Z =0
.----~E

E

NEXT
NEXT
Z =
=1
#$7F
A ID
#$7F

...__'-11-'1='---ADC

$40

$40 instruction
instruction is executed
executed right
right after
after the BNE
instruction if the Zero status
status is
the ADC $40
SNE instruction
#$7F instruction
instruction is executed
executed if the Zero status
status is 1.
0. The AND #$7F

347
3-47

BPL -— BRANCH IF PLUS (S = 0)
BPL
BPL
.__,

10
This instruction
instruction operates like the BCC instruction
instruction except
except that
that the branch
branch is executed
otherwise, the next instruction
instruction in sequence is executed.
only if the Sign status is 0; otherwise.
ing instruction
instruction sequence:
In the follow
following

S =00

------~L

NEXT
NEXT
S=
=1
AND
#$7F
D
#$7F

-B1 L

the ADC $40 instruction
instruction is executed
executed right
right after
after the BPL
instruction if the Sign status is
BPL instruction
0. The AND #$7F
$7F instruction
instruction is executed
executed if the Sign status is 1.
1.

3-48
3-

BAK-FORCE
BREAK (TRAP
(TRAP OR
OR SOFTWARE INTERRUPT)
INTERRUPT)
BRK —
FORCE BREAK
BRK
.._,_,
00
two and the
the Break
Break status is
is set
set to
to 1.
1. then
then the
the
The Program Counter
Counter is incremented
incremented by tw
(P) register are
are pushed onto the
the Stack.
Stack. The
The registers
registers and
and
Program Counter
Counter and Status (P)
are pushed
pushed are
are as
as follows:
follows:
the corresponding
corresponding memory locations into which they are
Register
M emory
m o r y Location
Register
(Stack Pointer contains
contains ss
ss at start of instruction
instruction execution.)
High byte
byte of
of Program
Program Counter
Counter
01 ss
High
Low byte
byte of
of Program
Program Counter
Counter
01ss
ss -- 1 1 Low
Status (P)
(P)register
register wwith
01 ss -- 2 2 Status
ith BB==11
(Stack Pointer contains
containsssss- - 33atatend
endofofinstruction
instructionexecution.)
execution.)
The Interrupt
Interrupt Mask bitit is then set to 1.
6502's interrupt
interrupt service ability,
1. This disables the 6502's
ability.
ill not respond to an interrupt
interrupt from a peripheral device.
i.e.,.. the processor will
device. The con­
contents of the Interrupt
Interrupt Pointer
Pointer (memory addresses
addresses FFFE-|g
FFFE15 and FFFFi6>
FFFF15) are
are then
then loaded
loaded
into the Program Counter.
instruction can be used for a variety of functions.
functions. It can provide a breakpoint
The BRK
BRK instruction
facility for debugging
debugging purposes or it can transfer control
control to a particularly
particularly important
portant soft­
facility
softoperating system or a monitor. Note that
ware system such as a disk operating
that the
the programmer
instruction from a regular interrupt
interrupt response.
must insert the code required to tell a BRK
BRK instruction
response.
coding to do this checks the value of the B status flag in the Stack as
The coding
as follows:
PLA
PHA
AND
BNE
BNE

# $10
10
BRKP
BRKP

GET STATUS
;GET
STATUS REGISTER
REGISTER
;BUT ALSO LEAVE
LEAVE IT ON
ON STACK
STACK
;IS BREAK
BREAK STATUS
STATUS SET?
SET?
YES, GO
;YES.
GO PROCESS
PROCESSBREAK
BREAK

that the operation
operation code for BRK
Note that
BRK is 00. This choice of operation code means
means that
BRK can ·be
be used to patch programs in fusible-link
fusible-link PROMs
BRK
PROMs since blowing
blowing all the fuses
fuses
contents of the word
word 00. Thus an erroneous instruction
instruction can be corrected by
makes the contents
by
changing the first
first object
object code byte to 00 and inserting
inserting a patch via the interrupt
interrupt vector
changing
that a bit
bit in a fusible-link
fusible-link PROM
blowing the
routine. Remember that
PROM can be set to
tci zero
zero (by blowing
fuse) but
but cannot
cannot be reset to one after
after the fuse has been blown. Such PROMs
PROMs are not
erasable.
erasable.
operation of the BRK
instruction may be illustrated
illustrated as follows:
The operation
BRK instruction

!slvl l1'D!
ljzjcl
SVBDIZC

Pj I 1,51 I I

___

X
V

----t
t----t

SPt--:::,,-""1--C--,
PC___
_.____

....,71-__

_.01ss

mm+ 2
mm

1

A

Data
Memory

- 2

Olss - 1
Olss

Program
Memory

,_
00

mmmm
mmmm + 1

qq

PP

3 -4 9
3-49

FFFE
FFFF

final contents
contents of the Program Counter
Counter are ppqq where
where pp represents the contents
contents
The final
memory location
location FFFF,a
FFFF-|g and qq
PQ the contents
contents of memory
memory location
location FFFE-|g.
of the memory
FFFE,a. Note
that the Stack is always
always on page 1 of memory;
memory: ie.
i.e.. the eight
eight most significant
significant bits oi
of the
that
Stack address are always
always 0115.
iq .

33-50

BVC
eve -— BRANCH
BRANCH IF
IF OVERFLOW
OVERFLOW CLEAR
CLEAR (V
(V == 0)
0)
BVC
SVC
,_,,_..
50
50
This
instruction operates
This instruction
operates like
like the
the BCC
SCC instruction
instruction except
except that
that the
the branch
branch is
is executed
executed
only
instruction in
only ifif the
the Overflow
Overflow status
status is
is 0;
O: otherwise,
otherwise. the
the next instruction
in sequence
sequence is
is executed.
executed.
In
ing instruction
instruction sequence:
In the
the follow
following
sequence:
V
V ==0
NEXT
NEXT
V
V ==11
#$7F
A
A <ID
#$7F

-------1:l'VC -B»'C

-----►ADC

$40

the ADC $40 instruction
instruction is executed
right after the BVC
instruction if the
executed right
SVC instruction
the Overflow
status is 0.
#$7F instruction
instruction is
Overflow status is 1.
0. The AND #$7F
is executed if the
the Overflow
1.

BVS -— BRANCH IF OVERFLOW SET (V = 1)
1)
BVS
SVS

----70

This instruction
instruction is just
just like the BCC
instruction except that the branch is executed only
SCC instruction
if the Overflow
Overflow status is 1: otherwise,
otherwise. the next instruction
instruction in sequence is executed.
In the follow
ing instruction
instruction sequence:
following

V =1

.---~S

NEXT
V =0
A D
#$7F

$40 instruction
instruction is executed
executed right
right after
after the SVS
BVS instruction
instruction if the Overflow
Overflow
the ADC $40
status equals 1. The AND #$7F
$7F instruction
instruction is executed
executed if the Overflow
Overflow status
status equals 0.
status

3
-5 1
3-51

CLC -— CLEAR CARRY
CARRY
CLC
CLC

-.,-,
18

Clear the Carry status. No other
other status or register's contents
contents are affected. Note that
that this
instruction
instruction is required as part of a normal addition
addition operation since the only addition
addition inin­
struction
struction available on the 6502 microprocessor
microprocessor is ADC, which
hich also adds in the Carry
status. This instruction
instruction is also required at the start
start of a multi-byte
ulti-byte addition
addition since there is
significant byte.
never a carry into the least significant
Data

S V B D I

M em ory

Z C

I IO I HI I I 1°1

p=[

Program
Program
M emory

18

m mmm
m mmm+-

3-52
3-

l

CLD
A L MODE
CLO -— CLEAR
CLEAR D ECIMAL
CLD
CLD

-.,-,

DB
8
Clear the Decimal Mode status. No
contents are
No other status or register's contents
are affected. This
instruction is used
hich ADC
instruction
used to
to return the
the 6502 processor to the binary mode in which
ADC and
and
SBC
instructions produce binary rather than BCD
instruction may be used
SBC instructions
BCD results.
results. This instruction
used
to ensure that the mode is binary in situations
situations where it may be uncertain
uncertain whether
whether the
Decimal Mode status has
has been set or cleared most recently.
Data
Data

s v
B d i
SVBOIZC

2

M em ory

c

pl I I l0 11I I

A
X
Program
M emory
ory
D8
DB

m mmm
m mmm +
+ l1

3 -53
53

CU
(ENABLE INTERRUPTS)
INTERRUPTS)
CLI -— CLEAR INTERRUPT M ASK
K (ENABLE
CLI
CLI

-._.,--,
58
interrupt mask bit
bit in the Status (P)
instruction enables the
Clear the interrupt
(P) register. This instruction
6502's
6502's interrupt
interrupt service ability.
ability, i.e.. the 6502 will
ill respond to the Interrupt
Interrupt Request concon­
that the I bitit is a mask or disadisa­
trol line.
line. No other registers or statuses are affected. Note that
interrupts and set to disable them.
ble bit. It must be cleared to enable interrupts
Data
M em ory

SVBOIZC

plI I I I0 1 I I

Program

J:I

~mm~...__m_m

M em
ory
emory

-~mmm+0

58

m mmm

+1
m mmm
m ■

3-54
3-

CLV -— CLEAR
CLEAR OVERFLOW
CLV
CLV

-..,-,
B8
B8
Clear the overflow
overflow bit in the Status register.
register. No other registers or statuses are affected.
Note that the 6502 has no SET
instruction.
SET OVERFLOW
OVERFLOW instruction.
Data
Data

SVBDIZC
p

M em ory

t z c

I I0 1I Ic ImI I

Program
M emory
ory

mm

88
1------1

3 -55

l

m mmm
mm
mmmm ++ 1

CMP —
COMPARE MEMORY
MEMORY WITH
WITH ACCUMULATOR
ACCUMULATOR
-COMPARE
instruction subtracts
subtracts the contents
contents of a selected memory byte from the Accum
ula­
This instruction
Accumulator, sets the condition
condition flags accordingly.
accordingly, but does not alter the contents
contents of the Acc­
cumulator
ulator or memory byte. This instruction
instruction offers the same memory addressing options
options
as the ADC instruction.
instruction. The first
first byte of object
object code selects the addressing
addressing mode as
follows:
7 6 55 44 33 2 2 1 1 0 0 ..--0;1

! Iol•1• 1• 1oI

Bit Number
Number

1 11
| l| Q |a |a |a |o |1
l ].,._Object
^
Q biect Code
1
Code

Number
of Bytes

Bit Value
for aaa
aaa

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

000
001
010
010
01
011
10
100
10
1
101
11
110
11
1
111

C1
C1
C5
C9
CD
D1
D1
D5
D9
DD

Indirect, pre-indexed
pre-indexed with
ith X
Indirect.
(direct)
Zero page (directl
Immediate
Immediate
Absolute (directl
(direct)
Absolute
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

0 00
001

2
2
2
2
2
3
2
2
2
2
3
3

2

We will
ill illustrate
illustrate the CMP instruction
instruction with
ith pre-indexed
pre-indexed indirect
indirect addressing (using Index
Register X).
discussions of addressing methods
methods and other
other instructions
instructions for examexam­
X). See the discussions
ples of the other addressing modes.
modes.
Data
Data

Memory

SVBDIZC

Plxl j I I jxjxl

.l .___ qq-'---.1 OOrr + cc
PP

n-----1

A

xx

X
y

rr

SP
PC

OOrr + cc + 1

Program
Memory
mm

mm

mmmm + 2

Cl
cc

mmmm
mmmm + 1
mmmm + 2

Subtract the contents
contents of the selected memory byte from the contents
contents of the Accum
ula­
Subtract
Accumulator and set the Sign, Zero,
reflect the result
subtraction.
Zero. and Carry statuses to reflect
It of the subtraction.
Suppose xx== F F
i 6 - yy = 1 8
ig
rr = 2 0
t 6 - cc== 2 3 |6
<0043•)g) = 6 D
1 0 , and
Suppose
F15.
815.
015.
2315.
(004315)
6D15.
(00 4
4 1 g) = 1515.
i 6- Note that
a t 0043
0043 = rr +
(004415)
+ cc and we have assumed that
(156D15)
yy = 1815.
056
ie = vv

3 -56

instruction
After the
the instruction
CMP
CMP

($23,X)
($23.X)

has
beenexecuted.
executed,the
the Accum
ulatorwill
w ill still
stillcontain
contain F6615.
6 ,and
has been
Accumulator
and memory location
156D15
1 6 will
ill still contain 1
8 -]0 ,but the
but
ill be
modified asfollows:
1815.
statuses willthe
bestatuses
modifiedwas
follows:
F6
F6 = = 1 11 1 1 01 01 1 01 0
Twos complem
ent ofof18
18 = 1—1 1 0 1 0 1
complement
01
0 10 10 0 0

L,

110
1011 11 111100

s,<sC m 1 :

I\

•Nonzero result
0
LNoornm
"'"" sets
"" Z
z to
mo

Sets S to 1-«------Note that C is equal to the resulting carry,
ent as is true on many
carry. not to its complem
complement
other microprocessors. Thus C = 0 if a borrow is required and C = 1 if no borrow is
necessary.
necessary.
Compare instructions
instructions are most frequently
frequently used to set statuses before the execution
execution of
Branch-on-Condition instructions.
instructions.
Branch-on-Condition

3-57
3-57

CPX -— COMPARE IN DEX REGISTER
REGISTER X WITH M E MORY
Y
>

This
InThis instruction
instruction is the same as CMP except
except that
that the memory byte is subtracted
subtracted from In­
dex Register X instead of the Accumulator.
are im­
imAccumulator. The only addressing
addressing modes allowed are
mediate, zero page (directl.
(direct), and absolute
absolute (direct). The first byte of object code selects
the addressing
addressing mode as follows:
follows:
7

6 5 4

3 2

1 0

..-s,,

Numbe,
Bit Num
ber

| l | l l l l Q | c | c
| Q | o | ^
Object
bject Code
~

Bit
Bit Value
for cc

Hexadecimal
Hexadecimal
Object
Object Code

00
01
10
11

EO
E0
E4

Number
Bytes
of Bytes

Addressing
Addressing Mode
Immediate
Immediate
Zero page (direct)
Used for INX instruction
instruction
Absolute
Absolute (direct)

EC
EC

2
2
3

See the discussion of
Wee will
ill illustrate
illustrate the CPX instruction
instruction with
ith immediate
mediate addressing. See
addressing methods
methods and other arithm
etic and logical instructions
instructions for examples of the
addressing
arithmetic
the
other addressing
addressing modes.
other
modes.
Data
Data

~

SVBDIZC

p

1x1I I I Ixixj

A ___

rr - yy

__

x1-_---t_.,_ __
y

_

Program

----,

SP._ ______
PC.__m_m_....,

Memory

_,,,--7

__ m_m_,.._

mmrnm + 2

'--lt-----1
-----t

EO

mmmm

YY

mmmm + 1
mmmm + 2

Subtract the contents
contents of the selected memory byte from the contents
contents of Index Register
Subtract
Register
reflect the result of the subtraction
subtraction in the same
X. The Sign, Zero,
Zero. and Carry statuses reflect
same
way as shown
shown for the CMP instruction.
instruction.
way

33-58

CPY -— COMPARE
COMPARE INDEX REGISTER
WITH MEMORY
MEMORY
REGISTER Y WITH
This instruction
instruction is
is the same
same as CMP
CMP except that
that the memory byte is subtracted
subtracted from In­
Index Register Y instead of the
Accumulator. The only addressing modes allowed are
the Accumulator.
are im-­
mediate. zero
zero page
page (direct),
(direct). and absolute (direct).
(direct). The first byte of object code selects
the addressing mode as follows:
follows:
77 6 5 4 3 2 11 0 ^
.,._B,t
| 1|
1 | 0 10 | c | c I Q | o | ^
~Ob1ect

Bit Value
for cc

Hexadecimal
Object Code
Code

00
01
01
10
11
11

CO
co
C4
CC
cc

Bit Num
ber
Number

--------O bject Code
Code

Number
of Bytes

Addressing
Addressing Mode

2
2

Immediate
Zero page (direct)
(direct)
Used
instruction
Used for INY instruction
Absolute (direct)
Absolute
(direct)

3

We will
ill illustrate
illustrate the CPY
instruction with zero page (direct) addressing. See
discus­
CPY instruction
See the discussion of addressing methods and other arithm
etic and logical instructions
instructions for examples
arithmetic
of the other addressing modes.
modes.
Data
Data

Memory

SVBOIZC

Plxl l i i jxjxj

------i,.

__vv_◄ OOqq

A---◄

xt-----1_--

Program

v1----◄

SPI--------....PC..__m_m_.....__m_m_~a

Memory
mmmm + 2

1---CC...4-◄ mmmm
qq
mmmm + 1
I---'-'--◄ mmmm + 2

Subtract the contents
contents of the selected memory byte from the contents
contents of Index Register
Subtract
Y. The Sign, Zero, and Carry statuses reflect
reflect the result
result of the subtraction
subtraction in the same
shown for the CMP instruction.
instruction.
way as shown

359
3-59

DEC-— DECREMENT MEMORY
1)
MEMORY (BY 1)
This instruction
DEC
instruction decrements
decrements by 1 the contents
contents of a selected memory location.The DEC
instruction
instruction uses four
four data memory addressing options:
DEC addr
1) Zero page (direct) -— DEC
2) Absolute
DEC addr16
Absolute (direct) -— DEC
3)
4)

DEC addr.X
Zero page indexed with
ith Index Register X -— DEC
Absolute
- DEC
DEC addr16,X
Absolute indexed with
ith Index Register X —

The first
as follows:
first byte of object
object code determines
determines which
which addressing mode is selected as
7 66 55 4 4 3 32 21 01 -0 *......_B,1 Bit Num
Number

~Objec1
1
i O b

b

i

Code
O bject Code

1 0

Bit Value
for bb

Hexadecimal
Hexadecimal
Object
Object Code

Addressing
Addressing Mode

00
0
01
10
1
11
1

C6
6
CE
D
066
DE

(direct)
Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

01

Number
Bytes
of Bytes

2

2

33

2

2

3

DEC instruction
adWee will
ill illustrate
illustrate the DEC
instruction with
ith absolute indexed addressing. The other ad­
dressing modes are shown
shown elsewhere.
Data

S V 8

p

D I Z C

Memory

Ixi I I I !xiI

yy

ppqq + rr

A

X
y

SP
PC

Program
Memory

mm

mm

DE

mmmm

qq

mmmm + 1

PP

mmmm + 2

mmmm + 3

Decrement the contents of the specified memory byte.
0
A5-|6' ppqq
PPdQ = 0 1 0
0 ig , and rr = OA-|
then after execution
execution of the instruction
instruction
If yy = A515.
10015.
OA15,

DEC
DEC

$0100,X
$0100,X

the contents
contents of memory
memory location
location 010A15
OIOA 1 0 will
ill be altered to A415.
4 i 0 .

A5 =
complement of 1 =
Ones complement

1 00 1 00 0 1 00 1
1 11 11 111111111 1

LL

10 1
0 100
0100100
Carry is
is not
not altered
Carry
alteredj
Sets S to 1-

Nonzero result sets Z to 0
Overflow
verflow (V)
(V) is not altered

33-60

1)
DEX- — DECREMENT
DECREMENT INDEX
INDEX REGISTER X (BY 1)
This instruction
X. The Zero and Sign
instruction decrements
decrements by 1 the contents
contents of Index Register X.
statuses are affected.

--DEX
CA

The effects
DEC except that the contents
contents of
effects of this instruction
instruction are the same as those of DEC
Index Register X are decremented
decremented rather than the contents
contents of a memory location.
Data
Data
Memory

SI/BDIZC
s v
b o i z c

■GEI lJlJl3x l3l

Pl x[

,..

rr -

1

t~rr~j.~::::::---__.
y

Program
Program

SPl-----1

Memory

X

PC~-----m-m--

....

Cl\

3-61
3-61

mmmm
mmmm
mmmm ++ 11

DEY -— DECREMENT
DECREMENT INDEX
INDEX REGISTER
Y (BY
(BY 1)
1)
DEY
REGISTER Y
This instruction
instruction decrements
decrements by
by 11 the
the contents
contents of
of Index
Index Register
Register Y.
Y. The
The Zero
Zero and
and Sign
Sign
This
statuses are
are affected
affected just
just as
as they
they are
are by
by DEC
DEC and
and DEX.
DEX.
statuses

---DEY
DEY

88

S V
B
SVBDIZC

Data
Data
Memory

lXlmI I I lXI I

p- E

A
X
yi--,,---1-~----SP
PC

C

rr-1
Program

Memory

~

mm

(

~{

mmmm + 1

----........_,_
__ __

88
___

3 -6
2
3-62

mmmm
mmmm h
+ 1
_,mmmm

EOR
EXCLUSIVE-OR AC CU M
ULA TO R WITH
IT H M EM
ORY
EOR-— EXCLUSIVE-OR
MULATOR
EMORY
contents of the Accum
ulator with
ith the contents
contents of a selected
selected memory
memory
Exclusive-OR the contents
Accumulator
byte. This instruction
instruction offers the same memory
memory addressing
addressing options
options as the ADC instrucinstruc­
first byte of object
object code selects the addressing
addressing mode as follows:
follows:
tion. The first
7 66 55 44 3 3 2 2 1 1 0 -4--B,t
^
^

Bit Number
Number

-------- Object
Obiect Code
Code

Bit Value
for aaa

Hexadecimal
Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
Number
of Bytes

000
001
001
010
011
011
100
101
101
110
111
111

41
41
45
49
4D
40
51
51
55
59
5D
50

Indirect, pre-indexed
pre-indexed with
ith X
Indirect.
Zero page (direct)
Immediate
Immediate
Absolute (direct)
Absolute
Indirect, post-indexed
post-indexed with
ith Y
Indirect.
indexed with
ith X
Zero page indexed
Absolute indexed
indexed with
ith Y
Absolute
Absolute indexed
ith X
Absolute
indexed with

2
2
2
3
2
2
3
3

We will
ill illustrate
illustrate the EOR
instruction with
ith post-indexed
post-indexed indirect
indirect addressing
addressing (using InIn­
EOR instruction
discussion of addressing
addressing methods
methods and other
other arithm
etic and
dex Register Y). See the discussion
arithmetic
logical
instructions for examples
examples of the other
logical instructions
other addressing
addressing modes.
S V
B D
VBDIZC

Data
Memory

z c

Pix! Il Il Il lI xxji II

P|X|

i

A .._ ___x.;..x_-f,.._
X
y..._ __
_

SP
PCl-_m_m
___

qq
pp
PP

OOcc
00cc
OOcc + 1
00cc

yy

ppqq + rr

Program
Memory

m_m_....,~-r
51
cc

3 -63
3

mmmm
mmmm

mmmm + 1
mmmm + 2
mmmm
mmmm + 3
mmmm

Logically
ulator wwith
ith the
Logically Exclusive-OR
Exclusive-OR the
the contents
contents of
of the
the Accum
Accumulator
the contents
contents of
of the
the
selected
selected memory
memory location,
location. treating
treating both
both operands
operands as
as simple
simple binary
binary data.
data. Suppose
Suppose that
that
xx
ig. AAfter
fte the
xx== E3-|0
E315 and
and yy
yy == AO
A015.
the instruction
instruction
EOR
EOR ($40,Y)
($40.Y)
has
ulator w
t6 . W
e assume
-|6_
has executed,
executed. the
the Accum
Accumulator
will contain
contain 4 3
4315.
We
assume also
also that
that rrrr == 10
1015.
qq == (40
(4015)
= 1E-|6,
1E15. pp
pp== (41
(4115)
2515. and
and (251
(251E15)
yy == AOig.
A015.
qq
q) =
ig ) == 25-|6’
E i©) == VV
E3
E3 =
A0
AO ==

11 11 11000 00 11 11
1100 11 00 00 000000

L

0 10
0 0 0 11
01000011
00 sets
sets SS to
to 00

_J

Nonzero result
LNonzero
result sets
sets ZZ to
to 00

EOR
EORis
is used
used to
to test
test for
for changes
changes in
in bit
bit status.
status. Note
Note also
also that
that the
the instruction
instruction EOR
EOR#$FF
#$FF
complements
ulator, changing
complements the
the contents
contents of
of the
the Accum
Accumulator.
changing each
each 'V
·1• bit
bit to
to aa 'O'
·o·and
and each
each
·o·bit
bit to
to aa T.
'0'
'1'.

364
3-64

INC -— INCREMENT
INCREMENT MEMORY
MEMORY (BY 1)
1)
This instruction
instruction increments
increments by 1 the contents
contents of a selected memory location. The INC
INC
instruction uses four
four data memory addressing options:
instruction

1)
1)

Zero page (direct) -— INC addr
Absolute (direct) -— INC addr16
Absolute
3)
ith Index Register X —
INC addr.X
3) Zero page indexed with
-INC
addr,X
4) Absolute
Absolute indexed with
ith Index Register X -— INC
INC addr16,X
2)

first byte of object
object code determines
determines which
hich addressing mode is selected as follows:
The first
7 6

5 4

3

Numbe,
2 1 0 ..,_B,t
-------- Bit Number

~Ob1ect
| 11
1 | 1 | b| b | 1 | 1 |0

Code
--------Object Code

Bit Value
for bb

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
of Bytes

00
01
10
11
11

E6
E6
EE
EE
F6
FE
FE

Zero page (direct)
Absolute
(direct)
Absolute (direct)
Zero page indexed with
ith X
Absolute indexed with
ith X
Absolute

2
3
2
3

ill illustrate
illustrate the INC instruction
instruction with
ith absolute (direct) addressing. The other adad­
We will
dressing modes are shown elsewhere.
Data
Data

SVB

DI

Memory

ZC

Ptx!l I l lxlI
VY+

1

-A----t

VY

ppqq

Program

Memory

EE

mmmm

QQ

mmmm + 1
mmmm + 2

t--pp---t

mmmm + 3

33-65

I

Increment the
the selected
selected memory
memory byte.
byte.
Increment
1@
. qq
qq == A215,
A2-|g, and yy
yy =
= C015.
COig- then
then after
after executing
executing an:
If pp
pp== 0 1
0115,

INC

$
01A2
$01A2

instruction, the
the contents
contents of
of memory
memory location
location 01
01 A215
A2-|e w
be incremented
incremented to C 115.
116.
instruction,
willill be
CO =
co

11 =

0 0 0 00 00 00
11 100

000
0 001
00000001
110
0 00 1
1000001

__J

LNonzero
1 ►
Nonzero result
result sets Z to 0

Sets S to 1 ---------1

Carry and Overflow
Overflow are not
altered
altered
instruction can be used to provide
provide a counter
counter in a variety
variety of applications
applications such as
The INC instruction
counting the occurrences
occurrences of an event
event dr specifying
specifying the number
number of times
times a task is to be
counting
performed.

33-66

INX -— INCREMENT
INCREMENT INDEX
INDEX REGISTER
REGISTER XX (BY 1)
1)
INX
This instruction
instruction increments
increments by 11 the
the contents
contents of
of Index
Index Register
Register X. The
The Zero
Zero and
and Sign
This
statuses are
are affected
affected just
just as by
by the
the INC
INC instruction.
instruction.
statuses

INC

--.,-,
EB
Data

s v
b o i z c
SVBOIZC

Memory

I
xf I I
I Ixf I
’
EETEEEO

p

A

X

rr + 1

t==~-=--=-l;.;__:!:>---_...

___
.._

y
SPt----~

PC

___

Program
Memory
Memory

__
EB

mmmm
mmmm
mmmm
mmmm -+ 1

contents of Index Register X and set the Zero and Sign flags according
according to
Add 1 to the contents
the result. Suppose that
fter the instruction
that Index Register X contains
contains 7A-|0,
7A15. After
instruction
INX
has
executed, Index Register X will
ill contain
contain 7815.
7B-|0, the Zero status will
ill be cleared since
has executed.
the result is nonzero, and the Sign status will
ill be cleared since the result has
has 0O in its
most significant
significant bit.

3-67
3-67

INYY -— IN C R
INCREMENT
INDEX
REGISTER Y
IN
EM EN T IN D
EX REGISTER
Y (BY
(BY 1)
1)
This
This instruction
instruction increments
increments by
by 11 the
the contents
contents of
of Index
Index Register
Register Y.
Y. The
The Zero
Zero and
and Sign
statuses
statuses are
are affected
affected just
just as
as by
by the
the INC
INC instruction.
instruction.

--INY
INY

cs8
C

SVBOIZC
s V
B D
p p m T

I

Z

Data
Data
M em ory

C

P[xl! l ! ilXin l

A

x,____

_,

rr + 1

Program

y
SP 1--"-"~PC __

m_m
_ _.__m_m __

emory
M em
ory
_

CB

m mmm
m mmm++ 1

Add 1 to the contents
contents of Index Register Y and set the Zero and Sign flags according to
Add
the result. Suppose that
INY has
has
that Index Register Y contains
contains OC15.
1 . Afterr the instruction
instruction INY
ill contain
contain 0015.
0D-|g, the Zero status will
ill be cleared since the
executed. Index Register Y will
the
result is nonzero.
nonzero, and the Sign status will
ill be cleared since the result has
result
has 0O in its most
significant bit.
significant

3-68

J MP
P -— J UMP
M P VIA ABSOLUTE OR INDIRECT ADDRESSING
instruction will
ill be illustrated
illustrated using indirect
indirect addressing. Note that
that it is
in­
This instruction
Is the only instruction that
that has the true indirect
indirect addressing mode.
first byte of object
object code deterdeter­
struction
mode. The first
follows:
mines the addressing mode as follows:
7 6 5 4 3 2 1 0 ^
..-s,t B it Number
Number
| 0 I
1 I y I 0 I 1 I 1 I o | o K ^ ------- O bject Code
~Ob1ect
Code

Bit Value
for y

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
of Bytes

0
0
1
1

4C
6
6C

Absolute (direct)
Absolute
Indirect
Indirect

3
3
Data

S V B D

I

Memory

Z C

pl I I I I I I I

ccdd
ccd d+ 1

A ___

-1

x._ __

-i

Program

y
---◄

SP.,_ __
+----,,
PC..__m_m_...__m_m _

Memory

_.l_

ppqq

6C
mmmm
t--d-,-d--tmmmm
+ 1

cc

mmmm + 2

Jump to the
instruction specified by the operand by loading the address from the
the instruction
selected memory bytes into the
the Program Counter.
In the follow
ing instruction
instruction sequence:
following
CLC
CLC
LDA
LOA
ADC
STA
STA
LDA
ADC
ADC
STA
STA
JMP
JMP

;CALCULATE LSB'S
LSB'S OF
OF DESTINATION
DESTINATION ADDRESS
ADDRESS
#BASEL CALCULATE
INDXL
JADDR
#BASEU CALCULATE
;CALCULATE MSB'S
MSB'S OF
OF DESTINATION
DESTINATION ADDRESS
ADDRESS
INDXU
INDXU
JADDR+1
(JADDR)
(JADDR) TRANSFER
;TRANSFERCONTROL
CONTROL TO
TO DESTINATION
DESTINATION

The JMP instruction
instruction will
ill perform an
an indexed jump relative to
to the
the 16-bit address
address con­
consisting of BASEU
BASEU ( 8
(8 MSBs)
MSBs) and BASEL
BASEL ( 8
(8 LSBs).
LSBs) The index here
here is assumed
assumed to
to be 16 bits
long
initially stored at addresses
long and
and to
to be initially
addresses INDXL ( 8
(8 LSBs)
LSBs) and
and INDXU
INDXU ( 8
(B MSBs).
MSBs). The ad­
addresses
ing the start of
instructions
dresses follow
following
of the
the table
table could then contain absolute JMP instructions
that
that transfer control to
to the
the proper routines.
routines.
JMP
JMP w
will not work properly if the
the indirect
1nd1rectaddress
address crosses
crosses aa page
page boundary
boundary -— that
that is,
Is. if
dd == F F
i q in
illustration above.
indirect addressing earlier
FF15
In the
the illustration
above. The discussion
discussion of indirect
earlier in
in this
th,s
chapter
in more detail.
detail.
chapter discusses this peculiarity
pecul1ar1ty in
The
instruction can also use
The JMP instruction
use the
the absolute
absolute (direct) addressing mode.
mode. In this
this case,
case.
the
the second
second byte of
of the
the instruction
InstructIon is
Is loaded
loaded into the
the low
low byte
byte of the
the Program
Program Counter,
Counter.
and
instruction is
and the
the third
third byte of
of the
the instruction
is loaded
loaded into
into the
the high byte
byte of
of the
the Program
Program
Instruction execution continues
Counter. Instruction
continues from
from this
this address.
address.

33-69

l

JSR -— J UMP
M P TO SUBROUTINE
instruction pushes the Program Counter
Counter onto the Stack and then transfers
transfers control
control
This instruction
to the specified
specified instruction.
instruction. Only absolute
absolute (direct) addressing
addressing is allowed.
allowed. Note that
that the
Stack Pointer
Pointer is decremented
decremented after
after the storage of each data byte and that
that the Program
Counter value that
that is saved is the address of the last (third) byte of the JSR instrucinstruc­
Counter
tion: i.e.,.. the initial
initial program counter
counter value plus 2. Remember also that
that the Stack grows
tion:
down in memory
memory and that
that the most significant
significant half of the Program Counter
Counter is stored
down
first
higher address (in the usual 6502
first and thus ends up at the higher
6502 address form).
Data
Data

S V

p

B

D I

z C

Memory

IIIIIIII

mm+ 2
mm

01 ss - 2
01ss - 1
01 ss

A

X
y

Program

SP

ss

PC

mm

Memory

20

mmmm

qq

mmmm + 1

pp

mmmm + 2

The Program Counter
Counter is incremented
incremented by 2 and then is pushed onto the Stack. The Stack
Pointer
adjusted to point
point to the next empty
Pointer is adjusted
empty location
location in the Stack. The address part of
the instruction
instruction is then stored in the Program Counter
Counter and execution
execution continues
continues from that
point.
mmmm = E34F-]
0 and that ss = E3-]
0 Then after
after the execution
execution of the inin­
Assume that mmmm
E34F16
E315.
struction
struction
JSR
JSR

$E100

the Program Counter
Counter will
ill contain
contain E100-|
q, the Stack Pointer
Pointer will
ill contain
contain El
E1 115.
0 , and the
E10015.
Stack locations
locations will
ill be as follows:
follows:

(01 ss)
E3) = PC(HI)
(01
ss) = (01E3)
PC (HI) = E3
(01 ss - 1)
1) = (01E2)
E2) = PC(LO)
(LO) = 5 115
(01
16
The next instruction
instruction to be executed
executed will
ill be the one at memory
memory address El1 OO-|
0.
0015.

33-70

LDA
ULA TO R FROM
ORY
LOA-— LOAD
LOAD A C CU MULATOR
FROM M EM
EMORY
Load the contents
contents of the selected memory
memory byte into
into the Accum
ulator. This instruction
instruction
Accumulator.
memory addressing
addressing options
options as the ADC instruction
instruction and will
ill be illusillus­
offers the same memory
ith Index Register X. See the discussion
discussion of
trated using zero-page indexed addressing with
methods and other
other arithm
etic and logical
logical instructions
instructions for examples of the
addressing methods
arithmetic
other addressing modes.
first byte of object
object code selects the addressing mode as
other
modes. The first
follows:
follows:
7 6 55 44 3 2 1 0 ^
-4-B,t
| l|
0 | l | a | a | a | 0 | 1~t^
~Obiect

Bit Number
Number

------- O bject Code
Code

Bit Value
for aaa
aaa

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
of Bytes

000
001
010
011
100
101
101
110
111
111

A1
A5
A9
AD
B1
B1
B5
B9
BD
BO

Indirect, pre-indexed
pre-indexed with
ith X
Indirect.
Zero page (direct)
Immediate
Immediate
Absolute (direct)
Absolute
Indirect, post-indexed
post-indexed with
ith Y
Indirect.
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

2
2
2
3
2
2
3
3
Data
Data

Memorv

SVBOIZC

plxj I I I lxl I

..

-----::

,./".,_-_-_-;,-'-vv~=Joorr
+ cc

yy

X

Program

y

Memorv

SP
P(

mm

mm
B5
cc

rnmmm

mmmm + 1

Load
contents of the
Accumulator.
Load the contents
the selected memory byte into the Accumulator.
Suppose that Index Register X contains 10
q and
1015
and cc== 43-|g.
4315. If memory location
OO53-|0
005315 contains
contains AA-|6,
AA,e. then
then after
LDA
LOA

$43.X

has
ulator w
AA-|g.
has executed,
executed. the
the Accum
Accumulator
will contain AA,e.
AA

=

I

1100 1100 1100 1 00

__J

L

LNonzero
result
sets S to 11-•------ 1
1 sets
'— ^N onzero result
sets Z to
0 sets Z to 0

31
3-71

LDX
RY
LOX -— LOAD
LOAD IN DEX REGISTER
REGISTER X FROM M E MORY
Load the contents
contents of the selected memory byte into Index Register X.
X. The addressing
modes allowed are:
are:
1)
1)
2)
3)
4)
5)

Immediate -— LDX
Immediate
LOX data
Absolute
LOX addr16
Absolute (direct) -— LDX
LOX addr
Zero page (direct) -— LDX
Absolute indexed with
ith Y -— LDX
addr16,Y
Absolute
LOX addr16.Y
Zero page indexed with
ith Y -— LDX
LOX addr.Y

Note that there are no indexing
indexing modes with
ith Index Register X,
post-in­
X. and there is no post-infirst byte of object
object code selects the addressing
addressing mode as follows:
follows:
dexing. The first
7 66 55 4

3 2 11 0 ..,._B,t
^

| l |
0 | l | d |d|d|1 |0
~Ob1ect

Bit Number
Number

------- Object Code
Code

Bit Value
for ddd

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

000
001
010
011
011
100
101
101
110
111
111

A2
A6
AA
AE
B2
B6
BA
BE
BE

Immediate
Immediate
Zero page (direct)
Used for TAX instruction
instruction
Absolute (direct)
Absolute
Not used
Zero page indexed with
ith Y
Used for TSX instruction
instruction
Absolute indexed with
ith Y
Absolute

Number
of Bytes
2
2
3
2
3

We will
ill illustrate
illustrate the LDX
instruction with
ith absolute indexed addressing using Index
LOX instruction
Register Y. See the discussion
discussion of addressing methods and other arithm
etic and logical
arithmetic
instructions for examples of the other
other addressing modes.
instructions
modes.
Data
Data

S V B D I

p

Memory

Z C

lxl I I I lxlI
VY

ppqq + rr

A
X
y

Program

SP
PC

Memory

BE

mmmm

qq

mmmm + 1

pp

mmmm + 2
mmmm + 3

3 -72

Load
Load the
the contents
contents of
of the
the selected
selected memory
memory byte
byte into
into Index
Index Register
Register X.
X. Suppose
Suppose that
that In­
Index
-\q, ppqq
ig . then
dex Register
Register YY contains
contains 2Q
2815.
ppqq == 2E1
2E1A 15. and
and yy
yy == (2E42-|e)
(2E4215) == 4 F
4F15.
then after
after
the
the execution
execution of
of the
the instruction
instruction
LDX
LOX

$2E1
A,Y
$2E1A.Y

Index
q
Index Register
Register X
Xw
will contain
contain 4 F-|
4F15.
4F
4F ==

0 sets S to O

00 11 0 00 11111 11 1

L
Nonzero result
LNonzero
result sets
sets ZZ to
to 00

__J

373
3-73

LDY -— LOAD IN DEX
EX REGISTER
REGISTER Y FROM MEMORY
EM O R Y
LOY
contents of the selected
selected memory
memory byte into
into Index Register Y. The addressing
Load the contents
allowed are:
modes allowed
1)
Immediate -— LDY data
11 Immediate
2)
4)

Absolute (direct) -— LDY addr16
addr16
Absolute
Zero page (direct) -— LDY addr
Absolute indexed
indexed with
ith X -— LDY addr16.X
addr16.X
Absolute

5)

indexed with
ith X -— LDY addr.X
addr,X
Zero page indexed

3)

Note that
that there are no indexing
indexing modes with
ith Index Register
Register Y nor is there any pre-indexpre-indexing.
The first
first byte of object
addressing mode as follows:
follows:
obJect code selects the addressing
7

6 5 4 3 2

1 0 .--0,1

| 1|
0 | 1 | d | d | d | o| 0
~Ob1ec1

Bit Number

--------Object Code
Code

Bit Value
for ddd

Hexadecimal
Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
Number
of Bytes

000
001
010
011
100
101
101
110
111
111

A0
AO
A4
A8
AB
AC
B0
BO
B4
B8
BS
BC
BC

Immediate
Immediate
Zero page (direct)
Used forrT A
instruction
TAY instruction
Absolute
Absolute (direct)
Used for BCS
instruction
BCS instruction
ith X
Zero page indexed with
Used for CLV instruction
instruction
Absolute indexed with
ith X
Absolute

2
2
3
2
3

W e will
ill illustrate
ith immediate
mediate addressing. See the discussion
illustrate the LDY instruction
instruction with
discussion of
etic and logical instructions
instructions for examples of the
addressing methods and other arithm
anthmetic
other addressing modes.
modes.
Data
Data
Memory

SVBOIZC

plXI l l I IXj I

Al------1
•.._ __
--4
y l--'-yy'-----1

__ ___

SPl---~---•--PC '-...,._

Program
Memory
mmmm + 2

AO
yy

33-74

Load the contents
contents of the selected memory byte into Index Register Y.
Y. Suppose that
yy = 0015.
OO-i6- then after the execution
execution of the instruction
instruction
LDY
LOY # 0
Index Register Y will
ill contain
contain zero.
zero.
00 ==

0 0 00 00 00 000000

Lzero-Zero result sets Z to 1
U

0 sets S to O___J

0

3 -75

LSR
ULA TO R OR M EMORY
RY
LSR -— LOGICAL
LOGICAL SHIFT RIGHT OF A C CU MULATOR
This instruction
Accumulator
instruction performs a one-bit
one-bit logical right
right shift
shift of the Accum
ulator or the selected
memory byte.
First. consider shifting
First,
shifting the Accumulator.
Accumulator.

----LSR A
LSR
4A

Data
Cata

s VBDIZC
8 D I Z c

Memory

___
...__

Program

0

y
SPl-----4
PC

mm

Memory
Memory

.....,_
4A

mmmm
mmmm + 1

Shift the contents
contents of the Accum
ulator right
right one bit. Shift
hift the low-order
low-order bit into the Car­
Shift
Accumulator
Carry status. Shift
Shift a zero into the high-order
high-order bit.
Suppose the Accum
ulator contains
contains 7A15.
7A-|g. After
After the
Accumulator
LSR
LSR A
instruction is executed.
executed, the Accum
ulator will
ill contain 3 D16
i 6 and the Carry status will
ill be
instruction
Accumulator
zero.
set to zero.

Accumulator
Accum
ulator

Carry
Carry

-01111010-x
0 1 1 1 1 0 1 0 — ►X
0 ------

0 0 11111 1
01
1101

00

L

_j

LSR always sets S to O
LSR
0-«------ 1

'

sets Z to 0
■» Nonzero result sets

Four methods
methods of addressing data memory are available with
ith the LSR
instruction; they
LSR instruction:
are:
are:

1)
1)

LSR addr
Zero page (direct) -— LSR

21 Absolute
Absolute (direct)
(direct) —
- LSR
LSRaddr16
addr16
2)
3) Zero
Register
LSR addr.X
addr.X
- LSR
Zero page
pageindexed
indexedw ith
withIndex
Index
Register X—
4)

Absolute indexed with
ith Index Register X -— LSR
addr16,X
Absolute
LSR addr16.X

The first byte of object
object code determines
determines which
hich addressing mode is selected as follows:
follows:
7

6 5 4

3 2

11 00 ^-4--811

| 0|
1 | 0 | b | b | 1 1 1 |0
~Object

BitNumber
Number

----------Object Code
Code

3-76
3-

Bit Value
for bb

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

00
01
10
11
11

46
4E
56
5E

Zero page (direct)
Absolute
Absolute (direct)
ith X
Zero page indexed with
Absolute indexed with
ith X
Absolute

Number
Number
of Bytes
2

3

2
3

We will
ill illustrate
illustrate the LSR
instruction with
ith absolute
absolute (direct) addressing. The other adad­
LSR instruction
shown elsewhere.
dressing modes are shown
B D I Z C

0

A
X
Program

y
SP
PC

Memory
mm

mmmm + 3

mm

4E
qq

mmmm

PP

mmmm + 2
m
mmmm ♦+ 3

mmmm + l1

Logically shift
shift the
the contents
contents of the selected memory
Logically
memorylocation
location right one bit.

one bit.

Suppose that ppqq = 04FA-|g
04FA15 and
and the
the contents
contents of
of memory
memorylocation
location04FA-|6
04FA15are
are0D-|g.
0D15.
After the instruction
instruction
After
LSR
LSR $04FA
has been
contents of memory location
been executed,
executed. the Carry status will be
be 1 and the contents
04FA-|g will
ill be 06-|g.
04FA15
0615.
(04FAig)
(04FA15)

Carry
Carry

o

0 ------0 0 0 0 1 1 0 1-x
1--------- ►X
-000011

000
0 0 110
0000110

I
O___J

LSR
LSR always sets
sets S to 0-

33-77

L

11

I___ Nonzero result sets
sets Z to 0

NOP -— NO OPERATION
OPERATION
NOP
NOP
---.EA

This is a one-byte
one-byte instruction
instruction which
hich does nothing
nothing except
except increment
increment the Program
instruction allows
allows you to give a label to an object
object program
program byte.
byte, to fine
Counter. This instruction
instruction adds twoo clock cycles),
instruction
tune a delay (each NOP
NOP instruction
cycles). and to replace instruction
that are no longer needed because of corrections
corrections or changes. NOPs
bytes that
NOPs can also be
JSRs) which
used to replace instructions
instructions (such as JSRs)
which you may not want
ant to include
include in
debugging runs. NOP
frequently used in finished
finished programs.
programs, but it is often
debugging
NOP is not very frequently
debugging and testing.
useful in debugging
Data
Data
s v
B o
SVBDIZC

I

z c

Memory

I I I I I Im I I

pPL 1 —L..L1

J:I

==m=m==-m_m_.,~mmm

+

0

Program
Program
Memory

EA

mmmm
mmmm -i+ 1

3-78
3-

-LOGICALLY
ORA —
LOGICALLY OR MEMORY
MEMORY WITH
WITH ACCUMULATOR
ACCUMULATOR
ORs the contents of aa memory location w
with the
the contents
contents of
of
This instruction
instruction logically
logically ORs
the same
same memory addressing options
options as
as the
the
the Accumulator.
ulator. This instruction
instruction offers the
mode as
as follows:
follows:
ADC instruction.
instruction. The first byte of object code selects the addressing mode
7

6

5 4 3 2

.,__Bit
Number
11 0 ^
--------Bit Number

~Object
10 |
0 [ 0 1a 1 a | a | Q | '

Code
-------Obiect Code

Bit Value
for aaa
aaa

Hexadecimal
Object
Object Code

Addressing Mode
Addressing

Number
Number
of
of Bytes
Bytes

000
001
001
010
011
011
100
100
101
101
110
111
111

01
01
05
09
0D
OD
11
11
15
15
19
19
1D

Indirect. pre-indexed with X
X
Indirect,
(direct)
Zero page (direct)
Immediate
Absolute
(direct)
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with Y
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

22
2
2
3
22
22
3
3

ill illustrate
illustrate the ORA instruction
instruction using absolute indexed addressing with Index
We will
Index
discussion of addressing methods and other arithm
etic and logical
Register Y. See the discussion
arithmetic
logical
instructions for examples of the other addressing modes.
instructions
modes.
S V B 0

p

Data
Data
Memory

I Z C

Ixj I I I jxj I

VY

A
X

,x

y

rr

Program
Memory

SP
PC

ppqq + rr

mm

19
qq
pp

mmmm
mmmm + l
mmmm + 2

Logically OR the contents
contents of the Accum
ulator with
ith the contents
contents of the selected memory
Logically
Accumulator
byte, treating
treating both operands
operands as simple binary
binary data.
byte.
data.

3-79
3-79

Suppose that
that ppqq
ppqq =— 1623
1 g, rr
rr == 1015.
10-|g, xx
E3-|g, and
and yy
yy == AB15.
AB-|g. A
fter the
the execuexecu­
Suppose
162315.
xx== E315.
After
tion of
of the
the instruction
instruction
tion
ORA $1623.Y
$1623,Y
ORA
the Accum
ulator w
contain EB
g.
the
Accumulator
willill contain
EB15.
E3 =
E3
AB ==
AB

0 0 00 11 11
11 1 1100
11 0 11 0 11 0 1111
111
0 1 0 111
1110101

_J

L

_j

Sets S
S to
to 11

~onzero
Nonzero result
result sets
sets ZZ to
to 00

This is aa logical
logical instruction;
instruction; itit is often
often used to
to turn
turn bits
bits "o
n ", i.e
i.e.,
them Ts.
'1's. For
This
"on".
.. make them
example, the instruction
instruction
example.

ORA

#$
80
$80

will
ill unconditionally
unconditionally set the high-order
high-order bit
bit in the Accum
ulator to 1.
Accumulator
1.

3-8
0
3-80

PHA-— PUSH ACCUMULATOR
ACCUMULATOR ONTO STACK
instruction stores the contents
contents of the Accum
ulator on the top of the Stack. The
This instruction
Accumulator
Pointer is then decremented
decremented by 1. No other
other registers or statuses are affected.
Stack Pointer
that the A ccum
ulator is stored in the Stack before the Stack Pointer
Pointer is decredecre­
Note that
ccumulator
mented.

--PHA

48

Data
Memory

SVBDIZC

pl I I I I I I I
-------

A

Olss - 1

... .t-~,:-::,--to, ss

xx

X
Program

y
SP
PC

Memory

ss
mm

4B

mmmm
mmmm + 1

Suppose that the Accum
ulator contains 3 A
- | 0 and the Stack Pointer contains
contains F7-]gAccumulator
3A15
F715.
After
fter the instruction
instruction PHA has been executed, 3A15
3A-|6 will
ill have been stored in memory
- | 0 and the Stack Pointer will
ill be altered to F6615.
-|0
location O1 F
01F715
The PHA instruction
instruction is most frequently
frequently used to save
ulator contents
contents before ser­
save Accum
Accumulator
serinterrupt or calling a subroutine.
vicing an interrupt

3-8
1
3-81

-

--

--------

PHP
— PUSH STATUS
STATUS REGISTER
REGISTER (P)
(P) ONTO
ONTO STACK
STACK
PHP-PUSH
This instruction
instruction stores
stores the
the contents
contents of
of the
the Status
Status (Pl
(P) register
register on
on the
the top
top of
of the
the Stack.
Stack.
This
The Stack
Stack Pointer
Pointer is
is then
then decremented
decremented by
by 1.
1. No
No other
other registers
registers or
or statuses
statuses are
are affected.
affected.
The
Note that
that the
the Status
Status register
register is
is stored
stored in
in the
the Stack
Stack before
before the
the Stack
Stack Pointer
Pointer is
is decredecre­
Note
mented.
mented.
The organization
organization of
of the
the status
status in
in memory
memory is
is as
as follows:
follows:
The
------ Bit Number
77 66 55 44 33 Z2 11 00 ^
.,__B,t
Number

|SIV
I I B I D I I | z | c ( - < ---- Register P
~RegisterP
Bit 5 is not
not used and
and its
its value
value is
is arbitrary.
arbitrary.
Bit

---PHP
PHP

08

SVBOIZC

pl

I IIIIIt

js!v! !B!D!
1fzjct

Data

-------

A

x---◄

______
_

Program
Memory

y
SP t--::-:ss,---1--:~,,.

PC

.._

08

mmmm

mmmm + 1

The PHP
instruction is generally
generally used to save
contents of the Status register before
PHP instruction
save the contents
calling a subroutine.
subroutine. Note that PHP
PHP is not necessary before servicing
servicing an interrupt
interrupt since
the interrupt
interrupt response
instruction automatically
atically save
response (to IRQ
IRO or NMI)
NMI) and
and the BRK
BAK instruction
save the
the
contents of the
contents
the Status register at
at the
the top
top of the
the Stack.
Stack.

3-8
2
3-82

....

PLA
PLA-— PULL CONTENTS OF ACCUMULATOR FROM
FROM STACK
This instruction
instruction increments
increments the
ulator
the Stack Pointer by 1 and then loads the Accum
Accumulator
from the top of the Stack.
incremented before the
c­
Stack. Note that the Stack
Stack Pointer
Pointer is incremented
the Accumulator
ulator is loaded.
loaded.
PLA

PLA
--.-,

68
Data

Memory

SVBDIZC

PlxiI I I Ixi I
01ss

Olss + 1

--..Jt---yy---1

A

VY

X

Program

y
SP

ss

PC

mm

Memory

68

mmmm
mmmm-+-1

Suppose the Stack Pointer
Pointer contains
contains F6-|g
memory location
location 01F716
01F7-|g contains
contains CE-|6
F615 and memory
CE15.
After the instruction
instruction PLA has executed.
executed, the Accum
ulator will
ill contain
contain CE-|g
After
Accumulator
CE15 and the
Pointer will
ill contain
contain F7-|g.
Stack Pointer
F716·

_J

F7 =
=

L

1 11 11 1 0
101 1 1111

,__J

LNonzero
Z to
to 0
0
Nonzero result
result sets
sets Z

Set S to 1-«

The PLA
PLA instruction
is most
used to
to restore
restore Accum
Accumulator
have
The
instruction is
most frequently
frequently used
ulator contents
contents that
that have
been saved
saved on
the Stack:
been
on the
Stack: e.g
e.g.,.. after
after servicing
servicing an
an interrupt.
interrupt, or
or after
after completing
completing a
a
subroutine.
subroutine.

3 -83
83

PLP
(P) FROM STACK
PLP -— PULL
PULL CONTENTS
CONTENTS OF STATUS
STATUS REGISTER (P)
This
(P) register
This instruction
instruction increments
increments the
the Stack
Stack Pointer
Pointer by
by 1 and then
then loads the Status
Status (P)
from
from the
the top
top of
of the
the Stack.
Stack. No
No other
other registers
registers are affected
affected but
but all the statuses may be
changed.
changed. Note
Note that
that the
the Stack
Stack Pointer
Pointer is incremented
incremented before the Status
Status register is
loaded.
loaded.
PLP
.__,
28
The
The organization
organization of
of the status
status in memory
memory is as follows:
follows:
7 6 5 4 3 2 1 0 '4-B1t
Numbe•
-------- Bit Number
~Reg,sterP
|s |v
| |Bl d | I lz |c t< ^ —

Register P

Bit 55 is not
not used.
used.
Bit
Data
Data
S V B D I

Memory

Z C

Olss

---t-----t01ss

+1

~-----t

y
SP

Program
Memory

I--,,--+~"

PC...__m_m
______

~

28

mmmm
mmmm + l

The PLP
instruction is generally used to restore the contents
contents of the
PLP instruction
the Status
Status register after
alter
completing a subroutine.
subroutine. Thus, it serves
instruction mentioned
completing
serves to balance the PHP
PHP instruction
earlier. Note that PLP
after servicing an interrupt
interrupt since
PLP is not necessary
necessary alter
since the
the RTI
RTI instruc­
instrucatically restores the contents
contents of the Status register from
tion autom
automatically
from the
the top
top of the
the Stack.
Stack.

33-84

ROL -— ROTATE AC CU M
ULA TO R OR
OR M E M
O R Y LEFT
LEFT THROUGH
THROUGH
ROL
ACCUMULATOR
MEMORY
CARRY
CARRY
This instruction
instruction rotates
rotates the
the Accum
ulator or
or the selected
selected memory
memory byte
byte one bit
bit to the
the left
left
This
Accumulator
through the
the Carry.
through
First, consider
consider rotating
rotating the
the Accumulator.
Accumulator.
First.
ROL A
ROL
~

2A
Data
S V
B D
VBOIZC

y
SP.,_ __

I

Memory

Z C

Program
Prograrn

-1

Memory

PC..__m_m_...__m_m __

mmmm + l

....__

2A

mmmm
mmmm++ 1

Rotate the Accum
ulator's contents
contents left one bit through
through the Carry status.
Accumulator's
Suppose the Accumulator
Accum ulator contains
contains 7A-|g
7A15 and the Carry status is set to 1.
1. After
After the
ROL
ROL A
instruction is executed.
executed, the Accum
ulator will
ill contain
contain F57
F5-|g6 and the Carry status will
ill be
instruction
Accumulator
reset to zero.
zero.
Accum
ulator
Accumulator
0 1 11 111 0
1011 00
1 11 11 1 0
10 1
10101

_j

Set S tto 1 Set

J

IL_

Carry
Carry
11
00

sets Z to
to zero
zero
Nonzero result sets

The
instruction allows four
The ROL
ROL instruction
four methods
methods of addressing
addressing data memory; they
they are:
are:
1)
1) Zero page (direct)
(direct) -— ROL
ROL addr
2)
2) Absolute
Absolute (direct)
(direct) -— ROL
ROL addr16
addr16
3)
3)

Zero
ith Index
Zero page
page indexed
indexed w
with
Index Register
Register X
X—
- ROL
ROL addr.X
addr,X

4)
4)

Absolute indexed
Absolute
indexed w
with Index
Index Register
Register X -— ROL
ROL addr16,X
addr16,X

The
The first
first byte
byte of
of object
object code
code determines
determines w
which addressing
addressing mode
mode is
is selected
selected as
as follows:
follows:
77 66 55 44

3J 22 11 00 .,._

|g| °
| 1 1b[b11111~
~Ob1ectCod•

3-8
5
3-85

Bit
BotNumber
Number
Object Code

Bit Value
for bb

Hexadecimal
Object Code

Addressing Mode
Addressing

00
01
1
10
1
1
11

26
2E
36
3E

Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

00
01

Number
of Bytes
2
3
2
2
3

2

ROL instruction
We will
ill illustrate
illustrate the ROL
instruction with
ith zero page indexed addressing (using Index
X). The other addressing modes are shown elsewhere.
Register X).
Data
Memory

A

X

rr
Program

y
SP
PC

Memory

mm

mmmm + 2

mm

36
t--cc--t
----t

mmmm
mmmm ♦ 1
mmmm + 2

Rotate the selected memory byte left one bit through
through the Carry status. Suppose that
cc== 3415.
34-|g. rr = 16615., the contents
contents of memory location 0 04A
4 A i16 are 2E-|62E15. and the Carry
zero. After
status is zero.
fter executing
executing a
ROL
$34,X
ROL $34.X
instruction, memory location
location 004A15
004A-|g will
ill contain
contain 5C-|6
instruction.
5C15
(004A
ig)
(004A15)
0101110
001
0 110
0 10
1100
1011100

_J

O_J
Set S to 0-«

Carry
Carry

L

00

00

LNonzero
Nonzero result
result sets
sets ZZ to
to 00

3-86
3-

ROR
ULA TO R OR
R Y RIGHT,
ROR-— ROTATE
ROTATE A C CU M
ACCUMULATOR
OR M E M
MEMORY
RIGHT,
THROUGH
THROUGH CARRY
CARRY
This
instruction rotates
ulator or
This instruction
rotates the
the Accum
Accumulator
or the
the selected
selected memory
memory byte
byte one
one bit
bit to
to the
the
right through
through the
the Carry.
Carry.
right

First consider
consider rotating
rotating the
the Accumulator.
First
Accumulator.
ROR
ROR A
A
.._.,-,
6A
Data
Data
Memory

O II 2Z cC
S V 8B D

V

___
.._

Program
Program
Memory

SPl-----t
PC

___
mm

___

mmmm + 1

6A

mmmm
mmmm + 11

Rotate the Accum
ulator's contents
contents right
right one bit through
through the Carry status. Suppose that
Accumulator's
the Accum
ulator contains
contains 7A15
7A-|g and the Carry status
status is
Execution of the
Accumulator
Is set to 1.
1. Execution
ROR
ROR A
instruction will
ill produce
produce these results: the Accum
ulator will
ill contain
contain 8D15
BD-)6 and the Car­
instruction
Accumulator
Carry status
status will
ill be 0.
Accum
ulator
Accumulator
0 1 1 11 1 0
101 1 0
101
0 1 1 11 1 0
101 1

Set S to, 1

_J

L

_._j

Carry
11
00

LNonzero
sets Z
to 0
Nonzero result
result sets
Z to
0

The
The ROR
ROR instruction
instruction allows
allows four
four methods
methods of
of addressing
addressing data
data memory;
memory: they
they are:
are:
2)
2)

1)
1)

Zero
ROR addr
Zero page
page (directl
(direct) -— ROR
addr
Absolute
Absolute (direct)
(direct) -— ROL
ROL addr16
addr16

3)
3)
4)
4)

Zero
with
ROR addr,X
Zero page
page indexed
indexed w
ith Index
Index Register
Register X
X -— ROR
addr.X
Absolute
with
ROR addr16,X
Absolute indexed
indexed w
ith Index
Index Register
Register X
X -— ROR
addr16,X

The
which
The first
first byte
byte of
of object
object code
code determines
determines w
hich addressing
addressing mode
mode is
is selected
selected as
as follows:
follows:
77 66 55 44 33 22 11 00 ......_B,t
Number
^
Bil Number

~Ob1ec1Code
i o] 1 I 1
I b I b | 1 I 1 | o h ^ --------Object Code

387
3-87

Bit Value
for bb

Hexadecimal
Hexadecimal
Object Code
Object

Addressing Mode
Addressing

00
01
10
11
11

66
6E
76
7E

Zero page (direct)
Absolute (direct)
Absolute
ith X
Zero page indexed with
Absolute indexed with
ith X
Absolute

Number
Number
of Bytes
2

3
2
3

We will
ill illustrate
illustrate the ROR
instruction with
ith absolute
absolute indexed addressing (using Index
ROR instruction
Register X).
X). The other
other addressing
shown elsewhere.
addressing modes are shown

y
SP ___

-4

PC"-_m_m_ ..... _m_m
__

___

mmmm + 3

Suppose that rr = 14-|q.
0 ig , the contents
contents of memory location 0 1 1
4 1 g are
1415. ppqq = 0 1 0
0015.
1415
are
ED-|6executing a:
ED15. and the Carry status is 1.
1. Afterr executing
a:
ROR
S0100.X
ROR $0100.X
instruction, the Carry status will
ill be 1 and memory location 011415
0114-|g will
ill contain
contain F6-]g.
instruction.
F615.
(011415)
-] g)

Carry
Carry

1 11 1 0
1011 1 0
1011
1 11 11 1 0
1011 1100

__J
_J

11
11

L

Set S to 1

LNonzero
Nonzero result
result sets
sets ZZ to
to 00

33-88
-88

RTI-— RETURN FROM INTERRUPT
Status (P)
register and the Program Counter
Counter off
off the top of the Stack. The
Pull the Status
(P) register
registers and the corresponding
corresponding memory locations
locations from which
which they
they are loaded are as
registers
follows, assuming
assuming that
that the Stack Pointer
Pointer contains
contains ss at the start
start of instruction
instruction execuexecu­
follows.
tion:
Memory Location
Location
Memory

Register

01ss+1
ss+1
01 ss+2
01ss+3
01ss+3

Status (P)
register
Status
(P) register
Counter
Low byte of Program Counter
Counter
High byte of Program Counter

The final
final value of the Stack Pointer
Pointer is its initial
initial value plus 3. The old values of the Status
register and Program Counter
Counter are lost.
register
lost.

RTI

--,-,
40
S V B

Z C

jsjvj jejojI jzjcl

Data
Memory
01ss
ss
01ss
ss + 1

qq
pp

A
X
y
SP
PC

01ss
ss + 2
01ss
ss + 3

Program
Program

ss
mm

Memory

mm

40

mmmm

Suppose that the Stack Pointer contains
contains E8-|g,
16.
E815. memory location 01E9-|
01E916g contains C 115.
memory location
location 01
EAi g contains
contains 3E-|g,
EB-| 6 contains
contains D5-|6
01EA15
3E15. and memory location 01
01EB15
0515.
After the instruction
instruction RTI
ill contain
contain Cl
C1 115.
6, the
After
RTI has
has been
been executed,
executed. the Status register will
Stack Poin!er
Pointer will
ill contain EB-|g.
Counter will
ill contain D53E-|g
EB15. and the Program Counter
D53E15 (this is
the address from which
which instruction
instruction execution
execution will proceed).
proceed). The statuses will be as
as
follows:
sSV v
b
d i z c
BDIZC
C1
|0 | 0 | 1 |
Cl== |1 |1 | 0 | 0 |0
j,j,jojojojojoj1I
Note that the Interrupt
Interrupt Mask bit will be set or reset depending
depending on its value at
at the time
the Status register was stored,
interrupt service routine did not
stored. assuming that the
the interrupt
change it while
hile it was
was on the
the Stack.
Stack.

3 -89

RTS -— RETURN
FROM SUBROUTINE
RETURN FROM
This
This instruction
instruction fetches
fetches a new
new Program
Program Counter
Counter value
value from
from the
the top
top of
of the
the Stack
Stack and inin­
crements itit before
before using
using itit to fetch
fetch an instruction.
instruction. Note
Note that
that the Stack
Stack Pointer
Pointer is
is increincre­
crements
mented before
before the
the loading
loading of
of each data
data byte
byte and its
its final
final value
value is thus
thus two
two greater
greater than
than
mented
initial value. ATS
RTS is normally
normally used at
at the
the end of
of a subroutine
subroutine to restore the return
return adad­
its initial
that was
was saved in the Stack
Stack by a JSR instruction.
instruction. Remember
Remember that
that the return
return adad­
dress that
actually the address of
of the third
third byte
byte of
of the JSR instruction
instruction itself;
itself:
dress saved by JSR is actually
hence, RTS
RTS must
must increment
increm ent that
that address
address before
before using
using it to resume
resume the main
main program.
hence.
The
The previous
previous contents
contents of
of the Program
Program Counter
Counter are lost. Every subroutine
subroutine must
must contain
contain
instruction.
at least one RTS instruction.
Data

S V

Pl

B 0

I

z C

Memory

I I IIIII

qq

PP

Olss
Olss + 1
01ss + 2

A
X

Program

V
SP

PC

Memory

ss
ppqq + 1

,60

mmmm

RTS
--..-60

No statuses are altered by an RTS
instruction.
RTS instruction.
Suppose that the Stack Pointer
Pointer contains
contains DF-|g,
location 01E0-|g
DF15. memory location
01E016 contains
08-]
5 , and memory location 0 1E115
E1 1 g contains
contains 7C15.
ig . After
After the instruction
instruction RTS
0815.
RTS has
has been
been
executed,
ill contain
contain E1
ig and the
Counter will
ill contain
executed. the
the Stack Pointer will
E115
the Program Counter
7C09-|g
which instruction
instruction execution
execution will proceed).
7C0916 (this is
is the
the address from
from which
proceed).

3-90
3-

SBC -— SUBTRACT M E MORY
O R Y FROM A C CU M
ULA TO R WITH
MULATOR
BORROW
Subtract the contents
contents of the
complement of the
Subtract
the selected memory byte and the complement
the Carry
status (i.e
(i.e.... 1 -— C)
contents of the
ulator. This instruction
instruction offers the
C) from
from the contents
the Accumulator.
the
same
instruction. The first
same memory addressing options as
as does
does the ADC instruction.
first byte of object
code selects the addressing mode as
as follows:
77 66 55 44 33 2 2 1 10 0 ^
~Bit

Bit Number

I l
M l H
~Ob1ect

Object Code
Code

. H

o

h

U

Bit Value
for aaa
aaa

Hexadecimal
Object Code

Addressing Mode
Addressing

Number
of Bytes

000
001
001
010
011
011
100
101
101
110
111
111

E1
E1
E5
E5
E9
E9
ED
ED
F1
F1
F5
F5
F9
F9
FD
FD

Indirect,
ith X
Indirect. pre-indexed with
Zero page (direct)
Immediate
Absolute (direct)
Absolute
(direct)
Indirect, post-indexed
post-indexed with
ith Y
Indirect.
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

2
2
2
3
2
2
3
3

ill illustrate
illustrate the SBC
instruction using pre-indexed
pre-indexed indirect
indirect addressing (via
We will
SBC instruction
(via Index
Register X).
arithm etic and logical
X). See the discussion
discussion of addressing methods and other arithmetic
instructions for examples of the other addressing modes.
instructions
modes.
Data
Data

Memory

SVBDIZC

PP

OOrr + cc
00rr+cc+1

VY

PPQQ

QQ

)C)(

A

xx

X
y

rr

-

VY -

C

Program
Memory

SP
PC

mm

mm

mmmm + 2

E1
cc

mmmm

mmmm + 1
mmmm + 2

Subtract the contents
contents of the selected memory
memory byte and the complement
complement of the Carry
Subtract
C). from the Accum
ulator, treating
treating all register
register contents
contents as simple
simple binary
status (1 -— Cl.
Accumulator.
data. Note.
Note, however.
however, that
that all data will
ill be treated as decimal
decimal (BCD)
(BCD) if the D status is set.

39
3-91

Suppose that
that xx
ig cc
1 g- rr =
= 37
-|g, ppqq
ppqq == 07E215,
07E2-|g, yy
yy == (07E2
1 g) = 3415,
34-|g,
Suppose
xx== 1 4
1415,
cc== 15
1515,
3715,
(07E215)=
and C
C = 0.
0. A
fter executing
executing a
and
After

SBC
SBC

($15,X)

instruction, the
the contents
contents of
of the
the Accum
ulator would
would be altered
altered to DF15.
DF-|g.
instruction,
Accumulator
Twos complement
complement of
Twos

14 = 0
0010100
14=00010100
35 = 1 1 0 0 1 0 1 1
0 1 1 111111
1 101

Set Carry to 0
o~LNonzero
Set S to 1

(see note below)

result sets Z to 0
..._
0O-V-O
-¥-0 - 0, set V to 0

(yy+C):
Note: xx -— yy -— (1 - C) = xx -— (yy+C);
-|g - 3415
34-|g - (1 - 0) = 1 4
ig - (3415
(34-|g + 1) = 14
1 g - 3515
35-|6
hence, 14
1415
415
1415
that the resulting
resulting Carry is not a borrow. It is, rather, the inverse of a borrow
borrow since it
Note that
borrow is required
required and cleared if a borrow
borrow is required. You should be
is set to 1 iiif no borrow
careful of this usage since it differs
differs from that
that of most other
other microprocessors.
microprocessors, which
which
careful
complement the Carry before it is stored follow
ing a subtraction.
subtraction.
complement
following
SBC is the only binary
binary subtraction
subtraction instruction
instruction. To use it in single-byte
single-byte operations
operations or to
subtract the low-order
low-order bytes of twoo multibyte
ultibyte numbers, a previous
previous instruction
instruction (SEC)
subtract
(SEC)
explicitly set C to 1 so that
that it does not affect
affect the operation.
operation. Remember that C must
must explicitly
be set (not cleared) before a subtraction
subtraction since its meaning
meaning is
inverted from the usual
Is inverted
6502 microprocessor,
microprocessor, unlike
unlike most others, has no subtraction
subtraction
borrow. Note also that the 6502
in s tru
c tio n that
that does not include
include the Carry.
✓
nstruction
Carry.

33-92

SEC -— SET CARRY
SEC
SEC
--.,-38
Set the Carry status to 1. No other status or register's
register's contents
contents are affected. Note that
instruction is required
required as part of a normal subtraction
subtraction operation
operation since the only
this instruction
subtraction
instruction available
available on the 6502
microprocessor is SBC,
subtraction instruction
6502 microprocessor
SBC, which
which also
subtracts the complemented
complemented Carry status. This instruction
instruction is also required at the start
start of
subtracts
a multi-byte
ulti-byte subtraction
subtraction since there is never a borrow
borrow from the least significant
significant byte.
Data

s v
a d i z c
SVBDIZC

Memory

PlI I I I I 111

Program
Memory
Memory

3B

mmmm

mmmm + 1

3 -93
3

SED
DECIMAL
SED -— SET
SET D ECIM
AL MODE
MODE

--SED
SED

F8
F8

Set
Set the
the Decimal
Decimal Mode
Mode status
status to
to 1.
1. No
No other
other status
status or
or register's
register's contents
contents are affected.
affected.
This
This instruction
instruction is
is used
used to
to place
place the
the 6502
6502 processor
processor in
in the
the decimal
decimal mode
mode in which
hich ADC
and
and SBC
SBC instructions
instructions produce
produce BCD
BCD rather
rather than
than binary
binary results.
results. The programmer
programmer should
should
be
willill produce
be careful
careful of
of the
the fact
fact that
that the
the same
same program
program w
produce different
different results.
results, depending
depending
on
on the
the state
state of
of the
the Decimal
Decimal Mode
Mode status.
status. This
This can
can lead
lead to puzzling
puzzling and seemingly
seemingly ranran­
dom
dom errors
errors ifif the
the state
state of
of the
the Decimal
Decimal Mode
Mode status
status is not
not carefully
carefully monitored.
monitored.
Data
Memory

SVBDIZC
p

I I I 111I I I

Program

Memory
mm

F8

3-94

mmmm
mmmm + l1

SEI -— SET INTERRUPT M ASK (DISABLE
(DISABLE INTERRUPTS)
INTERRUPTS)

-SE!
SEI
78

Set the interrupt
interinterrupt mask in the Status register. This instruction
instruction disables the 6502's
6502's inter­
rupt
line.
rupt service ability.
ability, i.e., the 6502
6502 will
ill not respond to the Interrupt
Interrupt Request control
control line.
No other
Interrupt Mask is bit 2 of the Status (P)
(P)
other registers or statuses are affected. The Interrupt
register.
Dala
D
ata
M em ory

S
s Vv B
b D
o I Z C
p

I I I I I 1l I I

Program

Memory
Memory

__

33-95

mmmm

78_-t::::::

•

mmmm♦ 1

-----------------------STA-— STORE
ULA TO R IN M E MORY
ORY
STORE ACCU MULATOR
contents of the A ccum
ulator into
into the specified
specified memory
memory location. This instrucinstruc­
Store the contents
ccumulator
memory addressing modes as the ADC instruction.
instruction, with
ith the excepexcep­
tion offers the same memory
that an immediate
mediate addressing
addressing mode is not available. The first
first byte of object
object code
tion that
addressing mode as follows:
follows:
selects the addressing
7 6 5 4 3 2 1 0 ^
'4--8,t
[jJ^££oJ^aJ^aJ^aJ^O ^J ^
~Object

Bit Number
Number
Object Code
Code

Number
Number
of Bytes

Bit Value
for aaa
aaa

Hexadecimal
Hexadecimal
Object Code
Object

Addressing Mode
Addressing

000
001
010
011
100
101
101
110
111
111

81
B1
85
B5
89
B9
8D
BD
91
95
99
9D

Indirect, pre-indexed
pre-indexed with
ith X
Indirect.
Zero page (direct)
Not used
Absolute (direct)
Absolute
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

2
2
3
2
2
3
3

We will
ill illustrate
illustrate the STA instruction
instruction with
ith zero page direct
direct addressing. See the discusdiscus­
sion of addressing methods and other arithmetic
arithm etic and logical instructions
instructions for examples
of the other addressing modes.
modes. No statuses are affected.
Data

Memory

SVBDIZC

p

I II I IIII
__

A L-_-.;;_xx _

_.~

XL----1
YL-

__

Program

_.

Memory

SP~------•~--./-,
PC

mm

--1;..►t::.2••~:j OOqq

mm

~ mmmm+2
85
mmmm
1-.....;.qq"----4 mmmm + 1
1----1

mmmm + 2

Store the contents
the Accum
Accumulator
6315 and
Store
contents of the
ulator in memory. Suppose that xx== 63-|6
qq = 3 A
-|6 - After
fter the instruction
instruction
3A15.
STA

$3A

has
executed, the
the contents
contents of
of memory
memory location
location 003A15
003A-|6 will
will be
be 63
1 0 . No registers
has been
been executed.
6315.
registers
or statuses
statuses are
affected.
or
are affected.

33-96

STORE IN DEX REGISTER
REGISTER X IN M EMORY
STX -— STORE
location. The
The addressing
addressing
Store the contents
contents of Index Register X in the selected memory location.
are:
modes allowed are:
1)
1)

STX addr
Zero page (direct) -— STX

2)

Absolute
STX addr16
Absolute (direct) -— STX

3)

STX addr.Y
Zero page indexed with
ith Y -— STX

Register X.
X. There
There is
is also
also no
no absolute
absolute
Note that there are no indexed modes using Index Register
mode. STX and LDX are the only instructions
use the
the zero
zero page
page indexed
indexed
indexed mode.
instructions that use
Y. No statuses are affected.
mode with
ith Index Register Y.
The first
as follows:
first byte of object
object code selects the addressing mode as
7

6 5 4

3 2

1 0 ^
~B,t

| l |
0 | 0 [ b | b [ l | 1| 0
~Object

Bit Number
Number

--------Object Code
Code

Bit Value
for bb

Hexadecimal
Object Code

Addressing Mode

00
01
10
11

86
B6
8E
BE
96
9E

Zero page
page (direct)
(direct)
Absolute (direct)
(direct)
Zero page indexed w ith Y
Not used
used

Number
of Bytes
Bytes
2
3
2

We will
ill illustrate
illustrate the STX instruction
instruction using zero page indexed addressing with Index
Index
discussion of addressing methods and other arithmetic
etic and
Register Y. See the discussion
and logical
instructions for examples of the other addressing modes.
instructions
modes.
Data
Da1a

S V B D I Z C

Memory

Pj I I I I I I I

VY

A
X

y

VY
rr

SP
PC

mm

OOrr + cc

Program
Memory

96
cc

mmmm

mmmm + 1
mmmm + 2

Store the
the contents
contents of Index Register X in the selected memory byte. Suppose that
Store
cc
1 6- rr = 2016,
2016- and
ar|d yy = E9l6fter executing
executing the
cc== 2 8
B16,
E916· After
STX

$28,Y
$28,Y

instruction, memory
memory location
location 004815
0048-|g will
ill contain
contain E915.
1 6- No registers or statuses are
instruction.
affected.
affected.

3-97

EX REGISTER Y IN M E M
ORY
STY -— STORE IN DEX
EMORY
contents of Index Register
Register Y in the selected
selected memory
memory location.
location. The addressing
addressing
Store the contents
allowed are:
modes allowed
1)

Zero page (direct) -— STY addr

2)

Absolute
Absolute (direct) -— STY addr16
addr16
indexed with
ith X -— STY addr.X
Zero page indexed

3)

Note that there are no indexed
indexed modes using Index Register Y. There is also no absolute
absolute
indexed mode. No statuses
statuses or registers are affected.
indexed
The first byte of object
object code selects the addressing
addressing mode as follows:
follows:
7

6

5 4 3 2 1 0 ^
,.___B,t Bit Number
Number

I 1|
0 1 Q| b | b | 1 | o | o t ^
~Object

--------Object Code
Code

Bit Value
for bb

Hexadecimal
Hexadecimal
Object Code
Object

Addressing
Addressing Mode

00
01
01
10
11
11

84
8C
BC
94
9C

Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Not used

Number
Number
of Bytes
2
3
2

We will
ill illustrate
illustrate the STY instruction
instruction with
ith absolute
absolute direct
direct addressing. See the discusdiscus­
sion of addressing
methods and other
other arithmetic
addressing methods
arithm etic and logical instructions
instructions for examples
of the other addressing
addressing modes.
modes.
Data
Data
Memory

SVBOIZC

Pl I I I I I I I
----.=--1-___!.YY:.__....Jppqq

A

.___ _.

X

y l--yy--l-~-

Program
Memorv

SPl---4-----.,_.,,,.

PC

mm

mm

I~

mmmm + 3

.,__B""C"--f mmmm
1---'-qq'---J

mmmm ♦ 1

1--'-P;_P --.J

mmmm + 2

t----l

mmmm + 3

the contents
the selected
selected memory byte. Suppose that
that
Store the
contents of Index Register Y in the
yy
1 6 and
VY= 0 115
and ppqq = 08F3i@.
08F316· A
Afterr the
the
STY
STY

$08F3

instruction has
3 i6 w
contain 01
ig No registers or
instruction
has executed,
executed. memory location
location 0 8 F
F315
will contain
0115.
statuses
statuses are affected.
affected.

I

3-98
3-

j

I

!
I

T AX -— M OVE FROM ACCU MULATOR
TO R TO IN DEX REGISTER
REGISTER X

_.,-,
AA

contents of the Accum
ulator to Index Register X. Set the Sign and Zero
Move the contents
Accumulator
statuses accordingly
accordingly.
I

I
I

TAX

S V B D
O

I

Data
Memory

Z C

I
I
I

I

I

PlxlI I I pqI
p i» i i i i i * n

I
l

A
X
X

xx

PC

-:--_,

___ ...
_.

Y
Y.,_ __
SP.,_ __
SP

mm

Program
Memory

-,1

.....,__

~_..

mm

r

mmmm + 1
mmmm
m mmm + 1

Suppose that xx = 00-|6
fter executing
executing the TAX instruction.
instruction, both the Accum
ulator
0015. After
Accumulator
and Index Register X will
ill contain
contain OOtg.
0015.
000
0 000
0000000

O__J

Set S to 0-*-------^

^LZero
"Z e ro result sets Z to 1

The follow
ing instruction
instruction sequence will
ill restore the contents
contents of Index Register X from
following
the Stack after
after completion
completion of a subroutine
subroutine or interrupt
interrupt service routine:
PLA
TAX

;GET
;GETOLD
OLD XX REGISTER
REGISTERFROM
FROMSTACK
STACK
: RESTORE
;RESTORETO
TO XX REGISTER
REGISTER

I

I

3 -99
9

TAY —
MOVE FROM
TAY-MOVE
FROMACCUMULATOR
ACCUMULATOR TO
TOINDEX
INDEX REGISTER
REGISTERYY

--

TAY
TAY
A8
AB

Move
ulator toto Index
Move the
the contents
contents ofof the
the Accum
Accumulator
Index Register
Register Y.Y. Set
Set the
the Sign
Sign and
and Zero
Zero
statusesaccordingly.
accordingly.
statuses
SSVBDIZC
V B D

Data
Data
I

Z C

Memory

[xJ1l I I I l I XIx
T I1 l

P
p<xi

A

xx
XX

X

.>

y

SP
PC

mmm
m

Program
Program
Memory
Memory

mm

AB

mmmm
mmmm
mmmm
mmmm ++ 1t

Suppose that
F1 115.
@ After
fter executing
executing the
instruction, both the Accum
ulator
that xx== Fl
the TAY instruction.
Accumulator
F115.
and Index Register Y will
ill contain
contain F1
-|g.

-J

111
1110
001
10001

Set
to 1-<
1__J
Set S
S to

L

Nonzero result
result sets
LNonzero
sets Z
Z to
to 00

ing instruction
instruction sequence
sequence will
ill restore the contents
contents of Index Register Y from
The follow
following
the Stack after
after completion
completion of a subroutine
subroutine or interrupt
interrupt service
service routine:
routine:

PLA
TAY
TAY

;GET
:GET OLD
OLD YY REGISTER
REGISTERFROM
FROM STACK
STACK
:RESTORETO
TOYY REGISTER
REGISTER
;RESTORE

3100
3-100

TSX -— M OVE FROM STACK POINTER TO INDEX REGISTER
REGISTER X

---TSX
BA

contents of the Stack Pointer
Pointer to Index Register X. Set the Sign and Zero
Move the contents
accordingly. Note that
that TSX is the only 6502
6502 instruction
instruction that
that allows you to acac­
statuses accordingly.
cess the value in the Stack Pointer. A typical
typical instruction
instruction sequence that
that saves the value
Pointer in memory
memory location
location TEMP is:
of the Stack Pointer
TSX
STX

TEMP
TEMP

;MOVE
:MOVE STACK
STACK POINTER
POINTERTO X
;SAVE
:SAVE STACK
STACK POINTER
POINTER IN MEMORY
MEMORY
I

Data
Data
S V
B D
VBDIZC

I Z C

Memory

Pjxj
I I NI
JxJI
p
l
*l IMI

Program
Memory

BA
----4

mmmm
m mmm+
mm+ 1

If,
contains ED-|g,
executing the TSX
instruction,
If, for example,
example. the Stack Pointer contains
ED15. after executing
TSX instruction,
both the Stack Pointer and Index Register X will
ill contain
contain EDi
g.
ED15.

L

111
0 110
1101
1011

,__J

Set
Set S to 1-

LNonzero
to 0
Nonzero result sets Z to

3-1
3-101

_

T XA- — M OVE FROM IN DEX REGISTER
TO ACCU MULATOR
TO R
REGISTER XTO

_,

TXA
8A
SA

contents of Index Register X to the Accum
ulator and set the Sign and Zero
Move the contents
Accumulator
statuses accordingly.
following
accordingly. The follow
ing instruction
instruction sequence will
ill save the contents
contents of InIn­
execution of a subroutine
subroutine or interrupt
interrupt service routine:
routine:
dex Register X in the Stack before execution

TXA
PHA

;MOVE
;MOVE XX REGISTER
REGISTERTO
TO ACCUMULATOR
ACCUMULATOR
;SAVE
;SAVE XX REGISTER
REGISTERIN
IN STACK
STACK
Data

VBOIZC
S V
B O

i

Z C

Memory

xl l l I IxlO I

’PlE O T

A
X

rr

~

y

Program

SP
PC

Memory

~

mm

mm

r~mmmm+1
8A

mmmm
mmmm
mmmm + 1

Suppose that rr = 3B-|
g. After
fter executing
executing the TXA instruction.
instruction, both Index Register X and
3816·
the
ulator will
ill contain
B i0 .
the Accum
Accumulator
contain 3815.

L

1101
0 00 111 1
0 1 11
Set
Set S to 0O__J

LNonzero
sets Z to 0
Nonzero result sets

3-102
3-1

T
X S -— M O
VE FROM
FROM IN D
EX REGISTER
REGISTER XTO
TO STACK
STACK POINTER
POINTER
TXS
MOVE
INDEX
TXS
TXS
'-v-'

9A
9A
Move the
the contents
contents of
of Index
Index Register
Register X to the Stack
Stack Pointer.
Pointer No
No other
other registers
registers or
Move
statuses are affected.
affected. Note
Note that
that TXS is
is the
the only
only 6502
6502 instruction
instruction that
that allows
allows you to
statuses
determine the value
value in the
the Stack
Stack Pointer. A typical
typical instruction
instruction sequence
sequence that
that loads the
determine
Stack Pointer
Pointer with
ith the value
value LAST is:
Stack
LDX
LOX
TXS

#LAST
#LAST

;GET
:GET LOCATION OF STACK ON PAGE 1
;PLACE STARTING LOCATION IN STACK POINTER
:PLACE
POINTER

that TXS does not
not affect
affect any statuses.
statuses, unlike
unlike TSX which
hich affects
affects the Zero and Sign
Note that
statuses.
Data
Data

z c

SVBDIZC

Memory

pC
I I I I I IE IDf

p

A
x ___

PC

..,.

______
_

y
5pt----t.....-

.._

Program

Memory
mmmm + 1

9A

mmmm
mmmm
mmmm
mmmm + 1

Suppose that rr =
— F2-]
g After
fter executing
executing the TXS InstructIon.
instruction, both Index Register X and
F216·
the Stack Pointer will
ill contain
contain F215.
1 q, making 0 1 F
2 ig the
current Stack location. No
F216
the current
statuses or other registers are
are affected.

3-1
3-103

--

TVA-— MOVE
MOVE FROM
FROM INDEX REGISTER
REGISTER Y TO ACCUMULATOR
TYA

--TYA
98

to the A ccumulator
and set
set the Sign
Sign and
and Zero
Zero
Move the contents
contents of Index Register Y to
ulator and
save the
the contents
contents of
of In­
Instatuses accordingly.
accordingly. The following
ing instruction
instruction sequence will save
subroutine or interrupt
service routine:
routine:
dex Register Y in the Stack before execution of a subroutine
interrupt service
TYA
PHA
PHA

;MOVE Y REGISTER
REGISTERTO ACCUMULATOR
ACCUMULATOR
;MOVE
REGISTERIN STACK
STACK
;SAVE Y REGISTER
Data
Data

VBDIZC
S v
B D

I

~
Memory

Z C

~rm
I II
lXl I

pfxI
p
een

A
X
y

rr

SP
PC

mm

~
b
mm

Program
Memory

r

mmmm + 1

9B

mmmm
mmmm
m
mmmm ++ 11

Suppose that
that rr =
i g. After
fter executing
executing the TYA instruction.
instruction, both Index Register Y and
= A F16·
and
ulator will
ill contain
contain AF-|g.
the Accum
Accumulator
AF15.
1 00 1 00 1 111111

L
Nonzero result sets Z to 0
LNonzero

,___J

Set S to 1-

3-104
3-104

6800
/6 5 0 2 COMPATIBILITY
COMPATIBILITY
800/6502
6502 microprocessor can certainly
certainly be used on its
Although the 6502
6800/6602
6800/6502
important characteristics
characteristics is its
own merits, one of its important
SIMILARITY
SIMILARITY
similarity
ilarity to the widely
idely used 6800
6800 microprocessor.
microprocessor. This
similarity
ilarity is not sufficient
sufficient to allow programs written
ritte n for one of these processors
processors at
level to be run on the other, but it is sufficient
sufficient so that propro­
the machine or assembly level
grammers
grammers can easily move from one CPU
CPU to the other. Most
Most of the external
external support
support
devices designed
designed for one of these processors can also be used with
ith the other. Chapters
troduction
icrocomputers:
Volumee 2 —
-Some
Real
9 and 10 of An In tro d
u ctio n to M icrocom
puters: Volum
Some Real
Microprocessors discuss this hardware com
patibility in more detail.
Microprocessors
compatibility
W e will
ill briefly
briefly describe and compare the 6800
6800 and 6502
6502 microprocessors
microprocessors with
ith regard
registers. statuses,
statuses. addressing modes,
modes. and instruction
sets. You should note
to their
their registers,
instruction sets.
that the two processors are far from mirror images,
that
images. but they are much closer to each
either is to an 8080,
description
other than either
8080. Z80,
Z80. F8,
F8. or 2650 microprocessor. This description
should give you some idea as to what
hat problems you would
would encounter
encounter in going from one
CPU
CPU to the other.

As for registers, both the 6800
6800 and the 6502
6502 have an 8-bit
-b it pri­
pri6800/6602
6800/6502
mary Accumulator
Accumulator (A register) and a 16-bit
16-bit Program
Program Counter
REGISTER
REGISTER
(or PC register). The other registers, however,
however, are slightly
COMPARISON
COMPARISON
Accumulator
register). a
different. The 6800 has a second 8-bitit Accum
ulator (B register),
16-bit
register. and a 16-bit
6502. on the other hand,
hand. has two
16-bit Index register,
16-bit Stack Pointer. The 6502,
8-bitit Index registers and an 8-bitit Stack Pointer. Thus the 6502 Index registers cannot
hold a complete
complete 16-bit
16-bit memory address while
hile the 6800 Index register can. Furthermore
the 6800's
6800's RAM Stack can be located anywhere
anywhere in memory because of its 16-bit
16-bit Stack
Pointer while
1.
hile the 6502's
6502's RAM Stack is always located on page 1.
6800/6502
6800/6602
flow,, Sign, andjn.terrupt
Interrupt Mask statuses. The difference in the
STATUS
Carry status is that the 6800
6800 and 6602
6502 version of this flag
COMPARISON
COMPARISON
have opposite meanings after
after subtraction operations.
operations. The
6800 Carry is set to 1 if a borrow is necessary and to 0 otherwise;
otherwise; the 6502 Carry is set
to 0 if a borrow is necessary
necessary and to 1 otherwise. This difference
difference means that,
that. before a
multi-byte
ulti-byte subtraction
subtraction operation.
operation, the programmer
programmer must clear the Carry on
on the 6800 and
set the
6800 and 6602
6502 also differ in how they perform
perform
the Carry on
on the 6502. The 6800
decimal arithmetic;
etic; the 6800 has
hile the 6502
has a Half-Carry flag (or
(or carry from bit 3)
3) while
has
6502 also has
has a Decimal Mode flag
flag. The 6602
has a Break flag which is not present in
in the
6800; it is not necessary in the 6800 because the 6800 Trap or Software Interrupt
Interrupt in­
6800;
instruction
response.
struction is automatically
atically vectored separately from the regular interrupt
interrupt response.
As for statuses,
6800 and 6602
6502 have identical Zero, OverOver­
statuses. the 6800

The 6502
6502 microprocessor
microprocessor has many more
more addressing
addressing modes
modes
6800/6602
6800/6502
than does
6800. This is partly necessitated by the fact that
that
does the 6800.
ADDRESSING
the 6502 index registers are
are only 8 bits long.
long. Table 3-7
3-7 compares
MODE
on the
the tw
two processors.
processors. The 6800
COMPARISON
the addressing modes available on
microprocessor has
indirect modes,
combinations of
microprocessor
has no indirect
modes. no combinations
of index­
indexing and
indirection, and no absolute indexed modes.
and indirection.
modes. There are
are also
also some
some other
differences
terms of which
modes are
are available with particular
differences in terms
hich modes
particular instructions;
instructions; we will
not discuss
discuss those differences,
differences. but they
they are
are enumerated
enumerated in Table 3-6.
3-6.

3-105
3-1

Table

3-7. M emory
ory

A d d re
ssin g Modes
odes A v a
ila b le
ressing
Available
Microprocessors

on
on the 6 8
68000

and
and 66502

6800

6502
6602

Immediate
Direct (zero-page)
(zero-page)
Extended (absolute direct)
Indexed (absolute)
(absolute)

Immediate
Zero Page
Page (direct)
(direct)
Absolute (direct)
Absolute
Absolute Indexed
Absolute
Zero Page
Page Indexed
Post-Indexed Indirect
Indirect
Pre-indexed
Indirect
Pre-Indexed Indirect
Indirect
Indirect
Relative (branches only)

Relative (branches only)

Note that many different
different variations
variations of indexed addressing are
are available on the
6502 microprocessor,
microprocessor. but remember that the 6502 index registers are
are only 8 bits
long while
hile the 6800 Index register is 16 bits long.
long.

The 6800
6502 instruction
6800/6502
6800 and 6502
instruction sets are similar but not identi6800/6502
cal (see
listing first
INSTRUCTION
(see Table 3-6).
3-6). Table 3-8 compares the two sets,
sets. listing
INSTRUCTION
the instructions
instructions which
hich are present in both,
instrucCOMPARISON
COMPARISON
both. then the 6800 instructions which
which have no 6502 equivalent.
equivalent, and finally
finally the 6502 instrucinstruc­
tions which
hich have no 6800 equivalent.
equivalent. Obviously
differences are a direct
Obviously some of these differences
direct
differences in the statuses and registers.
differences are minor,
result of the differences
registers. Most of the differences
minor.
and involve instructions
instructions that
that are a small part of common
common applications
applications programs. One
noticeable difference
difference is that the 6800 has Add and Subtract
Subtract instructions
instructions that do not inin­
noticeable
volve the Carry status (ADD and SUB)
hile the 6502 does not. This means that the
SUB) while
programmer must explicitly
explicitly clear or set the Carry status when
6502 assembly language programmer
its value should not affect
affect an addition
addition or subtraction
subtraction operation. Note that this similarity
ilarity
in the instruction
instruction sets does not extend to the object
object code level;
level: the actual machine
codes are entirely
entirely different
different on the two microprocessors.

3106
-106

Comparison of 6800
6800 and 6502
6502 Assembly
Assembly Language
Language Instruction
Instruction Sets
Table 3-8. Comparison

1
I.

Common Instructions

Instruction
ADC
AND
ASL
BCC
sec
BCS
BCS
BEQ
BEG
BIT
BMI
BNE
BNE
BPL
BPL
BVC
BVC
BVS
CLC
CLC
CLI
CLI
CLV
CMP
CMP
cpx1
CPX1 (also CPY
CPY on 6502)
DEC
DEC
DEX1 (also DEY
DEY on 6502)
EOR
EOR
INC
INC
INX1 (also
(also INY on 6502)
JMP
JSR
JSR
LDA
LOA
LDX1 (also
(also LDY
LOY on 6502)
LSR
LSR
NOP
NOP
ORA
ORA
PHA (PSH
(PSH on 6800)
6BOO)
PLA (PUL
(PUL on 6800)
ROL
AOL
ROR
ROA
RTI
RTI
RTS
ATS
sBc2
SBC2
SEC
SEC
SEI
SEI
STA
STA
STx1
STX1 (also
(also STY
STY on 6502)
TSX
TSX
TXS
TXS

Meaning
Meaning
ith Carry
Add with
Logical AND
A rithm
etic Shift
Shift Left
rithmetic
Branch if Carry Clear
Branch if Carry Set
1)
Branch if Equal to Zero (Z = 1)
Bit Test
Branch if Minus
inus (S = 1)
1)
Branch if Not Equal to Zero (Z = 0)
Branch if Plus (S = 0)
Overflow Clear
Branch if Overflow
Overflow Set
Branch if Overflow
Clear Carry
(Enable Interrupt)
Clear Interrupt
Interrupt Mask (Enable
Interrupt)
Clear Overflow
Overflow
ulator with
ith Memory
Compare Accum
Accumulator
ith Memory
Compare Index Register with
Decrement
1)
Decrement (by 1)
Decrement Index Register (by 1)
Decrement
1)
Logical Exclusive-OR
Exclusive-OR
Increment
1)
Increment (by 1)
Increment Index Register (by 1)
Increment
1)
Jump to New Location
Subroutine
Jump to Subroutine
Load Accum
ulator
Accumulator
Load Index Register
Logical Shift
Shift Right
No Operation
Logical (Inclusive) OR
OR
Push
ulator onto Stack
Push Accum
Accumulator
Pull Accum
ulator from Stack
Accumulator
Rotate Left through Carry
Rotate Right through
through Carry
Carry
Return from Interrupt
Interrupt
Return from Subroutine
Subroutine
Subtract with
ith Carry
Subtract
Set Carry
Carry
Set Interrupt
Interrupt Mask
Mask
Store Accum
ulator
Accumulator
Store Index Register
Transfer Stack Pointer to Index Register
Register (X)
(X)
(X) to
to Stack Pointer
Transfer Index Register (X)

11ndex
1
Index Register X is
is 16 bits
bits long
long on 6800,
6800. 8B bits long on 6502 which has
has Index
Index
Register
Register Y as
as well.
2Note that
different meaning on the
that SBC
SBC has
has a different
the 6502
6502 than
than on the 6800 since.
since.
for
subtraction operations, the
for subtraction
the 6800
6800 Carry
Carry is the
the inverse of
of the 6502 Carry.
Carry.

3-1
3-1077

Comparison of 6800
6800 and 6502
6502 Assembly
Assembly Language
Language Instruction
Instruction Sets
Table 3-8. Comparison
(Continued)
(Continued)

II.

Unique
6800 Instructions
Unique 6800
Instruction
ABA
ASA
ADD
ASR
BGE
BGE
BGT
SGT
BHI
SHI
BLE
BLE
BLS
BLS
BLT
BRA
BSR
BSR
CBA
CSA
CLR
CLR
COM
. DAA
DES
DES
INS
LDS
LOS
NEG
NEG
SBA
SEV
SEV
STS
STS
SUB
SUB
SWI
TAB
TAP
TBA
TPA
TST
WAI
WAI

III.
Ill.

Meaning
Add Accum
ulators
Add
Accumulators
Add (without
ithout Carry)
Add
A rithm
etic Shift
Shift Right
rithmetic
Branch if Greater than or Equal to Zero
Branch if Greater than Zero
Branch
Branch if Higher
Higher
Branch
Branch if Less than or Equal to Zero
Branch if Lower
Lower or Same
Branch if Less than Zero
Unconditionally
Branch Unconditionally
Branch to Subroutine
Subroutine
Branch
Compare Accumulators
Accumulators
Compare
Clear
Logical Complement
Complement
Logical
Decimal Adjust
Adjust Accum
ulator
Decimal
Accumulator
Decrement Stack Pointer
Pointer (by 1)
Decrement
1)
Increment Stack Pointer
Pointer (by 1)
Increment
1)
Load Stack Pointer
Pointer
Complement)
Negate (Twos Complement)
Subtract Accum
ulators
Subtract
Accumulators
Set Overflow
Overflow
Store Stack Pointer
Pointer
Subtract
Subtract (without
ithout Carry)
Software Interrupt
Interrupt (like 6502
6502 BRK)
Software
BRK)
ulator A to Accum
ulator B
Accumulator
Move from Accum
Accumulator
ulator A to CCR
Move from Accum
Accumulator
CCR
ulator B to Accum
ulator A
Move from Accum
Accumulator
Accumulator
ulator A
Move CCR
CCR to Accum
Accumulator
Minus
Test Zero or Minus
Wait
ait for Interrupt
Interrupt

Unique 6502
6502 Instructions
Instructions
Instruction

Meaning

BRK
BRK
CLD
CLO
PHP
PHP
PLP
PLP
SED
SEO
TAX (TAY)
(TAY)
TXA (TYA)
(TYA)

Break (like 6800
6800 SWI)
Clear Decimal
Decimal Mode
Push Status
Status Register onto Stack
Status Register from Stack
Pull Status
Set Decimal
Decimal Mode
Transfer Accum
ulator to Index
Register X (Y)
Transfer
Accumulator
lnde?<Register
(Y)
Transfer Index Register X (Y)
ulator
Transfer
(Y) to Accum
Accumulator

3 -1
08
108

6502 ASSEMBLER
MOS TECHNOLOGY 6502
CONVENTIONS
CONVENTIONS
standard 6502
6502 assembler
assembler is available
available from
from 6502
6502 manufacturers
manufacturers and on many
many
The standard
major time-sharing
time-sharing netw
orks; it is also included
included in most
ost developm
ent systems.
systems.
major
networks;
development
Cross-assembler versions
versions are available
available for
for most
most large computers
computers and many
many
Cross-assembler
minicomputers.
minicomputers.

ASSEMBLER FIELD STRUCTURE
ASSEMBLER
assembly language
language instructions
instructions have the standard
standard field
field structure
structure (see Table
The assembly
required delim
iters are:
2-1). The required
delimiters
1) AA space
space after
after aa label.
label. Note
Note that
that all
all labels
labels must
must start
start in
in column
column 1.
1.
2) AA space
space after
after the
the operation
operation code.
code.
3) AA comma
between operands
between the
offset adad­
comma between
operands in
in the
the address
address field,
field, i.e.,
i.e., between
the offset
dress and X or Y to indicate
indicate indexing
indexing with
ith Index
Index Register
Register X or Y respectively.
respectively.
dress
indirectly.
4) Parentheses
Parentheses around
around addresses
addresses that
that are
are to
to be
be used
used indirectly.
5) AA semicolon
exclamation point
semicolon or
or exclamation
point (we
(we w
will use
use the
the semicolon)
semicolon) before
before aa com­
comment.
ment.
Typical 6502
6502 assembly
assembly language
language instructions
instructions are:
Typical
START
LAST

LDA
LOA
ADC
BRK

(1000,X)
(1000.X)
NEXT
NEXT

;GET
;GET LENGTH
LENGTH
;END OF SECTION
SECTION

LABELS
Assembler often
often allow
only six characters
characters in labels
labels and truncates
truncates longer
longer
The Assembler
allowss only
character must
must be a letter
tte r wtiile
hile subsequent
subsequent characters
characters must
must be
ones. The firs
first t character
letters or numbers.
numbers. The single
single characters
characters A, X,
reserved for
for the AcAc­
letters
X. and Y are reserved
cumulator and the twoo index
index registers.
registers. The use of operation
operation codes
codes as labels
labels is
cumulator
often not
not allowed
allowed and is not
not good programming
programming practice
practice anyway.
anyway.
often

PSEUDO-OPERATIONS
PSEUDO-OPERATIONS
Assembler has the
the follow
ing exp
licit pseudo-operations:
pseudo-operations:
The Assembler
following
explicit

.BYTE
.DBYTE
.END
.TEXT
.WORD
=

Byte-Length Data
Data
-— Form Byte-Length
Double-Byte-Length Data with
ith MSBs
MSBs First
First
-— Form Double-Byte-Length
Program
-— End of Program
String of ASCII Characters
Characters
-— Form String
Double-Byte-Length Data with
ith LSBs First
First
-— Form Double-Byte-Length
-— Equate

Other pseudo-operations
pseudo-operations may be implemented
implemented by setting
setting the assembler's
assembler's location
location
Other
counter (denoted
(denoted by *) to a new
new or updated
updated value.
value. Examples
Examples are:
counter
•* = ADDR

*• = •+N
*+N

- Set
Set Program
Program Origin
Origin toto ADDR
ADDR
—
—
- Reserve
Reserve NN Bytes
Bytes for
for Data
Data Storage
Storage

.BYTE, .OBYTE
.DBYTE... .TEXT, and .WORD
.WORD are the Data
.BYTE, .DBYTE,
pseudo-operations used to place
place data in
pseudo-operations
In ROM... .BYTE is
■TEXT, .WORD
.TEXT,
-b it data,
data. .TEXT for 7-bit
7-bit ASCII characters
characters
used for 8-bit
PSEUDO-OPERATIONS
(MSB is zero)... .DBYTE for 16-bit
16-bit data with
ith the most
most sigsig­
nificant bits
bits first.
first, and .WORD
.WORD for 16-bit
16-bit addresses
addresses or data with
ith the least significant
bits
nificant
s1gn1ficant bits
Note particularly
particularly the difference
difference between
between .DBYTE and .WORD.
first. Note

3 -1
09
-109

Examples:
ADDR
ADDA

.WORD
.WORD

$3165
$3165

results in (ADDR)
5 and
and (ADDR+1) = 3131(hex).
(ADDA)== 665
(hex).
TCONV

.BYTE
.BYTE

32
32

This pseudo-operation
pseudo-operation places the number
number 32 (20-|
6> in the next byte of ROM
(2015)
ROM and
assigns the name TCONV to the address of that byte.
ERROR
ERROR

.TEXT
.TEXT

/ERROR/
/ERROR/

pseudo-operation places the 7-bit
7-bit ASCII
0, and R into the next
This pseudo-operation
ASCII characters E,
E. R,
R, R,
R. 0.
five bytes of ROM
ROM and assigns the name ERROR
ERRORto the address of the first byte. Any
character (not just
but we will
ill always
single character
just/)/) may be used to surround the ASCII text,
text. but
use / for the sake of consistency.
consistency.
MASK

.DBYTE
.DBYTE

$1000
$1000

results in (MASK)
10 and
and (MASK+1) = 0
0.
(MASK)= =10
=00.
OPERS
OPERS

.WORD

FADD.
FADD, FSUB.
FSUB. FMUL.FDIV
FMUL.FDIV

This pseudo-operation
pseudo-operation places the addresses FADD,
FADD. FSUB.
FSUB. FMUL,
FMUL. and FDIV in the next
eight bytes of memory (least significant
significant bits first) and assigns the name OPERS
eight
OPERS to the
address of the first
first byte.
The operation
operation '• = *+
N is the Reserve
pseudo-operation
SET ORIGIN
•+N
Reserve pseudo-operation
used to assign locations in RAM; it allocates a specified
PSEUDO-OPERATION
number of bytes. = is the Equate or Define pseudo-operanumber
tion used to define
define names.
pseudo-operation.
names. •* = ADDR
ADDA is the standard Origin pseudo-operation.
6502 programs usually have several origins
origins which
which are used as follows:
follows:
6502
1)
1)

To specify
specify the Reset
interrupt service addresses.
Reset and interrupt
addresses. These addresses must be
placed in the highest
highest memory addresses in the system (usually FFFA-|g
through
FFFA15 through
FFFF16).
FFFF15).

2)

To specify
specify the starting
starting addresses of the actual Reset
interrupt service routines.
Reset and interrupt
The routines themselves may be placed anywhere
anywhere in memory.

3) To
To specify
specify the
the starting
starting address
address of
of the
the main
main program.
program.
4) To
To specify
specify the
the starting
starting addresses
addresses of
of subroutines.
subroutines.
5) To
To define
define areas
areas for
for RAM
RAM storage.
storage.
6) To
To define
define an
an area
area (always
(always on
on page
page 1)
1) for
for the
the RAM
RAM Stack.
Stack.
7)
7) To
To specify
specify addresses
addresses used
used for
for I/O
1/0 ports
ports and
and special
special functions.
functions.

Examples:
RESET
RESET

=$3800
=$3800
•=$FFFC
*=$FFFC
.WORD
*=RESET
*=RESET

RESET
RESET

Note: $ means "hexadecim
al".
"hexadecimal".
instruction sequence in memory
memory beginning
beginning at address
This sequence places the Reset
Reset instruction
380
0 ig , and
locations (addresses
0015.
an~ places that address in the memory locations
(addresses FFFC-|6
FFFC15 and
FFFD15)
1 6 ) from which
which the 6502 CPU
CPU retrieves the Reset
Reset address.
address.
The instruction
instruction sequence which
hich follows
follows is stored in memory beginning
beginning at location
C000-|6.
C00015
MAIN

=$C000
=$COOO
•=MAIN
*=M
A IN
.END
ply marks the end of the assembly language program.
.END simply

3-110
3-110

LABELS
IT H PSEUDO-OPERATIONS
PSEUDO-OPERATIONS
LABELS WITH
recommendations for labels with
ith 6502
6502 pseudo-operations
pseudo-operations are as
The rules and recommendations
follows:
s:
1)
1)
2)

Simple equates, such as MAIN =$C000.
=$C000, require
require labels since their
their purpose is to
Simple
define the meanings
meanings of those labels.
define
.BYTE.
.DBYTE,.. .TEXT,.. .WORD,
'+ N pseudo-operations
pseudo-operations usually
usually have labels.
.BYTE, .DBYTE
WORD. and * =
•=•+N

3)

.END should
should not have a label,
label. since the meaning
meaning of such a label is unclear.

ADDRESSES
6502 Assembler
Assembler allows
allows entries
entries in the address field in any
The 6502
ing forms:
of the follow
following
1)
1)

Decimal (the default
default case)
Decimal
case)
Example: 1247

2)

Hexadecimal (must start
start with
ith $)
Hexadecimal
Example: $CE00
$CEO0

3)

Octal (must start
start with
ith @)
@)
Example: @1247

4)

Binary
%)
Binary (must start
start with
ith %)
%1
1100011
11100011
Example: %
ASCII (single character
character preceded by an apostrophe)
apostrophe)
Example: 'H

5)
6)

NUMBERS AND
NUMBERS
CHARACTERS IN
ADDRESS FIELD

offset from the Program Counter
Counter (*)
As an offset
(•)

Example: •+
*+ 77

6502 addressing modes are distinguished as
The various 6502
follows:
s:

ADDRESSING
ADDRESSING
MODES
MODES

•

Absolute or Zero Page (direct) are the default
default modes
Absolute
(the Assembler
Assembler chooses Zero Page if the address is less than 256, and Ab­
Absolute otherwise).
otherwise).
solute
# for immediate
immediate mode (precedes the data)

•

,X or ,Y for indexing
indexing (follows
(follows the offset
offset address)

•

around addresses that
that are used indirectly
indirectly so that
that
Parentheses around

•

(addr.X) indicates
indicates pre-indexing
pre-indexing (indexed address used indirectly)
indirectly)
(addri.Y indicates
post-indexing (indirect
ndexed)
(addrl.Y
indicates post-indexing
(indirect address is indexed)
(addri
indicates indirection
indirection with
ith JMP instruction
instruction only
(addr) indicates

______

In the indexed
indexed modes, as in the direct
direct modes,
Assembler autom
atically chooses the
modes. the Assembler
automatically
permitted and if the address is less than 256.
Zero Page version if it is permitted

,.

ASSEMBLER
ASSEMBLER
The Assembler
Assembler also allows
allows expressions
expressions in the address field. These
ARITHMETIC
ARITHMETIC
expressions consist
consist of numbers
numbers and names separated by the
expressions
EXPRESSIONS
arithm
etic operators
(multiplication), or/ / (integer
(integer division).
division).
arithmetic
operators+.+ , -, "• (multiplication).
Assembler evaluates
evaluates expressions
expressions from left to right;
right; no
The Assembler
parentheses are allowed
allowed to group
group operations,
operations, nor is there any hierarchy
hierarchy of operations.
operations.
parentheses
Fractional results
Fractional
results are truncated.
truncated.
that you avoid expressions within
in address fields whenever
whenever possipossi­
We recommend that
ble. If you must
must compute
compute an address, comm
ent any unclear
unclear expressions
expressions and be sure
comment
that the evaluation
evaluation of the expressions
expressions never produces
produces a result
result which
which is too large for its
that
ultim
ate use.
ultimate
use.

3-111
3-111

ASSEMBLER FEATURES
OTHER ASSEMBLER
standard 6502
6502 Assembler
Assembler has neither
neither a conditional
conditional assembly
assembly capability
capability nor
nor a
The standard
macro capability.
capability. Some 6502
6502 assemblers
assemblers have one or both
both of
of these capabilities.
capabilities, and
and
macro
you should
Wee w
willill not
should consult
consult your
your manual
manual for
for a description.
description. W
not use or
or refer
refer to either
either
capability
capability again.
again, although
although both
both can be quite
quite convenient
convenient in actual
actual applications.
applications.

3-1
3-112

Chapter 4
SIMPLE PROGRAMS
The only way
ay to learn assembly language
experience. The
language programming is through experience.
next six chapters of this book contain examples
examples of simple programs
that perform
next
programs that
actual microprocessor tasks. You should
should read each example carefully and try to
execute the program
6502-based microcomputer. Finally, you should
execute
program on a 6502-based
should work
the problems at the end of each chapter and run
run the resulting programs to insure
insure
that you understand the material.
This chapter
chapter contains
contains some very elementary
elementary programs.

GENERAL
GENERAL FORMAT OF
OF EXAMPLES
EXAMPLE
FORMAT
FORMAT

Each program example contains the following
ing parts:
1)
1)

that describes
describes the general problem.
A title that

2)

A statement
statement of purpose that describes
describes the specific
specific task that
that the program performs
and the memory locations
locations that it uses.
uses.

3) A
A sample
sample problem
problem w
with data
data and
and results.
results.
4) A
chart ifif the
A flow
flowchart
the program
program logic
logic is
is complex.
complex.
5) The
The source
source program
program or
or assembly
assembly language
language listing.
listing.
6) The
language listing.
listing.
The object
object program
program or
or hexadecimal
hexadecimal machine
machine languag.e
7)

Explanatory notes that
that discuss the instructions
instructions and methods
methods used in the program.
Explanatory

You should use the examples
examples as guidelines for solving the problems at the end of
each chapter. Be sure to run your solutions on a 6502-based
6502-based microcomputer
microcomputer to in­
insure that
that they
they are correct.
programs in the examples
examples have been constructed
constructed as follows:
follows:
The source programs

-----

..

GUIDELINES
GUIDELINES
FOR
EXAMPLES
EXAMPLES

1)

Standard 6502
6502 assembler
assembler notation
notation is used,
summarized in
Standard
used. as summarized
Chapter 3.
Chapter

2)

forms in which
which data and addresses appear
appear are selected
selected for
The forms
clarity rather
rather than for consistency.
consistency. Wee use hexadecimal
hexadecimal numnum­
clarity
memory addresses,
instruction codes,
decimal for numeric
numeric
bers for memory
addresses. instruction
codes. and BCD data; decimal
constants; binary
binary for logical
logical masks; and ASCII for characters.
constants;

3)

Frequently used instructions
instructions and programming
programming techniques
techniques are emphasized.
Frequently

4)

illustrate tasks that
that microprocessors
microprocessors perform
perform in communications.
communications, instruinstru­
Examples illustrate
mentation, computers.
computers, business equipment.
equipment, industrial.
industrial, and military
ilitary applications.
applications.
mentation.

5)

Detailed comments
comments are included.
included.
Detailed

6)

Simple and clear structures
structures are emphasized.
emphasized, but
but programs
programs are as efficient
efficient as possipossi­
Simple
ith in this guideline.
guideline. The notes often
often describe
describe more efficient
efficient procedures.
ble within

7)

Programs use consistent
consistent memory
memory allocations.
allocations. Each program
program starts
starts in memory
memory localoca­
Programs
0000 and ends with
ith the Break (BRK)
instruction. If your
your m icrocom
puter has no
tion 0000
(BRK) instruction.
icrocomputer
monitor
onitor and no interrupts,
interrupts, you may prefer
prefer to end programs
programs with
ith an endless loop inin­
struction, e.g.,..
struction.
HERE
HERE

JMP

4-1

HERE
HERE

JSR instruction
Some 6502-based
6502-based microcomputers
icrocomputers may require a JMP or JSR
instruction with
ith a
specific
specific destination
destination address to return
return control
control to the monitor.
monitor. Other
Other microcomputers
icrocomputers
BAK instruction
may require you to specify
specify the monitor
onitor address to be used by the BRK
instruction. For
example.
COOinto addresses
example, if you are using the popular
popular KIM-1.
KIM-1, you will
ill have to load 1COO
17FE
17FF. Be careful
carefu I —
- the 00 must
must be loaded into
into address 17FE
17FE and the 1C into
17FE and 17FF.
address 17FF.
17FF. We will
ill explain
explain later how the 6502
6502 stores addresses and how it impleimple­
ments the BRK
BAK instruction
(see Chapter
12).
instruction (see
Chapter 12).
Consult the User's Manual
Manual for your m icrocom
puter to determ
ine the required memory
Consult
icrocomputer
determine
allocations
instruction for your
your particular
allocations and terminating
inating instruction
particular system.

GUIDELINES FOR
FOR SOLVING PROBLEMS
Use the following
ing guidelines in solving the problems at the end of each chapter:
1)
1)

Comment
Comment each
each program
program so
so that
that others
others can
can understand
understand it.
it.
PROGRAMMING
PROGRAMMING
The comments
comments can be brief
brief and ungrammatical:
ungrammatical; they
GUIDELINES
explain the purpose of a section
section or instruction
instruction in
should explain
the program. Comments
Comments should not describe
describe the operation
operation
of instructions;
instructions; that
that description
description is available in manuals. You do not have to com-­
ment
format
exment each statement
statement or explain
explain the obvious. You may follow
follow the form
at of the ex­
provide less
amples but provide
less detail.

2)

Emphasize clarity.
clarity, simplicity,
plicity, and good structure
structure in programs. While
hile programs
programs
should be reasonably efficient.
efficient, do not worry
worry about
about saving a single byte of program
memory or a few microseconds.
microseconds.
memory

3)

Make programs
programs reasonably
reasonably general.
general. Do
Do not
not confuse
confuse parameters
parameters (such
(such as
as the
the num
num-­
Make
ber of elements
C).
elements in an array) with
ith fixed constants
constants (such as 1r
it or ASCII C).

4)

Never assume
assume fixed
fixed initial
initial values
values for
for parameters;
parameters; i.e.,
i.e.. assume
assume that
that the
the parameters
parameters
Never
RAM.
are already in RAM.

5)

assembler notation
notation as shown
shown in the examples
examples and defined
defined ininChapter
Use assembler
Chapter 3.3.

6)

Use hexadecimal
hexadecimal notation
notation for
for addresses. Use the clearest
clearest possible
possible form
form for data.
data.

7)

icrocomputer
it. start
If your m icrocom
puter allows
allows it,
start all programs
programs in memory
memory location
location 0000 and
4016
use memory
memory locations
locations starting
starting with
ith 0 0 4
0 -|q for data and temporary
temporary storage. OtherOther­
establish equivalent
equivalent addresses for your
your m icrocom
puter and use them consisconsis­
wise. establish
icrocomputer
tently. Again.
Again, consult
consult the user's manual.

8)

Use meaningful
meaningful names for labels and variables: e.g.... SUM or CHECK
rather than X.
CHECK rather
Y,
Y. or Z.
Z.

9) Execute
microcomputer. There
Execute each
each program
program on
on your
your microcomputer.
There is
is no
no other
other way
way of
of ensuring
ensuring
that
that your program
program is correct. We have provided
provided sample data with
ith each problem. Be
cases.
sure that
that the program works
works for special
special cases.

We now summarize some useful information that you should keep in mind when
programs.
writingg programs.
Almost
Subtract. AND,
AND.
ost all processing
processing instructions
instructions (e.g.. Add. Subtract,
USING THE
OR) use the contents
Accumulator
OR)
contents of the Accum
ulator as one operand and
ACCUMULATOR
ACCUMULATOR
place the result
cases. you
result back in the Accumulator.
Accumulator. In most cases,
Accumulator
LOA. You will
will
ill load the initial
initial data into the Accum
ulator with
ith LDA.
ill store the result from
the Accum
ulator into memory
memory with
ith STA.
Accumulator
STA.

4-2
2

USING
Frequently accessed data and frequently
frequently used base addresses or
Frequently
PAGE ZERO
ZERO
pointers should be placed on page zero of memory. This data can
OF MEMORY
MEMORY
then be accessed with
ith zero-page (direct),
pre-indexed, postpost­
(direct). pre-indexed.
indexed,
particular that
indexed. and zero-page indexed addressing. Note in particular
pre-indexing and post-indexing
post-indexing both assume that an address is stored on page zero.
pre-indexing
zero.
The zero-page direct
direct and indexed modes both require less time and memory than the
corresponding absolute addressing modes.
corresponding
modes.
Some instructions.
instructions, such as shifts.
shifts, increment
increment (add 1),
decrement (subtract
(subtract 1)
1). and decrement
1) can act
directly on data in memory. Such instructions
instructions allow you to bypass the user registers but
directly
execution time since the data must actually
actually be loaded into the CPU
they require extra execution
CPU
and the result must be stored back into memory.

4-3

PROGRAM EXAMPLES
8-Bit
-B it Data Transfer
Purpose: Move the contents
contents of memory location
location 0040
0040 to memory
memory location
location 0041.
Sample Problem:

Result:

(0040)

=

6A

(0041)

=

6A

Source Program:
LDA
STA
BRK
BRK

$40
$40
$41
$41

;GET
:GETDATA
DATA
TRANSFER
;TRANSFERTO
TONEW
NEWLOCATION
LOCATION

Object Program:
Object
Memory Location
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004

A5
40
85
41
00

Instruction
Instruction
(Mnemonicl
(Mnemonic)
LDA

$40

STA

$41

BRK
BRK

The LDA
Accumulator) and STA (Store
Accumulator) need an address to deterdeter­
LOA (Load
(Load Accumulator)
(Store Accumulator)
mine the source or destination
destination of the data.
in the example are
data. Since the addresses used in
on page zero (that is,
eight most significant
significant bits are all zero),
is. the eight
zero), the zero
zero page (direct)
(direct)
form of the instructions
instructions can be used
ith the address in the next word. The leading
used with
zeros
shorthand form
zeros can be omitted. The addresses
addresses are really 0040 and 0041, but the shorthand
can be used
conversation (e.g
(e.g.,.. we say "sixty
"sixty cents"
cents" rather than
used just as in everyday conversation
"zero dollars and sixty cents").
BRK
BRK (Force
(Force Break)
Break) is used to end all the examples and return control to the monitor.
Remember that you may have to replace this
instruction with whatever
whatever your microcomicrocom­
this instruction
puter requires.
requires.

44-4

8-Bitit Addition
Purpose: Add the contents
contents of memory
memory locations
locations 0040
0040 and 0041, and place the result
location 0042.
in memory location
Sample Problem:

Result:

(0040)
(0041)

=
=

38
28
2B

(0042)

=

63

Source Program:
CLC
CLC
LDA
LOA
ADC
STA
BRK
BRK

$40
$41
$42

;CLEAR
;CLEAR CARRY
CARRY TO START
START
;GET
;GET FIRST
FIRST OPERAND
OPERAND
;ADD SECOND
SECOND OPERAND
OPERAND
;STORE
;STORE RESULT
RESULT

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0005
0006
0007

18
A5
40
65
41
85
42
00

Instruction
Instruction
(Mnemonic)
(Mnemonic!
CLC
CLC
LDA
LOA

$40

ADC

$41

STA

$42

BRK
BRK

The only addition
addition instruction
instruction on the 6502 microprocessor
microprocessor is ADC (Add with
ith Carry),
Carry).
which results in (A)
where M is the addressed memory location.
which
(Al = (A)
(A) + (M)
(Ml++ (Carry)
(Carry) where
Thus,
initial CLC (Clear Carry)
instruction if the value of Carry is not to
Thus. we need the initial
Carry) instruction
affect the addition.
addition. Remember
Remember that the Carry will
ill be included
included in all additions
additions and
affect
subtractions.
subtractions.
The zero-page (direct) forms of all instructions
instructions are used,
used. since all the addresses are in
the first
first 256 bytes of memory.
ADC affects
affects the Carry bit.
bit, but LDA
etic and shift
shift instrucinstruc­
LOA and STA do not. Only arithm
arithmetic
affect the Carry; logical
logical and transfer
transfer instructions
instructions do not.
tions affect
LDA
affect the contents
contents of memory. STA changes the contents
contents of the
LOA and ADC do not affect
addressed memory location
location but does not affect
affect the contents
contents of the Accumulator.
Accumulator.
Be·sure
sure that
that the Decimal
Decimal Mode (D)
when you execute this program. To be
(D) flag is cleared when
absolutely certain
certain of the D flag's
flag's state,
instruction (D8-|
0 ) to the
absolutely
state. you could add a CLD
CLO instruction
(0815)
microcomputer, you should clear
start of the program. If you are using the KIM-1
KIM-1 microcomputer.
location OOF1
that the Decimal
Decimal Mode flag does not interfere
interfere with
ith
memory location
OOF1 to ensure that
ith the monitor.
your programs or with

44-5

Shift Left One Bit
Shift
Purpose: Shift
Shift the contents
contents of memory
memory location
location 0040
0040 left one bit and place the result
memory location
location 0041. Clear the empty
empty bit position.
into memory
Sample Problem:

Result:

(0040)

=

6F

(0041)

=

DE

Source Program:
LDA
LOA
ASL
STA
BRK
BRK

$40
A
$41

;GET
;GET DATA
;SHIFT
;SHIFT LEFT
LEFT
;STORE
;STORE RESULT
RESULT

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005

A5
40
OA
OA
85
B5
41
41
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$40

ASL
STA

A
$41

BRK
BRK

The instruction
instruction ASL A shifts the contents
contents of the Accum
ulator left one bit and clears the
Accumulator
least significant
significant bit. The most significant
significant bit is moved into the Carry.
Carry. The result is twice
the original
original data (why?).
(why?).
Note that we could
Id also shift
shift the contents
contents of memory location 0040 one bit with
ith the in­
instruction ASL $40 and then move the result to memory location 0041. This method
struction
would, however,
contents of memory location 0040 as
would.
however. change the contents
as well as the contents
of memory location 0041.

4 -6

Mask Off M ost Significant
Significant Four
Four Bits
Purpose:
significant four
Purpose: Place
Place the least
least significant
four bits of memory location 0040 in the least
least sig­
significant four
significant four
nificant
four bits of memory location 0041. Clear the
the most significant
four
bits of memory location 0041.

Sample Problem:
(0040)
(0040)

=

30
3D

Result:
It: (0041)
(0041)

=

OD
0D

Program:
Source Program
LDA
LOA
AND
STA
BRK
BRK

$40
#% 00
00
1
00001111
$41

;GET
:GETDATA
DATA
;MASK
;MASK44MSB'S
MSB'S
;STORE
;STORERESULT
RESULT

Note: # means immediate
mediate addressing and % means binary constant
constant in standard 6502
Assembler notation.
Assembler

Object
Program:
Object Program:
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006

A5
40
29
OF
OF
85
41
41
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$40

AND

# %00001111
0 0 0 0 1 111

STA

$41
$41

BRK
BRK

AND # % 0 0
00
1 logically
logically ANDs the contents
contents of the Accum
ulator with
ith the number
00001111
Accumulator
OF-]6
contents of memory location
location 000F.
Immediate addressing (indicated by
OF15 -— not the contents
OOOF.Immediate
#)) means that
that the actual data, not the address of the data.
data, is included
included in the instrucinstruc­
tion.
The mask (00001111)
(00001111) is written
ritten in binary
binary to make its purpose clearer to the reader.
reader. Bi­
Binary notation
notation for masks is clearer than hexadecimal
hexadecimal notation
notation since logical operations
are performed
performed bit-by-bit
it-by-bit rather
rather than digits
digits or bytes at a time. The result.
result, of course,
course. does
not depend on the programm
ing notation.
notation. Hexadecimal
notation should be used for
programming
Hexadecimal notation
masks longer than eight
eight bits because the binary versions become long and cumbercumber­
some.
comments should explain the masking operation.
some. The comments
instruction may be used to clear bits that are not in use.
A logical AND instruction
use. For example,
example. the
four least significant
significant bits of the data could be an input
input from a ten-position
ten-position switch
switch or an
four
output
output to a numeric
numeric display.

4-7
7

ory Location
Clear a M em
emory
Purpose: Clear memory
memory location
location 0040.

Source Program:
LDA
LOA
STA
BRK
BRK

#0# 0
$40
$40

;CLEAR LOCATION
LOCATION 40
40
:CLEAR

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0004

A9
00
85
40
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

#00

STA

$40

BRK
BRK

has no explicit
Zero is handled no differently
differently than any other number
number -— the 6502
6502 has
explicit Clear
instruction. However,
remember that LDA
instruction.
However. remember
LOA #00 does set the Zero flag to one.
one. Always
watch
(Zero) flag is set to one if the last result was zero.
zero.
watch this logic -— the Z (Zero)
STA does not affect
affect any status flags.
flags.

4-8
4-

Word Disassembly
Purpose:
Purpose: Divide
Divide the
the contents of memory location 0040 into two
two 4-bitit sections and
and
store them
signifi­
them in memory locations 0041
0041 and 0042. Place
Place the
the four
four most significant bits of memory location 0040 into the
significant bit positions
the four least significant
of memory location 0041; place the
significant bits of memory
the four least significant
location 0040 into the four least
significant bit positions of memory location
least significant
0042. Clear
significant bit positions of memory locations 0041
Clear the four
four most significant
0041
and 0042.
Sample Problem:

(0040)
(0040)

=

3F
3F

Result: (0041)
(0041)
Result:
(0042)
(0042)

=
=

03
OF
OF

ogram:
Source Program:
LDA
LOA
AND
STA
LDA
LOA
LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA
BRK
8RK

;GET
;GET DATA
;MASK OFF
OFF MSB'S
MS8'S
;STORE
;STORELSB'S
LS8'S
;RESTORE
;RESTOREDATA
LOGICALLY
:LOGICALLY SHIFT
SHIFT DATA RIGHT
RIGHT 4 TIMES
TIMES

$40
#% 00
0 0 1 111
00001111
$42
$40
A
A
A
A
$41
$41

;STORE
:STORE MSB'S
MS8'S

Object Program:
Object

Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
0008B

A5
40
29
OF
F
85
42
A5
40
4A
4A
4A
4A
85
41
00

oooc
oooc
000D
00D
000E
OOOE

Instruction
Instruction
(Mnemonic)
LDA

$40

AND

#% 00
0 0 1 111
00001111

STA

$42

LDA

$40

LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA

A
A
A
A
$41

BRK
8RK

shift right
right of four positions requires four executions
executions of the LSR
instruction.
A logical shift
LSR A instruction.
Each LSR instruction
instruction clears the most significant
significant bit
bit of the result. Thus.
Thus, the four most
significant bits of the Accum
ulator are all cleared after LSR
significant
Accumulator
LSR A has been executed four
times.
You might
ight wish
wish to try rew
riting the program so that
that it saves a copy of the data in Index
rewriting
hich version do you prefer and
Register X rather than loading the same data twice. Which
why?

4-9
9

Find Larger of Two
o Numbers
contents of memory
memory locations
locations 0040
0040 and 0041 into
into
Purpose: Place the larger of the contents
memory
contents of memory
memory location
location 0042. Assume
Assume that
that the contents
memory locations
locations 0040
0040
unsigned binary
binary numbers.
and 0041 are unsigned

Sample Problems:
a.
a.

(0040)
(0041)

=
=

(0042)

=

3F

(0040)
(0041)

=
=

75
A8
AB

(0042)

=

A8
AB

Result:

b.
Result:

3F
2B
28

Source Program:

STRES
STRES

LDA
LOA
CMP
BCS
BCS
LDA
LOA
STA
BRK
BRK

$40
$41
STRES
STRES
$41
$42

;GET
:GET FIRST
FIRST OPERAND
OPERAND
:IS
;IS SECOND
SECOND OPERAND
OPERAND LARGER?
LARGER?

:YES. GET
GET SECOND
SECOND OPERAND
OPERAND INSTEAD
INSTEAD
;YES.
;STORE
:STORE LARGER
LARGER OPERAND
OPERAND

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA

A5
40
C5
41
41
B0
BO
02
A5
41
41
85
42
00

Instruction
Instruction
(Mnemonic)

STRES
STRES

LOA
LDA

$40

CMP
CMP

$41
$41

BCS
BCS

STRES
STRES

LDA
LOA

$41
$41

STA

$42

BRK
BRK

CMP $41 subtracts
subtracts the contents
contents of memory location 0041 from the contents
contents of the Acc­
the result anywhere. The instruction
Is used merely to set
cumulator
ulator but does not store the
instruction is
the
subsequent conditional
conditional branch.
the flags
flags for
for aa subsequent
branch.
CMP
CMP affects
affects the
the flags as
as follows:
follows:

1) N
Ntakes
takesthe
the value
value of
1)
of the
the most
most significant
significant bit
bit of
of the
the result
result of the subtraction.
subtraction.
2)
2)

set toto 11 ifif the
the result
O otherwise.
Z isisset
result of
of the subtraction
subtraction Is
is zero and
and to
to 0

3)
3)

C
subtraction does
does not
not require
require aa borrow
borrow and
and to
to O
0 ifif itit does.
does. Note
Note
Cisisset
set toto 11ifif the
the subtraction
the actual borrow as it is
is on many other
that C is an inverted borrow, not the
microprocessors.

4)
4)

V
V isisnot
not affected.
affected.

44-10

ing cases:
Note the follow
following
1)
1)

operands are equal,
equal, Z = 0,
If the operands
equal. Z = 1; if they are not equal.
0.

2)

If the contents
contents of the Accum
ulator are greater
greater than or equal to the contents
contents of the
Accumulator
other address (considering
(considering both as unsigned
unsigned binary
binary numbers), C = 1,
bor­
other
1, since no borwould then be needed. Otherwise,
Otherwise, C =
= 0.
row would

Allll 6502
6502 conditional
conditional branch
branch instructions
instructions use relative
relative addressing.
addressing, in which
hich the second
word of the instruction
instruction is an 8-bit
-b it twos complement
complement number
number which
which the CPU
word
CPU adds to the
instruction to calculate
calculate the destination
destination address. In the example,
example, the
address of the next instruction
relative offset
offset is 0008
0008 (destination
(destination address) - 0006
0006 (address immediately
immediately follow
ing the
relative
following
Obviously, calculating
calculating relative
relative offsets
offsets is error-prone,
error-prone, particularly
particularly if the
branch) or 02. Obviously,
result is negative;
negative: however,
however, if you label all target
target instructions,
instructions, the assembler
assembler will
ill perper­
result
form the calculations
calculations for you.
BCS
branch if the Carry is one. If the Carry is zero,
processor continues
continues ex­
exBCS causes a branch
zero. the processor
ecuting instructions
instructions in their
their normal
normal sequence
sequence as if the Branch instruction
instruction did not exist.
ecuting
STRES
that the programmer
programmer assigns to a memory
memory address so that
that it is
STRES is a label,
label. a name that
remember and locate. Note that
that labels are followed
followed by a space on the line
easier to remember
where they are defined.
defined. The label makes the destination
destination of the branch
branch clear, particularly
particularly
where
when relative
relative addressing
addressing is being used. Using a label is preferable
preferable to just
|ust specifying
specifying the
when
offset (ie,
(i.e., 8CS"+4)
BCS*+4) since the 6502's
6502's instructions
instructions vary in length. You or another
another user of
offset
the program
program could
could easily make an error in determ
ining the offset
offset or the destination
destination.
determining

4-11

1 6-Bit
-B it Addition
Purpose: Add
Add the 16-bit
16-bit number
number in memory
memory locations
locations 0040
0040 and 0041 to the 16-bit
16-bit
number in memory locations
locations 0042
0042 and 0043. The most significant
significant eight
eight bits
number
are in memory locations
locations 0041 and 0043. Store the result in memory localoca­
0044 and 0045.
0045, with
ith the most significant
significant bits in 0045.
tions 0044
Sample Problem:
(0040)
(0041)
(0042)
(0043)

2A
67
F8
14

Result=672A +
Result=672A
+ 14F8 = 7C22
(0044)
(0045)

22
= 7C

Source Program:
Program:
CLC
CLC
LDA
LOA
ADC
STA
LDA
LOA
ADC
STA
BRK
BRK

$40
$42
$44
$41
$41
$43
$45

;CLEAR
;CLEAR CARRY
CARRY TO START
START
;ADD LEAST
LEAST SIGNIFICANT
SIGNIFICANT BITS
BITS

;ADD
:ADD MOST SIGNIFICANT
SIGNIFICANT BITS
BITS WITH CARRY
CARRY

Object Program:
Object
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
000A
000B
000B
OOOC
oooc
000D

18
18
A5
40
65
42
85
44
A5
41
41
65
43
85
45
00

Instruction
Instruction
(Mnemonic)
CLC
CLC
LDA
LOA

$40

ADC

$42

STA
STA

$44

LDA
LOA

$41
$41

ADC
ADC

$43

STA
STA

$45

BRK
BRK

You must clear the
addition since there
the Carry before the
the first
first addition
there is
is never a carry into the
the
least
significant bits.
least significant
bits.
ADC then
atically includes the
then automatically
the Carry
Carry from
from the
the least
least significant
significant bits in the addition
of the
significant bits.
the most significant
bits. Thus
Thus the
the microprocessor can
can add data of any length;
length: it adds
adds
numbers eight bits
ation from
bits at
at aa time
time with the
the Carry
Carry transferring
transferring information
from one
one 88-bitit sec­
section
tion to
to the
the next.
next. Note,
Note. however,
however. that
that each
each 8-bitit addition
addition requires the
the execution
execution of three
three
instructions (LDA,
accumulator.
instructions
(LOA. ADC,
ADC. STA)
STA) since there
there is
is only
only one accumulator.

44-12

--=-=

Table of
of Squares
Squares
Purpose:
Purpose: Calculate the
the square of the
the contents of memory location 0041
0041 from
from a table
and place the
the result in
in memory location 0042. Assume
Assume that
that memory location
0041
0041 contains a number between 0O and 7 inclusive -— 0 <$ (0041)
(0041) <$ 7.
7.
The table occupies memory locations 0050 to 0057.

Entry

Memory Address
Memory
(Hex)

(Hex)

0050
0051
0052
0053
0054
0055
0056
0057

00
01
01
04
09
10
19
24
31
31

(Decimal)
0
1
4
9
16
16
25
36
49

(02)
(0?)
(12)
(1?
(22)
Z)

(32)
(3
j
(42)
(4‘
(52)
(5,)
(62)
(6,)
(72)
(7

Sample Problems:
(0041)

=

Result:

(0042)

= 09
09

(0041)

= 06
06

Result:

(0042)

= 24
24

a.
a.

b.

03

Remember that the answer is a hexadecimal number.

Source Program:

SOTAB

LDX
LOX
LDA
LOA
STA
BRK
BRK
*=
$50
·=$50
BYTE
.BYTE

;GET
:GET DATA
;GET
:GET SQUARE
SQUARE OF DATA
;STORE
:STORE SQUARE
SQUARE

$41
$50,X
$50,X
$42

;SQUARES
;SQUARES TABLE

0, 1,4,9,16,25,36,49
16,25,36.49

413
-13

-_----

Object Program:
Object
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006

A6
41
41
B5
50
85
42
00

0050
0051
0052
0053
0054
0055
0056
0057

00
01
04
09
10
19
24
31

Instruction
Instruction
(Mnemonic)
LDX
LOX

$41

LDA
LOA

$50,X
$50.X

STA

$42

BRK
BRK
SQTAB
SOTAB

BYTE
.BYTE

0
1
4
9
16
25
36
49

Note that
that you must also enter the table of squares into memory (the assembler pseudopseudo­
operation .BYTE
BYTE will
ill handle this). The table of squares is constant
constant data,
operation
data. not parameters
initialize the table using the .BYTE
pseudo-opera­
that may change; that is why you can initialize
.BYTE pseudo-operation,
executing instructions
instructions to load values into the table. Remember that,
tion. rather than by executing
that.
in an actual application.
application, the table would
would be part of the read-only program memory. The
BYTE pseudo-operation
pseudo-operation places the specified data in memory in the order in which
which it apap­
.BYTE
pears in the operand field.
The pseudo-operation
ply determines
determines where the loader (or assembler)
ill place
pseudo-operation•=* = simply
assembler) will
the next section of code when
when it is finally
finally entered into the microcom
puter's memory for
microcomputer's
execution.
pseudo-operation does not actually
actually result in any object
object code
execution. Note that
that the pseudo-operation
being generated.
Indexed addressing (or indexing) means that the actual address used by the instruction
instruction
(often referred to as the effective
effective address) is the sum of the address included
included in the inin­
struction
struction and the contents
contents of the Index register. Thus LDA
LOA $50,X
$50.X (,X
(.X or ,Y
.Y indicates in­
indexed addressing with
ith the specified Index register in 6502
6502 assembly language) is
equivalent to LDA
$50+(X) or LDA
equivalent
LOA $50+(X)
LOA $53 if (X)
(X) =
= 03. In the example program,
program. Index
Register X contains
contains the number
number to be squared and the address included
included in the instrucinstruc­
tion is the starting
starting address of the table of squares.
squares. Note that there is a special zero-page
indexed mode using Index Register X.
X.
Indexing always takes extra time since the m icrocom
puter must perform an addition
addition to
Indexing
icrocomputer
calculate the effective
effective address.
$50,X requires four
four clock cycles while
hile LDA
calculate
address. Thus LDA
LOA $50.X
LOA
would clearly take a great deal more time to access
$50 requires only three. However,
However. it would
access
the table entry if the m icrocom
puter lacked indexing
indexing and the address calculation
calculation had to
icrocomputer
be performed with
ith a series of instructions.
instructions.
Remember that the Index registers are only 8 bits long so the maximum
maximum offset from the
(FF15). Note also that the offset
base address is 255 (FF-ig)offset is an unsigned number
number (unlike the
wrap­
offset in relative addressing) so that it can never be negative. However,
However. we do get wrapcontents of the index register
around. That is,
is. if the sum of the base address and the contents
exceed the maximum
aximum allowed
value, the most significant
significant bits of the sum are simply
allowed value.
simply
indexing, the maximum
maximum allowed value is FF-|g.
dropped. In the case of zero page indexing.
FF15. If,
If. for
example,
example. the base address on the zero page is F0-|g
F015 and the index register contains
effective address for zero page indexing
indexing is 000815;
000B-|g; there is no carry to the
1B-|0,
B15. the effective
more significant
significant byte. Thus we can get the effect
effect of a negative
negative offset.

4 -14
14

There are a few special instructions
instructions that
that operate on one of the Index registers rather
ulator. These are:
than on the Accum
Accumulator.
are:
CPX,
Compare Memory
Memory and Index Register
CPX. CPY - Compare
DEX,
Decrement Index Register (by 1)
DEX. DEY - Decrement
1)
1)
INX. INY - Increment
Increment Index Register (by 1)
LDX,
Memory
LOX. LDY
LOY - Load Index Register from Memory
STX, STY - Store Index Register into Memory
Memory
Transfer Accum
ulator to Index Register
TAX. TAY - Transfer
Accumulator
TXA, TYA - Transfer
Transfer Index Register to Accum
ulator
TXA.
Accumulator
Remember that
that there are only a few addressing
addressing modes available
available with
ith CPX,
Remember
CPX. CPY,
CPY. LDX,
LOX.
LDY,
Consult Table 3-4 for more details.
LOY. STX,
STX. and STY.
STY. Consult
A rithm
etic that
that a microprocessor
microprocessor cannot
cannot do directly
directly in a few
rithmetic
ARITHMETIC
ARITHMETIC
WITH
instructions is often
often best performed
performed with
ith lookup tables. Lookup
instructions
WITH
tables simply
simply contain
contain all the possible answers to the problem;
problem;
TABLES
organized so that
that the answer
answer to a particular
particular problem
problem
they are organized
can be found
found easily. The arithm
etic problem
problem now becomes an accessing
accessing problem
problem -—
arithmetic
correct answer
answer from the table? We must
must know
know two
two things:
things: the
how do we get the correct
position of the answer
answer in the table (called the index) and the base,
starting, address
position
base. or starting.
of the table. The address of the answer
answer is
Is then the base address plus the index.
fixed number
number for a particular
particular table. How can we deterdeter­
The base address,
address. of course,
course. is a fixed
simple cases,
where a single piece of data is involved.
involved, we can organorgan­
mine the index? In simple
cases. where
ize the table
table so that
that the data is the index. In the table of squares,
Oth entry
entry in the tata­
squares. the 0th
ble contains
contains zero squared.
squared, the first
first entry
entry one squared.
squared, etc. In more complex
complex cases,
cases.
where the spread of input
input values is very large or there are several data items involved
involved
where
quadratic equation
equation or number
number of permutations).
permutations), we must
must use more comcom­
(e.g.,.. roots of a quadratic
plicated methods
methods to determine
determine indexes.
plicated
The basic tradeoff
tradeoff in using a table
table is time vs. memory. Tables are faster,
com­
faster. since no computations are required.
required, and simpler.
simpler, since no mathematical
mathematical methods
methods must
must be devised
putations
However, tables
tables can occupy
occupy a large amount
amount of memory
memory if the range of the
and tested. However.
input data is large. We can often
often reduce the size of a table by limiting
iting the accuracy
accuracy of
input
results, scaling
scaling the input
input data,
organizing the table
table cleverly. Tables are often
the results.
data. or organizing
used to compute
compute transcendental
transcendental and trigonom
etric functions.
functions, linearize inputs.
inputs, convert
convert
trigonometric
codes,
perform other
other mathematical
athematical tasks.
codes. and perform
tasks.

44-15

Ones Complem
ent
Complement
Purpose: Logically
Logically complem
ent the contents
contents of memory
memory location
location 0040
0040 and place the
complement
memory location
location 0041.
result
It in memory
Sample Problem:
(0040)

= 6A

Result=(0041) = 95
Result=(0041)

Source Program:
LDA
LOA
EOR
EOR
STA
BRK
BRK

$40
#% 1
1111111
%11111111
$41

;GET
;GETDATA
DATA
:LOGICALLY
;LOGICALLY COMPLEMENT
COMPLEMENT DATA
;STORE
;STORERESULT
RESULT

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006

A5
40
49
FF
FF
85
41
41
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$40

EOR
EOR

#% 1
1111111
%11111111

STA

$41
$41

BRK
BRK

The 6502 microprocessor
microprocessor lacks some simple instructions,
instructions, such as
Complement,
as Clear or Complement
that are available in most other sets.
sets. However, the required operations are easily ac­
accomplished with
ith the existing
existing instructions
instructions if the programmer
programmer simply gives the matter a
complished
thought.
little thought.
Exclusive-ORing a bit with
ith 'V
complements the bit since
'1' complements
1 -V-0
-¥-0== 1

and

1 -V-1
-¥-1 = 00

So the Exclusive-OR
function turns each 'O'
Exclusive-OR function
'O' bit into a '1' and each
each T
'1' bit into a 'O',
'O', just
like a logical complement
complement or inverse.
inverse. Note,
Note, however, that the instruction
instruction EOR
EOR
#% 1
1111111 occupies two bytes of memory, one for the operation code and one for
11111111
the mask.
explicit Complement
Complement instruction
instruction would require only one byte.
mask. An explicit
byte.
One
ith this approach is that the purpose of the instructions
instructions may not be im­
One problem with
immediately obvious. A reader would probably have
hat an Ex­
have to think about exactly what
Exclusive-OR function
function with an all-ones word actually does.
Adequate documentation
documentation is
does. Adequate
is
essential here,
clarify the situation.
here, and the
the use
use of macros can also
also help clarify

4-16
4-16

PROBLEMS
PROBLEMS
1)
1) 1 6-Bitit Data Transfer
Purpose:
contents of memory location 0040 to memory location 0042 and
Purpose: Move the contents
and
the
the contents of memory location 0041 to
to memory location 0043.
Sample Problem:

Result:

2)

(0040)
(0041)
(0041)

=
=

3E
3E
B7
B7

(0042)
(0043)
(0043)

=
=

3E
3E
B7

8 -Bit
it Subtraction

Purpose:
Subtract the contents
contents of memory location 0041 from the contents
contents of memory
Purpose: Subtract
location 0040. Place the result into memory location 0042.
Sample Problem:

Result:
Result:

3)

(0040)
(0041)
(0041)

=
=

77
39

(0042)
(0042)

=

3E

Shift Left T wo Bits

Purpose: Shift
Shift the contents
contents of memory location 0040 left tw o bits and place the result
into memory location 0041. Clear the two least significant
significant bit positions.
Sample Problem:
(0040)
Result:

4)

(0041)

5D
=

=

5D

74
'"/4

Mask Off Least Significant Four
Four Bits

Purpose: Place the four most significant
significant bits of the contents
contents of memory location 0040
location 0041. Clear the four least significant
significant bits of memory
into memory location
location 0041.
location
Sample Problem:
(0040)

Result:
It:

5)

(0041)

C4
=

=

C4

CO
CO

Set a M emory
ory Location to All Ones
Ones

Purpose: Memory
Memory location
location 0040
0040 is set to all ones (FF-|g).
(FF15).

6)

Word Assembly

Purpose: Combine
Combine the four
four least significant
significant bits of memory
memory locations
locations 0040
0040 and 0041
memory location
location 0042. Place the four
four least sigsig­
into a word and store them in memory
nificant bits of memory
memory location
location 0040
0040 into
into the four
four most significant
significant bit
bit posiposi­
nificant
tions of memory
memory location
location 0042;
0042: place the four
four least significant
significant bits of memomemo­
tions
location 0041 into
into the four
four least significant
significant bit
bit positions
positions of memory
memory localoca­
ry location
tion 0042.
Sample Problem:

Result:

(0040)
(0041)

= 6A
= B3

(0042)

= A3

4-17
4-17

7)
7)

Find Sm
Smaller of
of T w
Two Numbers
Numbers
Find

Purpose:
Purpose: Place
Place the
the smaller
smaller of
of the
the contents
contents of
of memory
memory locations
locations 0040
0040 and
and 0041
0041 in
in
memory
memory location
location 0042.
0042. Assume
Assume that
that memory
memory locations
locations 0040
0040 and
and 0041
0041 con­
contain unsigned
unsigned binary
binary numbers.
numbers.
tain
Sample Problems:
Problems:
Sample
a.

(0040) = 3F
(0040)
3F
(0041) = 2B
(0041)
2B
Resu
It: (0042)
(0042) = 2B
Result:
2B

b.
b.

(0040) = 75
(0040)
75
(0041) = A8
(0041)
AB
Result: (0042)
(0042) = 75
75
Result:

8)

2 4-Bit
-B it Addition

Purpose:
24-bit number
Purpose: Add the 24-bit
number in memory locations
locations 0040,
0040. 0041, and 0042 to the
the 24bit number in memory locations 0043,
significant
0043. 0044,
0044. and 0045. The most significant
significant eight
eight bits are in
In memory locations 0042 and 0045,
0045. the
the least significant
bits in memory locations 0040 and 0043. Store the
the result in memory loca­
locations 0046, 0047,
ith the most significant
significant bits in 0048 and the
0047. and
and 0048 with
least significant
least
significant bits in 0046.
Sample Problem:

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)

=
=
=
=
=

2A
67
35
FB
F8
A4
51
51

(0046)
(0047)
(0048)

=
=
=

22
oc
OC
87

=

that
Is. 35672A
that is,
35672A
+51A4F8
+51A4F8
870C22
870C22

9)

Sum of Squares

Calculate the squares of the contents
memory locations
locations 0040
0040 and 0041
Purpose: Calculate
conten-ts of memory
in memory
memory location
location 0042. Assume
and add them together. Place the result In
that memory
memory locations
locations 0040
0040 and 0041 both
both contain
that
contain numbers
numbers between
between 0 and
and
inclusive: 1.e
i.e.,0
and 00 <
4 1 )<
< 77. Use the table
of
7 inclusive
.0 <
< (0040) << 7 and
<( 0 0
(0041)
table of
squares from the example
of Squares.
Squares~
example entitled
entitled Table of

Sample Problem:
(0040)
(0041)

= 03
=
=
= 06

Result = (0042) = 2D
that
that is.
is, 32
32 + 52
62 = 9 + 36
36 == 45
45 == 2D15
2D-] e

418
4-18

10)

T wos Complement

Purpose: Place the twos complement
complement of the contents
contents of memory location
location 0040
0040 in
location 0041. The twos complement
complement is the ones complement
complement plus
memory location
one.
one.
Sample Problem:

Result:

(0040)

=

3E

(0041)

=

C2

The sum of the original
original number
number and its twos complement
complement is zero.
comple­
zero. So the twos complement of X is 0-X. Which
hich approach
approach (calculating
(calculating the ones complem
ent and adding
adding one,
ment
complement
one. or
subtracting from zero)
shorter and faster program?
subtracting
zero) results in a shorter

4 -19
19

Chapter 5
SIMPLE PROGRAM LOOPS
SIMPLE
LOOPS
The program
program loop
loop is the basic
basic structure that forces the CPU to repeat a sequence
sequence
of instructions.
instructions. Loops
Loops have four sections:
1)

that establishes the starting
starting values of counters, pointpoint­
The initialization section that
ers,
ers, indexes,
indexes, and other variables.

2)

The processing
anipulation occurs. This is the
processing section where the actual data manipulation
that does the work.
section that

3)
counters and indexes for the next iteration.
31 The loop
loop control section that updates counters
4)

The concluding
concluding section that analyzes and stores the results.
results.

Note that the computer
computer performs
performs Sections 1 and 4 only once while
hile it may perform Sec­
Sections 2 and 3 many times. Thus, the execution
execution time of the loop will
ill mainly
mainly depend on
the execution
execution time of Sections 2 and 3. You will
ill want
ant Sections
Sections 2 and 3 to execute as
quickly as possible;
possible: do not worry
worry about
about the execution
execution time of Sections 1 and 4. A typitypi­
quickly
cal program loop can be flowcharted
flowcharted as shown in Figure 5-1, or the positions of the pro­
processing and loop control
control sections may be reversed as shown in Figure 5-2. The process­
proces~ing section in Figure 5-1 is always executed at least once, while
hile the processing section
in Figure 5-2 may not be executed at all. Figure 5-1 seems more natural,
natural. but Figure 5-2
is often more efficient
efficient and avoids the problem of what
hat to do when there is no data (a
computers and the frequent
frequent cause of silly situations
situations like the computer
puter dundun­
bugaboo for computers
ning someone for a bill of $0.00).
The loop structure
structure can be used to process entire blocks of data. To accomplish
accomplish this,
this. the
increment an Index register after each iteration
iteration so that the effective
effective adad­
program must increment
dress of an indexed instruction
instruction is the next element
element in the data block. The next iteration
will
ill then perform the same operations
operations on the data in the next memory
memory location. The
computer
puter can handle blocks of any length (up to 256, since the Index registers are 8
ith the same set of instructions.
instructions. Indexed addressing is the key to processing
bits long) with
blocks of data with
ith the 6502 microprocessor, since it allows you to vary the actual (or
changing the contents
contents of Index registers. Note that in the
effective) memory address by changing
direct and immediate
mediate addressing modes,
completely determined
determined by
direct
modes, the address used is completely
the instruction
instruction and is therefore fixed if the program memory is read-only.

5 -1

Start

Initialization
Section

Processing
Section

Loop Control
Section

Concluding

Section

End

Figure 5-1. Flowchart
Flowchart of a Program Loop
Loop

55-2

Start

Initialization
Section

Loop Control
Section

Yes

Processing

Concluding

Section

Section

End

Figure 5-2. A Program Loop that Allow
Iterations
Allowss Zero Iterations

5-3

EXAMPLES
EXAMPLES
Sum of
of Data
Data
Sum
Purpose: Calculate
Calculate the
the sum
sum of
of aa series
series of
of numbers.
numbers. The
The length
length of
of
Purpose:
8-BIT
8-BIT
the series
series is
is in
in memory
memory location
location 0041.
0041. and
and the
the series
series
the
SUMMATION
SUMMATION
begins in
in memory
memory location
location 0042.
0042. Store
Store the
the sum
sum in
begins
memory location
location 0040.
0040. Assume
Assume that
that the
the sum
sum is
is an
an 8
-b it number
number so
so that
that vou
you
memory
8-bit
can ignore
ignore carries.
carries.
can
Sample Problem:
Problem:
Sample
(0041)
(0041)
(0042)
(0043)
(0044)
Result:
Result:

(0040)

03
28
28
55
26
26
(0043)
(0044)
(0042) + +
(0043)
+ +
(0044)
= 28+5
5+26
8+55+26
= A3

There are three entries
entries in the sum. since (0041)=03.
(0041)=03.

Flowchart:
Flowchart:
Start

Sum =0
Index= 0

Sum= Sum+
(0042+1ndax)

Index = Index + 1

(0040) = Sum

End

Note:
Note: (0042
(0042 ++ Index)
Index) isis the
the contents
contents of
of the
the memory
memory location
location whose
whose address
address isis the
the sum
sum
of
of 0042
0042 and
and Index.
Index Remember
Remember that
that on
on the
the 6502
6502 microprocessor,
microprocessor. 0042
0042 isis aa 16-bit
16-bit
address.
address. Index
Index isis an
an 8 -b
8-bit offset,
offset. and
and (0042
(0042 ++ Index)
Index) isis an
an 8 -b
8-bit byte
byte of
of data.
data.

5-4
5-4

Source Program:

SUMD
SUMO

LDA
LOA
TAX
CLC
ADC
INX
CPX
BNE
BNE
STA
BRK
BRK

##0

$42,X
$42,X
$41
$41
SUMD
SUMO
$40
$40

SUM
:SUM== ZERO
ZERO
:INDEX = ZERO
ZERO
:DO NOT INCLUDE
INCLUDE CARRY
CARRY
SUM = SUM++ DATA
:SUM=
INCREMENT INDEX
:INCREMENT
:HAVE ALL ELEMENTS
ELEMENTS BEEN
BEEN SUMMED?
:NO, CONTINUE
CONTINUE SUMMATION
YES, STORE
STORE SUM
:YES.

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
OOOB
0009
000A
OOOA
000B
OOOB

A9
00
AA
18
1B
75
42
E8
EB
E4
E4
41
DO
DO
F8
FB
85
B5
40
00

OOOC
oooc
000D

Instruction
Instruction
(Mnemonic)

SUMD
SUMO

LDA
LOA

#00

TAX
CLC
CLC
ADC

$42,X
$42,X

INX
CPX
CPX

$41
$41

BNE
BNE

SUMD
SUMO

STA

$40

BRK
BRK

The initialization
initialization section of the program is the first two instructions,
instructions, which
hich set the sum
and index to their starting
starting values.
contents of the Acc­
values. Note that TAX transfers the contents
cumulator
ulator to Index Register X but leaves
ulator as
leaves the Accum
Accumulator
as it was.
was. The base
base address
address
of the array and the location of the counter
counter are fixed within
ith in the
the program and need
need not
be initialized.
The processing section of the program consists of the single instruction
instruction ADC $42,X,
$42.X.
which adds the contents
contents of the effective
effective address (base
which
(base address plus Index Register X)
X) to
the
Accumulator. This instruction
instruction does the real
the contents of the Accumulator.
real work of the program.
program.
The CLC
instruction simply clears the Carry flag so that it does not affect the summa­
CLC instruction
summation.
contents of a new effective
effective address
tion. Note that each iteration of the loop adds in the contents
address
even
instructions do not change.
even though the instructions
The loop control section of the program consists of the
instruction INX.
instruction
the instruction
INX. This instruction
updates the Index register (by
(by 1)
1) so that
that the next
next iteration adds the
the next number to the
sum.
sum. Note that
that (0041)
(0041) - X tells
tells you how
how many iterations
iterations are
are left to
to be
be done.
done.
The
instruction BNE
The instruction
BNE causes
causes a branch if the
the Zero flag
flag is
is 0.
0. CPX
CPX sets
sets the
the Zero
Zero flag to
to 11 if
Index
Index Register X and the
the contents
contents of memory location
location 0041 are
are the same
same and to
to 0O if
they are
ent number
count begins from
are not.
not. The
The offset is
is a twos
twos complem
complement
number and
and the count
from the
the
memory location immediately
immediately follow
ing the BNE
instruction. In
following
BNE instruction.
In this
this case,
case. the required
jum
jump is
is from
from memory
memory location 000B
OOOBto
to memory location 0003.
0003. So'the
So'the offset is:
is:
0003
0003 =
-00
0 B ==
-OOOB

55-5

03
03
+F5
+F5
F8
FB

If the Zero flag is one. the CPU
CPU executes the next instruction
(STA $40).
$40).
instruction in sequence (STA
Since CPX $41 was the last instruction
BNE to affect
affect the Zero flag,
flag. BNE
BNE SUMD
SUMO
instruction before BNE
causes a branch
SUMO if CPX $41 does not produce a zero result;
result: that is.
is.
branch to SUMD
SUMO if (X)
(X) - (0041)
(0041) *~O
SUMD
0

{

(PC) =
(PC)
{

(X)-- (0041) =00
(PC)+2 if (X)

The 2 is caused by the two-word
BNE instruction.
two-word BNE
instruction. A single instruction
instruction combining
combining the
Decrement
set.
Decrement and the Jump
Jump would
would be a useful addition
addition to the 6502 instruction
instruction set.
The order in which
INX must come
which instructions
instructions are executed
executed is often very important.
important. INX
after
after ADC $42.X
$42,X or else the first
first number
number to be added to the sum will
ill be the contents of
memory
CPX $41 must
memory location
location 0043
0043 instead of the contents
contents of memory location
location 0042. CPX
come right
SUMO. since otherwise
CPX
right before BNE SUMD,
otherwise the Zero status setting
setting produced by CPX
could
instruction.
could be changed
changed by another
another instruction.
CPX and CPY are the same as CMP except that the contents
contents of memory are subtracted
from
Note. however,
however. that CPX
CPX and
and
from an Index register
register rather
rather than from the Accumulator.
ulator. Note,
(see Table 3-4).
3-4).
CPY offer
offer limited
limited addressing
addressing options
options (see
Most computer
computer loops count
count down
down rather than up so that the Zero flag can serve as
Most
as an
exit
eliminating
bit
exit condition.
condition, thus
thus elim
inating the need for a Compare instruction.
instruction. This method is a bit
awkward for people although
although it is used occasionally
occasionally in launch countdowns
countdowns and in a few
awkward
other
is
other situations.
situations. Remember that
that the Zero flag is set to 1 if the result of an instruction
instruction is
zero and to 0
O if the result is not zero.
zero.
Wee could
could easily revise the loop so that
that it works backward through
through the array (see
(see the
next
following
versions.
next flowchart).
flowchart). The follow
ing programs are revised versions.

Source Program:

SUMD
SUMO

LDA
LOA
LDX
LOX
CLC
ACD
DEX
BNE
BNE
STA
BRK
BRK

#0
#0
$41
$41
$41,X
$41.X
SUMD
SUMO
$40
$40

SUM
;SUM== ZERO
ZERO
INDEX = MAXIMUM
AXIMUM COUNT
;INDEX
COUNT
;DO NOT INCLUDE
INCLUDE CARRY
CARRY
SUM
:SUM== SUM + DATA
DECREMENT
;DECREMENT INDEX
INDEX
BRANCH BACK
;BRANCH
BACK IF ALL ELEMENTS
ELEMENTS NOT
NOT SUMMED
SUMMED
STORE
;STORE SUM

55-6

Note that
$42.X; the number
that the addition
addition instruction
instruction is now ADC $41,X
,X instead of ADC $42,X;
in the Index register
one
register is one larger than before. Clearly, the net result of subtracting
subtracting one
from
zero. The reorganized object pro­
profrom the base address and adding
adding one to the index is zero.
gram is:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000
000BB

A9
00
A6
41
18
75
41
CA
DO
DO
FA
85
40
00

oooc
oooc

Instruction
Instruction
(Mnemonic)

SUMO
SUMD

LOA
LDA

#0

LOX
LDX

$41
$41

CLC
CLC
ADC

$41,X

DEX
DEX
BNE
BNE

SUMD
SUMO

STA

$40

BRK
BRK

In most applications.
applications, the slight
slight time and memory differences
differences between one implementaimplementa­
another do not matter
matter very much. You should therefore select the ap­
tion of a loop and another
apthat is the clearest
clearest and easiest for you to use.
ill discuss program design
proach that
use. We will
efficiency later in Chapters
Chapters 13 and 15.
and efficiency
15.
wish to verify
verify the hexadecimal
hexadecimal values for the relative offsets in the last two
You may wish
final test of any calculations
calculations that you make is whether
hether the
programs. The final
the program runs
correctly. If. for whatever
whatever reason,
hexadecimal calculations
calculations fre­
correctly.
reason. you must perform hexadecimal
frequently. we suggest
suggest that
that you consider
consider a calculator
calculator (like the Texas Instruments
Instruments Program­
quently.
Programnumerous manual aids that
that are available.
mer) or one of the numerous

5-7
5-7

Flowchart (of reorganized summation program):
Start

Sum-0
Index - 10041I

Sum• Sum+
10041 +lndeK)

lndOK- lnde• -1

10040) - Sum

End

5-8

16
-B it Sum
Sum of Data
6-Bit
Calculate the sum
sum of a series
series of
of numbers. The length
length of the
the series is in
Purpose: Calculate
memory location
location 0042
0042 and the
the series itself
itself begins
begins in memory
memory location
location 0043.
Store the sum in memory locations
locations 0040
0040 and 0041 (eight
(eight least significant
significant
bits in 0040).
bits

Sample Problem:

(0042)
(0043)
(0044)
(0045)

=
=
=
=

03
C8
CB
FA
96

Result== C8
0258-|6
CB +
+ FA ++ 96 = 025816
(0040) = 58
(0041) =
= 02

Flowchart:
Flowchart:
Start

Base= 0043
Index= 0
Suml = 0
SumU = 0

Suml = Suml +
(Base + Index)

SumU = SumU
+1

Index = Index + 1

10040) = Suml
10041) = SumU

End

55-9

Source Program:

SUMD
SUMO

COUNT

ID
LDA
TAX
TAY
CLC
ADC
BCC
BCC
INY
INX
CPX
CPX
BNE
STA
STY
BRK
BRK

#00

$43,X
$43,X
COUNT

;SUM== ZERO
ZERO
;INDEX== ZERO
ZERO
;MSB'S OF SUM = ZERO
ZERO
;DO NOT INCLUDE
INCLUDE CARRY
CARRY
;SUM== SUM++ DATA

;ADD CARRY
CARRY TO MSB'S OF SUM
$42
SUMD
SUMO
$40
$41

;CONTINUE
;CONTINUE UNTIL ALL ELEMENTS
ELEMENTS SUMMED
;STORE
;STORE LSB'S OF SUM
;STORE
;STORE MSB'S OF SUM

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
OOOC
oooc
000D
000E
OOOE
000F
OOOF
0010
0011
0012
0013

A9
00
AA
A8
AB
18
75
43
90
01
C8
CB
E8
EB
E4
E4
42
DO
DO
F5
F5
85
40
84
41
41
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

SUMD
SUMO

COUNT

LDA

#00

TAX
TAY
CLC
CLC
ADC

$43,X
$43,X

BCC
BCC

COUNT
COUNT

INY
INY
INX
CPX
CPX

$42

BNE
BNE

SUMD
SUMO

STA

$40

STY
STY

$41
$41

BRK
BRK

The structure
structure of this program is the same
structure of the last example. The most
same as the structure
significant bits of the sum must now be initialized
initialized and stored. The processing section
significant
consists of four instructions
instructions (CLC;
including a con­
(CLC; ADC $43,X;
$43,X; BCC
BCC COUNT;
COUNT; and INY),
INY), including
condition jump.
dition
BCC
BCC COUNT
COUNT causes aa jump to
to memory location COUNT
COUNT if Carry== 0.
0. Thus, if there is no
carry from
addition, the program jumps around the
statement that
increments
from the 8-bitit addition.
the statement
that increments
the most significant
significant bits of the sum.
sum. The
The relative offset
offset is
is
000A
OOOA
-0009
09
0101
The relative
relative offset for
for BNE
BNE SUMD
SUMO is
0004
0004 =
-OOOF
-000F

0004
0004
-t-FFFl
+FFF1
F5
~

55-10

INY
contents of Index Register Y,
hich is used here as a temporary
temporary
\NY adds 1 to the contents
Y. which
addition. We could also use a memory location
location to
register to save the carries from the addition.
hold the carries,
instruction can be used to directly
directly increm
ent the concon­
carries. since the INC instruction
increment
tents of a memory
memory location.
You might
ight wish to try reorganizing
reorganizing this program so that
that it decrements
decrements the index down
to zero rather than increm
enting it. Which
hich version is faster
faster and shorter?
incrementing

------ ..

Relative branches
branches are limited
ited to short
short distances
distances (7F16
1 g or + 127
27
LONG
forward, 8 016
-| 6 orr -128 backward
backward from the end of the branch
branch inin­
CONDITIONAL
forward.
CONDITIONAL
struction). This limitation
itation is seldom important.
portant, since most propro­
struction).
BRANCHES
gram branches
branches are short. However,
conditional
However. if you need a conditional
ith a greater
greater range,
invert the condition
condition logic and branch
branch with
range. you can always invert
instruction. For example.
example, to branch
branch to location
location FAR
around a JMP instruction.
FAR if Carry== 0, use the
sequence
BCS
8CS
JMP

NEXT
NEXT
FAR
FAR

NEXT
NEXT
NEXT is the address immediately
mediately follow
ing the last byte of the JMP instruction.
instruction. JMP
following
allows only absolute
absolute (direct) and indirect
indirect addressing.
allows

5 -11

Number of Negative
egative Elements
Elements
Number
Purpose: Determine
Determine the number
number of negative
negative elements
elements (most significant
significant bit
bit 1) in a
length of the
the block
block is in memory
memory location
location 0041 and the block itself
itself
block. The length
starts
starts in memory
memory location
location 0042.
0042. Place the number
number of negative
negative elements
elements in
memory location
location 0040.
memory
Sample Problem:

Result:
It:

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)

=
=
=
=
=
=
=

06
68
F2
87
30
59
2A

(0040)

=

02, since 0043
0043 and 0044
0044 contain
contain
02.
numbers with
1.
ith an MSB of 1.

Flowchart:
Flowchart:
Start

Nneg = 0
Base= 0042
Index= 0

Nneg = Nneg + 1

Index = Index + 1

{0040) = Nneg

End

5-12
5 -1
2

Source Program:

SRNEG

CHCNT

LDX
LOX
LDY
LOY
LDA
LOA
BPL
INY
\NY
INX
CPX
BNE
BNE
STY
BRK
BRK

#00
#00
$42,X
$42.X
CHCNT

;INDEX = ZERO
ZERO
;NUMBER OF NEGATIVES
NEGATIVES== ZERO
ZERO
;IS NEXT ELEMENT
ELEMENT NEGATIVE?
NEGATIVE?
;YES,
;YES. ADD 1 TO NUMBER OF NEGATIVES
NEGATIVES

$41
SRNEG
SRNEG
$40

iCONTINUE
;CONTINUE UNTIL ALL ELEMENTS
ELEMENTS EXAMINED
;SAVE NUMBER
NUMBER OF NEGATIVES
NEGATIVES

Object Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
OOOB
000C
oooc
000D
000E
OOOE
000F
OOOF
0010

A2
00
AO
00
B5
42
10
01
C8
CB
E8
EB
E4
E4
41
41
DO
DO
F6
F6
84
40
00

Instruction
Instruction
(Mnemonic)

SRNEG
SRNEG

CHCNT
CHCNT

LDX
LOX

#00

LDY
LOY

#00

LDA
LOA

$42,X
$42.X

BPL
BPL

CHCNT
CHCNT

INY
INX
CPX
CPX

$41

BNE
BNE

SRNEG
SRNEG

STY
STY

$40

BRK
BRK

LDA
immediately check
LOA affects the Sign (S)
(S) and Zero (Z)
(Z) status flags. Therefore,
Therefore. we can immediately
to see
number that
that has
see if a number
has been loaded is negative or zero.
zero.
BPL,
Branch-on-Plus, causes a branch over the specified
specified number
number of locations
locations if the Sign
BPL. Branch-on-Plus.
(or Negative) bit is zero.
zero. A sign bit of zero
zero may indicate
indicate a positive
positive number
number or may just in­
indicate the value of the most significant
significant bit position;
position; the interpretation
interpretation depends on what
what
the numbers mean.
mean.
The offset for BPL
calculated from the first memory location
location follow
ing the
two-byte
BPL is calculated
following
the two-byte
instruction.
instruction. Here
Here the
the offset is simply from
from 0008 to
to 0009,
0009. or one location (i.e.,
(i.e.. the
the INY
\NY in­
instruction is skipped if the Negative bit is zero).
ill be
struction
zero). The Negative bit will
be zero
zero if the
the most
most
significant bit of
$42,X instruction
instruction is zero.
significant
of the data loaded from memory by the LDA
LOA $42.X
zero.
Remember that negative-signed
negative-signed numbers all have
significant bit (bit 7)
have a most significant
7) of 1.
1. All
negative
actually larger,
negative numbers
numbers are
are actually
larger. in the
the unsigned sense,
sense. than positive numbers.
numbers.

55-13

M axim
Maximum Value
Value
Purpose:
Purpose: Find
Find the
the largest
largest element
element in
in aa block
block of
of data.
data. The
The length
length of
of the
the block
block is
is in
in
memory
memory location
location 0041
0041 and
and the
the block
block itself
itself begins
begins in
in memory
memory location
location 0042.
0042.
Store
Store the
the maximum
maximum in
in memory
memory location
location 0040.
0040. Assume
Assume that
that the
the numbers
numbers in
in
the
the block
block are
are all
all 88-bit unsigned
unsigned binary
binary numbers.
numbers.
Sample Problem:
Problem:
Sample
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

Resu
It: (0040)
(0040) =
Result:

05
05
67
67
79
79
15
15
E3
E3
72
72
E3.
E3. since this is
is the
the largest of
the
the five
five unsigned numbers.
numbers.

Flowchart:
Start

Base= 0041
Index = (00411
Max= 0

Max = (Base+lndex)

Index = Index -1

(00401 = Max

End

514
5-14

Source Program:
Program:

MAXM
MAXM

NOCHG
NOCHG

LDX
LOX
LDA
LOA
CMP
CMP
BCS
BCS
LDA
LOA
DEX
DEX
BNE
BNE
STA
STA
BRK
BRK

$41
$41
#0
$41,X
$41,X
NOCHG
NOCHG
$41,X

;GET
:GET ELEMENT
ELEMENT COUNT
COUNT
:MAXIMUM
;MAXIMUM= =ZERO
ZERO (MINIMUM POSSIBLE
POSSIBLEVALUE)
VALUE)
;IS
MAXIMUM?
:IS NEXT
NEXT ELEMENT
ELEMENT ABOVE
ABOVE MAXIMUM?
;NO.
;NO, KEEP
KEEPMAXIMUM
:YES,
;YES, REPLACE
REPLACE.MAXIMUM
,MAXIMUM WITH ELEMENT
ELEMENT

MAXM
$40

CONTINUE
;CONTINUE UNTIL
UNTIL ALL ELEMENTS
ELEMENTS EXAMINED
EXAMINED
;SAVE
MAXIMUM
;SAVE MAXIMUM

Object Program:
Object
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008
000C
oooc
000D
000E
OOOE
000F
OOOF

A6
41
41
A9
00
D5
41
41
BO
BO
02
B5
85
41
CA
DO
DO
F7
85
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonicl

MAXM

NOCHG
NOCHG

LDX
LOX

$41
$41

LDA
LOA

#0

CMP
CMP

$41,X

BCS
BCS

NOCHG
NOCHG

LDA
LOA

$41,X

DEX
DEX
BNE
BNE

MAXM

STA

$40

BRK
BRK

The relative offset
offset for BCS
BCS NOCHG
NOCHG is:
is:
000A
OOOA
-0008
-0008
02

The relative offset for BNE
BNE MAXM is:
is:
0004
0004
-000D
-000D

=

04
+F3
F7
F7

first twoo instructions
instructions of this program form the initialization
initialization section.
The first
program takes advantage
advantage of the fact
fact that
that zero is the smallest
smallest 8-bit
-b it unsigned
unsigned binary
This program
hen you set the register that
that contains
contains the maximum
maximum value -— in this case,
number. When
case,
ulator — to the
the m
inimum possible
possible value
value before
the Accum
Accumulatorminimum
before you
you enter
enter the loop,
loop, then the
program will
ill set the Accum
ulator to a larger
larger value unless all the elements
the array
array
program
Accumulator
elements inin the
are zeros.
program works
works properly
properly if there are twoo elements
elements in the array, but
but not if
zeros. The program
only one or none at all. Why?
Why? How could
could you solve this problem?
there is only
instruction CMP $41.X
$41,X sets the Carry flag as follows
follows where
where ELEMENT
con­
The instruction
ELEMENT is the coneffective address and MAX
MAX is the contents
contents of the Accum
ulator:
tents of the effective
Accumulator:
Carry = 00 ifif ELEMENT
ELEMENT >> MAX
MAX
Carry== 1 if ELEMENT
X
ELEMENT< M A
_:<::;MAX

515
-15

Remember that
that the
the carry
carry is
is an
an inverted
inverted borrow.
borrow. IfIf Carry
Carry = 1, the
the program
program proceeds
proceeds to
Remember
address NOCHG
and does
does not
not change
change the
the maximum.
maximum. If Carry
0, the program
program replaces
replaces
address
NOCHG and
Carry== 0.
aximum w
ith the current
current element
element by
by executing
executing the
the instruction
instruction LOA
LDA $41.X.
$41.X.
the old m
maximum
with
program does not
not work
work if the
the numbers
numbers are signed.
signed, because negative
negative numbers
numbers will
ill
The program
appear to be larger
larger than
than positive
positive numbers. This
This problem
problem is somewhat
somewhat tricky
tricky because a
appear
twos complem
ent overflow
overflow could
could make the sign
sign of
of the result
result incorrect.
incorrect. A further
further probprob­
twos
complement
lem is
is that
that the CMP instruction
instruction does not
not affect
affect the
the Overflow
Overflow flag. A program
program for
for signed
lem
numbers would
would therefore
therefore have to use the SBC instruction
instruction and check
check both
both the Sign and
numbers
Overflow flags. The Carry flag would
would have to be set to 1 before the subtraction
subtraction
the Overflow
(remember that
that Carry is an inverted
inverted borrow
borrow and the SBC instruction
instruction inverts
inverts it before
(remember
subtracting it).
it), and an addition
addition would
would be required
required to restore the original
original value of the
subtracting
maximum. Note how convenient
convenient it is in the example
example that
that CMP does not
not actually
actually change
maximum.
contents of the Accumulator.
Accumulator.
the contents

55-16

Justify a Binary Fraction
Justify
Purpose: Shift
Shift the contents
contents of memory location 0040
0040 left until
until the most significant
significant bit
number is 1.
of the number
1. Store the result in memory location 0041 and the number
contents of memory
of left shifts required in memory location 0042. If the contents
0040 are zero,
location 0040
zero. clear both 0041 and 0042.
Note: The process is just
just like converting
converting a number to a scientific
scientific notation:
notation: for example:

3
= 5.7 Xx 100.0057 =
O'3
Sample Problems:
a.
a.
Result:
Result:
b.
b.
Result:
Result:
c.
c.
Result:
Result:

d.
Result:
Result:

(0040)
(0040)

=

22

(0041)
(0041)
(0042)
(0042)

=

=

88
02

(0040)
(0040)

=

01
01

(0041)
(0041)
(0042)
(0042)

=

=

80
07

(0040)
(0040)

=

CB
cs

(0041)
(0041)
(0042)
(0042)

=
=

CB
CB
00

(0040)
(0040)

=

00

(0041)
(0041)
(0042)
(0042)

=
=

00
00

Flowchart:
Flowchart:
Start

Nshft = 0
Numb = 10040)

Shift Numb

10041 I = Numb
100421 = Nshft

left 1 bit

Nshft = Nshft + 1

End

55-17

Source Program:
Program:

CHKMS
CHKMS

DONE
DONE

LDY
LOY
LDA
LOA
BEQ
BEO
BMI
BM!
INY
!NY
ASL
JMP
STA
STY
STY
BRK
BRK

#00
$40
DONE
DONE
DONE
DONE
A
CHKMS
CHKMS
$41
$42

;NUMBER
;NUMBER OF SHIFTS
SHIFTS =0
;GET
;GET DATA
;DONE
;DONE IF DATA IS ZERO
ZERO
;DONE
;DONE IF MSB IS ONE
ONE
;ADD 1 TO NUMBER
NUMBER OF SHIFTS
SHIFTS
;SHIFT
;SHIFT LEFT
LEFT ONE
ONE BIT
;SAVE JUSTIFIED
JUSTIFIED DATA
;SAVE NUMBER
NUMBER OF SHIFTS
SHIFTS

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
OOOB

AO
00
A5
40
FO
FO
07
30
05
C8
CB
OA
4C
06
00
85
41
84
42
00

OOOC
oooc
000D
000E
OOOE
000F
OOOF
0010
0011

Instruction
Instruction
(Mnemonic)

CHKMS
CHKMS

DONE
DONE

LDY
LOY

#00

LDA
LOA

$40

BEQ
BEO

DONE
DONE

BMI

DONE
DONE

INY
ASL
JMP

A
CHKMS
CHKMS

STA

$41

STY
STY

$42

BRK
BRK

BMI DONE
location DONE
condition may
DONE causes a branch to location
DONE if the Sign bit is 1.
1. This condition
mean that the last result was a negative
negative number.
number, or it may just
just mean that its most sigsig­
nificant bit was 1 —
puter only supplies the results; the programmer
programmer must propro­
nificant
- the computer
interpretation.
vide the interpretation.
ASL A shifts
shifts the contents
contents of the Accum
ulator left one bit and clears the least significant
significant
Accumulator
bit.
JMP is an unconditional
unconditional branch instruction
instruction that
that always places a new value in the ProPro­
gram Counter. It only allows absolute (direct) or indirect
indirect addressing. The indirect
indirect mode
provides fle xib
ility since the actual
actual destination
destination address can be stored in RAM. Note that
that
provides
xibility
there is no relative addressing and no special page-zero modes.
modes.
The address in the JMP instruction
instruction is stored in tw o successive memory locations with
ith
the least significant
significant bits first
first (at the lower address).
which
address). This is the standard way in which
the 6502 microprocessor
microprocessor expects to find addresses,
whether they are part
addresses. regardless of whether
of instructions
instructions or are used indirectly.
indirectly. The same upside-down
upside-down method is used in the
8080, 8085.
8085, and Z80 microprocessors.
microprocessors, but the opposite
opposite approach
approach (most significant
significant bits
8080.
6800 microprocessor. Note that an address occupies two bytes of
first) is used on the 6800
memory, although
although there is a single byte of data located at that address.
memory.
address.

5 -18
8

We could
could reorganize
reorganize this program
program so as to eliminate
eliminate the extraneous
extraneous JMP instruction.
instruction.
One reorganized
reorganized version
version would
ould be:

CHKMS

DONE
DONE

LDY
LDA
BEQ
BEO
INY
ASL
BCC
BCC
ROR
ROR
DEY
DEY
STA
STY
BRK
BRK

#0
$40
DONE
DONE
A
CHKMS
A
$41
$41
$42

:NUMBER OF SHIFTS
SHIFTS== 0
:GET DATA
DATA IS ZERO
;DONE IF DATA
ZERO
:ADD 1 TO NUMBER OF
OF SHIFTS
SHIFTS
:SHIFT LEFT
LEFT ONE BIT
:CONTINUE IF MSB NOT ONE
ONE
OTHERWISE. SHIFT BACK ONCE
:OTHERWISE,
ONCE
:AND IGNORE
IGNORE EXTRA SHIFT
SHIFT
:SAVE JUSTIFIED
JUSTIFIED DATA
;SAVE NUMBER OF SHIFTS
SHIFTS

version shifts
shifts the data until
until the Carry becomes 1.
adjusts the data and the
This version
1. Then it adjusts
number of shifts
shifts back one since the last shift
shift was not really necessary. Show
Show that
that this
number
hat are its advantages
advantages and disadvantages
disadvantages as compared
compared to the
version is also correct. What
previous
ight wish to try some other
organizations to see how they
previous program?
program? You might
other organizations
compare in execution
execution time and memory
memory usage.
compare
usage.

5 -19
9

Post-Indexed (Indirect) Addressing
Addressing
We have already noted the additional
additional flexib
ility provided
provided by
flexibility
POST-INDEXED
POST-INDEXED
instructions can be
the indexed addressing mode.
mode. The same instructions
(INDIRECT)
used to process each element
element in an array or table. But even
ADDRESSING
more flexib
ility is provided by the post-indexed
post-indexed addressing
flexibility
MODE
mode in which
hich the instruction
instruction only specifies the address on
page zero that
that contains
contains the base address of the table or array.
array. Now the same program
can handle an array or table located anywhere
anywhere in memory. All that we have to do is
place the starting
starting address in the appropriate
appropriate locations on page zero.
start­
zero. Note that the starting address occupies two bytes of memory,
ith the least significant
significant byte first (at the
memory. with
address). Post-indexing
Post-indexing requires extra clock cycles (six
lower address)
(six as compared to four for
the zero-page indexed
indexed mode)
mode) but provides tremendous
tremendous additional
additional flexibility.
flexibility. Entire
Entire arar­
rays need
notbe
bemoved.
moved, nor
nor are
are repeated
repeated versions
versions of
of the
the same
same program
program required.
need not
required.
ith Index Register Y. So the maxmax­
Post-indexed (indirect) addressing can only be used with
ith post-indexed
post-indexed addressing is as follows.
follows, assuming that the
imum value program with
location 0041 and its starting
starting address is in memory
length of the array is in memory location
locations 0042 and 0043.
For example,
example.
(0041)
(0042)
(0043)
(0044)
(0045)
(0045)
(0046)
(0047)
(0048)

= 05
05
= 43
43 (LSBs
(LSBsofof starting
starting address
address minus
minus one)
one)
= 00
00 (MSBs
(MSBsofofstarting
starting address
address minus
minus one)
one)
= 67
67 (first
(first element
element inin array)
array)
= 79
79
= 15
15
= E3
E3
= 72
72

ResultIt = (40)
(40) = E3 since this is the largest
of the 5 unsigned numbers.

Source Program:
Program:

MAXM

NOCHG
NOCHG

LDY
LOY
LDA
LOA
CMP
BCS
BCS
LDA
LOA
DEY
DEY
BNE
BNE
STA
BRK
BRK

$41
$41
#0
($42),
($42).Y
NOCHG
NOCHG
($42).Y
($42),Y

;GET
ELEMENT COUNT
COUNT
;GET ELEMENT
iM AXIM
UM = ZERO
;MAXIMUM=
ZERO (MINIMUM POSSIBLE
POSSIBLEVALUE)
VALUE)
;IS NEXT
MAXIMUM?
NEXT ELEMENT
ELEMENT ABOVE MAXIMUM?
;NO,
MAXIMUM
;NO. KEEP
KEEP MAXIMUM
;YES,
MAXIMUM WITH ELEMENT
ELEMENT
;YES. REPLACE
REPLACE MAXIMUM

MAXM
$40

;CONTINUE
;CONTINUE UNTIL ALL ELEMENTS
ELEMENTS EXAMINED
EXAMINED
;SAVE MAXIMUM
MAXIMUM

5 -20
0

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0004
0005
0006
0006
0007
0007
0008
0008
0009
000A
OOOA
000B
OOOC
oooc
000D
OOOD
000E
OOOE
000F
OOOF

A4
41
A9
00
D1
D1
42
BO
BO
02
B1
B1
42
88
DO
DO
F7
85
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

MAXM
MAXM

NOCHG
NOCHG

LDY

$41

LDA

#00

CMP

($42).Y
($42),

BCS
BCS

NOCHG
NOCHG

LDA

($42),Y

DEY
DEY
BNE
BNE

MAXM
MAXM

STA

$40

BRK
BRK

indirect address (in memory
memory locations
locations 0042
0042 and 0043) is stored in the usual 6502
The indirect
fashion, with
ith the least significant
significant bits first
first (at the lower address).
address).
We could use the same program
program to find the maximum
aximum element
element in an array of 5 entries
starting in memory
memory address 25E1. Allll that
that we would
would have to do is change
change the indirect
indirect
starting
executing the program.
program, that is,
address to 25E0
25EO before executing
is,
(0042) = E0
starting address minus one)
EO (LSBs
(LSBs of starting
one)
(0043) = 25 (MSBs
starting address minus one)
(MSBs of starting
one)
How would
would you handle the array starting
starting in memory address 25E1
25E1 if the program used
ordinary indexed addressing
addressing (as
that the program is in
ordinary
(as in the earlier example)? Assume that
ROM
that you cannot
cannot change
change the addresses in the instructions.
instructions.
ROM so that

5 -21

Pre-lndexed (Indirect)
(Indirect) Addressing
Addressing
Pre-Indexed
The pre-indexed
pre-indexed addressing
addressing mode
mode gives
gives you
you aa different
different kind
kind of
The
PRE-INDEXED
PRE-INOEXED
flexibility. This
This method
method allows
allows you
you to
to choose
choose one address from
from
(INDIRECT)
flexibility.
table of
of addresses, rather
rather than
than being
being limited
limited to
to a particular
particular
ADDRESSING
a table
ADDRESSING
memory address. For example,
example, rather
rather than having
having memory
memory
memory
MODE
MODE
location 0041
0041 contain
contain the length
length of
of the
the array in
in the maximum
m aximum
location
could let
let it contain
contain the index
index of the address that
that contains
contains the length
length of
of the
problem, we could
array. The table
table of addresses must
must be located somewhere
somewhere on page zero.
zero, perhaps startstart­
memory address 0060,
0060, that
that is
ing at memory
(0060) =
= 2F '
(0060)
•in w hich
h'Ich counter
d
ddress in
counter #O
# 0 •is
(00
) = 2F} • add
1sstored
(0061) = 000
(0062) =
= 801
.in wh1c
• h counter
(0062)
ddress
hich
counter #
#11 •is
(00
) = 80} add
1sstored
ress in
(0063) = 00 (
(0064) =>A5}
A 5 ( dd
h. h counter #2
(0064)
ddress •in hich
# 2 •is
Is storedd
(006
(0065)) =
; 00 a ress in w Ic counter

(

One problem
problem is that
that addresses occupy
occupy two bytes of memory
memory so that
that you must multiply
ultiply
counter number
number by twoo before applying
applying the pre-indexed
pre-indexed addressing mode. Note
the counter
that all addresses are stored in the usual 6502 manner, with
ith the least significant
significant bits
that
addressing is not as useful as post-indexed
post-indexed addressing, but it does
first. Pre-indexed addressing
come in handy occasionally.

55-22

PROBLEMS

1)

Checksum of Data

Purpose: Calculate
series is in
Calculate the checksum
checksum of a series of numbers. The length of the series
memory
memory location
location 0041 and the series itself begins in memory location 0042.
Store the checksum
checksum in memory location
location 0040. The checksum is formed by
Exclusive-ORing
Exclusive-ORing all the numbers in the series together.
Note: Such checksums
ensure
checksums are often used in paper tape and cassette systems to ensure
that
to
that the data has been read correctly. The calculated
calculated checksum is compared to
the one stored with
agree. the system
ith the data -— if the two checksums do not agree,
automatically
read the data
data
will
ill usually
usually either
either indicate
indicate an error to the operator or autom
atically read
again.
Sample Problem:

Result:

2)

(0041)
(0042)
(0043)
(0044)

= 03
03
= 28
28
= 55
55
= 26
26

(0040)

(0042)©EB(0043)
(0043)©EB(0044)
(0044)
= (0042)
= 28 ©
555
5 ©
226
6
EB
EB
0101000
= 00 1
0 1000
©
EB 0 1 0
1010101 1 0 1
0 11
1110 1
1111101
© 00
1 0 0 1 10
EB00100110
0 10
1 1 0 11
1011011
= 58
5B

Sum of 16-Bit
-B it Data

Calculate the sum of a series of 16-bit
16-bit numbers. The length of the series
Purpose: Calculate
series is in
in
memory location
location 0042
0042 and the series itself begins in memory location 0043.
memory
0040 and 0041 (eight most significant
significant
Store the sum in memory locations 0040
16-bit number
number occupies two memory locations,
bits in 0041).). Each 16-bit
locations. with the
eight most significant
significant bits in the higher address.
eight
address. Assume that the sum can
can
contained in 16 bits.
be contained

Sample Problem:
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)

= 03
= Fl
F1
= 28
= 1A
= 30
= 89
= 48
4B

301A +
4B89 =A494
=A494
Result: 28F1
28F1 +
+ 301A
+ 4889
(0040) = 94
(0041) = A4

55-23

3)

Positive, and Negative
egative Numbers
Number of Zero, Positive,

zero. positive
Purpose: Determine
Determine the number
number of zero,
positive (most significant
significant bit
bit zero but entire
number
zero). and negative
number not zero),
negative (most significant
significant bit 1) elements
elements in a block.
The length
length of the block is in memory location
location 0043
0043 and the block itself
itself starts
in memory
memory location
location 0044. Place the number
number of negative
negative elements
elements in memory
location
location 0040.
0040, the number
number of zero elements
elements in memory location
location 0041.
0041, and
the number
number of positive
positive elements
elements in memory location
location 0042.
Sample Problem:
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)

=
=
=
=
=
=
=

06
68
F2
87
00
59
2A

Result: 2 negative. 1 zi
zero. and 3 positive. so
Result:
(0040) = 02
(0041) = 01
(0041)
(0042)
(0042) = 03

4)

Find
Find M inimum

Purpose: Find the smallest element
element in a block of data. The length of the block is in
memory location 0041 and the block itself begins in memory location 0042.
Store the m inim
um in
in memory location 0040. Assume that the numbers in
inimum
the block are 8-bitit unsigned binary numbers.
numbers.
Sample Problem:
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
Result:
It:

5)

(0040)
(0040)

05
67
79
15
15
E3
E3
72
=

15. since this
this is the smallest of the
15,
numbers.
five unsigned numbers.

Count 1 Bits

are ones and place the
Purpose: Determine how many bits in memory location 0040 are
result in memory location 0041.

Sample Problem:

Result:
Result:

(0040)
(0040)

=

3B
38 == 00111011

(0041)
(0041)

=

05
05

55-24
-24

Chapter 6
CHARACTER-CODED DATA
CHARACTER-CODED
Microprocessors often handle character-coded data. Not only do keyboards,
teletypew
riters, communications devices, displays,
ex­
teletypewriters,
displays, and computer terminals exst systems, and
pect or provide character-coded data, but many instruments, test
controllers also require data in this form. The most commonly used code is ASCII.
Baudot and EBCDIC are found less frequently.
frequently. We will
ill assume all of our charactercoded data to be 7-b
ith the most significant bit zero (see Table 6-1).
7-bitit ASCII with
remember in handling
ASCII-coded data
Some principles to remember
handling ASCII-coded
are:
1)

HANDLING
HANDLING
DATA IN
ASCII

The codes for the numbers and letters
letters form ordered subsub­
sequences. The codes for the decimal
decimal numbers are 3015
30^6
through 3915
39-|6 so that you can convert
convert between decimal
decimal and ASCII
ith a simple
through
ASCII with
additive factor. The codes for the upper case letters are 417
115
q through
through 5A7i 6 so that
additive
you can do alphabetic
alphabetic ordering
ordering by sorting
sorting the data in increasing numerical
numerical order.
order.

2)
between printing and non-printing charac­
21 The computer draws no distinction between
characters. Only the I/O
distinction.
1/0 devices make that distinction.
3)

An ASCII device will
ill handle only ASCII data. To print
rint a 7 on an ASCII
ASCII printer,
printer.
the microprocessor
microprocessor must send
-|g to the printer;
printer; 0716
07-|g is the 'bell'
'bell' character.
eend 3 716
Similarly, the microprocessor
microprocessor will
ill receive the character
character 9 from an ASCII
Similarly,
ASCII keyboard
as 3 9
-|g; 0915
09-|6 is the 'tab' character.
915;

4) Some
Some ASCII
ASCII devices
devices do
do not
not use
use the
the full
full character
character set.
set, For
For example,
example. control
control
characters and lower case letters may be ignored or printed as spaces or question
characters
marks.
marks.
5) Some
idely used
Some wwidely
used ASCII
ASCII characters
characters are:
are:
OAi
0A15e - line feed (LF)
(LF)

0D15
(CR)
0D-|6 -■ carriage return (CR)
2 015
ig - space
3F-|6
mark)
3F15 - ? (question mark)
7F
i0 - rubout
rubout or delete character
character
F15

6)

Each ASCII character occupies eight bits.
character set but is
bits, This allows a large character
wasteful when the data is limited
limited to a small subset such as the decimal
decimal numbers.
wasteful
An 8-bit
-b it byte, for example,
decimal digit.
digit, while
hile it
example. can hold only one ASCII-coded decimal
can hold twoo BCD-coded digits.

6 -1

Table 6-1.
6-1. Hex-ASCII
Table
Hex-ASCIITable
Table

~

0

,

2

3

4

SP

0

@

!

1

A
B
C
D
E
F
G
H
I

6

7

p

'

Q

a
b

p
q

6

D

,

0

2
3
4
6

6
7
8
9
A
B
C

D
E
F

NUL
SOH
STX
ETX
EOT
ENO
ACK
BEL
BS
HT
LF
VT
FF
CR

so
SI

DLE
DC1
DC2
DC3
DC4
NAK
SYN
ETB
CAN
EM
SUB
ESC
FS
GS
RS

us

,,

2

3
4

#
$

%
&

5
6
7
8
9

(

.
)

+

<
=

-

>

I

?

6-2

R

s

T

u

C

r
s

d

t

e

u

V

f

V

w

X

g
h

y
z

w
y

J

z

K
L
M
N

[

i
j
k

\

I

]

m
n

0

-

A

0

X

I
I
}

DEL

EXAMPLES
Length
Length of a String of Characters
Purpose: Determine
Determine the length
length of a string of ASCII characters
characters (seven bits with
ith most
significant bit zero).
string starts in memory
memory location
location 0041;
0041; the end of
significant
zero). The string
the string
string is marked by a carriage return character
character CCR',
ODig). Place the
('CR', 0015).
length of the string
string (excluding
(excluding the carriage return) into memory
memory location
length
0040.

Sample Problems:
a
Result:

b

Result:
It:

(0041)

=

0D
OD

(0040)

=

00

first character
character is a carriage
carriage return.
since the first

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)

=
=
=
=
=
=
=

52
41
54
48
45
52
OD
OD

'R'
■R
'A'
T
'H'
T
'E'
'R'
CR
CR

(0040)

=

06

Flowchart:
Flowchart:
Start

Base= 0041
Length= 0

Yes

Length = Length

(0 040)
0 ) = Length

+1

C

6-3

End
E
nd

)

Source Program:
Program:

CHKCR

DONE

LDX
LOX
LDA
LOA
CMP
BEQ
BEO
INX
JMP
STX
BRK
BRK

;STRING
= ZERO
ZERO
;STRING LENGTH
LENGTH =
;GET ASCII
ASCII CARRIAGE
CARRIAGE RETURN
RETURN TO COMPARE
COMPARE
:GET
;IS
:IS CHARACTER
CHARACTER A CARRIAGE
CARRIAGE RETURN?
RETURN?
;YES,
:YES. DONE
DONE
;NO,
:NO. ADD 1 TO STRING
STRING LENGTH
LENGTH

#00
# $0D
0D
$41,X
$41.X
DONE
DONE
CHKCR
CHKCR
$40

;SAVE
:SAVE STRING
STRING LENGTH
LENGTH

Object Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008
o ooc
oooc
000D
000E
OOOE

A2
00
A9
OD
OD
D5
41
FO
FO
04
E8
ES
4C
04
00
86
40
00

Instruction
Instruction
(Mnemonic)

CHKCR
CHKCR

DONE
DONE

LDX
LOX

#0

LDA
LOA

# $0D
0D

CMP

$41,X
$41.X

BEQ
BEO

DONE
DONE

INX
JMP

CHKCR
CHKCR

STX
STX

$40

BRK
BRK

The carriage return character. 'CR',
just another
another ASCII
q as far as the comcom­
'CR', is just
ASCII code (ODi
(0D15)
puter is concerned. The fact that this character
character causes an output
output device to perform a
puter
control function
function rather than print
print a symbol
symbol does not affect
affect the computer.
control
The Compare instruction.
instruction. CMP,
subtraction had been performed
CMP. sets the flags as if a subtraction
character in the Accum
ulator for later comparisons. The
but leaves
leaves the carriage return character
Accumulator
Zero (Z)
affected as follows:
follows:
(Z) flag is affected
Z=
=1

if the character
character in the string is a carriage return

Z =
=0

if it is not a carriage return

The instruction
instruction INX adds 1 to the string
string length counter
counter in Index Register X. LDX
LOX #00 in­
initializes this counter
counter to zero before the loop begins. Remember to initialize
initialize variables
before using them in a loop.
loop.
This loop does not terminate
inate because a counter
counter is decremented
decremented to zero or reaches a
maximum value. The computer
puter will
ill simply
until it finds
maximum
simply continue
continue examining
examining characters
characters until
a carriage return. It is good programming
programming practice
practice to place a maximum
maximum count
count in a loop
like this to avoid problems with
ith erroneous strings
strings that do not contain
contain a carriage return.
What
hat would
ould happen if the example program were used with
ith such a string?

6-4
6-4

Note that
that by rearranging
rearranging the logic and changing
changing the initial
initial conditions,
conditions, you can shorten
program and decrease its execution
execution time. If we adjust
adjust the flowchart
chart so that
that the pro­
the program
program increments
increments the string
string length
length before it checks for the carriage return, only one
Jumpp instruction
instruction is necessary instead of two. The new flow
chart and program are as
flowchart
follows:
follows:

Start

Base= 0041
Length= -1

Length = Length
+1

100401 =Length

End

Source Program:

CHKCR

LDX
LOX
LDA
LOA
INX
CMP
BNE
BNE
STX
BRK
BRK

#$FF
#$ 0D
D
$41,X
CHKCR
CHKCR
$40

:STRING
;STRING LENGTH
LENGTH =
= -1
:GET
;GET ASCII CARRIAGE
CARRIAGE RETURN
RETURN TO COMPARE
COMPARE
;ADD 1 TO STRING
STRING LENGTH
LENGTH
;IS CHARACTER
CHARACTER A CARRIAGE
CARRIAGE RETURN?
RETURN?
;NO, CHECK
CHECK NEXT CHARACTER
CHARACTER
;YES.
LENGTH
;YES, SAVE STRING
STRING LENGTH

shorter and faster, but it also contains
contains no absolute
absolute destination
destination
This version is not only shorter
addresses:
anywhere in memory. The earlier version concon­
addresses; thus it can easily be placed anywhere
instruction with
ith a specific
specific absolute
absolute address, while
hile this version has only
tains a JMP instruction
instructions with
ith relative
relative addresses.
branch instructions
addresses.

66-5

Object Program:
Object
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
000B

A2
A2
FF
FF
A9
A9
OD
OD
E8
EB
D5
D5
41
41
DO
DO
FB
FB
86
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LDX
#$FF
LOX
LDA
LOA

# $0D
D

CHKCR
CHKCR INX
INX
CMP
CMP

$41.X

BNE
BNE

CHKCR
CHKCR

STX
STX

$40

BRK
BRK

66-6

Find First Non-Blank Charactet
Character
(seven bits with
zero)
Purpose: Search a string
string of ASCII characters (seven
ith most significant
significant bit zero)
for a non-blank
Place
non-blank character. The string starts in memory location 0042. Place
the index of the first
first non-blank
non-blank character
character in memory location 0040. A blank
character
character is 2015
0 i6 in ASCII.
ASCII.

Sample Problems:
a.
Result:
It:
b.

Result:

(0042)

37

(0040)

00. since memory location 0042 contains
00,
contains a
non-blank character.
non-blank

ASCII 7
ASCII

(0042)
(0043)
(0044)
(0045)
(0046)

=
=
=
=
=

20
20
20
46
20

(0040)

=

03. since the three previous memory locations
contain blanks.
all contain
blanks.

SP
SP
SP
SP
SP
SP
'F
T'
SP
SP

Flowchart:
Flowchart:
Start

Base= 0042
Index= 0

No

Index = Index + 1

100401 = Index

End

6
6-7

Source Program:

CHBLK
CHBLK

DONE
DONE

LDX
LOX
LDA
LOA
CMP
BNE
INX
JMP
STX

#00
#''
$42,X
$42.X
DONE
DONE
CHBLK
$40

;START WITH INDEX =
= ZERO
ZERO
SPACE FOR
FOR COMPARISON
COMPARISON
;GET ASCII SPACE
:IS CHARACTER
CHARACTER AN ASCII SPACE?
SPACE?
;IS
;NO. DONE
DONE
;NO,
;YES. EXAMINE NEXT CHARACTER
CHARACTER
;YES.
FIRST NON-BLANK
;SAVE INDEX OF FIRST
; CHARACTER
CHARACTER

BRK
BRK

Note the use of an apostrophe
(') or single quotation
apostrophe 0
quotation mark before an ASCII character.

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0004
0005
0006
0007
0008
0008
0009
000A
OOOA
0008
0006
000C
oooc
000D
000E
OOOE

A2
00
A9
20
D5
42
DO
DO
04
E8
EB
4C
04
00
86
40
00

Instruction
Instruction
(Mnemonic)

CHBLK
CHBLK

DONE
DONE

LOX
LDX

#00

LOA
LDA

#''

CMP

$42.X
$42,X

BNE
BNE

DONE
DONE

INX
JMP

CHBLK
CHBLK

STX

$40

BRK
BRK

strings is a common
common task.
eliminated from
Looking for spaces in strings
task. Spaces often are
are eliminated
strings
strings when they are used simply
simply to increase readability
readability or to fit particular
particular formats. It is
obviously wasteful
wasteful to store and transm
beginning, ending,
particularly
obviously
transmitit beginning.
ending. or extra spaces,
spaces. particularly
if you are paying for the communications
capability and memory required. Data and
unications capability
program entry,
simpler if extra spaces are tolerated. Microcom
entry. however,
however. are much simpler
Microcom-­
easy
puters are often used in situations
situations like this to convert
convert data between forms that
that are easy
for
efficiently handled on computers
computers and com­
for humans to use and forms
forms that
that are
are efficiently
communications
unications lines.
lines.

66-8

Again.
Again, if we alter
alter the initial
initial conditions
conditions so that
that the loop control
control section
section precedes
precedes the propro­
cessing
cessing section.
section, we can reduce
reduce the number
number of bytes
bytes in the program
program and decrease
decrease the
execution time. The rearranged
rearranged flow
chart is:
loop's execution
flowchart
Start

Base= 0042
Index= -1

Index = Index + 1

(00401 = Index

End

Source Program:
Program:

CHBLK
CHBLK

LDX
LDA
INX
CMP
CMP
BEQ
BEO
STX
STX

#$FF

#'
$42,X
$42.X
CHBLK
CHBLK
$40

:START WITH INDEX
INDEX =
= -1
-1
:GET
ASCII SPACE
SPACE FOR
FOR COMPARISON
COMPARISON
GET ASCII
INCREMENT INDEX
:INCREMENT
INDEX
:IS CHARACTER
CHARACTER AN ASCII
ASCII SPACE?
SPACE?
:YES.
CHARACTER
YES, EXAMINE NEXT CHARACTER
NO, SAVE INDEX
:NO.
INDEX OF
OF FIRST
FIRST NON-BLANK
: CHARACTER
CHARACTER

BRK
BRK

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
, 0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008

A2
FF
FF
A9
20
E8
EB
D5
42
FO
FO
FB
FB
86
40
00

Instruction
Instruction
(Mnemonic)

CHBLK
CHBLK

LDX
LDX

#$FF

LDA

#''

INX
INX
CMP
CMP

$42.X
$42,X

BEO
BEQ

CHBLK
CHBLK

STX
STX

$40

BRK
BRK

6-9
6-9

Replace Leading
ith Blanks
Leading Zeros with
Blanks
Purpose;
decimal characters by replacing
replacing all leading zeros
ith
Purpose: Edit a string of ASCII
ASCII decimal
zeros with
blanks. The string starts in memory location 0041;
0041; assume that
that it consists
entirely of ASCII-coded decimal digits. The length
length of the string is in memory
entirely
location 0040.
location
Sample Problems:
a.
a.

(0040)
(0040)
(0041)

= 02
= 36

ASCII
ASCII 6

The program leaves the string unchanged.
unchanged, since the leading digitit is not zero.
zero.

b.

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

=
=
=
=

08
30
30
38

ASCII
ASCII 0
ASCII
ASCII 0
ASCII
ASCII 8

(0041)
(0041)
(0042)
(0042)

=
=

20
20

SP
SP
SP
SP

The twoo leading ASCII
ASCII zeros
zeros have been replaced by ASCII
ASCII blanks.
blanks.

Flowchart:
Flowchart:
Start

Count = (00401
Index= 0

Base= 0041

(Base+lndex)

=

ASCII Space (20 151
Index = Index + 1

End

6 -10
10

Source Program:
Program:

CHKZ
CHKZ

DONE
DONE

LDX
LOX
LDY
LOY
LDA
LOA
CMP
BNE
BNE
STY
INX
CPX
CPX
BNE
BNE
BRK
BRK

#00
#'
#'O
'0
$41.X
,X
DONE
DONE
$41,X
$41.X

;INDEX== ZERO
ZERO TO START
START
INDEX
:GET
SPACE FOR
FOR REPLACEMENT
REPLACEMENT
GET ASCII SPACE
:GET ASCII ZERO
ZERO FOR
FOR COMPARISON
COMPARISON
:IS LEADING
LEADING DIGIT ZERO?
ZERO?
;NO, END
END REPLACEMENT
REPLACEMENT PROCESS
PROCESS
:IS LEADING
LEADING DIGIT
DIGIT ZERO?
ZERO?

$40
CHKZ

;EXAMINE NEXT
NEXT DIGIT IF ANY

Single quotation
frontt of a character
quotation mark in fron
character indicates
indicates that
that the operand is an ASCII
code.

Object Program:
Object
Memory
Memory Address
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0004
0005
0006
0007
0008
0008
0009
000A
OOOA
OOOB
000B

A2
00
AO
20
A9
30
D5
41
DO
DO
07
94
41
E8
EB
E4
E4
40
DO
DO
F5
00

oooc
oooc
000D
000E
OOOE
000F
OOOF
0010
0011

Instruction
Instruction
(Mnemonic)

CHKZ
CHKZ

DONE
DONE

LDX
LOX

#00

LDY
LOY

#''

LDA
LOA

#'O
'0

CMP

41,X
$4
1.X

BNE
BNE

DONE
DONE

STY

41.X
$4
1.X

INX
CPX
CPX

$40

BNE
BNE

CHKZ
CHKZ

BRK
BRK

You will
ill frequently
frequently want
ant to edit
edit decimal
decimal strings
strings before they are printed
printed or displayed
displayed to
improve their
their appearance. Common
Common editing
editing tasks include
include elim
inating leading zeros,
improve
eliminating
zeros.
justifying
markers. and rounding.
Clearly.
justifying numbers.
numbers, adding
adding signs or other
other identifying
identifying markers,
rounding. Clearly,
printed
printed numbers
numbers like 0006
0006 or $27.34382
$27.34382 can be confusing
confusing and annoying.
Here the loop has two exits- — one if the processor finds a nonzero dig
digitit and the other if
it has examined
examined the entire string.

hex) in a memory locaThe instruction
instruction STY $41.X
$41,X places an ASCII space character
character (20 hex)
loca­
tion that previously
previously contained
contained an ASCII zero.
limited number
number
zero. Note that STY has only a limited
addressing modes (see
3-4); there are no indexing
indexing modes with
ith Register Y, no
of addressing
(see Table 3-4):
pre-indexing, and no absolute
absolute indexing.
indexing. The only indexed addressing
addressing mode is the zeropre-indexing.
zeropage mode with
ith Index Register X.
All digits
is. the digits
digits in the string
string are assumed to be ASCII; that
that is,
digits are 3015
30-|6 through
39
1 0 rather than the ordinary
ordinary decimal
decimal 0
to 9. The conversion
conversion from decimal
decimal to ASCII is
916
Oto
simply
015
simply a matter
atter of adding
adding 3 0
ig to the decimal
decimal digit.
digit.

6 -11

You can place a single
presingle ASCII character
character in a 6502 assembly language program by pre­
ceding
apostrophe(').
ASCII characters in
in program
ceding it with
ith an apostrophe
(’). You can place a string of ASCII
memory
ASCII Text) pseudo-operation
assemmemory by using
using the .TEXT (Store ASCII
pseudo-operation on the 6502 assem­
bler. A delim
delimiter
text: the usual form is:
is:
iter character
character (usually/)/) must surround the text;

Label

peration
O pe
ra tio n
Code
Code

Operand
Operand

EMSG
EMSG

.TEXT
.TEXT

/ERROR/
/ERROR/

You may have to be careful.
zeros, to leave one zero in the event that all
careful, when
when blanking
blanking zeros,
the digits
zero. How would
digits are zero.
would you do this?
Note that
ASCII digit
BCD digit.
that each ASCII
ig it requires eight
eight bits.
bits, as compared to four for a BCD
Therefore, ASCII is an expensive
transmitit numerical
numerical data.
data.
expensive format
at in which
hich to store or transm

6 -12
12

Add Even Parity to ASCII Characters
Purpose: Add even parity to a string of 7-bit
7-bit ASCII
ASCII characters. The length of the string
is in memory location 0040 and the string itself begins in memory location
significant bit of each character
character by set­
0041. Place even parity in the most significant
setting the most significant
significant bit to 1 if that makes the total number of 1 bits in
the word an even number.
Sample Problem:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0045)
(0045)
(0046)
(0046)
(0041)
Result: (0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

- 06
=
=
=
=
=
=

31
31
32
33
34
35
36

=

B1
B1
B2
33
B4
35
36

=
=
=
=
=

6-13

Flowchart:
Flowchart:
Start

Base= 0040
Index = (0040)

Bit Count= 0

Data = (Base +
Index)

Bit Count=
Bit Count + 1

Shift Data Left One
Bit Arithmetically

(LSB = 01

Set MSB of
(Base+lndex)
to 1

End

6-14

Source
Source Program:
Program:
LDX
GTDATA
GTDATA LDY
LDA
LDA
CHBIT
BPL
INY
CHKZ
ASL
CHKZ
BNE
TYA
TYA
LSR
BCC
LDA
ORA
STA
NEXTE
DEX
BNE
BRK

sec

$40
$40
#00
$40.X
$40.X
CHKZ

INDEX = MAXIMUM
MAXIMUM COUNT
BIT COUNT== ZERO
DATA
ZERO FOR
FOR DATA
BLOCK
GET DATA
DATA FROM BLOCK
;IS NEXT DATA
DATA BIT 1?
;YES.
YES, ADD 1 TO BIT COUNT
;EXAMINE NEXT BIT POSITION
POSITION
;UNLESS ALL BITS
BITS ARE ZEROS
ZEROS

A
CHBIT

;DID DATA
EVEN NUMBER OF
OF '1' BITS?
DATA HAVE EVEN

A
NEXTE
$40.X
$40,X
%10000000
#% 1
0000000
$40.X
$40,X

;NO.
SET PARITY BIT
NO, SET

GTDATA
GTDATA

;CONTINUE THROUGH
THROUGH DATA BLOCK
BLOCK

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
0008
OOOC
000D
OOOD
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0013
0013
0014
0014
0015
0016
0016
0017
0017
0018
0019

A6
40
AO
00
85
B5
40
10
01
01
C8
CB
OA
OA
DO
DO
FA
98
4A
90
06
B5
85
40
09
80
95
40
CA
DO
DO
E9
E9
00

oooc

Instruction
Instruction
(Mnemonic!
(Mnemonic)
LDX

$40

GTDATA LDY

#0

LDA

$40,
X
$40.X

CHBIT

BPL
BPL

CHKZ
CHKZ

CHKZ
CHKZ

INY
INY
ASL
BNE
BNE

A
CHBIT
CHBIT

TYA
LSR
LSR
BCC

sec

A
A
NEXTE
NEXTE

LDA

$40,
X
$40.X

ORA
ORA

#%10000000
10000000

STA
STA

$40,
X
$40.X

DEX
DEX
BNE
BNE

GTDATA
GTDATA

NEXTE
NEXTE

:

BRK
BRK

Parity is often added to ASCII
characters before
itted on
ASCII characters
before they
they are
are transm
transmitted
on noisy
noisy com­
communications
unications lines; this
provides a simple error-checking
error-checking facility.
facility. Parity
this provides
Parity detects
detects all
all
single-bit errors but does not allow
allow for error
correction; that
single-bit
error correction;
that is,
is. you
you can
can tell
tell by
by checking
checking
the parity
parity of the data that an error has
occurred, but
has occurred.
but you
you cannot
cannot tell
tell which
which bit
bit was
was
incorrectly. All that
received incorrectly.
that the receiver can do
do is
is request
request retransmission.
retransmission.

66-15

The procedure for calculating
calculating parity is to count
count the number
number of '1' bits in the data words.
If that number
number is odd, the MSB of the data word is set to 1 to make the parity even.
even.
ASL clears the least significant
significant bit of the number
number being shifted. Therefore.
Therefore, the result of
a series of ASL instructions
instructions will
ill eventually
eventually be zero,
original value of
zero. regardless of the original
the data (try it!). The bit counting
counting section of the example program not only does not
need a counter.
counter, but also stops examining
examining the data as soon as all remaining
remaining bits are
zeros.
execution time in many cases.
zeros. This procedure saves
saves execution
cases.
The MSB of the data is set to T
logically ORing it with
ith a pattern that has a '1' in its
'1' by logically
significant bit and zeros
Logically ORing a bit with
ith one produces a
most significant
zeros elsewhere. Logically
original value, while
hile logically
logically ORing a bit with
ith zero does
result of one regardless of the original
original value.
not change the original

55-16

Pattern Match
Purpose: Compare twoo strings
strings of ASCII
ASCII characters to see if they are the same.
same. The
length of the strings
strings is in memory location 0041:
0041; one string starts in memory
length
location 0042 and the other in memory location
location 0052. If the two strings
location
match, clear memory location 0040;
0040; otherwise.
otherwise, set memory location 0040
0040 to
match.
FF-ie
FF15 (all ones).
ones).
Sample Problems:

(0041)
(0041)

a.

(0042)
(0042)
(0043)
(0043)
(0044)
(0044)

Result:

b.

Result:
Result:

=

03

. 43 'C'
·c·
=
=

41
54

'A'
’A'
T
'C'
■c
'A'
T
since the two strings are the same.

(0052)
(0052)
(0053)
(0054)

=
=
=

43
41
54

(0040)

=

00,

(0041)

=

03

(0042)
(0042)
(0043)
(0043)
(0044)

-

52
41
54

'R'
■R
'A'
T

43
41
= 54

·c·
'C
'A'
'T'
T

=

(0052)
(0053)
(0054)

=
=

(0040)
(0040)

=

FF,
FF. since the first characters in the
strings differ.
strings

Note: The matching
matching process ends as soon as the CPU
difference -— the rest of
CPU finds a difference
the strings
strings need not be examined.

6-17

Flowchart:
Flowchart:
Start

Index= 0
Mark= FF16

Index = Index + 1

Mark= 0

(00401 = Mark

End

Source Program:
Program:

CHCAR
CHCAR

DONE
DONE

LDX
LOX
LDY
LOY
LDA
LOA
CMP
CMP
BNE
BNE
INX
INX
CPX
CPX
BNE
BNE
LDY
LOY
STY
STY
BRK
BRK

#0
#$FF
$42,X
$42.X
$52,X
$52.X
DONE
DONE
$41
$41
CHCAR
CHCAR
#0
$40

START WITH FIRST
;START
FIRST ELEMENT
ELEMENTIN STRINGS
STRINGS
MARKER
;MARKER FOR
FOR NO MATCH
GET
;GET CHARACTER
CHARACTERFROM
FROM STRING
STRING 1
IS THERE
THERE A MATCH WITH STRING
2?
;IS
STRING 27
NO, DONE
;NO.
DONE

CHECK NEXT
NEXT PAIR
PAIR IF ANY LEFT
LEFT
;CHECK
;IF NONE
NONE LEFT,
LEFT. MARK
MARK MATCH
;SAVE MATCH MARKER
MARKER

6 -18
18

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
000B

A2
00
A0
AO
FF
FF
B5
42
D5
05
52
DO
DO
07
E8
EB
E4
41
DO
DO
F5
A0
AO
00
84
40
00

oooc
oooc
0000
00D
0
00E
OOOE
000F
OOOF
0010
0011
0012
0013

Instruction
Instruction
(Mnemonic)

CHCAR
CHCAR

DONE
DONE

LDX
LOX

#00

LDY
LOY

#$FF

LDA
LOA

$42.X
X

CMP

$52.X
$52,X

BNE
BNE

DONE
DONE

INX
CPX
CPX

$41

BNE
BNE

CHCAR
CHCAR

LDY
LOY

#00

STY
STY

$40

BRK
BRK

Matching
atching strings
strings of ASCII
characters is an essential part of recognizing
recognizing names or com­
ASCII characters
commands. identifying
identifying variables or operation codes in assemblers and compilers, finding
finding
files,
files. and many other tasks.
tasks.
Index Register X is used to access both string;,
strings -— only the base addresses are different.
different.
This method allows the strings
memory, although
would
strings to be located anywhere
anywhere in memory.
although we would
have to use the absolute indexed addressing modes if the strings
strings were not on page
zero.
post-indexed mode (with Index Register Y)
zero. We could also use the post-indexed
Y) if we had two
different base addresses stored somewhere on page zero.
different
zero.
The instruction
instruction CMP $52.X
$52,X compares the Accum
ulator to the contents
contents of the indexed
Accumulator
instruction with
ith INY.
Why? Compare
memory location. We could replace the LDY
LOY #0 instruction
INY. Why?
the time and memory requirements
requirements of the two alternatives.
alternatives. Which
hich version do you think
is clearer? The replacement
replacement would
would also allow
allow you to use a memory location
location for the
register (why?).
marker rather than a register
(why?).

6 -19
19

PROBLEMS
PROBLEMS
1)

eletypewriter
Length of a T ele ty p
e w rite r Message

ASCII message.
message. All characters are
are 7-bit
ASCII
Purpose: Determine
Determine the length
length of an ASCII
7-bit ASCII
= 0. The string
message is embedded
with
ith MS8
MSB =
string of characters
characters in which
hich the message
starts in memory
ASCII STX
STX
memory location
location 0041. The message itself starts with an ASCII
character
ETX (0315).
message
character (0215)
1 @ and ends with
ith ETX
6) Place the length of the message
(the number
ETX but including
number of characters
characters between the STX and the ETX
including
neither) into
into memory
memory location
location 0040.
Sample Problem:

Result:
It:

2)

(0041)
(0042)
(0043)
(0044)
(0045)

= 40
40
STX
= 02
02 STX
'G'
= 47
47 'G'
·o·
= 4F
4F ’O’
= 03
03 ETX
ETX

(0040)

since there
there are
aretw
two
characters between
= 02, since
o characters
betweenthe
theSTX
STX
ETX in location 0045.
in location
location 0042
0042 and ETX

Find Last Non-Blank Character
Find

ASCII characters
characters for
for the
the last non-blank
Purpose: Search a string
string of
of ASCII
non-blank character. The
string
location 0042
0042 and
and ends
ends wwith
string starts in memory
memory location
ith aa carriage
carriage return
return
character (0D-|g).
non-blank character
character in memory
character
(OD15). Place the index of the last non-blank
location
location 0040.
Sample Problems:
a.
Result:

b.

Result:

=

(0042)
(0043)

=

(0040)

—

00, since the last (and only) non-blank
non-blank character
is in memory location 0042.

(0042)
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)

=
=
=
=
=
=
=

41
20
48
41
54
20
20
0D
OD

(0040)

=

04

37 ASCII 7
0D
OD CR
CR

'A'
SP
SP
'H'
'A'
T
SP
SP
SP
SP
CR
CR

620
6-20

3)

Truncate
Decimal
Truncate Decim
al String to Integer
Integer Form

ASCII decimal characters by replacing
Purpose: Edit a string of ASCII
replacing all digits
digits to the right
right of
the decimal
decimal point
point with
ith ASCII
q). The string
string starts in memory loca­
ASCII blanks (20-)
(2015).
location 0041 and is assumed to consist entirely
entirely of ASCII-coded decimal
decimal digits
digits
2E15).
The
and a possible decimal
decimal point
point ( 2 E
-|Th
e length
length of the string is in memory
location
location 0040.
0040- If no decimal point
point appears in the string.
string, assume that the
decimal
decimal point
point is implicitly
plicitly at the far right.
Sample Problems:

a.

Result:

b

Result:
Result:

4)

(0040)

=

04

(0041)
(0042)
(0043)
(0044)
(0044)

=
=
=
=

37
2E
38
31
31

ASCII 7
ASCII
ASCII.
ASCII
ASCII
ASCII 8
ASCII 1
ASCII

(0041)
(0042)
(0043)
(0044)

—

37
2E
20
20

ASCII
ASCII 7
ASCII.
ASCII
SP
SP
SP
SP

(0040)

=

03

(0041)
(0042)
(0043)

=
=

36
37
31

=
—

=

=

ASCII 6
ASCII
ASCII
ASCII 7
ASCII 1
ASCII

Unchanged.
nged, as number
number is assumed to be 671.

Check Even Parity in ASCII Characters

ASCII characters. The length
Purpose: Check even parity in a string of ASCII
length of the string is
in memory location 0041.
0041, and the string itself begins in memory location
0042. If the parity
correct. clear memory
parity of all the characters in the string is correct,
location
(all ones)
ones) into memory location 0040.
location 0040;
0040; otherwise.
otherwise, place FF15
1 q (all
Sample Problems:

a.

Result:
b

Result:

(0041)

=

03

(0042)
(0042)
(0043)
(0043)
(0044)

=

=

B1
B1
B2
33

(0040) =

00,

(0041)
(0041)

=

03

(0042)
(0043)
(0043)
(0044)
(0044)

=
=
=

B1
B1
B6
33

(0040)
(0040)

=

FF,
FF. since the character
character in memory location 0043
does not have even parity.

=

since all the characters have even parity.

6 -21

5)

String Comparison
Comparison

ASCII characters to see
see which
Purpose: Compare twoo strings
strings of ASCII
which is larger {i.e
(i.e.,.. which
follows
is in
follows the other in alphabetical
alphabetical ordering). The length of the strings is
memory location
the
location 0041;
0041; one string starts in memory location 0042 and the
other
other in memory
memory location
location 0052. If the string starting
starting in memory location
0042
string. clear memory location
0042 is greater
greater than or equal to the other string,
0040;
{all ones).
ones).
0040; otherwise.
otherwise, set memory location 0040 to FF,e
FF-|g (all

Sample Problems:
a.

Result:
b

Result:
c.

Result:

(0041)

03

(0042)
(0043)
(0044)

43
41
54

·c·
'C'

(0052)
(0053)
(0054)

42
51
54

'B'
'A'
T

(0040)

00,,

'larger· than BAT.
BAT.
since CAT is 'larger'

(0041)

03

10042)
(0042)
10043)
(0043)
10044)
(0044)

43
41
54

'C'
■c
'A'
T

10052)
(0052)
10053)
(0053)
10054)
(0054)

43
41
54

'A'
T

(0040)

00,.

strings are equal.
since the two strings

(0041)

03

(0042)
(0043)
(0044)

43
41
54

'C'
'C
'A'
T

(0052)
(0053)
(0054)
10054)

43
55
54

'C'
·u·
'U'
T

10040) =
(0040)

FF,
'larger' than CAT.
FF. since CUT is 'larger·
CAT.

'A'
'T
T

·c·
'C'

622
6-22

Chapter 7
CODE CONVERSION
CONVERSION
Code conversion is a continual problem in most microcomputer
icrocomputer applications. Pe­
Peripherals
codes. The system must
ripherals provide data in ASCII,
ASCII, BCD, or various special codes.
Output devices may rere­
convert the data into some standard form for processing.
processing. Output
quire data in ASCII.
ASCII, BCD, seven-segment,
seven-segment, or other codes.
codes. Therefore, the system
must convert
convert the results to a suitable form after
after the processing
processing is completed.
several ways
ways to approach code conversion:
There are several
1)

2)

3)

etic or
Some conversions can easily be handled by algorithms involving arithmetic
logical functions. The program
program may.
however, have to handle some special cases
may, however.
separately.
ith lookup tables. The lookup tata­
More complex conversions can be handled with
ble method
method requires little
little programming
programming and is easy to apply. However.
However, the table
may occupy
occupy a large amount
amount of memory if the range of input
input values is large.
large.
Hardware is readily available for some conversion tasks. Typical
Typical examples
examples are
Hardware
decoders for BCD to seven-segment
seven-segment conversion
conversion and Universal
Universal Asynchronous
Asynchronous
decoders
Receiver/Transmitters (UARTs)
conversion between
between parallel (ASCII)
Receiver/Transmitters
(UARTs) for conversion
(ASCII) and serial
(teletypewriter) formats.
(teletypewriterl

In most applications,
applications, the program
program should do as much as possible of the code conversion
conversion
ell as in increased
work. This results in a savings in parts and board space as well
reliability. Furthermore.
Furthermore, most code conversions
conversions are easy to program
program and require little
little
reliability.
execution time.
execution

7-1

EXAMPLES
EXAMPLES
ASCII
Hex to ASCII
Purpose:
Purpose:

Convert the
the contents
contents of
of memory
memory location
location 0040
0040 to an ASCII character.
character.
Convert
Memory location
location 0040
0040 contains
contains aa single
single hexadecimal
hexadecimal dig
(the four
four most
most
Memory
digitit (the
significant bits
bits are zero). Store
Store the
the ASCII character
character in memory
memory location
location
significant
0041.
0041.

Sample Problems:
a.
Result:
b.
Result:

(0040)
(0040)

0C
oc

(0041)

43

(0040)
(0040)

06

(0041)

36

·c·
'C'
'6'

Flowchart:
Flowchart:

(

Start

i

)

Data = 10040)

Data=
Data + ASCII A ASCII 9 -1

Result=
Data+ ASCII Zero

10041) = Result

c__

E_nd
__

)

Source Program:
Program:

ASCZ
ASCZ

LDA
LOA
CMP
CMP
BCC
BCC
ADC
ADC
ADC
ADC
STA
STA
BRK
BRK

$40
$40
#1
#100
ASCZ
ASCZ
##'A-'9-2
'A -'9 -2
##'O
'0
$41
$41

;GET
:GET DATA
DATA
;IS
:IS DATA
DATA LESS
LESS THAN
THAN 10?
10?
1)
;NO. ADD
ADD OFFSET
OFFSETFOR
FOR LETTERS
LETTERS (CARRY
(CARRY == 1)
;NO.
;ADD
.ADD OFFSET
OFFSETFOR
FORASCII
ASCII
;STORE
;STORE ASCII
ASCII DIGIT
DIGIT

77-2

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0 0
0002
0003
0003
0004
0004
0005
0006
0007
0008
0008
0009
000A
OOOA
000B
0 0 0
c
oooc

A5
40
C9
0A
OA
90
0
02
69
06
69
30
85
41
0
00

0 00 0
0001

Instruction
Instruction
(Mnemonic)

ASCZ

LDA
LOA

$40

CMP

# 1 0

BCC
BCC

ASCZ

ADC

# 'A
-'9 -2
'A-'9-2

ADC

#'O

STA

$41

#10

#■0

BRK
BRK

The basic idea of this program is to add ASCII zero (3015)
1 q) to all the hexadecimal
hexadecimal digits.
addition converts
converts the decimal
decimal digits
digits to ASCII
correctly; however.
however, there is a break
This addition
ASCII correctly:
between ASCII
g) and ASCII A (41 1 0
which must
must be considered.
considered. This break must
between
ASCII 9 (39-|
(3915)
15) which
be added to the non-decimal
non-decimal digits
digits A,
first ADC instruction
instruction ac­
A. B,
B. C,
C. D,
D. E,
E. and F.
F. The first
accomplishes this by adding
adding the offset
offset 'A-'9-2
'A-'9-2 to the contents
contents of the Accumulator.
Accumulator. Can
complishes
you explain
explain why
why the offset is 'A-'9-2?
'A-'9-2?
The problem
problem here is that
that the letters do not follow
follow immediately
mediately after the decimal
decimal digits
digits in
ASCII.
occupied by the ASCII
characters as:: (3A15).
1 0 >, =
ASCII. There is a gap occupied
ASCII codes for such characters
(3D
1 g), and @ (40ig).
bridge this gap,
constant factor
factor determined
determined by
(3015).
(4015). To bridge
gap. we must add a constant
the distance
distance between
between the actual
actual value of ASCII
1 0 ) and the value it would
would have if
ASCII A (4115)
there were no gap (3A-|g).
factor of 1 provided
provided by the Carry flag.
15). There is also an extra factor
You can compare this situation
situation to the problem of walking
walking from one address to another
another
on a street that
that is divided
divided into two discontinuous
discontinuous sections
sections by a canyon
canyon or a river.
that the ADC instruction
instruction always
always adds in the Carry bit. After
fte r the BCC
instruc­
Remember that
BCC instruction,
know that
that the Carry contains
contains one (otherwise
(otherwise a branch
branch would
would have occurred).
tion. we know
So we simply
ply reduce the additive
additive factor
factor by 1 to account
account for the Carry. As for the second
ADC instruction.
instruction, the Carry will
ill be zero if the program
program branched
branched after
after the CMP instrucinstruc­
tion (since the BCC
instruction was used)
ulator contained
contained a valid hexhex­
BCC instruction
used) or if the A ccum
ccumulator
adecimal digit
ig it (10 through
through 15)
additive factor
factor is only 7.
Therefore, we do not
adecimal
15) since the additive
7. Therefore.
have to worry
orry about
about the Carry in any reasonable case.
case.
routine could
could be used in a variety
variety of programs:
programs; for example.
example, monitor
onitor programs
This routine
convert hexadecimal
hexadecimal digits
digits to ASCII in order to display
display the contents
contents of memory
must convert
locations in hexadecimal
hexadecimal on an ASCII
printer or CRT
locations
ASCII printer
CRT display.
Another
nother (quicker) conversion
conversion method
method that requires no conditional
conditional jumps
ps at all is the
following program.
program, described
described by AllisonJ
following
Allison.1
SED
SEO
CLC
CLC
LDA
LOA
ADC
ADC
STA
CLD
CLO
BRK
BRK

$40
# $90
90
# $40
40
$41

:MAKE ADDITIONS. DECIMAL
CLEAR CARRY
:CLEAR
CARRY TO START
START
GET HEXADECIMAL DIGIT
:GET
DIGIT
DEVELOP EXTRA
:DEVELOP
EXTRA 66 AND CARRY
CARRY
:ADD IN CARRY,
CARRY. ASCII OFFSET
OFFSET
STORE ASCII DIGIT
:STORE
DIGIT
CLEAR DECIMAL MODE BEFORE
;CLEAR
BEFOREENDING
ENDING

7 -3

Try this
be
this program
program on some digits. Can you explain why it works? Note that you must be
careful
careful to clear
clear the decimal
decimal mode flag when you have completed
completed all decimal arithmetic.
arithmetic.
Otherwise,
(including the monitor) where they
Otherwise, you will
ill get decimal
decimal results in programs (including
are not wanted.
wanted.

Decimal
Seven-Segment
Decim
al to Seven-Segm
ent
Purpose:

Convert
Convert the contents
contents of memory location 0041 to a seven-segment
seven-segment code in
memory
memory location
location 0042. If memory location 0041 does not contain a single
decimal
decimal digit.
digit, clear memory location 0042.

Seven-segment
following
to
Seven-segment table: The follow
ing table can be used to convert
convert decimal numbers to
seven-segment
seven-segment code. The seven-segment
seven-segment code is organized with
ith the most significant
significant
bit
(1 = on, 0 = off) for segments g,
g, f,f, e,
e, d,
d, c.
c, b,
b, and a
bit always
always zero followed
followed by the code (1
(see Figure 7-1 for the positions
(see
positions of the segments). The segment names are standard but
the organization
organization that we have chosen is arbitrary. In actual applications,
applications, the hardware
determines the assignment
assignment of data bits to segments.
determines
Note that
off) to avoid
that the table uses 7D for 6 rather than the alternative
alternative 7C (top bar off)
confusion
particuconfusion with
ith lower
lower case b, and 6F for 9 rather than 67 (bottom bar off), for no particu­
lar reason.
reason.

Digit
Digit

Code

0
1
2
3
4
5
6
7

3F
06
5B
58
4F
66
6D
7D
07
7F
6F

8
B
9

b

g

•

Seven-segment Arrangement
Arrangement
Figure 7-1. Seven-segment

Sample Problems:
a.

(0041)
(0041)

Result:
It:
b.
Result:

= 03
03

(0042)
(0042)

= 4F
4F

(0041)
(0041)

= 28
28

(0042)
(0042)

= 00
00

I·
d

7
-4
7-4

Flowchart:
Flowchart:
Start

Data - (0041 I

Yes

Result=

Result= O

(SSEG + Data)

(00421 • Result

End

that the addition
addition of base address
address (SSEG)
index (OATA)
(DATA) produces
produces the address
address
Note that
(SSEG) and index
that contains
contains the answer.
answer.
that

Source Program:

DONE

LDA
LOA
LDX
LOX
CPX
BCS
LDA
LOA

#0
$41
#100
DONE
SSEG.X

STA

$42

SSEG
SSEG

o

II

CM
m

BRK
BRK
·=$20
.BYTE
.BYTE

:GET ERROR
ERROR CODE TO BLANK DISPLAY
DATA
:GET DATA
DATA A DECIMAL
DECIMAL DIGIT?
:IS DATA
NO, KEEP
:NO.
KEEP ERROR
ERROR CODE
SEVEN-SEGMENT CODE FROM
;YES. GET
GET SEVEN-SEGMENT
; TABLE
SAVE SEVEN-SEGMENT
SEVEN-SEGMENT CODE OR ERROR
:SAVE
ERROR
: CODE

;SEVEN-SEGMENT CODE TABLE
:SEVEN-SEGMENT
$3F,$06.$5B.$4F.$66
$3F,$06.$5B.$4F,$66
$6D,$7D,$07,$7F.$6F
$6D.$7D.$07.$7F.$6F

77-5

Object Program:
Object
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory
Contents
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008
oooc
oooc

A9
00
A6
41
E0
EO
0A
OA
BO
BO
02
B5
85
20
85
42
00

0020
0021
0022
0023
0024
0025
0026
0027
0028
0029

3F
06
5B
58
4F
66
6D
60
7D
70
07
7F
6F

Instruction
Instruction
(Mnemonic)
LDA
LOA

#00

LDX
LOX

$41

CPX
CPX

#100

BCS
BCS

DONE
DONE

LDA
LOA

SSEG.X
SSEG,X

DONE
DONE

STA

$42

SSEG
SSEG

■
.BYTE

BRK
BAK

.BYTE
.BYTE

$3F
$06
$5B
$58
$4F
$66
$6D
$60
$7D
$70
$07
$7F
$6F

calculates the memory address of the desired code by adding
adding the index
The program calculates
seven-segment code table.
(i.e.,.. the digitit to be displayed) to the base address of the seven-segment
table.
This procedure is known
known as a table lookup. No explicit
explicit instructions
instructions are required for the
addition, since it is performed autom
atically in the indexed addressing modes.
addition.
automatically
modes.
The assembly language pseudo-operation
pseudo-operation .BYTE
byte-length data) places concon­
.BYTE (define byte-length
include tables,
stant data in program memory. Such data may include
tables. headings, error
messages,
ing messages,
at characters, thresholds, etc. The label attached
attached to
messages. priming
messages, format
a .BYTE
pseudo-operation is assigned the value of the address into which
hich the first byte
.BYTE pseudo-operation
of data is placed.
Tables are often used to perform code conversions
conversions that are more complex
complex than the prepre­
vious example. Such tables typically
contain all the results organized according
according to the
typically contain
input data;
entry is the code corresponding
corresponding to the number
number zero.
input
data: e.g.... the first entry
zero.
Seven-segment displays
displays provide recognizable forms of the decimal
decimal digits
digits and a few letlet­
Seven-segment
ters and other
other characters. Calculator-type
Calculator-type seven-segment
seven-segment displays are inexpensive,
easy to multiplex.
ultiplex, and use little
little power. However, the seven-segment
seven-segment coded digits
digits are
somewhat difficult
ifficu lt to read.
somewhat
read.
The assembler simply
simply places the data for the table in memory. Note that one .BYTE
.BYTE
pseudo-operation can fill
fill many memory locations. We have left some memory space
pseudo-operation
additions or corrections.
between the program and the table to allow for later additions
The table can be placed anywhere
anywhere in memory, although
although the absolute indexed addressaddress­
ing mode would
would have to be used if it was not on page zero.
zero. We could also use post-indexing (with Index Register Y)
Y) and have the base address saved in two memory loca­
locations on page zero.
zero. The same program could then be used with
ith any table since the base
address would
would be specified in RAM rather than in ROM.
ROM.

7-6

ASCII to Decimal
Purpose: Convert
Convert the contents
contents of memory location
location 0040
0040 from an ASCII character
character to a
decimal digit
ig it and store the result in memory
memory location
location 0041. If the contents
contents of
decimal
memory location
location 0040
0040 are not the ASCII
representation of a decimal
decimal digit.
digit,
memory
ASCII representation
set the contents
contents of memory
memory location
location 0041 to FFig.
FF15.
Sample Problems:
(0040) = 37
37 (ASCII
(0040)
(ASCII 7)

a.

Result:
b.
Result:

7)

(0041) = 07
07
(0041)

(0040)
(0040) =

55 (an
invalid
not
(an
invalidcode,
code.since
sinceit itis is
notanan
55
ASCII
decimal digit)
ASCII decimal

(0041)
(0041) =

FF
FF

Flowchart:
Flowchart:
Start

Data = 100401

Yes

Yes

Result=
Data -ASCII 0

Result = FF16

10041) = Result

End

7-7
7-7

Source Program:
Program:

DONE
DONE

LDX
LDA
SEC
SEC
SBC
SBC
BCC
BCC
CMP
BCS
BCS
TAX
STX
BRK
BAK

#$FF
$40
#'0
'0
DONE
DONE
#10
10
DONE
DONE
$41

GET ERROR
:GET
ERRORMESSAGE
MESSAGE
GET DATA
;GET
IGNORE CARRY
:IGNORE
CARRY IN SUBTRACTION
;IS DATA BELOW ASCII ZERO?
ZERO?
YES. NOT A DIGIT
;YES.
DIGIT
:IS DATA ABOVE ASCII NINE?
NINE?
YES, NOT A DIGIT
:YES.
DIGIT
:SAVE DIGIT IF VALID
:SAVE DIGIT OR ERROR
ERROR MARKER
MARKER

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
000A
000B
oooc
oooc
000D
000D
OOOE
000E
000F
0010
0010

A2
FF
FF
A5
40
38
E9
30
90
05
C9
OA
0A
BO
BO
01
AA
86
41
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

DONE
DONE

LDX

#$FF

LDA

$40

SEC
SEC
SBC
SBC

#'0
'0

BCC
BCC

DONE
DONE

CMP

#10
10

BCS
BCS

DONE
DONE

TAX
STX
STX

$41

BRK
BAK

program handles ASCII-coded
ASCII-coded characters
characters just
just like ordinary
ordinary numbers. Note that the
This program
decimal digits
digits and the letters
letters form groups
groups of consecutive
consecutive codes. Strings
Strings of letters
letters (like
decimal
names) can be alphabetized
alphabetized by placing
placing their
their ASCII representations
representations in
increasing
In increasing
numerical order (ASCII
numerical
(ASCII B =
= ASCII A++ 1 for example).
Subtracting ASCII zero (30-|
q) from any ASCII decimal
decimal d ig
it gives the BCD representarepresenta­
Subtracting
(3015)
1g1t
that digit.
digit.
tion of that
must be set before a subtraction
subtraction if
affect the result
result since SBC
pro­
The Carry must
11it is not to affect
SBC prowhere M is the contents
contents of the addressed memory
memory
= (A)
(A) - (M)
(M) - (1
(1 - Carry) where
duces (A)
(A) =
Compare instructions.
instructions, on the other
other hand,
include the Carry in their
their im-­
location. Compare
hand. do not include
subtractions.
plied subtractions.
ASCII-to-decimal conversion
conversion is necessary when
when decimal
decimal numbers
numbers are being entered
ASCII-to-decimal
from an ASCII device
device like a teletypewriter
teletypewriter or CRT
terminal.
CRT terminal.
program is to determine
determine if
character is
between ASCII 0 and
The basic idea of the program
11the character
Is between
ASCII 9, inclusive.
inclusive. If so.
character is an ASCII decimal
decimal digit
ig it since the digits
digits form a
so. the character
converted to decimal
decimal simply
simply by subtracting
subtracting 3 0
i6 (ASCII
sequence. It may then be converted
015
(ASCII 0):
e.g.,.. ASCII 7 - ASCII 0 = 37 - 30 = 7.
7.
that one comparison
comparison is
ith an actual
actual subtraction
subtraction (SBC
'0 ) since the
Note that
Is done with
(SBC #'0)
subraction is necessary to convert
convert ASCII to decimal
decimal. The other
other comparison
comparison is done with
ith
subraction
an implied
implied subtraction
subtraction (CMP #10)
#10) since the final
final result
result is
ulator if
Is now in the Accum
Accumulator
1f the
original number
number was valid.
original
7 -8

BCD to Binary
Purpose: Convert
Convert two
two BCD digits
digits in memory
memory locations
locations 0040
0040 and 0041 to a binary
binary
number in memory
memory location
location 0042.
0042. The most significant
significant BCD digit
digit is in
number
memory location
location 0040.
memory
Sample Problems:
(0040)
(0041)

a.

(0042)
Result: (0042)
b.

Result:

=
=

02
09

= 1015
1D -] 6 == 2910
29 -| o

(0040)
(0041)

= 07 07
= 01 01

(0042)

=

47
1 g = 7110
•] q
715

Note: We include
include no flowchart
chart because the program
program multiplies
ultiplies the most significant
significant
digit
ig it by 10 simply
ply by using the formula
formula 10x =Bx+
8x + 2x.
ultiplying by 2 requires
2x. Multiplying
one arithm
etic left shift
shift and multiplying
ultiplying by 8 requires three such shifts.
arithmetic

Source Program:
LDA
LOA
ASL
STA
ASL
ASL
CLC
CLC
ADC
ADC
STA
BRK
BRK

$40
A
$42
A
A

GET MOST SIGNIFICANT DIGIT
:GET
DIGIT (MSD)
(MSD)
:MSD TIMES TWO
:SAVE MSD TIMES TWO
:MSD TIMES FOUR
FOUR
:MSD TIMES
TIMES EIGHT
EIGHT

$42
$41
$42

:MSD TIMES
TIMES TEN
TEN (NO
(NO CARRY)
CARRY)
:ADD LEAST
LEAST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
STORE
:STORE BINARY
BINARY EQUIVALENT

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008
000C
oooc
000D
0000
000E
OOOE

A5
40
OA
OA
85
42
OA
OA
OA
OA
18
18
65
42
65
41
41
85
42
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$40

ASL
STA

A
$42

ASL
ASL
CLC
CLC
ADC
ADC

A
A

ADC

$41
$41

STA
STA

$42

BRK
BRK

7 -9

$42

BCD
converted to binary in order to save on storage and to simplify
plify calculacalcula­
BCD entries are converted
tions. However.
However, the need for conversion may offset some of the advantages
advantages of binary
storage and arithmetic.
arithmetic.
ultiplies the BCD digit
ig it in memory location
location 0040
0040 by 10 using left shifts
This program multiplies
2 Note that ASL A multiplies
and additions. 2
ultiplies the contents
contents of the Accum
ulator by 2,
Accumulator
2. This
allows you to multiply
ultiply the contents
Accum ulator by small decimal
decimal numbers in a
contents of the Accumulator
instructions. How would
would you use this procedure to multiply
ultiply by 16? by 12? by 7?
few instructions.
BCD
about 20% more storage than do binary numbers. Representing 0
BCD numbers require about
1 =
to 999 requires 3 BCD
digits (12 bits) and 10 bits in binary (since 2^0
= 1000).
= 1024::::
1000).
BCD digits

7 -10
0

Convert Binary Number to ASCII String
Purpose: Convert the 8-bitit binary number in memory
memory location 0041
0041 to
to eight
eight ASCII
ASCII
Purpose:
ASCII 0 or ASCII
ASCII 1)
1) in
in memory
memory locations
locations 0042 through
through
characters (either ASCII
0049 (the most significant
significant bit is in
In 0042).
0042)
Sample Problem:

(0041)
(0041)
Result:
Result:

=

02 ==1 1 0 1
11010010
D2
001

(0042)
31
31
(0042)
(0043) = 31
31
(0043)
(0044) = 30
(0044)
(0045) = 31
31
(0045)
(0046) = 30
(0046)
(0047)
(0047) = 30
31
(0048) = 31
(0048)
(0049) = 30
(0049)

ASCII 1
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII

Flowchart:
Flowchart:
Start

Base= 0041
Index= B

(Base + Index) =
ASCII Zero
Shift Data Right
One Bit

(Base + Index) =
ASCII One
li.e , (Base + Index)

+ 1)

Index = Index • 1

End

77-11

Source Program:
Program:

CONV

COUNT

LDA
LDX
LDY
STY
LSR
LSR
BCC
BCC
INC
DEX
DEX
BNE
BNE
BRK
BRK

$41
#88
#'O
'0
$41.X
$41.X
A
COUNT
$41,X
$41.X

GET DATA
;GET
:NUMBER OF BITS== 88
:GET
ZERO TO STORE
STORE IN STRING
STRING
GET ASCII ZERO
;STORE
ZERO IN STRING
STRING
STORE ASCII ZERO
DATA ZERO?
;IS NEXT BIT OF DATA
ZERO?

;NO. MAKE STRING
STRING ELEMENT
ELEMENT ASCII ONE
ONE
;NO,
BITS
;COUNT BITS

CONV

Object Program:
Object
Memory
Memory Address
Address
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000
B
OOOB
oooc
OOOC
000D
OOOD
OOOE
000E
000F
OOOF
0010
0010

A5
41
A2
08
AO
30
94
41
4A
90
02
F6
41
CA
DO
DO
F6
F6
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

CONV

COUNT

LDA

$41

LDX

#88

LDY

#'O
'0

STY

$41.X
,X

LSR
LSR
BCC
BCC

A
COUNT

INC

$41.X
$41.X

DEX
DEX
BNE
BNE

CONV

BRK
BRK

digits form a sequence
sequence so ASCII 1 = ASCII 0
instruction can be
The ASCII digits
O+
+ 1.1. The INX instruction
increment
used to directly
directly increm
ent the contents
contents of a memory
memory location.
location. The savings
savings here are that
no explicit
explicit instructions
instructions are required
required to load the data from memory
memory or to store the result
back into memory. Nor are any of the user registers
registers (A,
disturbed. However.
However,
(A. X,
X. and Y) disturbed.
CPU must
the CPU
must actually
actually load the data from memory.
memory, save it in a temporary
temporary register.
register, increincre­
ment
it. and store the result back into memory.
ment it,
memory. All data processing
processing actually
actually takes place
inside the CPU.
CPU.
Be careful
careful of the difference
difference between
between INX and an instruction
instruction like INC $41.X.
$41.X. The INC inin­
struction adds one to the contents
contents of Index Register
Register X; INC $41.X
,X adds one to the concon­
struction
It has no effect
X.
tents of the indexed
indexed memory
memory location
location -— it
effect on Index Register X.

Binary-to-ASCII
Binary-to-ASCII conversion
conversion is necessary when
when numbers
numbers are printed
printed in binary
binary form on an
ASCII device.
The conversion
(3015).
conversion to ASCII simply
ply involves
involves adding
adding ASCII zero (30-|
6>.

7-12
7-

PROBLEMS
1)

ASCII to Hex
Hex
ASCII

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040 to a hexadecimal
hexadecimal digit
digit and
store the result
result in memory location
location 0041. Assume
Assume that memory location
0040 contains
contains the ASCII representation
representation of a hexadecimal
hexadecimal dig
ith
0040
digitit (7 bits with
MSB 0).
Sample Problems:
a.
a.

b.

(0040)
(0040)

=

ASCII C
43 ASCII
C
43

(0041)
Result: (0041)

=

0C
oc

(0040)
(0040)

=

36 ASCII
ASCII 66
36

(0041.) =
Result: (0041)

2)

06
06

Seven-Segm
ent to Decimal
Seven-Segment

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040
0040 from a seven-segment
seven-segment code
to a decimal
decimal number
number in memory location
location 0041. If memory
memory location
location 0040
0040 does
contain a valid seven-segment
seven-segment code,
memory location
location 0041 to FFi
g.
not contain
code. set memory
FF16
Use the seven-segment
seven-segment table given under the Decimal
Decimal to Seven-Segment
Seven-Segment exex­
ample and try to match codes.
codes.
Sample Problems:
a.
a.

b.

3)

(0040)
(0040)

=

4F
4F

(0041)
Result: (0041)

=

03
03

(0040)
(0040)

=

28
28

(0041)
Result: (0041)

=

FF
FF

Decimal
al to ASCII

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040
0040 from a decimal
decimal digit
digit to an
ASCII character
character and store the result in memory
memory location
location 0041. If the number
number
in memory
memory location
location 0040 is not a decimal
decimal digit.
digit, set the contents
contents of memory
location 0041 to an ASCII blank character
character (20-|g).
location
(2015).
Sample Problems:
a.
a.

b.
b.

4)

(0040)
(0040)

= 07
07

(0041)
Result: (0041)

=

37 ASCII
37
ASCII 77

(0040)
(0040)

=

55
55

(0041)
Result: (0041)

=

ASCII SPACE
SPACE
20 ASCII
20

Binary to BCD

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040
0040 to two BCD digits
digits in memory
locations
igit.
locations 0041 and 0042
0042 (most significant
significant d ig
it in 0 041).'
4 1 ).'The number
number in
memory location
location 0040
0040 is unsigned
unsigned and less
memory
less than 100.
100.
Sample Problems:
a.
a.

b.
b.

(0040)
(0040)

=

(29decimal)
decimal)
1D (29
1D

(0041)
Result: (0041)
(0042)

=
=

02
02
09

(0040)
(0040)

=

47
(71decimal)
decimal)
47 (71

(0041)
Result: (0041)
(0042)

=
=

07
07
01

7 -13

5)
6)

ASCII String to Binary Number

Purpose: Convert the eight
eight ASCII
locations 0042 through
through 0049
ASCII characters in memory locations
to an 8-bitit binary number
number in memory location 0041 (the most significant
significant bit
ASCII characters
is in 0042). Clear memory location
location 0040
0040 if all the ASCII
characters are either
ASCII 1 or ASCII
ASCII 0 and set it to FF•)q
FF15 otherwise.
ASCII
Sample Problems:
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)

= 31
= 31
= 30
= 31
= 30
= 30
= 31
= 30

(0041)
(0040)

=
=

D2
00

a· except:
b. same as •'a'
(0045)

=

37

(0040)

=

FF
FF

a.

Result:

Result:
Result:

ASCII 1
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII

ASCII 7
ASCII

7-14
7-

REFERENCES
REFERENCES
1.

D. R.
Allison, "A Design Philosophy
Philosophy for M icrocom
puter Architectures."
Architectures,” Computer.
Computer,
R. Allison.
icrocomputer
February 1977. pp. 35-41.
35-41. This is an excellent
excellent article
article which
which we recommend
recommend highly.
February

2.

Other BCD-to-binary
BCD-to-binary conversion
conversion methods
methods are discussed
discussed in J.A. Tabb and M.L.
Other
Roginsky, "Microprocessor
icroprocessor Algorithm
BCD-Binary Conversions
Conversions.Super-fast,"
Roginsky.
Algorithmss Make BCD-Binary
Super-fast."
EDN.
January 5,
1977, pp. 46-50
46-50 and in J.B. Peatman.
Peatman, Microcomputer-based
Microcomputer-based
EON. January
5. 1977.
Design. (New York: McGraw-Hill.
McGraw-Hill, 1977,
400-406.
Design.
1977. pp. 400-406.

77-15

Chapter 8
ARITHMETIC PROBLEMS
ARITHMETIC
PROBLEMS
Most
ost arithmetic
arithm etic in microprocessor applications consists of multiple-word
ultiple-word binary
or decimal manipulations. A decimal correction (decimal adjust) or some other
means for performing decimal
decimal arithm
etic is frequently
frequently the only arithmetic
etic instrucinstruc­
arithmetic
tion provided besides basic addition and subtraction. You must implement
implement other
arithmetic
etic operations with
ith sequences of instructions.
Multiple-precision
ultiple-precision binary arithmetic
etic requires simple repetitions
repetitions of the basic
single-word instructions. The Carry bit transfers
transfers inform
ation between
between words. Add
single-word
information
with
ith Carry and Subtract
Subtract with
ith Carry use the information
information from the previous
previous arithm
etic
arithmetic
operations. You must
must be careful
careful to clear
clear the Carry before operating
operating on the first
first words
words
operations.
(obviously there is no carry into or borrow
borrow from the least significant
significant bitsl.
bits).
(obviously
Decimal arithm
etic is a common
common enough
enough task for microprocessors
microprocessors that
that most have
Decimal
arithmetic
special instructions
instructions for this purpose. These instructions
instructions may either
either perform
perform decimal
decimal
special
operations directly
directly or correct
correct the results
results of binary
binary operations
operations to the proper
proper decimal
decimal
operations
form. Decimal
Decimal arithm
etic is essential
essential in such applications
applications as point-of-sale
point-of-sale terminals.
terminals,
arithmetic
calculators, check processors.
processors, order entry
entry systems.
systems, and banking
banking terminals.
terminals.
calculators.
plement multiplication
ultiplication and division
division as series of additions
additions and subtractions
subtractions
You can implement
respectively, much
much as they are done by hand. Double-word
Double-word operations
operations are necessary
respectively.
ultiplication produces
produces a result
result twice
twice as long as the operands.
operands, while
hile a division
division
since a multiplication
similarly
ilarly contracts
contracts the length
length of the result. Multiplications
ultiplications and divisions
divisions are time-cone-con­
suming when
when done in software
software because of the repeated arithm
etic and shift
shift operations
operations
suming
arithmetic
that are necessary. Of course.
course, multiplying
ultiplying or dividing
dividing by a power
power of 2 is simple
simple because
that
operations can be implemented
implemented with
ith an appropriate
appropriate number
number of left or right
right
such operations
arithm
etic shifts.
arithmetic

8-1

EXAMPLES
EXAMPLES
Multiple-Precision
M
ultiple-Precision Binary Addition
Purpose:
twoo m
multiple-word
Purpose: Add
Add tw
ultiple-word binary
binary numbers.
numbers. The length
length of the numbers
numbers (in bytes)
Is
is In
in memory
memory location
location 0040.
0040, the numbers
numbers themselves
themselves start
start (most significant
significant
bits
bits first)
first) inin memory
memory locations
locations 0041 and 0051.
0051, respectively.
respectively, and the sum
replaces
replaces the
the number
number starting
starting in memory
memory location
location 0041.
Sample
Sample Problem:
Problem:

Result:

that is,
is.

(0040)
(0040)

04

(0041)
(0041)
(0042)
(0042)
(0043)
(0044)
(0044)

2F
5B
A7
C3

(0051)
(0052)
(0053)
(0054)

14
DF
35
B8

(0041)
(0042)
(0043)
(0044)

44
3A
DD
7B
2F5BA7C3

+ 14DF35B8
443ADD7B
443ADD7B

Flowchart:
Flowchart:
Start

Index = (0040)
Carry= 0

(0040+1ndex) =
(0040+1ndex) +
(OOSO+lndex) +
(Carry)

Index = Index - 1

End

8-2
8-2

(This step also produces new Carry)

Source Program:

ADDW
ADDW

LDX
CLC
LDA
ADC
STA
DEX
BNE
BRK
BRK

$40
$40,X
$40.X
$50,X
$50.X
$40,X
$40,X

;INDEX
:INDEX== LENGTH OF STRINGS
STRINGS
;CLEAR CARRY TO START
:CLEAR
;GET
:GET BYTE FROM STRING
STRING 1
;ADD BYTE FROM STRING
:ADD
STRING 2
;STORE
:STORE RESULT
RESULT IN STRING
STRING 1

ADDW
ADDW

CONTINUE
:CONTINUE UNTIL ALL BYTES
BYTES ADDED

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
OOOB
OOOC
oooc

A6
40
18
B5
40
75
50
95
40
CA
DO
DO
F7
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

ADDW
ADDW

LDX

$40

CLC
CLC
LDA

$40,X
$40,X

ADC

$50,X
$50.X

STA

$40,
$40.XX

DEX
DEX
BNE
BNE

ADDW
ADDW

BRK
BRK

relative address for BNE
ADDW is:
The relative
BNE ADDW
is:
0003 =
-000C
-OOOC

03
+F4
F7F7

The instruction
instruction CLC is
Is used to
to clear the
the Carry bit since there is no carry involved
involved in the
addition of the least significant
significant bytes.
addition
The instruction
instruction ADC. Add with
ith Carry,
includes the Carry from the previous
previous words in the
Carry. includes
addition. ADC is
instruction in
affects the Carry
Carry. In particular.
Inparticular,
addition.
Is the only InstructIon
In the
the loop that affects
note that increm
ent and decrement
decrement instructions
instructions (DEC,
increment
(DEC. DEX,
DEX. DEY,
DEY. INC,
INC. INX,
INX. INY)
INYI do not
affect the
affect
the Carry.
Carry.
This program uses the same index with
ith two
different base ad­
two different
addresses to handle the
any­
the tw
two strings. The strings can be located anywhere in memory. Furthermore,
ifficu lty in
Furthermore. there would
would be no difficulty
In
storing the
the result in
In a third string.

DECIMAL
DECIMAL
ACCURACY
IN BINARY

This
procedure can add binary numbers
This procedure
numbers of any length. Note that ten
ten binary bits corres­
correspond
pond to
to three
three decimal
decimal digits
digits since 2^0
210 = 1024
1024 =
::::::1000. So.
So. you
you can calculate
calculate the
the num-­
ber
accuracy in decimal
decimal digits. For
ber of bits required
required to
to give a certain accuracy
For example,
example. twelve
decimal ddigitit accuracy
accuracy requires:
decimal

f

1
12
12 xx ^

88-3

=400 bits
bits

Decimal Addition
Purpose: Add twoo multi-byte
ulti-byte decimal
decimal (BCD)
(BCD) numbers. The length of the numbers (in
bytes) is in memory location 0040, the numbers themselves start (most
sig­
(most significant bits first) in memory locations
locations 0041 and 0051, respectively,
respectively, and the
nificant
sum replaces the number
number starting
starting in memory location 0041.
Sample Problem:

Result:
Result:

that is,
is.

(0040)

=

04

(0041)
(0041)
(0042)
(0043)
(0043)
(0044)

=

=
=
=

36
70
19
85
B5

(0051)
(0051)
(0052)
(0052)
(0053)
(0053)
(0054)
(0054)

=
=
=
=

12
66
34
59

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)

=
=
=
=

49
36
54
44
36701985
36701985
+12663459
+12663459
49365444
49365444

Flowchart:
Flowchart:
Start

Set Decimal Mode
Index = (0040)
Carry= 0

(0040+1ndex) =
(0040+1ndex) +
(0050+1ndex) +
(Carry)

Index = Index - l

Clear Decimal Mode

End

88-4

(This step also produces new Carry)

Source Program:

ADDW
ADDW

SED
LDX
LOX
CLC
LDA
LOA
ADC
STA
DEX
BNE
CLD
CLO
BRK
BRK

$40
$40
$40,X
$40.X
$50,X
$50.X
$40,X
$40.X
ADDW
ADDW

;MAKE
MAKE ALL
ALL ARITHMETIC DECIMAL
DECIMAL
;INDEX== LENGTH OF STRINGS
STRINGS
INDEX
:CLEAR CARRY TO START
:GET TWO
TWO DIGITS FROM STRING 1
;ADD
STRING 2
ADD TWO
TWO DIGITS FROM STRING
STORE RESULT
:STORE
RESULT IN STRING 1
:CONTINUE
CONTINUE UNTIL ALL DIGITS ADDED
:RETURN TO BINARY MODE
:RETURN

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
OOOB
oooc
oooc
000D
000D
000E
OOOE

F8
A6
40
18
B5
40
75
50
95
40
CA
DO
DO
F7
D8
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

ADDW
ADDW

SED
SED
LOX
LDX

$40

CLC
LOA
LDA

$40.X
$40.X

ADC

$50.X
$50,X

STA

$40.X
$40,X

DEX
DEX
BNE
BNE

ADDW
ADDW

CLD
CLO
BRK
BRK

The Decimal mode automatically
automatically takes care of the following
situations in which binary and BCD addition differ:
1)
1)

15 inclusive.
The sum of two digits
digits is between
between 10 and 15
inclusive. In this
case,
must be added to
right result,
case. six must
to the sum to give the
the right
result. i.e.,
1.e..

+ 1000

0101

(5)
(5)
(8))
(8

1101

(D)
(D)

+

6502
6502
DECIMAL
DECIMAL
MODE

+ 0110
0001 0011

2)
2)

(BCD 13,
13. which
(BCD
which is correct)

d1g1tsis 16 or more. In this
this case,
case. the result is a proper
BCD digitit but
The sum of two digits
proper BCD
six less
i.e.,..
less than
than it should be,
be, i.e
(8))
1000 (8
(9)
+
1001 (9)
+ 1001
0001 0001
+
+ 0110

(BCD 11)
11)
(BCD

0001 0111
0001

(BCD 17,
17. which
correct)
(BCD
hich is correct)

Six must
recognized by
must be
be added in
in both situations.
s1tuat1ons. However,
However. case
case 11 can be recognized
by the
the fact
fact
that the
the sum is
is not a BCD
BCD digit.
e . itit is
is between
(or A and F
F hexadecimal).
that
digit, 1
i.e..
between 10 and 15 (or
Case 22 can only be
be recognized
by the
the fact
fact that
that the
the carry from
from the
the d ig
d1g1t
1sone
one
Case
recognized by
it addition
addition is
since
since the
the result is
is aa valid
valid BCD
BCD number.
number.

8-5

tic is carried out in the decimal
When the Decimal Mode flag is set, all arithem
arithemtic
form. This includes subtractions as welll as additions, regardless of which address­
addressing
ing mode is employed.
However, the Increment
Increment and Decrement
Decrement instructions pro­
DECIMAL
However,
proDECIMAL
duce
duce binary results even when the Decimal Mode flag is
MODE
set. Thus DEC.
DEC, DEX.
DEX, DEY.
DEY, INC,
INX, and INY can only be used
LIMITATIONS
INC. INX.
LIMITATIONS
to maintain
maintain binary
binary counters.
counters. For example.
example, to increment
increment a
decimal counter
counter in memory
memory location
location 0040.
0040, you must
must use the sequence:
sequence:
decimal
SED
SED
LDA
CLC
CLC
ADC
STA
CLD

$40
#1
$40

;MAKE ARITHMETIC DECIMAL
;GET
;GET COUNTER
COUNTER
;KEEP
;KEEP CARRY
CARRY FROM
FROM AFFECTING
AFFECTING ADDITION
INCREMENT
;INCREMENT COUNTER
COUNTER (DECIMAL)
(DECIMAL)
;RETURN
;RETURN TO BINARY MODE

instructions may not be necessary if other
other parts of the program
program
The SED,
SED. CLC,
CLC. and CLD instructions
set the status
status flags appropriately.
appropriately.
Subtractions in the decimal
decimal mode produce
produce correct
correct BCD results
results with
ith the Carry being an
Subtractions
inverted
ulator contains
contains 03,
memory
inverted borrow. For example,
example. if the Accum
Accumulator
03. the addressed memory
location contains
contains 27,
contains 1. after
after the execution
execution of an SBC
instruction
location
27. and the Carry contains
SBC instruction
the Accum
ulator will
ill contain
contain 76 and the Carry will
ill be 0. As in the binary
binary mode,
Accumulator
mode. a Carry
that a borrow
borrow has been generated.
of zero means that

The Sign bit is not meaningful after
after additions and subtractions when
when the Decimal
reflects the result
result of the binary
binary operation.
operation, not of the decimal
decimal operaopera­
Mode flag is set. It reflects
tion. In the most recently
recently mentioned
mentioned situation
situation (03-27),
ill be set (as
(03-27). the Sign bit will
(as it
would be if the numbers
numbers were binary) even though
though the decimal
decimal result
result (76)
would
(76) has a most
significant bit of zero.
significant
zero.
procedure can add decimal
decimal (BCD)
numbers of any length.
This procedure
(BCD) numbers
Here four binary
binary bits are required
required for each decimal
decimal digit.
digit, so
twelve-digit
elve-digit accuracy
accuracy requires

ACCURACY IN
BINARY AND BCD

12 x 4
= 48 bits
4=48
as opposed to 40 bits in the binary
binary case
case. This is six 8-bit
-b it words
words instead of five.
program for decimal
decimal addition
addition is the same as that
that for binary
binary addition
addition except
except for the
The program
surrounding CLD and SED
instructions. Thus a single sequence
sequence of instructions
instructions can propro­
surrounding
SED instructions.
entirely different
different results depending
depending on the value of a flag that
that is not even
duce twoo entirely
mentioned explicitly.
explicitly. Can you suggest
suggest some problems
problems this might
ight create in connecting
connecting
mentioned
programs written
ritten at different
different times
times or by different
different people?
people?
programs

8-6

8 -Bit
it Binary Multiplication
ultiplication
Purpose: Multiply
ultiply the 8-bit
-b it unsigned
number in memory
memory location
location 0040
0040 by the 8-bit
Purpose:
unsigned number
8-bit
unsigned number
number in memory location
location 0041. Place the eight
eight least significant
significant
unsigned
result into
into memory
memory location
location 0042
0042 and the eight
eight most significant
significant
bits of the result
memory location
location 0043.
bits into memory
Sample Problems:
a.
a.

(0040)
(0040)
(0041)

= 03
03
= 05
05

(0042)
Result: (0042)
(0043)

= OF
OF
= 00
00

or in decimal
decimal 3 xx 55 = 15
b.

(0040)
(0040)
(0041)

= 6F
6F
= 61
61

(0042)
Result: (0042)
(0043)

= OF
OF
= 2A
2A
or 111 x 997 == 10.
10.767
767

You can perform
perform multiplication
ultiplication on a computer
puter in the same way that
that you do long
multiplication
ultiplication by hand. Since the numbers
numbers are binary.
binary, the only problem
problem is whether
whether to
multiply
ultiply by 0
ultiplying by zero obviously
obviously gives zero as a result.
result, while
hile multiplyultiply­
O or 1;
1: multiplying
ing by one produces
produces the same number
number that
that you started with
ith (the multiplicand).
Itiplicand). So,
So. each
step inina binary
binary m
ultiplicationcan
canbebereduced
reducedtotothe
thefollowing
followingoperation.
operation.
multiplication
If the current
current bit in the multiplier
ultiplier is 1. add the multiplicand
ultiplicand
to the partial
partial product.
product.

MULTIPLICATION
MULTIPLICATION
ALGORITHM_____
ALGORITHM

The only remaining
remaining problem
problem is to ensure that you line everything
everything up correctly
correctly each
time. The follow
ing operations
operations perform this task
task.
following
1)
1)
2)

Shift the multiplier
ultiplier left one bit so that the bit to be examined
examined is placed in the Carry.
Shift
Carry.
Shift the product
product left one bit so that
that the next addition
addition is lined up correctly.
correctly.
Shift

complete process for binary
binary multiplication
ultiplication is as follows:
follows:
The complete
Initialization
Step 1 - Initialization
Product
Product== 0
Counter
Counter== 8
Shift Product
Product so as to line up properly
properly
Step 2 - Shift
Product = 2 x Product
Product (LSB
Product
(LSB = 0)
Shift Multiplier
ultiplier so bit goes to Carry
Step 3 - Shift
Multiplier=
ultiplier = 2 x Multiplier
ultiplier
ultiplicand to Product
Product if Carry is 1
Step 4 - Add Multiplicand
If Carry== 1,
ultiplicand
1. Product
Product== Product
Product++ Multiplicand
Decrement Counter
Counter and check for zero
Step 5 - Decrement
Counter
Counter - 1
Counter== Counter
If Counter
Counter ¥=
0 go to Step 2
cfoO

8-7

In
In the
the case
case of
of Sample
Sample Problem
Problem b,
b. where
where th
the multiplier is 6115 and the multiplicand
6Fi
q the
6F15
the process
process works
works as
as follows:
follows:

Initialization:
Initialization:
Product
Product
Multiplier
ultiplier
M
ultiplicand
Multiplicand
Counter
Counter

0000
0000
61
61
6F
6F
08
08

A
fter first
After
first iteration
iteration of
of steps
steps 2-5:
2-5:
Product
Product
M
ultiplier
Multiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from
ultiplier
from M
Multiplier

0000
C2
C2
6F
6F
07
07
0

After
After second iteration:
iteration:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from Multiplier
ultiplier

006F
84
6F
6F
06
1

After
After third iteration:
iteration:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
ultiplier
Carry from Multiplier

014D
08
6F
05
1

After fourth
fourth iteration:
iteration:
After
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
ultiplier
Carry from Multiplier

029A
029A
10
6F
04
0

After
fter fifth
fifth iteration:
iteration:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from Multiplier
ultiplier
Carry

0534
0534
20
6F
03
0

After sixth
sixth iteration:
iteration:
After
0A68
Product OA68
Product
Mult1pl1er
ultiplier
40
M
Muultiplicand
lt1plicand
6F
Counter
Counter
02
Carry from
from M
ultiplier
Carry
Multiplier
0
After seventh
seventh iteration:
iteration:
After
Product
Product
M
ultiplier
Multiplier
M
ultiplicand
Multiplicand
Counter
Counter
Carry from
from M
ultiplier
Carry
Multiplier

14D0
80
80
6F
6F
01
00

8-8
8-8

is

After
fter eighth
eighth iteration
iteration:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
ultiplier
Carry from Multiplier

2A0F
2AOF
00
6F
00
1

Flowchart:
Flowchart:
Start

Product= 0

Count= 8
Multiplicand-(0040)
Multiplier - 10041)

Product=2 x Product
(Shift left 1 bit)
Multiplier= 2 x
Multiplier
(Shift left 1 bit)

Product = Product
+ Multiplicand

Count = Count • 1

10042 and 00431 Product

End

8 -9

Source Program:
Program:
Source

SHIFT

CHCNT
CHCNT

LDA
LOA
STA
STA
LDX
LOX
ASL
ASL
ROL
AOL
ASL
ASL
BCC
CLC
ADC
BCC
BCC
INC
DEX
BNE
STA
BRK
BAK

#
#00
$43
$43
#B8
A
A
$43
$43
$41
CHCNT
CHCNT
$40
$40
CHCNT
$43
$43
SHIFT
$42
$42

LSB'S OF
OF PRODUCT
ZERO
;LSB'S
PRODUCT== ZERO
;MSB'S
PRODUCT== ZERO
MSB'S OF
OF PRODUCT
ZERO
NUMBER OF BITS
BITS IN
IN MULTIPLIER
;NUMBER
MULTIPLIER== 88
SHIFT PRODUCT LEFT
LEFT ONE
ONE BIT
BIT
;SHIFT
SHIFT MULTIPLIER LEFT
LEFT
;SHIFT
;NO
NO ADDITION
ADDITION IF
IF NEXT
NEXT BIT
BIT IS
IS ZERO
ADD MULTIPLICAND
MULTIPLICAND TO PRODUCT
;ADD

WITH CARRY IF NECESSARY
;WITH
UNTIL 8 BITS ARE MULTIPLIED
MULTIPLIED
;LOOP UNTIL
STORE
STORE LSB'S OF PRODUCT

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
000C
oooc
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0013
0014
0015
0016
0017
0018
0018
0019
0019

A9
00
85
43
A2
08
OA
26
43
06
41
90
07
18
65
40
90
02
E6
E6
43
CA
DO
DO
EF
EF
85
42
42
00

Instruction
Instruction
(Mnemonicl
(Mnemonic)

SHIFT

CHCNT
CHCNT

LDA
LOA

#00

STA

$43

LDX
LOX

#88

ASL
ROL
AOL

A
$43

ASL

$41

BCC
BCC

CHCNT

CLC
CLC
ADC

$40

BCC
BCC

CHCNT

INC
INC

$43

DEX
DEX
BNE
BNE

SHIFT
SHIFT

STA
STA

$42
$42

BRK
BAK

88-10

Besides its obvious
terminals. multiplication
key
obvious use in calculators
calculators and point-of-sale
point-of-sale terminals,
ultiplication is a key
part
speed at which
part of almost
almost all signal processing and control
control algorithms.
algorithms. The speed
CPU in process
process con­
conmultiplications
ultiplications can be performed
performed determines
determines the usefulness of a CPU
trol.
trol, signal
signal detection.
detection, and signal analysis.
This
This algorithm
algorithm takes between
between 170 and 280 clock cycles to multiply
ultiply on a 6502
microprocessor.
microprocessor. The precise time depends on the number
number of 1 bits in the multiplier.
multiplier.
Other
algorithmss may be able to reduce the average execution
Other algorithm
execution time somewhat.
somewhat, but 250
clock
Some
clock cycles will
ill still
still be a typical
typical execution
execution time for a software
software multiplication.
ultiplication. Some
microprocessors
inmicroprocessors (such as the 9900.
9900, 8086.
8086, and Z8000) have hardware multiplication
ultiplication in­
structions
exterstructions that
that are somewhat
somewhat faster but
but maximum
maximum speed requires the addition
addition of exter­
nal hardware.

8-11

8 -Bit
it Binary Division
Purpose:
16-bit unsigned
unsigned number
number in memory locations 0040
0040 and 0041
Purpose: Divide the 16-bit
(most significant
significant bits in 0041) by the 8-bit
-b it unsigned
unsigned number
number in memory
memory localoca­
tion 0042. The numbers are normalized so that 1)
significant bits of
1) the most significant
dividend and the divisor
divisor are zero and 2) the number
number in memory
both the dividend
location 0042
0042 is greater
greater than the number
number in memory
memory location 0041.Thus.
0041.Thus, the
location
quotient is an 8-bit
-b it number. Store the quotient
quotient in memory location
location 0043 and
quotient
the remainder
remainder in location 0044.

Sample Problems:
a.
a.(0040)

=

40 (64(0040)
decimal)
(0041) =
(0042) =
Result

b.(0040)

=

=

40 (64 decimal)
00
08
(0043) = 08
(0044) = 00
i.S„ 6 4/8
/8 = 8
ie.

(0040)decimal)
6D (12.909 decimal)
6D (12,909
(0041) = 32
(0042) = 47 (71
(71 decimal)
Result

=

= B5 (181
(181 decimal)
(0043) =
(0044) = 3A (58 decimal)
12,909/71 = 181
ith a remainder
remainder of 58
i.e.,.. 12.909/71
181 with

You can perform division
division on the computer
puter just
just like you would
would perDIVISION
DIVISION
form division
division with
ith pen and paper,
subtractions.
ALGORITHM
paper. i.e.,.. using trial subtractions.
ALGORITHM
Since the numbers are binary.
binary, the only question
question is whether
whether the bit
”
in the quotient
quotient is 0 or 1,
whether the divisor
divisor can be subtracted
subtracted from what
hat is left of
1. i.e.,.. whether
the dividend.
dividend. Each
division can be reduced to the follow
ing operation:
Each step in a binary division
following
If the divisor
divisor can be subtracted
subtracted from the eight
significant bits of the dividend
dividend without
ithout
most significant
a borrow.
borrow, the corresponding
corresponding bit in the quoquo­
otherwise it is 0.
tient is 1; otherwise
The only remaining
remaining problem is to line up the dividend
dividend and quotient
quotient properly. You can
do this by shifting
shifting the dividend
dividend and quotient
quotient logically
logically left one bit before each trial
subtraction. The dividend
dividend and quotient
quotient can share a 16-bitit register.
register, since the procedure
subtraction
clears one bit of the dividend
dividend at the same time as it
determines one bit of the quotient.
quotient.
11determines
The complete
complete process for binary division
division is:
Step 1 - Initialization:
Initialization:
Quotient
Quotient== 0
Counter== 8
Step 2 - Shift Dividend
Dividend and Quotient
Quotient so as to line up properly:
properly:
Dividend = 2 x
X Dividend
Dividend
Quotient = 2 x Quotient
Quotient
Quotient
Step 3 - Perform trial Subtraction.
Subtraction. If no Borrow add 1 to Quotient:
Quotient:
If 8 MSBs of Dividend
Dividend >
> Divisor then
MSBs of Dividend
Dividend = MSBs of Dividend
D1v1dend- Divisor
D1v1sor
Quotient = Quotient
Quotient +
Quotient
+1
Step 4 - Decrement
Decrement counter
counter and check for zero:
zero·
Counter== Counter - 1
if Counter -..00., go to Step 2
Remainder = 8 MSBs
MSBs of Dividend

8-12
8-12

In the
the case
case of
of sample
sample problem
problem b.
b, where
where the
the dividend
dividend is
is 326D15
326D-|6 and
and the
the divisor
divisor is
is47-|g,
4715.
the process
process works
works as
follows:
the
as follows:
Initialization:
Initialization:
Dividend
Dividend
Divisor
Divisor
Quotient
uotient
Counter
Counter

326D
47
47
00
00
00
00

After
fter first
first iteration
iteration of Steps 2 - 4:
(Note that
that the dividend
dividend is shifted
shifted prior
prior to the trial subtraction)
subtraction)
Dividend 1DDA
Dividend
ODA
47
Divisor
01
Quotient
Quotient
07
Counter
Counter

After second iteration of Steps 2 - 4:
3BB4
Dividend 38B4
Dividend
47
Divisor
02
Quotient
Quotient
06
Counter
Counter
After
fter third
third iteration:
iteration:
Dividend
D1v1dend 3068
47
Divisor
Divisor
05
Quotient
uotient
Counter
05
Counter
After
fter fourth
fourth iteration:
iteration:
Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

19D0
47
0B
OB
04

Dividend
Dividend
Divisor
Divisor
Quotient
uotient
Counter
Counter

33A0
33AO
47
16
03

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

2040
47
2D
02

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

4080
47
5A
01

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

3AOO
3AOO
47
B5
00

After
fter fifth
fifth iteration:
iteration:

After sixth iteration:
iteration:
After

After seventh iteration:
iteration:
i:
After

After
fter eighth
eighth iteration:
iteration:

remainder is 3A
So the quotient is B5 and the remainder

8-13
813

The MSBs
MSBs of dividend
dividend and divisor
plifies calculations
calculations
divisor are assumed to be zero; this simplifies
(the shift prior to the trial subtraction
subtraction would otherwise place the MSB of the dividend
dividend in
the Carry).
plified by removing parts of
Carry). Problems that are not in this form must be simplified
the quotient
quotient that
that would
would overflow
overflow an 8-bit
8-bit word. For
For example:
1024 = 400 (Hex)
(Hex) =
3
3

+ 100 (Hex)
100 +
3
100 (Hex)

The last problem is now in the proper form. An extra division
division may be necessary.
necessary.

Flowchart:
Flowchart:
Start

Dividend = (0040
and 0041)
Divisor= (00421
Count= 8
Quotient= 0

Dividend = 2 x
Dividend

Quotient = 2 x
Quotient

(Shift both left 1 bit)

8 I\ISBs of
Dividend = 8 MS8s
of Dividend • Divisor
Quotient=
~
Quotient+ 1

Count = Count - 1

(0043) = Quotient
(0044) = 8 MS8s of
Dividend

End

8 -14
14

Source Program:
Program:

DIVID

CHCNT

LDX
LOX
LDA
LOA
STA
LDA
LOA
ASL
ROL
ROL
CMP
BCC
BCC
SBC
SBC
INC
DEX
DEX
BNE
BNE
STA
BRK
BRK

#88
$40
$43
$41
$43
A
$42
CHCNT
$42
$43
DIVID
$44

;NUMBER OF BITS IN DIVISOR== 8
;START WITH LSB'S OF DIVIDEND
;GET
;GET MSB'S OF DIVIDEND
;SHIFT DIVIDEND.
DIVIDEND, QUOTIENT LEFT
LEFT 1 BIT

;CAN DIVISOR
DIVISOR BE
BE SUBTRACTED?
SUBTRACTED?
NO, GO TO NEXT STEP
,NO,
STEP
YES, SUBTRACT DIVISOR (CARRY
;YES,
(CARRY== 1)
1)
;AND INCREMENT
INCREMENT QUOTIENT BY 1
;LOOP UNTIL ALL 8 BITS HANDLED
;STORE
;STORE REMAINDER
REMAINDER

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
OOOB
oooc
oooc
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018

A2
08
A5
40
85
43
A5
41
06
43
2A
C5
42
90
04
E5
E5
42
E6
43
CA
DO
DO
F2
85
44
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

DIVID

CHCNT

LDX
LOX

#88

LDA
LOA

$40

STA

$43

LDA
LOA

$41

ASL

$43

ROL
ROL
CMP

A
$42

BCC
BCC

CHCNT

SBC
SBC

$42

INC

$43

DEX
DEX
BNE
BNE

DIVID

STA

$44

BRK
BRK

Division is used in calculators,
calculators, terminals,
terminals, comm
unications error checking,
checking, control
control
Division
communications
algorithms, and many other
other applications.
applications.
algorithms,
algorithm takes between
between 150 and 230 microseconds
microseconds to divide
divide on a 6502
6502 with
ith a 1
The algorithm
MHz clock. The precise time depends
depends on the number
number of 1 bits in the quotient.
quotient. Other
Other
algorithms can reduce the average time somewhat.
somewhat, but
but 200 microseconds
microseconds will
ill still
still be
algorithms
typical
typical for a software
software division.
division.
instructions ASL $43 and ROL
together provide
provide a 16-bit
16-bit arithm
etic left shift
shift of
The instructions
ROL A together
arithmetic
the dividend
ROL.instruction
dividend (MSBs in A). The ROL
instruction picks up the bit which
which the ASL instrucinstruc­
tion left in the Carry.

8 - 15
5

An 8-bitit subtraction
subtraction is necessary,
simple way to perform
perform a 16-bit
16-bit
necessary, since there is no simple
subtraction or comparison,
comparison.
subtraction
Memory
0043 and the Accum
ulator hold both the dividend
dividend and the quotient
Memory location
location 0043
Accumulator
quotient
(MSBs
Accumulator). The quotient
quotient simply
simply replaces the dividend
dividend in
memory location
(MS8s in Accumulator!,
In memory
0043 as the dividend
dividend is shifted
shifted left arithmetically.
arithmetically.
0043
worry about
about the Carry in the SBC
instruction. It must be 'V
We do not have to worry
SBC instruction,
'1' since
otherwise BCC
would have caused a branch,
branch. Remember that a Carry value of '1' has no
otherwise
8CC would
effect on the result of an SBC
instruction since
inverted borrow,
borrow.
effect
SBC instruction
s,nce the Carry is
Is an inverted
The fo llo
w in g ro u
tin e o ffe
rs an im p ro
ve m e n t in
in g over
over the pre
vio u s exam
ple
llowing
utine
ffers
provement
In tim
tImIng
previous
example
w ith
o u t in crea
sin g m em
ory usage.
usage. It also
also p e rfo
rm s error
rro r checking.
checking.
ithout
creasing
emory
rforms
DIV

DIVID
DIVID

CHCNT

DONE

LDX
LDA
STA
LDA
CMP
CMP
BCS
ROL
AOL
ROL
AOL
CMP
BCC
sec
SBC
DEX
BNE
ROL
AOL
STA
RTS
ATS

#8
$
S40
$43
S43
$41
$
S42
DONE
$
S43
A
$
S42
CHCNT
$42
42
DIVID
DIVID
S43
$
$444

NUMBER OF BITS IN DIVISOR
:NUMBER
DIVISOR== 8
LSB’S OF DIVIDEND
DIVIDEND
:START WITH LSB'S
MSB'S OF DIVIDEND
DIVIDEND
:GET MSB'S
SHOULD BE LESS THAN DIVISOR
:SHOULD
:IF NOT, ERROR
ERROR EXIT (CARRY== 1)
SHIFTDIVIDEND, QUOTIENT
QUOTIENT LEFT 1 BIT
:SHIFTDIVIDEND,
ANSWER BIT -— SEE DEX BELOW)
BELOW)
:(AND NEW ANSWER
DIVISOR BE SUBTRACTED?
SUBTRACTED?
:CAN DIVISOR
:NO, GO TO NEXT STEP (CARRY== 0)
SUBTRACT DIVISOR
DIVISOR (CARRY== 1)
:YES, SUBTRACT
ANSWER BIT
:NOTE CARRY' ' NEW ANSWER
HANDLED
:LOOP UNTIL ALL 8 BITS HANDLED
ANSWER BIT
:SHIFT IN THE LAST ANSWER
REMAINDER (CARRY== 0 HERE)
:STORE REMAINDER
HERE)
QUIT (CARRY 0, NORMAL,
1, ERROR)
ERROR)
;QUIT
NORMAL, CARRY l,

8-166
8-

Self-Checking Numbers
Double Add Double Mod 10
Purpose: Calculate
Calculate a checksum
checksum dig
string of BCD digits.
digits. The length
length of the
digitit from a string
string of digits
digits (number
(number of words) is in memory
memory location
location 0041;
0041; the string
string of
string
digits (2 BCD digits
digits to a word) starts in memory
memory location
location 0042. Calculate
Calculate the
digits
checksum digit
ig it by the Double
Double Add Double
Double Mod 10 technique
technique1 and store it in
checksum
memory location
location 0040.
memory
The Double
Double Add
Add Double
Double Mod
Mod 10
10 technique
technique works
works as
asfollows:
follows:
1) Clear
1)
Clear the
the checksum
checksum to
to start.
start.
2) M
ultiply the
Multiply
the leading
leading d ig
digit by
by two
two and
and add
add the
the result
result to
to the
the
checksum.
checksum.

SELF-CHECKING
SELF-CHECKING
NUMBERS
NUMBERS

3) Add
Add the
the next
next d ig
digit to
to the
the checksum.
checksum.
4) Continue
Continue the
the alternating
alternating process
process until
until you
you have
have used
used all
all the
thedigits.
digits.
5) The
significant d ig
self-checking digit.
digit.
The least
least significant
digit of
of the
the checksum
checksum is
is the
the self-checking
Self-checking digits
digits are commonly
commonly added to identification
identification numbers
numbers on credit
credit cards, inin­
Self-checking
ventory tags, luggage.
luggage, parcels, etc., when
when they are handled
handled by computerized
computerized systems.
ventory
routing messages,
identifying files, and other
other applications.
applications.
They may also be used in routing
messages, identifying
The purpose
purpose of the digits
digits is to minimize
minimize entry
entry errors such as transposing
transposing digits
digits (69 inin­
stead of 96), shifting
shifting digits
digits (7260 instead of 3726), missing
missing digits
digits by one (65 instead of
64), etc. You can check the self-checking
self-checking number
number autom
atically for correctness
correctness upon
automatically
entry and can eliminate
eliminate many errors immediately.
immediately.
entry
self-checking methods
methods is quite
quite complex.
complex. For example.
example, a plain checksum
checksum
The analysis of self-checking
will
ill not find transposition
ill
+ 9 = 9 ++ 4). The Double
Double Add Double
Double algorithm
algorithm will
transposition errors (4 +
simple transposition
transposition errors (22 x 44 +
+ 9 = 177 ^/c2 xx99 ++ 4); but willill miss some errors,
errors.
find simple
transpositions across even numbers
numbers of digits
digits (367 instead of 763). However,
such as transpositions
this method
method will
ill find many common
common errors! The value of a method
method depends
depends on what
what erer­
rors it will
ill detect
detect and on the probability
probability of particular
particular errors in an application.
application.
For example.
example, if the string
string of digits
digits is

549321
result will
ill be:
the result
Checksum
Checksum
Self-checking digit
ig it
Self-checking

= 5 xx 22 +
+ 3 +
+ 2 xx22 +
0
+ 4 ++ 9 xx22 +
+ 1 == 440
= 0 (least significant
significant digit
ig it of a checksum)
checksum)

Note that
that an erroneous
erroneous entry
entry like 543921 would
would produce
produce a different
different self-checking
self-checking digit
digit
(4),
erroneous entries
entries like 049321
049321 or 945321 would
would not be detected
detected.
(4), but erroneous

Problems:
Sample Problems:
a.
a.

(0041)
(0041)
= 03 03
(0042) = 36
(0043) = 68
(0044) = 51
Result: Checksum
Checksum= = 3 xx 22 +
+ 6 ++ 6 xx 22 ++ 8 ++ 5 xx22 ++ 1 = 4433
(0040) = 03

b.

(0041)
= 04 04
(0041)
(0042) = 50
(0043) = 29
(0044) = 16
(0045) = 83
Result: Checksum
+ 0 ++ 2 xx 22 ++ 9 ++ 1 x 22 ++ 6 ++ 8 xx 22 ++ 3 = 50
Checksum= = 5 xx 22 +
(0040) =
= 00
8 -17
7

Flowchart:
Flowchart:

c

Start

D

Checksum== 0
Base=- 0041
0041
41)
Index = (0 0
(00411

MSD = (Base
(Base
+lndex)/16
lndex)/16
LSD== (Base+lndexl
(Base+lndex)
1111
AND 0 0 0 0
0001111
(binary)
Checksum
Checksum==
Checksum
Checksum+2 x MSD + LSD

Index = Index -1

(0 040)) = Checksum
AND
1111
AND 0 0 0 0
01111
(binary)
(binary)

End

8 -1
8-18

Source Program:

CHKDG

SED
SEO
LDX
LOX
LDY
LOY
LDA
LOA
LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA
CLC
ADC
STY
ADC
STA
LDA
LOA
AND
CLC
ADC
TAY
DEX
BNE
AND
STA
CLD
BRK
BRK

$41
#00
$41,X
$41.X
A
A
A
A
$40
$40
$40
$40
$40
$41,X
$41.X
#% 00
0 1 111
%00001111

MAKE ALL ARITHIMETIC DECIMAL
DECIMAL
;MAKE
INDEX
;INDEX== LENGTH OF STRING
STRING
:CHECKSUM = ZERO
ZERO
DATA
:GET NEXT 2 DIGITS OF DATA
SIGNIFICANT DIGIT
;SHIFT OFF
OFF LEAST SIGNIFICANT

;CLEAR CARRY FROM SHIFTING
SIGNIFICANT DIGIT
;DOUBLE MOST SIGNIFICANT
:DOUBLING A DIGIT NEVER
NEVER PRODUCES
PRODUCES A
CARRY
;ADD DOUBLED MSD TO CHECKSUM
SIGNIFICANT DIGIT
;GET LEAST SIGNIFICANT
; (MASK OFF
OFF MSD)
ADD LSD TO CHECKSUM
:ADD

$40
$40

CHKDG
#% 00
0 1 111
%00001111
$40

CONTINUE
:CONTINUE UNTIL ALL DIGITS SUMMED
;SAVE LSD OF SELF-CHECKING DIGIT
:SAVE
;RETURN
;RETURN TO BINARY MODE

8-19
8-19

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000BB
OOOC
oooc
000D
000E
OOOE
000F
OOOF
0010
0011
0012
0013
0014
0014
0015
0016
0017
0018
0019
001A
001A
0018B
001C
0010D
001E
01E
001F
01F
0020
0021
0022
0023
0024
0025
0026

F8
A6
41
AO
00
B5
41
4A
4A
4A
4A
85
40
18
65
40
84
40
65
40
85
40
B5
B5
41
41
29
OF
OF
18
65
40
A8
AS
CA
DO
DO
E4
E4
29
OF
OF
85
40
D8
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

CHKDG
CHKDG

SED
SEO
LDX
LOX

$41

LDY
LOY

#00

LOA
LDA

$41,X
$41.X

LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA

A
A
A
A
$40

CLC
CLC
ADC

$40

STY

$40

ADC

$40

STA

$40

LDA
LOA

$41.X
,X

AND

00001111
#% 00
00
1

CLC
CLC
ADC

$40

TAY
DEX
DEX
BNE
BNE

CHKDG
CHKDG

AND

#% 00
00
1
00001111

STA

$40

CLD
CLO
BRK
BRK

The digits are removed by shifting
shifting and masking. Four logical right shifts are needed
needed to
separate out the
significant digit.
the most significant
All arithmetic
etic is performed in the decimal mode.
mode Remember,
Remember. however,
however. that DEX
DEX still
produces a binary result.
result.
There
doubling a decimal
decimal digitit since the
There is no problem with the
the Carry from doubling
the result can
can
never be larger than
eliminate the final
instruction if the
than 18.
18. You may be able to
to eliminate
final CLC
CLC instruction
numbers
numbers to be
be summed are
are known to be
be too small to
to ever produce a Carry.
Carry.

8-20

Accumulator
You can double
double a decimal
decimal number
number in the Accum
ulator by
adding it to itself in the decimal
mode. A typical
decimal mode.
typical sequence is as
follows
follows (using memory location
location 0040 for temporary
temporary storage):
SED
SEO
STA
CLC
CLC
ADC
CLD
CLO

:MAKE ARITHMETIC
ARITHMETIC DECIMAL
;MAKE

DOUBLING AND
HALVING
DECIMAL
DECIMAL
NUMBERS

$40

$40

;KEEP
:KEEP CARRY
CARRY FROM
FROM AFFECTING
AFFECTING ADDITION
:DOUBLE NUMBER
NUMBER
;DOUBLE
:RETURN
:RETURN TO BINARY
BINARY MODE
MODE

You may not need the SED,
instructions if other parts of the program set
SED. CLC,
CLC. and CLD
CLO instructions
the Carry and Decimal Mode flags appropriately.
appropriately. Note that you cannot
cannot use ASL A to
decimal number
number because that
that instruction
instruction produces a binary result even if the
double a decimal
Decimal Mode flag is set.
set.
You divide
divide a decimal
decimal number
number by 2 simply
simply by shifting
shifting it right
right logically
logically and then
subtracting 3 from any digit
ig it that is 8 or larger (since
following
subtracting
(since 10 BCD
BCD is 16 binary). The following
divides a decimal
decimal number
number in memory location
location 0040
0040 by 2 and places the result
program divides
in memory location
location 0041.
LDA
LOA
LSR
LSR
TAX
AND
CMP
sec
BCC
TXA
SBC
SBC

DONE
DONE

TAX
STX
BRK
BRK

$40
A

;GET
:GET DECIMAL NUMBER
NUMBER
;DIVIDE
:DIVIDE BY 2 IN BINARY
BINARY

00001111
#% 00
00
1
#88
DONE
DONE

;IS
MORE?1
:IS LEAST
LEAST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT 8 OR
OR MORE

#33

:YES, SUBTRACT
SUBTRACT 3 FOR
FOR DECIMAL
;YES,
CORRECTION
: CORRECTION

$41

:STORE NUMBER
NUMBER DIVIDED
DIVIDED BY 2
;STORE

SBC instruction
There is no problem with
ith the Carry in the SBC
instruction since that instruction
instruction is only
executed if the Carry is set.
set. Remember that SBC
SBC subtracts
subtracts off the complemented
complemented Carry
(1 - C)
C) so a Carry of 1 does not affect
It.
(1
affect the result.
28. 30,
30. and 37. Do you underTry the division
division method by hand on the decimal
decimal numbers 28,
under­
stand why
hy it works? You may also wish to try the program on the same data.
whether the numbers are binary
Rounding is simple regardless of whether
or decimal. A binary number
number can be rounded as follows:
follows:

-----

BINARY
ROUNDING

1.
If the most significant
significant bit to be dropped
dropped is 1.
add 1 to the remaining
remaining bits. Otherwise.
Otherwise, leave
leave
the remaining
remaining bits alone.
alone.
O and 10 in binary.
This rule works because 1 is halfway
halfway between 0
binary, much as 5 is halfway
decimal== 0.1 binary).
in decimal
decimal (note that 0.5 decimal
So.
ing program will
ill round a 16-bit
16-bit number in memory locations 0040 and
So. the follow
following
0041 (MSBs
(MSBs in 0041) to an 8-bitit number in memory location 0041.

DONE
DONE

LDA
LOA
BPL
BPL
INC
INC
BRK
BRK

$40
DONE
DONE
$41

:IS MSB OF EXTRA
EXTRA BYTE
BYTE 1?
;IS
:YES. ROUND
ROUND MSB'S
UP
:YES,
MSB’S UP

8-21

number is longer than 16 bits, the rounding
rounding must ripple
ripple through
through all the bytes as
If the number
needed. Note that
that we could use BIT $40 instead of LDA
$40 since the BIT instruction
instruction
LOA $40
sets the Sign flag according
according to the most significant
significant bit
bit of the addressed memory
memory localoca­
Accumulator
tion. This approach leaves the Accum
ulator as it was although
although it does change the
status flags.
rounding is a bit
bit more d iffic
u lt because the crossover
Decimal rounding
ifficult
point is now BCD 50 and the rounding
rounding must produce
produce a decimal
decimal
point
result. The rule is:

DECIMAL
DECIMAL
ROUNDING

If the most significant
significant digitit is to be dropped
dropped
is 5 or more, add 1 to the remaining
remaining digits.
following program will
ill round a 4-digit
-digit BCD number
number in memory locations 0040
0040 and
The following
0041 (MSDs in 0041) to a tw o-digit
-d ig it BCD number
number in memory
memory locatlon
location 0041.

DONE
DONE

LDA
CMP
BCC
BCC
SED
SEO
LDA
LOA
ADC
STA
CLD
CLO
BRK
BRK

$40
#$
50
$50
DONE
DONE

:IS
;IS BYTE
BYTE TO BE
BE DROPPED
DROPPED50 OR
OR MORE?
MORE?

;YES. ROUND
ROUND MSD'S
;YES,
MSD’S UP BY 1 IN DECIMAL
$41
#00
$41

CARRY (KNOWN TO BE
BE SET)
SET)
;ADD IN CARRY
:RETURN
;RETURNTO BINARY
BINARY MODE
MODE

Remember that you cannot use the INC instruction
instruction to add 1 because that instruction
instruction always produces a binary result. The instruction
instruction A DC#O
C # 0 will
ill add 1 to the Accum
ulator
Accumulator
since the Carry must be 1 for the instruction
instruction to be executed (otherwise the BCC
BCC instruc­
instrucusual. we must be careful
tion would
would have forced a branch). As usual,
careful to set and clear the
numbers. the rounding
Decimal Mode flag appropriately.
appropriately. For longer numbers,
rounding must ripple
as needed.
needed.
through more significant
significant digits
digits as

8-22

PROBLEMS
1) Multiple-Precision
ultiple-Precision Binary Subtraction
Subtraction
Purpose: Subtract
Subtract one multiple-word
ultiple-word number
number from another. The length
length of the numnum­
bers is in memory
memory location
location 0040, the numbers
numbers themselves
themselves start (most signifisignifi­
memory locations
locations 0041 and 0051,
0051, respectively,
respectively, and the
cant bits first) in memory
difference replaces the number
number starting
starting in memory
memory location
location 0041. Subtract
Subtract
difference
the number
number starting
starting in 0051 from the one starting
starting in 0041.
Sample Problem:

Result:

(0040)

=

04

(0041)
(0042)
(0043)
(0044)

=

2F
5B
A7
C3

=
=
=

(0051)
(0052)
(0053)
(0054)

=
=
=

14
DF
OF
35
B8

(0041)
(0042)
(0043)
(0044)

=
=
=
=

1A
7C
72
OB
OB

-

2F5BA7C3
14DF35B8
1A7C720B
A7C720B

=

that is.

2)

Decimal
al Subtraction
Subtraction

Purpose: Subtract
Subtract one multiple-word
ultiple-word decimal
decimal (BCD)
number from another. The length
(BCD) number
numbers is in memory location
location 0040,
0040, the numbers
numbers themselves
themselves start
of the numbers
significant digits
digits first) in memory locations
locations 0041 and 0051.
0051, respecrespec­
(most significant
difference replaces the number
number starting
starting in memory location
location
tively, and the difference
Subtract the number
number starting
starting in 0051 from the one starting
starting in 0041.
0041. Subtract
Sample Problem:

Result:

(0040)

=

04

(0041)
(0042)
(0043)
(0044)

=

=
=
=

36
70
19
85

(0051)
(0052)
(0053)
(0054)

=
=
=
=

12
66
34
59

(0041)
(0041)
(0042)
(0043)
(0044)

=
=
=
=

24
03
85
26

-

36701985
36701985
12663459
12663459
24038526
24038526

that is.

8 -23
3

3)

8-Bitit by 1 6-Bit
-B it Binary Multiplication
ultiplication

Purpose: Multiply
ultiply the 16-bit
16-bit unsigned
unsigned number
number in memory locations 0040 and 0041
loca(most significant
significant bits in 0041) by the 8-bitit unsigned
unsigned number
number in memory loca­
tion 0042. Store the result in memory locations 0043
0043 through
through 0045. with
ith the
significant bits in memory location 0045.
most significant
Sample Problems:
a.

(0040)
(0041)
(0042)

03

(0043)
Result: (0043)
(0044)
(0045)

= OF
OF
= 00
00
= 00
00

00
05

that is.
that
is.

b

Result:

x5=15
3x
5 = 15
(0040)
(0041)
(0042)

6F
(29.295 decimal)
72 (29,295
61 (97 decimal)

(0043)
(0043)
(0044)
(0045)

OF
OF
5C
2B
28

that is.
is.

4)

29,295
29.295 xX 97 = 2,841,615
2,841.615

Signed Binary Division

Purpose: Divide the 16-bit
16-bit signed number
number in memory locations
locations 0040
0040 and 0041 (most
(most
significant
significant bits in 0041) by the 8-bit
8-bit signed number
number in memory
memory location
Thenumbers
numbersare
arenormalized
normalized so
sothat
thatthe
themagnitude
magnitudeofofmemory
memorylocaloca­
0042. The
tion 0042 is greater than the magnitude
magnitude of memory
memory location 0041. Store the
quotient
quotient (signed) in memory
memory location
location 0043
0043 and the remainder
remainder (always posiposi­
0044.
tive) in memory location 0044
Sample Problems:
a.
a.

Result:
Result:
b.

Result:
Result:

co

(0040)
(0041)
(0042)
(0042)

=
=
=

CO
FF (-64)
(-64)
FF
08

(0043)
(0044)

=
=

(-8) quotient
F8 (-8)
quotient
(0) remainder
00 (0)

(0040)
(0041)
(0042)

=

=
=

93
ED (-4717)
(71 decimal)
47 (71

(0043)
(0044)

=
=

BO (-67 decimal)
BD
28 (+40
(+40 decimal)

Hint: Determine
Determine the sign of the result.
result, perform an unsigned
unsigned division.
division, and adad­
just the quotient
quotient and remainder
remainder properly.
just

8 -24

Self-Checking Numbers
NumbersAligned
Aligned 1,1,3,3, 77 M od
Mod 10
10
5) Self-Checking
Purpose: Calculate
Calculate a checksum
checksum digit
ig it from a string
string of BCD digits. The length of the
string
of digits
digits (number
(number of
ofwords)
words) is
location 0041;
0041: the string
string of
is in
in memory
memory location
string ofof
digits
BCD digits to
to aa word)
word)starts
starts in
Calculate the
the
digits (2 BCD
in memory
memory location
location 0042.
0042.Calculate
checksum digit
1, 3.
3, 7 Mod 10 method and store it in memory
ig it by the Aligned
Aligned 1,
location
location 0040.
1, 3, 7 Mod 10 technique
The Aligned
Aligned 1.
technique works as follows:
1)
1)

Clear the checksum
checksum to start.

2)

Add the leading digit
ig it to the checksum.
Multiply
ultiply the next digit
ig it by 3 and add the result to the checksum.

3)
4)
5)
6)

digitit by 7 and add the result to the checksum.
Multiply
ultiply the next dig
Continue
Continue the process (Steps 2-4) until
until you have used all the digits.
The self-checking
self-checking digitit is the least significant
significant digitit of the checksum.

For example,
string of digits
digits is:
example. if the string
is:
549321
the result will
ill be:
Checksum =
Self-checking digitit =
Self-checking

5+
6
+ 3 xX 44 ++ 7 xX99 ++ 3 ++ 3 xX22 ++ 7 xX 11==996
6

Sample Problems:
a.

(0041) = 0303
(0041)
(0042) = 36
(0043) = 68
(0044) = 51
51
Result: Checksum== 3 +
3
+ 3 xx66 ++ 7 xx 66 ++ 8 ++ 3 xx55 ++ 7 xx11 = 993
(0040) = 03
03

b.

(0041) = 0404
(0041)
(0042) = 50
(0043) = 29
(0044) = 16
(0045) = 83
Result: Checksum== 5 +
+ 3 xx 00 ++ 7 xx 22 ++ 9 ++ 3 xx11 ++ 7 xx 66 ++ 8
+
+ 3 xX 3 = 90
80
(0040) == 00
00

+ 1 and 3 = 2 xx11 ++ 1, so the form
formula
Hint:
in t: Note that
a t 7 = 2 xx 33 +
ula
Mj = 2 x Mj_i
calculate the next multiplying
ultiplying factor.
Mi
Mi-1 + 1 can be used to calculate

8-25
8-

REFERENCES
1.
1.

J. R.
"Self-Checking Number
Number Systems,”
Computer Design,
R. Herr,
Herr. "Self-Checking
Systems." Computer
Design. June 1974,
1974. pp.
85-91.
--

2.

implementing multiplication,
ultiplication, division.
division, and other
other arithm
etic tasks
Other methods for implementing
arithmetic
tasks
are discussed in:
S.
ig ita l Processing Gets a Boost from Bipolar LSI
ultipliers," EDN.
S. Davis,
Davis. "Digital
LSI Multipliers."
EDN.
November 5,
5. 1978,
197B. pp. 38-43.
-A. Kolodzinski and D.
Wainland, "M u
ltip lyin g with
ith a M icrocom
puter," Electronic
D. Wainland.
ultiplying
icrocomputer,"
Design,
January 18,
Design. January
18. 1978,
1978. pp. 78-83.
B.
Parasuraman "H ardw
are M u ltip
lic a tio n Techniques
Techniques for Microprocessor
icroprocessor
B. Parasuraman
ardware
ultiplication
Computer Design. April
April 1977,
Systems," Computer
1977. pp. 75-82.
pplications of Microprocessors
Microprocessors in Control
Control Problems."
Problems," 1977 Joint
Joint
T. F.
F. Tao et al.,
al.. "Applications
Autom
atic Control
Control Conference Proceedings. San Francisco. CA„.. June 22-24.
22-24, 1977,
Automatic
1977.
"State-of-the-art in High-Speed A rithm
etic Integrated
Integrated Circuits."
Circuits," ComS. Waser "State-of-the-art
rithmetic
puter Design,
Design. July 1978, pp.
pp. 67-75.
S.
"Dedicated Multiplier
ultiplier ICs Speed Up Processing in Fast Computer
Computer
S. Waser "Dedicated
Systems," Electronic
Electronic Design,
September 13,
Systems."
Design. September
13. 1978,
1978. pp. 98-103.

S. Waser
"Medium-Speed
Multipliers
S.
Waser and
and A.
A. Peterson.
Peterson, "M edium
-Speed M
ultipliers Trim
Trim Cost.
Cost, Shrink
Shrink BandBand­
width
th in Speech Transmission,"
Electronic Design,
Transmission.·· Electronic
Design. February 1,
1. 1979,
1979. pp. 58-65.
A. J. Weissberger
Weissberger and T.
"Tough Mathematical
Mathematical Tasks Are Child's
Child’s Play for
T. Toal,
Toal. "Tough
Number Cruncher."
Cruncher," Electronics.
Electronics, February 17.
Number
17. 1977. pp. 102-107.

8 -26
26

Chapter 9
TABLES AND LISTS
Tables and lists
lists are twoo of the
the basic
basic data structures
structures used with
ith all computers.
computers. We
Tables
have
arithmetic.
have already
already seen tables
tables used
used to perform
perform code
code conversions
conversions and arithm
etic. Tables
Tables
also be used to identify
identify or respond
respond to commands
commands and instructions,
instructions, linearize
linearize
may also
data, provide
provide access
access to files
files or records,
records, define
define the
the meaning
meaning of keys
keys or switches,
switches,
choose among
among alternate
alternate programs.
programs. Lists
Lists are usually
usually less structured
structured than tata­
and choose
bles. Lists
Lists may record
record tasks
tasks that
that the processor
processor must
must perform,
perform, messages
messages or data
that the
the processor
processor must
must record,
record, or conditions
conditions that
that have
have changed
changed or should
should be
that
monitored. Tables
Tables are a simple
simple way
way of making
making decisions
decisions or solving
solving problems,
problems, since
since
monitored.
computations or logical
logical functions
functions are necessary.
necessary. The task,
task, then,
then, reduces
reduces to
no computations
organizing the
the table
table so that
that the
the proper
proper entry
entry is easy to find.
find. Lists
Lists allow
allow the
the execuexecu­
organizing
tion of sequences
sequences of tasks,
tasks, the preparation
preparation of sets
sets of results,
results, and the
the construction
construction
tion
of interrelated
interrelated data files
files (or data
data bases). Problems
Problems include
include how
how to add elements
elements to
of
a list
list and remove
elements from
from it.
remove elements

9-1

EXAMPLES
EXAMPLES
AddEntry
EntrytotoList
List
Add
Purpose:
Purpose: Add
Addthe
thecontents
contentsofofmemory
memorylocation
location0040
0040totoa alist
listif ifit itisisnot
notalready
alreadypres­
present
entininthe
thelist.
list.The
Thelength
lengthofofthe
thelist
listisIsininmemory
memorylocation
location0041
0041and
andthe
thelist
list
itselfbegins
beginsininmemory
memory location
location0042.
0042.
itself
SampleProblems:
Problems:
Sample
a.
(0040) =
a.
(0040)
(0041) =
(0041)
(0042) =
(0042)
(0043) =
(0043)
(0044) =
(0044)
(0045) =
(0045)

6B
6B
04
04
37
37
61
61
38
3B
10
1D

Result: (0041)
(0041) =
Result:
(0046) =
(0046)

05
05
6B
6B

The
The entry
entry (6B)
(6B)isisadded
added to
to the
the list,
list. since
since itit isisnot
not already
already present.
present. The
The length
length of
of the
the list
list isis
incremented by
by 1.1.
incremented

b.
b.

(0040) = 6B
(0040)
6B
(0041) = 04
(0041)
04
(0042) = 37
37
(0042)
(0043) = 6B
6B
(0043)
(0044) = 38
38
(0044)
(0045) = 1D
10
(0045)
Result: No change,
change. since the
the entry (6B)
(6B) is
Is already in the
the list
11st(in memory loca­
location 0043).

9-2
9-2

Flowchart:
Flowchart:
Start

Entry = (0040)
Length = (0041 I
Index = Length

Index = Index .1

Length= Length+ 1
(0041 +Length)=
Entry

End

Source Program:

SRLST

DONE

LDA
LOA
LDX
LOX
CMP
BEQ
SEO
DEX
BNE
INC
LDX
LOX
STA
BRK
BRK

$40
$41
$41
$41.X
DONE
SRLST
$41
$41
$41
$41
$41,X

;GET ENTRY
;INDEX = LENGTH OF LIST
:INDEX
;IS
:IS ENTRY = ELEMENT IN LIST?
:YES,
:YES. DONE
;NO, GO ON TO NEXT ELEMENT
:NO.
;ADD 1 TO LIST LENGTH
;ADD
;ADD ENTRY TO LIST
;ADD

9-3

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0005
0006
0007
0008
0009

A5
40
A6
41
D5
41
FO
FO
09
CA
DO
DO
F9
E6
E6
41
A6
41
95
41
00

000A
OOOA
000B
0008

oooc
oooc

000D
OOOD
000E
OOOE
000F
OOOF
0010
0011

Instruction
Instruction
(Mnemonic)

SRLST
SRLST

DONE
DONE

LDA
LOA

$40

LDX
LOX

$41

CMP

$41,X
$41.X

BEQ
SEO

DONE
DONE

DEX
DEX
BNE
BNE

SRLST
SRLST

INC
INC

$41

LDX
LOX

$41

STA

$41,
$41.XX

BRK
BRK

I

Clearly, this method of adding
adding elements is very inefficient
inefficient if the list
I HASHING
HASHING! I
is long. We could improve
improve the procedure by limiting
iting the search to
part of the list or by ordering
using the entry to
ordering the list. We could limit the search by using
get a starting point in the list. This method is called "h ash
ashing",
ing ", and is much like
selecting
selecting a starting
starting page in a dictionary
dictionary or directory
directory on the basis of the first letter
letter in an
entry. We could order the list by numerical
numerical value. The search could then end when the
list values went
smaller. depending
ent beyond the entry (larger or smaller,
depending on the ordering
ordering techtech­
nique used).
used). A new entry would
would have to be inserted properly.
properly, and all the other entries
would have to be moved down
down in the list.
would
The program could be restructured
restructured to use two tables. One table could provide a starting
starting
point
point in the other
other table; for example.
example, the search point
point could be based on the most or
least significant
significant 4-bit
-b it digitit in the entry.

happens?). We could
The program does not work if the length of the list is zero (what happens?).
avoid this problem by checking
checking the length initially.
initially. The initialization
initialization procedure
procedure would
be;
then be:

ADELM

LOX
LDX
SEO
BEQ

$41
$41
ADELM
ADELM

;INDEX
;INDEX== LENGTH
LENGTH OF
OF LIST
LIST
;ADD ENTRY
ENTRYTO
TO LIST
LIST IF
IF LENGTH
LENGTH IS
IS ZERO
ZERO
;ADD

INC

$41

;ADD 1 TO LIST
LIST LENGTH
LENGTH

Unlike many other processors,
processors. the 6502's
6502's Zero flag is affected
affected by Load instructions.
instructions.
pattern-matching
necesIf each entry were longer than one word.
word, a pattern-m
atching program would
would be neces­
sary.
program would
would have to proceed to the next entry if a match failed;
failed; that is,
sary. The program
is.
skip over the last part of the current
current entry once a mismatch
ismatch was found.

9-4
4

Check an Ordered List
Purpose:

Check the contents
contents of memory location
location 0041 to see
that value is in an or­
see if that
orlength of the list is in memory
memory location
location 0042;
0042; the list itself
dered list. The length
begins in memory
memory location
location 0043
0043 and consists
consists of unsigned
unsigned binary
binary numbers
begins
in increasing
increasing order. If the contents
contents of location
location 0041 are in the list,
list. clear
location 0040;
0040; otherwise,
otherwise, set memory
memory location
location 0040
0040 to FF-|
q
memory location
FF15.

Sample Problems:
a.

Result:
b.

Result:

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)

=.
=
=
=
=
=

6B
68
04
37
55
7D
70
A1

(0040)

=

FF,
FF, since 6B is not in the list.

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)

6B
68
04
- 37
= 55
= 68
6B
= A1

(0040)

=

00, since 68 is in the list.

9-5

Flowchart:
Flowchart:
Start

Entry = 10041)
Length = 10042)
Mark = 0
Index

= Length

Index = Index -1

Mark= FF15

10040) = Mark

End

ts a bit different
The searching
searching process is
different here since the elements
elements are ordered. Once we
find an element
than the entry (remember that
that we are moving
find
element smaller than
moving backward
through the
subsequent ele­
through
the list in the
the usual 6502
6502 fashion),
fashion). the
the search is over,
over. since subsequent
elewill be even smaller. You may want
to try an example
example to
to convince
ments w
want to
convince yourself
yourself that
the
procedure works. Note
that an element
element smaller
indicated by a com­
the procedure
Note trat
smaller than
than the
the entry is indicated
comparison that
borrow (that is.
that does
does not produce
produ~e a borrow
is. Carry == 1).
1),
in the
the previous problem,
problem. a table
table or
or other method
method that
that could
As in
choose a good starting
starting point
point would
would speed
speed up
up the
the search. One

SEARCHING
SEARCHING
METHODS
METHODS

method would be
be to start in
in the middle
middle and
and determine which
half of the list the entry was in,
in, then divide the half into halves, etc. This method
is
is called aa binary search,
search, since
since it divides the
the remaining part
part of the
the list in
in half each
each
time.1
time.1

9-6

Source Program:

SRLST

NOTIN
DONE

LOA
LDA
LOX
LDX
LOY
LDY
CMP
BEO
BEQ
BCS
DEX
BNE
LOY
LDY
STY
BAK
BRK

$41
$42
$42
#00
$42.X
$42,X
DONE
NOTIN

GET ENTRY
ENTRY
GET
LENGTH OF LIST
INDEX = LENGTH
MARK = ZERO
ZERO FOR
FOR ELEMENT IN LIST
LIST
:IS ENTRY
ENTRY EQUAL TO ELEMENT?
ELEMENT?
:YES. SEARCH
SEARCH COMPLETED
;ENTRY NOT IN LIST IF GREATER
GREATER THAN ELEMENT
ELEMENT

SRLST
#$FF
#$FF
$40
$40

:MARK
FOR NOT IN LIST
;MARK = FF FOR
:SAVE
;SAVE MARK

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
000A
000B
OOOB
oooc
OOOC
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013

A5
41
A6
42
AO
00
05
D5
42
FO
FO
07
BO
BO
03
CA
DO
F7
AO
FF
84
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LOA
LDA

$41
$41

LOX
LDX

$42

LDY
LOY

#0

CMP

$42,X
$42.X

BEQ
BEO

DONE
DONE

BCS
BCS

NOTIN

DEX
DEX
BNE
BNE

SRLST
SRLST

NOTIN

LDY
LOY

#$FF
#$FF

DONE
DONE

STY

$40

SRLST
SRLST

BRK
BAK

This algorithm
algorithm is a bit
bit slower
slower than the one in the example
example given under
under "Add
dd Entry to
This
to
List" because
because of the extra
extra conditional
conditional jumpp (BCS
execution time
List"
(BCS NOTIN).
NOTIN). The average execution
for this
this simple
simple search
search technique
technique increases linearly
linearly with
ith the length
length of the list while
hile the
for
the
average execution
execution timee for
for a binary
binary search increases
increases logarithmically.
logarithmically. For example.
example, if the
average
the
length of the list
list is doubled.
doubled, the simple
simple technique
technique takes twice
ice as long on the average
length
while
hile the binary
binary search method
method only
only requires
requires one extra iteration.
iteration.

9-7

ent from Queue
Remove Element
Purpose:

Memory locations
locations 0042 and 0043 contain
contain the address of the head
Memory
head of the
first element
element (head)
queue (MSBs in 0043). Place the address of the first
(head) of a
memory locations
locations 0040
0040 and 0041 (MSBs in 0041) and update
queue into memory
the queue to remove the element. Each element
element in the queue is two bytes
long and contains
contains the address of the next two-byte
two-byte element
element in the queue.
The last element
element in the queue contains
contains zero to indicate
indicate that
that there is no next
element.

hich it will
ill be used, or tasks in the
Queues are used to store data in the order in which
order in which
which they
they will
ill be executed.
executed. The queue is a first-in,
first-in, first-out
first-out data strucstruc­
elements are removed
removed from the queue in the same order in which
which they
ture; i.e., elements
were entered.
entered. Operating
Operating systems place tasks in queues so that they will
ill be executed
were
in the proper order. I/O
drivers transfer
transfer data to or from queues
queues so that it will
ill be transm
it­
1/0 drivers
transmitted or handled in the proper
proper order. Buffers may be queued
queued so that the next available
one can easily be found and those that are released can easily be added to the available
storage. Queues may also be used to link requests for storage.
storage, timing.
ing, or I/O
1/0 so that
they can be satisfied in the correct
correct order.
order.
In real applications.
applications, each element
element in the queue will
ill typically
typically contain
contain a large amount
amount of
information or storage space besides the address required to link the element
element to the
information
next one.
one.

Sample Problems:
a.
a.

Result:

b.
b.
Result:

(0042)
(0043)
(0046)
(0047)
(0040)
(004D)
(004E)
(004EI

6~}
6~}address of second element
element in queue

(0040)
(00401
(0041)
(0042)
(0043)

ueue
6~}address of element
element removed from quei
queue
J- address of new first element
element in queue
6~}

(0042)
(0043)

~~} empty
empty queue

(0040)
(00401
(0041)

element available from queue
~~} no element

q® j- address of first
first element
element in queue

~~} end of queue

qq

9-8

Flowchart:
Flowchart:

c

Start

D

=

Pointer = (0
042
10042
and 0 043)
43)
(0
0
4
0
and
0
0
4 1 )I =
10040
41
Pointer

(00421 = (Pointerl
(00431 = (Pointer+ 1I

End

Source Program:

DONE

LDA
LOA
STA
LDA
LOA
STA
ORA
BEQ
BEO
LDY
LOY
LDA
LOA
STA
INY
LDA
LOA
STA
BRK
BRK

$42
$40
$43
$41
$41
$42
DONE
#0
($40).
($40) Y
$42

;REMOVE
;REMOVE HEAD
HEAD OF
OFQUEUE
QUEUE

;IS
;ISQUEUE
QUEUEEMPTY?
EMPTY?
;YES,
;YES.DONE
DONE
;NO.
;NO.MOVE
MOVE NEXT
NEXTELEMENT
ELEMENTTO
TOHEAD
HEADOF
OFQUEUE
QUEUE

($40),Y
($40).Y
$43

9-9
9-9

Object Program:
Object
Program:

!

Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0003
0003
0004
0004
0005
0006
0006
0007
0007
0008
0009
0009
000A
OOOA
000B
oooc
oooc
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0014
0014
0015
0016
0016
0017

A5
42
85
40
A5
43
85
41
05
42
F0
FO
0B
OB
A0
AO
00
B1
B1
40
85
42
C8
CB
B1
B1
40
85
43
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

DONE
DONE

LDA
LOA

$42

STA

$40

LDA
LOA

$43

STA

$41

ORA

$42

BEQ
SEO

DONE
DONE

LDY
LOY

#00

LDA
LOA

($40).Y

STA

$42

INY
LDA
LOA

($40).Y
($40),

STA

$43

BRK
BRK

Queuing can handle
handle lists that are not in sequential
sequential memory
memory locations. Each element
element in
Queuing
the queue must
must contain
contain the address of the next
next element. Such lists allow
allow you to handle
data or tasks in the proper order,
variables, or fill in definitions
definitions in a program. Ex­
order. change variables.
Extra storage is required
required but elements
elements can easily be added to the queue or deleted
deleted from it.
Post-indexing, or indirect
indirect indexed addressing.
addressing, is very handy here since it allows
allows us to
Post-indexing.
use the contents
contents of memory
memory locations
locations 0040
0040 and 0041 as a pointer.
pointer. Those locations
locations concon­
tain the address of the head of the queue which.
which, in turn,
contains the address of the
turn. contains
next element. The memory
memory locations
locations in which
hich the address of the element
element is stored must
next
be on page zero,
ith the post-indexed
post-indexed addressing
addressing mode. All other
zero. since they are used with
addresses can be anywhere
anywhere in memory. The post-indexed
post-indexed mode could
could also be used later
to transfer
transfer data to or from the element
element that has just
just been removed from the queue.
that post-indexing
post-indexing is only available
available for addresses on page zero.
Furthermore,
Remember that
zero. Furthermore.
only Index Register Y can be used in this mode.
mode.
Note the use of the sequence
LDA
LOA
ORA

$43
$43
$42
$42

to determine
determine if the 16-bit
16-bit number
number in memory locations
locations 0042
0042 and 0043
0043 is zero.
zero. Try to
other sequences
sequences that
that could handle this problem
problem -— it obviously
obviously occurs
devise some other
whenever you use a 16-bit
16-bit counter
counter rather than the 8-bit
-b it counter
counter that
that we have used in
whenever
most of the examples.
One problem
problem with
ith the 6502
6502 instruction
instruction set is that
that there are no instructions
instructions that
specifically move 16-bit
16-bit addresses (or data) from one place to another
another or that perform
specifically
other 16-bit
16-bit operations.
operations. Of course.
course, such instructions
instructions would
ould have to operate eight
eight bits at
other
time, but
but some InstructIon
instruction fetch and decode cycles could be saved.
Most other
a lime.
saved. Most
microprocessors have such instructions.
instructions.
microprocessors
9 -10
10

It may be useful to maintain pointers to both ends of the queue rather than just to
head.2,33 The data structure may then be used in either
manits head.2'
either a first-in.
first-in, first-out
u t man­
ner or in a last-in, first-o
first-out
u t manner, depending on whether
hether new elements
elements are adad­
ded to the head or to the tail. How would
would you change the example
example program
program so that
locations 0044
0044 and 0045
0045 contain
contain the address of the last element
element (taill
(tail) of the
memory locations
queue?
elements in the queue.
queue, the program clears memory
memory locations
locations 0040
0040 and
If there are no elements
0041. A program
program that
that requested
requested an element
element from the queue would
would have to check those
memory
memory locations
locations to see if its request
request had been satisfied. Can you suggest
suggest other
other ways
to provide
provide this information?
information?

9 -11

8-Bit
it Sort
Purpose:
Purpose: Sort an array of unsigned binary numbers into descending order.
order. The length
of the array is in memory location 0040 and the array itself begins in memomemo­
ry location 0041.

Sample Problem:

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

= 06
= 2A
= B5
= 60
= 3F
= D1
D1
= 19

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

=
=
=
=
=

D1
D1
B5
B5
60
3F
2A
19

A simple sorting technique
technique works as follows:

SIMPLE
SORTING
ALGORITHM
ALGORITHM

1)
Step 1)

INTER.
Clear a flag INTER.

Step 2)
2)

Examine each consecutive
consecutive pair of numbers in the array.
array. If
order. exchange them and set INTER.
INTER.
any are out of order,

3)
Step 3)

INTER = 1 after the entire array has been examined, return to Step 1.
1.
If INTER

INTER will
order. Therefore,
Therefore. if IN­
ININTER
ill be set if any consecutive
consecutive pair of numbers is out of order.
TER
through the entire array,
TER = 0 at the end of a pass
pass through
array, the array is in proper order.
order.
The technique
technique operates as shown in the follow
ing simple case.
following
case. Let us assume that we
want
order: the array has four
12, 03, 15,
15,
want to sort an array into descending order;
four elements -— 12,
08. We will
ill work backwards through
through the array in normal 6502 processing style.

1st Iteration:
Step 1)
11 INTER
INTER = 0

Step 2)
2)

Final order of the array is:
is:
15
12
03
08
15) is exchanged and so is the third pair (12.15)
since the second pair (03,15)
(12,15).
INTER
INTER= 1.
1.

2nd Iteration:

1)
Step 1)

INTER== 00
INTER

Step 2)
2)

Final order of the array is:
is:
15
12
12

08
03
(08.03) is exchanged. INTER
INTER = 1.
1.
since the first pair (08,03)

9-12
9-

Iteration:
3rd Iteration:

Step 1) INTER
INTER== 00
elements are already in order; no exchanges
exchanges are necessary,
Step 2) The elements
necessary. and
INTER
INTER remains zero.
zero.
that one extra iteration
iteration is always performed
performed to ensure that
that the elements
elements are in the
Note that
Clearly, there is a large potential
potential for im provem
ent in this method
method and new
proper order. Clearly.
provement
sorting techniques
techniques are an important
portant area of current
current research.6
research.®
sorting

Flowchart:
Flowchart:
Start

Inter= 0
Index = {0040) -1
Base = 0041

Temp= (Base+
Index -1)
{Base+lndex -1) =
{Base+lndex)
{Base+lndex) =
Temp
Inter= 1

Index = Index -1

No

No

End

9-13

Source Program:
SORT

PASS

COUNT

LDY
LOY
LDX
LOX
DEX
LDA
LOA
CMP
BCS
LDY
LOY
PHA
LDA
LOA
STA
PLA
STA
DEX
BNE
DEY
BEQ
BEO
BRK
BAK

#00
$40
$40
$40,X
$40.X
$4
1.X
41.X
COUNT
#1

;INTERCHANGE
= ZERO
ZERO
INTERCHANGE FLAG =
;GET LENGTH OF ARRAY
:ADJUST
ADJUST ARRAY
ARRAY LENGTH TO NUMBER OF PAIRS
;IS
ORDER?
IS PAIR OF ELEMENTS IN ORDER?
:YES.
YES, TRY NEXT PAIR
:NO.
NO, SET INTERCHANGE FLAG
:INTERCHANGE ELEMENTS USING THE STACK

$41,X
$41.X
$40,X
$40.X
$4
1.X
41,X
:CHECK FOR
FOR COMPLETED PASS
PASS
SORT
SORT

:WERE ALL ELEMENTS IN ORDER?
ORDER?
:NO.
NO, GO THROUGH ARRAY AGAIN
AGAIN

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
OOOA
000B
0008
OOOC
oooc
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0016
0016
0017
0017
0018
0018
0019
0019
001A
01A
00
1B
0018

AO
00
A6
40
CA
85
B5
40
D5
05
41
BO
BO
OA
OA
AO
AO
01
48
85
B5
41
95
40
68
95
41
41
CA
DO
DO
ED
ED
88
88
FO
FO
E5
E5
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)
SORT
SORT

PASS

COUNT

LOY
LDY

#00

LOX
LDX

$40

DEX
LDA
LOA

$40,
$40.XX

CMP

$41.X
,X

BCS
BCS

COUNT

LOY
LDY

#1

PHA
LDA
LOA

$41.X
$41,X

STA

$40.X
$40,X

PLA
STA

$41.X
$41,X

DEX
DEX
BNE
BNE

PASS

DEY
DEY
BEO
BEQ

SORT
SORT

BRK
BAK

99-14

The
proThe case where
where twoo elements
elements in the array are equal is very important. The pro­
since that interchange
interchange would
gram should not perform an interchange in that
that case since
be
pass. The result would be that every pass
pass would set the In­
Inbe performed in every
every pass.
terchange flag, thus producing
producing an endless loop.
loop. The program compares the elements
in the specified
that the Carry flag is set if the elements are already arranged
specified order so that
correctly.
correctly. Remember that
that comparing
comparing twoo equal values sets the Carry flag since that flag
is an inverted
inverted borrow
borrow after
after subtractions
subtractions or comparisons.
The 6502
6502 Conditional
Conditional Branch instructions
instructions can be limiting.
iting, and are particularly
particularly limiting
iting
in this
CMP, we have only BCC
BCC —
- branch if
this program.
program. Following
Following an instruction
instruction like CMP,
(M) >
(A)) -— and BCS
BCS -— branch if (M) :5:
(A). The 6502 has no Branch instructions
(M
)>(A
)<(A).
instructions for the
cases where
is, (M)~
(A)
:5:(A).
where the equality
equality condition
condition is on the other
other side, that
that is,
>(A
) and (M)<(A).
Therefore,
Therefore, we must
must be careful
careful of the order of operations.
Before starting
pass, we must be careful
Instarting each sorting
sorting pass,
careful to reinitialize
reinitialize the Index and the In­
terchange
terchange flag.
The program
program must
must reduce the Counter
Counter by 1 initially,
initially, since the number of consecutive
consecutive
pairs is one less than the number
has no successor).
successor).
number of elements (the last element
element has
This
array.
This program
program does not work
work properly
properly if there are fewer than two elements in the array.
How could you handle
case?
handle this degenerate
degenerate case?
SORTING
OTHER SORTING
There are many sorting
algorithmss that
sorting algorithm
that vary widely
widely in efficienefficien­
METHODS
cy. References 1, 4. and 5 describe some of these.
cy. References 1, 4, and 5 describe some of these.

The Stack is easy to use for temporary
temporary storage
storage inin this
program since the
thePHA
PHA (Push
(Push Acthis program
Ac­
cum
ulator or Store Accum
ulator in Stack)
Stack) and
and PLA
ulator or Load AcAc­
cumulator
Accumulator
PLA (PullAccum
Accumulator
cumulator
is in the
cum
ulator from Stack) instructions
instructions are each only one byte long. The address is
Pointer (extended with
ith 01 as its page number). If you wish,
substitute a
Stack Pointer
wish. you can substitute
fixed
is:
fixed memory
memory location.
location, such as 003F. The interchange
interchange then is:
STA

$3F

LDA
STA
LDA
STA

$4
1.X
41.X
$40,X
$40,X
$3F
$41,X
$41,X

;INTERCHANGE ELEMENTS
ELEMENTS USING
USING TEMPORARY
TEMPORARY
INTERCHANGE
; STORAGE
STORAGE

Chapter 10 for a further
further discussion
discussion of the 6502 RAM Stack.
See Chapter
Stack.

9-15
9-15

Using an Ordered Jump Table
Purpose:

Use
contents of memory location
location 0042 as an index to a jumpp table startstart­
Use the contents
memory location
location 0043. Each
contains a 16-bit
16-bit
ing in memory
Each entry in the jumpp table contains
address with
ith LSBs in the first
first byte. The program
program should transfer
transfer control
control to
the address with
ith the appropriate
appropriate index; that
that is,
pro­
is. if the index is 6,
6. the proentry #66 in the table. Assume
Assume that
that the table
gram should jumpp to address entry
has fewer
fewer than 128 entries.

Sample Problem:
Prablem:

Result:

(0042)

=

(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)
(004A)

=

(PC)
(PC)

=

=
=
=
=
=
=
=

02

index for jump table

6g}

4C
j- zeroth element
element in jumpp table
00
50
j- first
first element
element in jumpp table
00
54
j- second element
element in jum
jumpp table
00
58
| third
third element
element in jumpp table
00

6~}

66}

6~
}

00!
0054. since that is entry #2 (starting from zero) in the
jumpp table. The next instruction
executed will
ill be
instruction to be executed
the one located at that
that address.
address.

Flowchart:
Flowchart:
Start

Index - (0042) x 2

(0040) - (0043
+Index)

(0041 I - 10044
+Index)

IPCI (0041110040)

The last box results in a transfer
transfer of control
control to the address obtained
obtained from the table.

Source Program:
LDA
LOA
ASL
TAX
LDA
LOA
STA
LDA
LOA
STA
JMP

$42
A

;GET
;GET INDEX
INDEX
;DOUBLE
;DOUBLE INDEX
INDEX FOR
FOR 2-BYTE TABLE

$43,X
$43.X
$40
$44,X
$44.X
$41
($40)
($40)

;GET
;GET LSB'S OF
OF JUMP ADDRESS
ADDRESS
;GET
;GET MSB'S OF
OF JUMP ADDRESS
ADDRESS
TRANSFER
;TRANSFER CONTROL
CONTROL TO DESTINATION
DESTINATION

9-16
-1 6

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
OOOB
oooc
oooc
000D
0000
000E
OOOE

A5
42
0A
OA
AA
B5
43
85
40
B5
44
85
41
6C
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LDA
LOA

$42

ASL
TAX
LDA
LOA

A

STA

$40

LDA
LOA

$44,XX

STA

$41

JMP

($40)
($40)

$43,X
$43,X

Jump tables are very useful in situations where
where one of several
several routines must be
selected for execution.
execution. Such situations arise in decoding commands (entered, for
selected
example, from a control keyboard).
keyboard), selecting test
st programs, choosing
alternative
example,
choosing alternative
methods, or selecting an I/O
1/0 configuration.
configuration,
The jump table replaces a series of conditional jump operations. The program that
accesses
different tables merely by
accesses the jumpp table could be used to access several different
using the post-indexed,
post-indexed, or indirect
indirect indexed, addressing mode,
which the starting
starting ad­
mode. in which
address of the table is placed in RAM on page zero.
zero.
The data must be multiplied
ultiplied by 2 to give the correct
correct index since each entry in the jump
table occupies two bytes.
bytes.
The instruction
instruction JMP ($40) uses indirect
indirect addressing:
addressing: the destination
destination is the address
stored at the specified
specified location
location rather than the specified
specified location
location itself. JMP is the only
instruction that uses indirect
indirect addressing. Note that there is no page-zero mode
6502 instruction
and that the address is stored in the usual 6502 fashion with
ith the least significant
significant bits
first.
The terminology
inology used
describing Jump
Jump or Branch instructions
instructions is JUMP
JUMP AND
used in describing
often quite confusing.
confusing. A Jump
Jump instruction
instruction that is described as
as BRANCH
using direct
direct addressing actually
actually loads the specified address into TERMINOLOGY
TERMINOLOGY
the
Counter; this works more like immediate
mediate addressing
the Program Counter:
than like direct
direct addressing as applied to other instructions
instructions such as
as Load
Load or Store.
Store. A
Jump instruction
instruction using indirect
indirect addressing works like other instructions
instructions using direct
direct
addressing.
No ending operation
operation (such
(such as aa BRK
BAK instruction)
instruction) is necessary since JMP
JMP ($40)
($40) transfers
transfers
control to
obtained from the
control
to the
the address obtained
the jum
jump table.
table.
References
additional examples of
References 77 and
and 8 contain additional
of the use of jum
jump tables.
tables. The
The program
assumes that
that the
the jump table
table contains fewer than
than 128 entries (why?).
(why?). How could you
change the program to
to allow longer tables?
tables?

99-17

PROBLEMS
PROBLEMS
1)

Remove an Entry From
From a List

Purpose:

Remove
contents of memory location 0040 from a list if it is present.
Remove the contents
present.
The length
length of the list is in memory
memory location 0041 and the list itself begins in
memory location
location 0042. Move the entries below the one removed up one
position and reduce the length of the list by 1.
position
1.

Sam
Sample Problems:
(0040)

a.

=

6B

entry to be removed from list

(0041)

=

04

length of list

(0042)
(0043)
(0044)
(0045)

=
=
=
=

37 first
first element in list
61
28
2B
1D

Result:
entry is not in the list.
Result: No change. since the entry

b

Result:
Result:

(0040)

=

6B

entry to be removed from list

(0041)

=

04

length of list

(0042)
(0042)
(0043)
(0044)
(0045)

=
=
=
=

37 first element
element in list
6B
28
2B
1D

(0041)

=

03

(0042)
(0043)
(0044)

=
=
=

37
28 other
other elements
elements in list moved iup one position
1D

length of list reduced by 1

The entry is removed from the list and the ones below it are moved up one position. The
length of the list is reduced by 1.
length
1.

9 -18
18

2)

Add an Entry to an Ordered List

Purpose:

Place the contents
contents of memory
memory location
location 0040
0040 into an ordered list if they are
length of the list is in memory
memory location
location 0041.
0041. The list
not already there. The length
itself begins
begins in memory
memory location
location 0042
0042 and consists
consists of unsigned
unsigned binary
binary num
itself
num-­
increasing order. Place the new entry
entry in the correct
correct position
position in the
bers in increasing
list, adjust
adjust the elements
elements below
below it down,
down, and increase the length
length of the list by
list.
1..

Sample Problems:
a.

Result:

b.

(0040)

=

6B

(0041)

=

04

length of list
length

(0042)
(0043)
(0044)
(0045)

=
=
=
=

37
55
7D
A1

first element
element in list
first

(0041)

entry to be added to list
entry

=

05

length of list increased by 1
length

(0044)
(0045)

=

6B
7D

entry placed in list
entry
other elements in the list moved down one
position
position

(0046)

=

A1

(0040)

=

6B

entry to be added to list

(0041)

=

04

length of list
length

(0042)
(0043)
(0044)
(0045)

=
=
=
=

37
55
6B
A1
A1

first element
element in list
first

Result: No change, since the entry is already in the list.

3)

Add an Element
ent to a Queue

Purpose:

Add the address in memory locations
locations 0040 and 0041 (MSBs
(MSBs in 0041) to a
queue. The address of the first element
element of the queue is in memory locations
element in the queue contains either
0042 and 0043 (MSBs
(MSBs in 0043). Each
Each element
the
element in the queue or zero
the address of the next element
zero if there is no next ele­
eleith the least significant
significant bits in the first
ment; all addresses are 16 bits long with
byte of the
element goes at the end (tail)
the element. The new element
(taill of the
the queue: its
address will
ill be in the element
element that was at the end of the
ill
the queue and it will
indicate that
contain zero
zero to indicate
that it is now the end of the queue.

Sample Problem:
(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

=
=
=
=

4D
4D}| new element to be added to
to queue
00
46
pointer to head
pointer
head of queue
00 }

(0046)
(0046)
(0047)
(0047)

=

00
^ last
last element
element in queue
00

Result: (0046)
(0046)
(0047)
(0047)

=

=

6~
}
gg}

=

4D
4D l old last element points to
00 }f ' new last element
element

(004D)
(004D) =
(004E)
(004E) =

00
j- new
element in queue
new last
last element
00

gg}

How
How would
would you
you add
add an
an element
element to
to the
the queue if memory locations
locations 0044 and
and 0045
0045 con­
contained
tained the
the address
address of
of the
the tail
tail of
of the
the queue (the last
last element)?
element)?
99-19

4)

1 6-Bit
it Sort

Purpose:

an array of unsigned 16-bit binary numbers into descending order.
order. The
Sort an
length of the array is in memory location 0040 and the array itself begins in
16-bit number is stored with
ith the least signifisignifi­
memory location 0041. Each
Each 16-bit
cant bits in the first byte.

Sample Problem:

(0040)
(0040)

=

03

length of list

(0041)
(0041)
(0042)
(0042)

=
=

D1
D1
19

LSBs of first element in list
LSBs
MSBs of first element in list

(0043)
(0043)
(0044)
(0044)

=

60
3F

(0045)
(0045)
(0046)
(0046)
Result:

=

=
=

2A
B5
B5

(0041)
(0041)
(0042)
(0042)

=

(0043)
(0043)
(0044)
(0044)

=

60
3F

(0045) =
(0045)
(0046)
(0046) =

D1
D1
19

=

2A
B5

LSBs of first element in sorted list
LSBs
MSBs of first element in sorted list
MSBs

19D1.
The numbers are B52A, 3F60, and 19D1.

5)

Using a Jump Table with
ith a Key

Purpose:

Use the contents of memory location 0040 as
as the key to a jump table startUse
start­
ing in memory location 0041. Each
Each entry in the jumpp table contains
contains an B-bit
8-bit
(MSBs in second byte) to which
key value followed
followed by a 16-bit
16-bit address (MSBs
hich the
program should transfer control if the key is equal to that key value.
value.

Sample Problem:

Result:

(0040)
(0040)

=

38

search
key value for search

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

=
=
=

32
4A
00

key value for first entry
LSBs
LSBs of jump address for first entry
MSBs of jump address for first entry

(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

=
=
=

35
4E
00

(0047)
(0047)
(0048)
(0048)
(0049)
(0049)
(PC)
(PC)

=
=
=
=

38
52
00
0052, since that address corresponds
to key value 38.
38.

9-20
9-

REFERENCES
REFERENCES
1.
1.

D. Knuth,
D.
Knuth. The Art
rt of Computer
Computer Programming. Volume
Volume Ill:
III: Sorting and Searching
(Reading.
Addison-Wesley. 1978.
1978).
(Reading. Mass.:
Mass.: Addison-Wesley.
D. Knuth. "A lg o
lgorithms,"
1977. pp. 63-80.
D.
rithm s," Scientific
Scientific American.
American. April
pril 1977,

2.

K. J. Thurber
P. C.
C. Patton, Data Structures
(LexK.
Thurber and P.
Structures and Computer
puter Architecture
Architecture (Lex­
ington, Mass.: Lexington
Lexington Books,
1977).
ington.
Books, 1977.

3.

E. Teja,
Teja. "Data Structures
1," EDN.
EDN, March 5,
5. 1979.
pp.
J. Hemenway and E.
Structures - Part 1,”
1979, pp.
89-92.
-

4.

B. W. Kernighan and P.
P. J. Plauger,
Plauger, The Elements of Programming
B.
Programming Style (New
York: McGraw-Hill,
McGraw-Hill, 1978).
1978).

5.

K. A. Schember
R. Rumsey,
Rumsey. "Minimal
K.
Schember and J. R.
inim al Storage Sorting and Searching TechTech­
Applications," Computer.
Computer, June 1977, pp. 92-100.
niques for RAM Applications,"

6.

"Sorting
DPS," Datamation.
1978. pp. 200-203.
"Sorting 30 Times Faster with
ith DPS,”
Datamation, February 1978,

7.

L.
u t Your Processor's
Computation Time,"
Time," Electronic Design,
L. A. Leventhal,
Leventhal. "Cut
Processor's Computation
Design.
August 16, 1977, pp.
August
pp. 82-89.

8.

8. Peatman,
Peatman. Microcomputer-Based
1977).
J. B.
Microcomputer-Based Design (New York: McGraw-Hill.
McGraw-Hill, 1977),
Chapter 7.

9-21
9-21

Chapter 10
SUBROUTINES
examples thatt we have shown so far is typically
typically a program all by it-­
None of the examples
ost real programs perform a series of tasks, many of which
hich may be the
self. Most
several different
different programs.
ay to formuformu­
same or may be common to several
programs. We need a way
conveniently available both in
late these tasks once and make the formulations conveniently
different parts of the current
current program and in other
other programs.
different
programs.
rite subroutines that
that perform parpar­
SUBROUTINE
The standard method is to write
SUBROUTINE
LIBRARY
ticular tasks. The resulting sequences of instructions can be
ticular
written
ritte n once, tested
tested once, and then used repeatedly.
repeatedly. They
They can
form a subroutine library that
that provides documented
documented solutions to common probprob­
lems.
lems.
SUBROUTINE
Most
o st microprocessors
icroprocessors have special
special in structions
ction s for
SUBROUTINE
transferring control to subroutines and restoring control to
INSTRUCTIONS
INSTRUCTIONS
often refer to the special
special instruction
instruction
the main program. We often
that transfers
transfers control
control to a subroutine
subroutine as Call. Jump-to-Subroutine.
Jump-to-Subroutine, Jump
Jump and Mark
that
Place,
Jump and Link. The special
special instruction
instruction that
that restores control
control to the main propro­
Place. or Jump
usually called Return. On the 6502
6502 microprocessor.
microprocessor, the Jump-to-Subroutine
Jump-to-Subroutine
gram is usually
(JSR)
instruction saves the old value of the Program Counter
Counter in the RAM Stack before
(JSR) instruction
placing the starting
starting address of the subroutine
subroutine into the Program
Program Counter;
Counter; the Returnplacing
from-Subroutine
-Subroutine (RTS)
instruction gets the old value from the Stack and puts it back in
(RTS) instruction
effect is to transfer
transfer program
program control.
control, first
first to the subroutine
subroutine
the Program Counter. The effect
and then back to the main program.
subroutine may itself
transfer control
control to
program. Clearly the subroutine
itself transfer
a subroutine.
subroutine, and so on.
on.
In order to be really useful, a subroutine must be general. A routine
routine that
that can perform
perform
specialized task,
looking for a particular
particular letter
letter in an input
input string
string of fixed
only a specialized
task. such as looking
length, will
ill not be very useful. If,
other hand,
subroutine can look for any letlet­
length.
If. on the other
hand. the subroutine
strings of any length.
length, it will
ill be far more helpful.
helpful. We
We call the data or addresses
ter in strings
that the subroutine allowss to vary "param
eters." An important
portant part of writing
riting
that
"parameters."
subroutines is deciding
deciding which
hich variables
variables should
should be parameters.
subroutines
One problem
problem is transferring
transferring the parameters
parameters to the subroutine;
subroutine; this
PASSING
simplest method
method is for
PARAMETERS
process is called passing parameters. The simplest
program to place the parameters
parameters into registers. Then the
the main program
subroutine can simply
ply assume that
that the parameters
parameters are there. Of course.
course, this technique
technique
subroutine
is limited
limited by the number
number of registers
registers that
that are available. The parameters
parameters may,
however,
may. however.
be addresses as well
well as data. For example.
example, a sorting
sorting routine
routine could
could begin with
ith Index
containing the address on page zero at which
which the length
length of the array is lo­
Register X containing
located.

6502 microprocessor is limited by the fact
fact that
that it has no address-length
address-length (16The 6502
bit) registers in which
hich to pass address-length
address-length parameters. However,
However, such
bitl
such
parameters can easily be passed by reserving locations on page zero; these localoca­
parameters
tions effective
additional registers. A further
further advantage
advantage of this approach
effectivelyly act as additional
is that
that addresses on page zero can be accessed using the post-indexed
post-indexed (indirect
pre-indexed (indexed
(indexed indirect) addressing modes, as well
e l as the
indexed) and pre-indexed
short page-zero
page-zero forms of direct
direct and indexed addressing.
addressing.

10
10-1

Another
Another approach
approach is to use the Stack. The main program can place the parameters in
the
the Stack and the
the subroutine
subroutine can retrieve
retrieve them. The advantages
advantages of this method are that
the Stack
Stack is usually
usually fairly
fairly large (up to one page) and that
that data in the Stack is not lost
even if the
the Stack is used again. The disadvantages
disadvantages are that
that few 6502 instructions
instructions use
the
Jump-to-Subroutine
the Stack.
Stack, and the Jum
p-to-Subroutine instruction
instruction stores the return address at the top
of
of the
the Stack.
Still
Still another
another approach
approach is to assign an area of memory for parameters. The main program
can place the address of the area on page zero and the subroutine
subroutine can retrieve the data
using the post-indexed
However. this approach is awkward if the
post-indexed addressing
addressing mode. However,
parameters
addresses.
parameters are themselves
themselves addresses.

I

I

Sometimes
Sometimes a subroutine
subroutine must have special characteristics.
characteristics. A
| RELOCATION |
subroutine is relocatable
relocatable if it can be placed anywhere
anywhere in
memory. You can use such a subroutine
easily. regardless of the placement
subroutine easily,
placement of other
programs
use
programs or the arrangement
arrangement of the memory. A strictly
strictly relocatable
relocatable program can use
no absolute
program.
absolute addresses; all addresses must be relative
relative to the start of the program.
A relocating
relocating loader is necessary to place the program in memory properly; the loader
will
ill start
start the program
program after
after other
other programs and will
ill add the starting
starting address or reloca­
relocation constant
constant to all addresses in the program.
tion

A subroutine is reentrant
reentrant if it can be interrupted
interrupted and called by
REENTRANT
interrupting program and still give the correct results for
SUBROUTINE
the interrupting
interrupting and interrupted
interrupted programs.
both the interrupting
programs. Reentrancy is
is
Otherwise the inter­
interimportant
portant for standard subroutines
subroutines in
in an interrupt-based
interrupt-based system. Otherwise
rupt service routines
routines cannot
cannot use the standard subroutines
subroutines w ithout
o u t causing errors.
rupt
errors.
Microprocessor subroutines
subroutines are easy to make reentrant.
reentrant, since the
instruction uses
Microprocessor
the Call
Call instruction
uses
the Stack and that
that procedure is autom
atically reentrant. The only remaining require­
automatically
requirement is that
that the subroutine
subroutine use the registers and Stack rather than fixed
ment
fixed memory loca­
locatemporary storage. This is a bit awkward.
awkward, but usually can be
tions for temporary
be done if necessary.
necessary.
A subroutine is recursive if it calls itself. Such a subroutine
subroutine clearly must also
also be
be re­
reentrant. However.
However, recursive subroutines
subroutines are uncommon
uncommon in microprocessor
microprocessor applications.
entrant.
Most
ost programs consist of a main program and several subroutines. This
This is
is advan­
advantageous because you can use
use proven routines and debug and
and test the other
separately. You must, however,
however, be careful to use
subroutines separately.
use the subroutines pro­
proremember their exact
exact effects
effects on registers, memory locations,
perly and remember
locations. and
and flags.
flags.

SUBROUTINE D O C U M E
N TA TIO N
SUBROUTINE
UMENTATION
Subroutine listings must provide enough information so
so
that users need not examine the subroutine's internal
that
Among the necessary specifications
specifications are:
structure. Among
are:
description of the purpose of the subroutine
subroutine
• A description
• A list of input
input and output
output parameters
• Registers and memory locations used
used
•- A sample case
case
If these guidelines
ill be
guidelines are
are followed,
followed. the subroutine
subroutine w
will
be easy
easy to
to use.
use.

110-2
0-2

DOCUMENTING
DOCUMENTING
SUBROUTINES

EXAMPLES
portant to note that
that the follow
ing examples all reserve an area of memory
memory for the
It is important
following
RAM Stack. If the monitor
onitor in your
your m icrocom
puter establishes
establishes such an area,
icrocomputer
area, you may use
establishing your own Stack area, remember
remember to save and
it instead. If you wish to try establishing
restore the monitor's
onitor's Stack Pointer
Pointer in order to produce
produce a proper return at \he
the end of
your main program.
your
onitor Stack Pointer, use the instruction
instruction sequence
To save the monitor
TSX
STX

TEMP
TEMP

To restore the monitor
onitor Stack Pointer, use the sequence
LDX
LOX
TXS

TEMP
TEMP

Note that
that the Stack Pointer can only be loaded or stored via Register X. Remember that
the 6502 always keeps its Stack on page 1 of memory so that the real Stack address is
01 ss,
contents of the 8-bitit Stack Pointer register.
ss. where ss is the contents
1 g as the starting
starting point
point for the Stack. You may have to concon­
We have used address 01FF15
sistently replace that
that address with
ith one more suitable
suitable for your
your configuration.
configuration. You should
sistently
consult your m icrocom
puter's User's Manual to determine
determine the required changes.
consult
icrocomputer's
changes.

The basic sequence for initializing
initializing the Stack
Stack Pointer
Pointer is
is thus
thus
LDX
LOX
TXS

#$FF
#$FF

;PLACE STACK AT TOP
TOP OF PAGE
;PLACE
PAGE 1

1 0-3

Hex
ex to
to ASCII
Purpose: Convert
Convert the
the contents
contents of
of the
the Accum
ulator from
from a hexadecimal
hexadecimal d
ig it to
to an
an
Purpose:
Accumulator
digit
ASCII character.
character. Assume
Assume that
that the
the original
original contents
contents of
of the
the Accum
ulator form
form
ASCII
Accumulator
valid hex
hex digit.
digit.
aa valid
Sample Problems:
Problems:
Sample

oc

(A)
(A) = 0C

a.
Result:
Result:

(A) = 43
(A) =

b.
Result:

(A) =

ASCII C

06
36 ASCII 6

Flowchart:
Flowchart:
Start

(Al= (A)+ASCII A.
ASCII 9 • 1

(A)=(A) + ASCII 0

End

The calling
calling program starts the Stack at memory location
location 01 FF,
FF. gets the data from
location 0040,
conversion subroutine.
subroutine, and stores the result in memory
0040. calls the conversion
memory location
0041.
location 0041.
*=0
LDX
LOX
TXS
TXS
LDA
LOA
JSR
JSR
STA
STA
BRK
BRK

#$FF

;PLACE
:PLACE STACK AT END
END OF
OF PAGE
PAGE 1

$40
$40
ASDEC
ASDEC
$41
$41

GET
:GET HEXADECIMAL DATA
DATA
CONVERT DATA TO
;CONVERT
TO ASCII
ASCII
STORE
:STORE RESULT
RESULT

The subroutine
subroutine converts
hexadecimal data
converts the
the hexadecimal
data to
to ASCII.
ASCII.
ASDEC
ASDEC

ASCZ
ASCZ

'= $
*=$20
CMP
CMP
BCC
BCC
ADC
ADC
ADC
ADC
RTS
RTS

#10
ASCZ
ASCZ
# 'A
-'9 -2
#'A-'9-2
##'0
’0

:IS
;IS DATA
DATA A DECIMAL
DECIMAL DIGIT?
DIGIT?
;NO.
;NO. ADD
ADD OFFSET
OFFSETFOR
FOR LETTERS
LETTERS
;CONVERT
:CONVERT TO
TO ASCII
ASCII BY
BY ADDING
ADDING ASCII ZERO

10-4
10-4

Subroutine Documentation:
Documentation:
:SUBROUTINE ASDEC
ASDEC
SUBROUTINE
PURPOSE:
:PURPOSE: ASDEC
ASDEC CONVERTS
CONVERTS A HEXADECIMAL
DIGIT IN THE
THE ACCUMULATOR TO AN
DIGIT
: ASCII
ASCII DIGIT
DIGIT IN THE
THE ACCUMULATOR

;INITIAL CONDITIONS:
CONDITIONS: HEX
HEX DIGIT
DIGIT IN
IN A
:FINAL CONDITIONS:
CONDITIONS: ASCII
ASCII CHARACTER
CHARACTER IN
IN A
:REGISTERSUSED:
USED: A
REGISTERS
:SAMPLE
SAMPLE CASE
CASE
INITIAL CONDITIONS
CONDITIONS: 6 IN ACCUMULATOR
CONDITIONS: ASCII
ASCII 6 (HEX
(HEX 36)
FINAL CONDITIONS:
IN ACCUMULATOR

Object Program:
Object
Memory
Memory Address
(Hex)
(Hex)
1)

Calling
Calling program
0000
0000
0001
0002
0003
0004
0004
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA

2)

Instruction
Instruction
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

A2
FF
FF
9A
A5
40
20
20
00
85
41
00

LDX
LOX

#$FF

TXS
LDA
LOA

$40

JSR
JSR

ASDEC
ASDEC

STA

$41

BRK
BRK

Subroutine
Subroutine
0020
0020
0021
0022
0022
0023
0023
0024
0024
0025
0025
0026
0026
0027
0027
0028
0028

C9
OA
90
02
69
06
69
30
60

ASDEC

ASCZ

CMP

#10
10

BCC
BCC

ASCZ

ADC

# 'A
-'9 -2
'A-'9-2

ADC

#'O
'0

RTS
RTS

instructions LDX
#$FF and TXS start
start the Stack at memory
memory location
location 01
01FF.
Remem­
The instructions
LOX #$FF
FF. Rememthat the Stack grows
grows downward
downward (toward
(toward lower
lower addresses) and that
that the 6502
6502 Stack
ber that
Pointer always
always contains
contains the address on page one of the next
next empty
empty location
location (rather
(rather than
Pointer
the last filled
filled one as on some other
other microprocessors).
microprocessors).

10
10-55

The Jump-to-Subroutine
p-to-Subroutine instruction
instruction places the subroutine
subroutine starting
starting address (0020) in
the Program Counter
Counter and saves the old Program Counter
Counter (the address of the last byte of
the JSR
instruction) in the Stack. The procedure is:
JSR instruction)
is:
STEP
Counter in Stack,
decrement Stack Pointer.
STEP 1 -— Save MSBs of old Program Counter
Stack. decrement
STEP
decrement Stack Pointer.
STEP 2 -— Save.LSBs
Save,LSBs of old Program Counter in Stack,
Stack. decrement
Note that the Stack Pointer is decremented
decremented after the data is stored.
The MSBs of the Program Counter
Counter are stored first.
first, but those bits end up at the higher
address (in the usual 6502 fashion) since the Stack is growing
growing down.
The result in the example is:

(01FF)
(01FF) = 00
(01FE)
FE) = 07
(S) =
(S)

FD

The value which
which the Jump-to-Subroutine
p-to-Subroutine instruction
instruction saves is the Program Counter
before the last byte of the JSR
instruction has been fetched. This value is therefore one
JSR instruction
less than the proper return address.
Return-from-Subroutine (RTS)
instruction
address. The Return-from-Subroutine
(RTS) instruction
retrieves the top twoo entries from the Stack,
Stack. adds one (because of the odd 6502 offset
just mentioned).
mentioned), and places the result back in the Program Counter. The procedure is:
just
is:
STEP
Increment Stack Pointer.
Pointer, load eight
eight bits from Stack,
STEP 1 -— Increment
Stack. place result into LSBs
LSBs of
Program Counter.
STEP
ent Stack Pointer,
eight bits from Stack, place result into MSBs of
STEP2 -— Increment
Pointer. load eight
Program Counter.
STEP
Increment Program Counter
Counter before actually
actually fetching
fetching an instruction.
instruction.
STEP 3 -— Increment
Here the Stack Pointer is incremented
incremented before the data is loaded.
loaded.
The result in the example is:
is:

(PC) =
(PC)
=
(S) =
(S)

+1
(00FF)(00FE)+
(00FFM00FE)
0008
FF
FF

subroutine has a single parameter and produces a single result. The Accum
ulator
This subroutine
Accumulator
is the obvious place to put both.
The calling
calling program consists of three steps: placing the data in the Accumulator,
Accumulator, callcall­
ing the subroutine.
subroutine, and storing the result in memory. The overall initialization
initialization must also
place the Stack in the appropriate
appropriate area of memory.
The subroutine
subroutine is reentrant
reentrant since it uses no.data memory; it is relocatable
relocatable since the adad­
dress ASCZ is only used in a Conditional
Conditional Branch instruction
instruction with
ith relative addressing.
Note that the Jump-to-Subroutine
p-to-Subroutine instruction
instruction results in the execution
execution of four or five inin­
structions taking 13 or 14 clock cycles. A subroutine
subroutine call can take a long time even
structions
though it appears to be a single instruction
instruction in the program.
though
If you plan to use the Stack for passing parameters,
remember that
that Jump-to-Subroutine
Jump-to-Subroutine
parameters. remember
saves the return address at the top of the Stack. You can move the Stack Pointer to In­
Index Register X to get access to the data,
remember to provide the proper
data. but you must remember
offsets. You can also gain access to the data by using tw o extra PLA instructions
instructions to
move the Stack Pointer past the return address,
remember to adjust
address. but you must then remember
the Stack Pointer back to its original
original value before returning.
returning.

10-6
10

Length of a String of Characters
Purpose:
starting address of
Purpose: Determine the length of a string of ASCII
ASCII characters. The starting
the string is in memory locations 0040 and 0041. The end of the string is
marked by a carriage return character
character (CR.
(CR. 0D-|6).
OD15). Place the length of the
(excluding carriage return) in the Accumulator.
Accumulator.
string (excluding
Sample Problems:

(0040) =
(0040)
(0041)
(0041) =

a.

(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)
(0048)
(0048)
(0049)
(0049)
Result:
Result:

b.

Result:

43
00

= 52
= 41
= 54
= 48
= 45
= 52
OD
= 0D

(A) =
(A)

06

(0040) =
(0040)
(0041) =
(0041)

43
00

(0043) =

0D
OD

(A) =
(A)

00

starting address of string
starting

'R'
'R'
'A'

'T
T
'H'
H
'E'
'E'
'R'
■R
CR
CR

stai
starting address of string

Flowchart:
Flowchart:
Start

Base =(0040 and
0041)
Index= -1

1ndex= Index + 1

End

10-7

Source Program:

The calling
FF. stores the starting
calling program
program starts the Stack at memory
memory location
location 01 FF,
starting adad­
dress of the string
string in memory
memory locations
locations 0040
0040 and 0041.
0041, calls the string
string length
subroutine.
subroutine, and stores the result
result in memory
memory location
location 0042.
0042, Memory
Memory locations
locations 0040
0040 and
0041 are used as if they were extra registers.
'=00
LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
JSR
STA
BRK
BRK

#$FF
#$FF

;PLACE STACK AT END OF PAGE
PAGE 1
:PLACE

# $43
43
$40
#00
$41
STLEN
STLEN
$42

;SAVE
STARTING ADDRESS
ADDRESS OF
OF STRING
STRING
.SAVE STARTING

;DETERMINE LENGTH
LENGTH OF STRING
STRING
DETERMINE
;STORE STRING
STRING LENGTH
LENGTH
;STORE

The subroutine
subroutine determines
determines the length
length of the string
string of ASCII characters
characters and places the
length
length in the Accumulator.
Accumulator.
STLEN
STLEN
CHKCR
CHKCR

'=$20
•=
$20
LDY
LOY
LDA
LOA
INY
CMP
BNE
BNE
TYA
RTS
RTS

#$FF
#$FF
#$
0D
#$0D

($40).Y
($40),
CHKCR
CHKCR

;STRING
STRING LENGTH
LENGTH = -1
;GET
CARRIAGE RETURN
RETURN TO COMPARE
COMPARE
GET ASCII CARRIAGE
:ADD 1 TO STRING
STRING LENGTH
LENGTH
;IS NEXT CHARACTER
CHARACTER A CARRIAGE
CARRIAGE RETURN?
RETURN?
;NO.
KEEP LOOKING
LOOKING
NO, KEEP
;SAVE STRING
STRING LENGTH
LENGTH IN ACCUMULATOR
ACCUMULATOR

Documentation:
Subroutine Documentation:
SUBROUTINE STLEN
:SUBROUTINE
STLEN

;PURPOSE:
STLEN DETERMINES
DETERMINES THE LENGTH
LENGTH OF AN ASCII STRING
STRING
PURPOSE: STLEN
; (NUMBER
(NUMBER OF CHARACTERS
CHARACTERS BEFORE
BEFOREA CARRIAGE
CARRIAGE RETURN)
RETURN)
INITIAL CONDITIONS: STARTING ADDRESS
;INITIAL
ADDRESS OF STRING
STRING IN MEMORY
0040 AND 0041
; LOCATIONS 0040

;FINAL CONDITIONS: NUMBER OF CHARACTERS
CHARACTERS IN A
;REGISTERSUSED:
USED: A,
A. Y. ALL FLAGS EXCEPT
EXCEPT OVERFLOW
REGISTERS
;MEMORY LOCATIONS USED: 0040
0040. , 0041
;SAMPLE CASE:
CASE:
0043 IN MEMORY LOCATIONS 0040
0040 AND 0041
INITIAL CONDITIONS: 0043
35.35,
(0044)
= =
46.46,
(0045)
= =
ODOD
(0043) = =
(0044)
(0045)
(A) = 02
FINAL CONDITIONS: (A)

10-8
10

Object
Program:
Object Program:

Memory Address
(Hex)
(Hex)
1)
1)

Calling program
0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008

oooc
OOOC
000D
0000
000
E
OOOE
000F
OOOF
0010

2)

Memory Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

A2
FF
FF
9A
A9
43
85
40
A9
00
85
41
41
20
20
00
85
42
00

LDX
LOX

#$FF

TXS
LDA
LOA

#$
43
$43

STA

$40

LOA
LDA

#00

STA

$41

JSR
JSR

STLEN
STLEN

STA

$42

BRK
BRK

Subroutine
Subroutine

0020
0021
0022
0023
0024
0025
0026
0027
0028
0029
002A

AO
FF
FF
A9
OD
OD
C8
CB
D1
01
40
DO
DO
FB
FB
98
60

STLEN
STLEN

CHKCR
CHKCR

LDY
LOY

#$FF

LDA
LOA

# $00
0D

INY
INY
CMP
CMP

($40).Y
($40),

BNE
BNE

CHKCR
CHKCR

TYA
RTS
RTS

Pointer. placing the
The calling program consists of four steps: initializing
initializing the Stack Pointer,
starting address of the string in memory locations 0040 and 0041.
0041, calling the
subroutine, and storing the result.
subroutine.
addresses 0040 and 0041.
The subroutine
subroutine is not reentrant.
reentrant, since it uses fixed memory addresses
However. if these locations are considered as extra registers and their contents
auHowever,
contents are au­
tomatically
atically saved and restored with
ith the user registers,
subroutine can be used in a
registers. the subroutine
reentrant
sizes use registers that
reentrant manner. Many computers
computers of all sizes
that are actually
actually located in
memory; this approach makes memory management
management more complex but does not
change the basic procedures.
Accumulator.
The subroutine
subroutine changes Index Register Y as well as the Accum
ulator. The programmer
lost: the subroutine
must be aware that data stored in Index Register Y will
ill be lost;
subroutine docudocu­
mentation
entation must describe what
hat registers are used.
used.

1 0-9

One way to preserve register contents
contents during
during a subroutine
subroutine is to save them in the Stack
and then restore them before returning.
returning. This approach makes life easier for the user of
the routine.
routine, but costs extra time and memory (in the program
program and in the Stack).
Stack). To save
and restore Index Register Y, you would
would have to add the sequence

TYA
PHA

;SAVE
:SAVE OLD
OLD CONTENTS
CONTENTSOF
OF YY

to the beginning
beginning of the program and
PLA
TAY

;RESTORE
;RESTOREOLD
OLD CONTENTS
CONTENTSOF
OFYY

to the end of the program.
subroutinehas aa single
easiest
to
This subroutine
single input
input parameter,
parameter. which
which is
isananaddress.
address.The
The
easiest way to
pass
this parameter
parameter is through
through tw
memory locations
locations on
on page
6502 has no
no
pass this
twoo memory
pagezero.
zero.The
The 6502
address-length registers in which
which this parameter
parameter could be passed.
address-length
passed.
If the terminating
inating character
character were not always an ASCII
return, we could make
ASCII carriage return.
character into another
another parameter. Now the calling
calling program would
would have to place
that character
the terminating
inating character
character in the Accum
ulator and the starting
starting address of the string in
Accumulator
locations 0040
0040 and 0041 before calling
calling the subroutine.
subroutine.
memory locations
One way to pass parameters that are fixed for a particular
particular call is to place their
their values in
memory immediately
mediately after the Jump-to-Subroutine
p-to-Subroutine instruction.1
instruction.^ You can use
program memory
the old Program Counter
Counter (saved
data, but you
(saved at the top of the Stack) to access the data.
adjust the return address (increase it by the number
number of bytes used for parameters)
must adjust
parameters)
before transferring
transferring control
control back to the main program. For example.
example, we could pass
pass the
value of the terminating
inating character
character this way. The main program would
ould contain
contain the
pseudo-operation .BYTE',
immediately after the JSR
instruction. The subroutine
subroutine could
pseudo-operation
.BYTE'. immediately
JSR instruction.
place the return address in memory
memory locations 0050
0050 and 0051 and access the various
post-indexing. The following
following sequence could save the return address,
parameters using post-indexing.
address,
remembering that
that the Stack is always on page 1 of memory and that the Stack Pointer
remembering
contains the address of the next available location.
always contains
TSX
LDA
STA
LDA
STA

$0101,X
$0101,X
$50
$50
$0102,X
$0102,X
$51
$51

;GET
:GET STACK
STACK POINTER
POINTER
;GET MSB'S OF RETURN
ADDRESS
;GET
RETURN ADDRESS
;GET LSB'SOF
ADDRESS
;GET
OFRETURN
RETURN
ADDRESS

Be careful of the fact that
that the return address is actually
actually the address of the last (third)
instruction, not the address immediately
immediately after the JSR
instruction as it
byte of the JSR
JSR instruction,
JSR instruction
is on most other
other microprocessors. The actual return address must also be offset by 1,
1.
ill autom
atically add 1 to it.
since RTS
RTS will
automatically
The instructions
instructions PHA (Store Accum
ulator in Stack)
ulator from
Accumulator
Stack) and PLA (Load
(Load Accum
Accumulator
Stack) transfer eight
eight bits of data between the Accum
ulator and the RAM Stack. Index
Accumulator
Registers X and Y can only be saved and restored via the Accum
ulator. As in the JumpJumpAccumulator.
to-Subroutine instruction,
instruction, the Stack Pointer is decremented
decremented after data is stored in the
to-Subroutine
Stack and incremented
incremented before data is loaded from it. Remember that the RAM Stack
downward (to lower addresses).
grows downward
addresses).

1 0-10
10

M aximum Value
Value
Purpose:
Purpose: Find
Find the
the largest
largest element
element in
in aa block
block of
of unsigned
unsigned binary
binary numbers.
numbers. The
The length
length
of
of the
the block
block is
is in
in Index
Index Register
Register YY and
and the
the starting
starting address
address of
of the
the block
block is
is in
in
memory
memory locations 0040 and
and 0041.
0041. The
The maximum value
value is
is returned
returned in
in the Ac­
Accumulator.
Sample
Sample Problem:
Problem:
(Y) = 05
05
(Y)
43
(0040) = 43
(0040)
(0041) = 00
(0041)

(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)
Result:
(Al
Result:
(A)

=
=
=
=
=

length of
of block
block
starting
starting address
address of
of block
block

67
79
79
15
15
E3
E3
72
72
E3. since this
this is
is the
the largest of five
five unsigned numbers
E3,

Flowchart:

(

StartT ~ )
Z

Base
4 and
Base == (0 0
10040
and
0 041))
Index
Index== (Y)
Max
Max== 0

Index :z: Index -1

Max = (Base + Index)

End

1 0 -11

Source Program:
Program:
calling program
program starts the Stack at memory
memory location
location 01 FF,
starting address
The calling
FF. sets the starting
block to 0043.
0043, gets the block
block length
length from memory
memory location
location 0030.
0030, calls the maxmax­
of the block
imum
imum subroutine.
subroutine, and stores the maximum
aximum in memory
memory location
location 0042.
*=00
LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
LDY
LOY
JSR
JSR
STA
BRK
BRK

#$FF
#$FF

;PLACE
:PLACE STACK AT END OF PAGE
PAGE 1

# $43
43
$40
#00
$41
$30
MAXM
MAXM
$42

STARTING ADDRESS
ADDRESS OF BLOCK
BLOCK
;SAVE STARTING

:GET
:GET LENGTH
LENGTH OF
OF BLOCK
BLOCK
;FIND
MAXIMUM VALUE
:FIND MAXIMUM
;SAVE MAXIMUM
:SAVE
MAXIMUM VALUE

The subroutine
subroutine determines
determines the maximum
aximum value in the block.
MAXM
MAXM
CMPE
CMPE

NOCHG
NOCHG

*=$20
$20
LDA
LOA
DEY
DEY
PHP
PHP
CMP
BCS
BCS
LDA
LOA
PLP
PLP
BNE
BNE
RTS
RTS

#0

($40).Y
($40),Y
NOCHG
NOCHG
($40).Y
($40),Y
CMPE
CMPE

:MAXIMUM=
ZERO (MINIMUM
POSSIBLE VALUE)
VALUE)
M
AXIMUM = ZERO
(MINIMUM POSSIBLE
DECREMENT INDEX
:DECREMENT
INDEX
:SAVE STATUS
;IS NEXT
NEXT ELEMENT
ELEMENT ABOVE MAXIMUM?
MAXIMUM?
NO, KEEP
MAXIMUM
:NO.
KEEP MAXIMUM
:YES.
REPLACE MAXIMUM
ELEMENT
YES, REPLACE
MAXIMUM WITH ELEMENT
:RESTORE
RESTORESTATUS
TUS
:CONTINUE
ELEMENTS EXAMINED
CONTINUE UNTIL ALL ELEMENTS

Subroutine Documentation:
SUBROUTINE
MAXM
:SUBROUTINE MAXM

:PURPOSE MAXM DETERMINES
DETERMINESTHE
THE MAXIMUM
BLOCK
iPURPOSE:
MAXIMUM VALUE IN A BLOCK
;: OF
OF UNSIGNED
UNSIGNED BINARY
BINARY NUMBERS
NUMBERS
:INITIAL CONDITIONS:
CONDITIONS: STARTING
STARTING ADDRESS
ADDRESS OF
OF BLOCK
BLOCK IN MEMORY
MEMORY
: LOCATIONS
LOCATIONS 0040 AND 0041,
0041. LENGTH
LENGTH OF
OF BLOCK
BLOCK IN
IN Y

;FINAL CONDITIONS:
CONDITIONS: MAXIMUM
IN A
:FINAL
MAXIMUM VALUE IN
:REGISTERSUSED:
USED: A,
A. Y,
Y. ALL FLAGS
FLAGS EXCEPT
EXCEPT OVERFLOW
OVERFLOW
REGISTERS
:MEMORY LOCATIONS
LOCATION·s USED:
USED: 0040, 0041
0041
;MEMORY
:SAMPLE CASE:
CASE:
: INITIAL CONDITIONS:
CONDITIONS 0043
0043 IN
IN MEMORY
MEMORY LOCATIONS
LOCATIONS 0040
0040 AND
AND 0041
0041
(Y) == 03,
03. (0043)
(0043) == 35,
35. (0044)
(0044) == 46.
46. (0045)
(0045) == 0D
OD
;
(Y)
FINAL CONDITIONS:
CONDITIONS: (A)
(A) = 446
: FINAL
6

This subroutine
has tw
two parameters -— an address and aa number. Memory locations
This
subroutine has
0040 and 0041 are
are used
used to pass
pass the address,
address. and Index Register Y
Y is
is used
used to pass
pass the
0040
number. The
Accumulator.
The result
result is a single
single number
number that
that is
is returned in
in the
the Accumulator.
The calling program must
must place
place the
the starting
address of
of the
the block
block in
in memory
memory locations
locations
The
starting address
0040
transferring con­
0040 and
and 0041 and
and the
the length of
of the
the block in Index Register Y
Y before
before transferring
control to the
subroutine.
the subroutine.

10-12
10-

1 1
UT

765432 4

HE

2

1 0 ^

--------Bit No.

| Z |C | ^

1B I C

Processor Status

A

*

,._
I-" ___
...................
-----

Carry
Zero
Result
Zero Result
■ Interrupt Disable
Disable

,._ -------------------------Decimal
_____
DecimalMode
Mode
,__ ______

Break Command
— Break
Command

'--------(Not------------------------- (Not used)
used)

,._ ________------------------------- Overflow
Overflow
------------------------- Negative Result
,._---------Negative
Result (Sign)
(Sign)

6502 Status
Status Register
Figure 10-1. The 6502
The subroutine
subroutine returns
returns control
control with
ith zero in Index Register Y. It is not reentrant
reentrant unless
locations 0040
0040 and 0041 are treated as extra registers. It is relocatable
relocatable since
memory locations
the addresses are relative
relative and the Stack is used for temporary
temporary storage.
instructions PHP
hich save and restore the Status
Note the use of the instructions
PHP and PLP
PLP which
register. This register
register is organized as shown
shown in Figure 10-1. We could reorganize the
change the initial
initial conditions
conditions so as to eliminate
inate the need for these instrucinstruc­
program and change
Chapter 5).
would be to provide
provide the address one before the start
tions (see
(see Chapter
5). The key here would
of the array as a parameter. This is easy to do with
ith most assemblers since they allow
allow
simple
arithmetic
(see Chapter
3).
simple arithm
etic expressions
expressions (such as START-1) in the operand field (see
Chapter 3).
However,
subroutine must be warned
warned that this offset is necessary.
However. the user of the subroutine
necessary.

1 0 -13

Object Program:
Program:
Object
Memory
emory Address
Address
(Hex)
(Hex)
1)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)

Calling
Calling Program
Program

0000
0001
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
000B
0008

oooc

OOOC
000D
000E
000E
000F
0010
0011
0011
0012

A2
A2
FF
FF
9A
A9
A9
43
85
40
A9
A9
00
85
41
A4
30
20
20
00
85
42
00

LDX
LDX

#$FF

TXS
TXS
LDA
LDA

#$43
#$
43

STA
STA

$40

LDA
LDA

#0

STA
STA

$41
$41

LDY
LDY

$30

JSR

MAXM
MAXM

STA
STA

$42

BRK
8RK

2)
2) Subroutine
Subroutine
0020
0021
0021
0022
0022
0023
0023
0024
0024
0025
0025
0026
0026
0027
0027
0028
0028
0029
0029
002A
002A
002B
002B
002C
002C
002D
002D

A9
A9
00
88
08
D1
D1
40
BO
BO
02
B1
B1
40
28
28
DO
DO
F5
F5
60
60

1010-14

MAXM
MAXM

LDA
LDA

#0

CMPE
CMPE

DEY
DEY
PHP
PHP
CMP
CMP

($40).Y
($40),
Y

BCS
BCS

NOCHG
NOCHG

LDA
LDA

($40).Y
($40),Y

PLP
NOCHG
NOCHG PLP
BNE
BNE

CMPE
CMPE

RTS
RTS

2
Pattern M atch
tc h 2
Purpose: Compare two strings of ASCII
ASCII characters to see if they are the same.
same. The
length
length of the strings is in Index Register Y. The starting
starting address of one string
is in memory locations 0042 and 0043; the starting
starting address of the other is in
memory locations 0044 and 0045. If the two strings
strings match, clear the AcAc­
cumulator; otherwise.
otherwise, set the Accum
ulator to FF
q.
cumulator;
Accumulator
FF15.
Sample Problems:
(Y) =
(Y)

a.
a.

(0042)
(0043)
(0043)

(0044)
(0044)
(0045)
(0045)

Result:
b.
b.

03

length of strings

#1
6~}
6~}starting address of string #2

46>

q q J starting
starting address of string

(0046) = 43
(0046)
(0047) = 41
(0047)
(0048) = 54
(0048)

·c·
'C'
'A'
T

(0050) =
(0051) =
(0051)
(0052) =
(0052)

'C'
'A'
'T
T

43
41
54

(A) =
(A)

00. since the strings are the same
same
00,

(Y) =
(Y)

03

length of strings

6~}
(0044)
6~}starting address of string #2
(0045)
(0045) = S } startin9 addreSS of Strin9 # 2

(0042) =
(0042)
(0043) =
(0043)

Result:

46
| starting address of string #1
00

(0046)
(0046)
(0047)
(0047)
(0048)
(0048)

= 52
52 'R'
-R'
= 41
41 'A'
’A'
= 54
54 T
T

(0050)
(0050)
(0051)
(0051)
(0052)

·c·
= 43
43 ‘C
= 41
41 'A'
'T
= 54
54 T

(A) =
(A)

FF, since the first characters differ
FF,

1 0-15
-15

Flowchart:
Flowchart:
Start

Basel =
(0042 and 0043)
Base2 =
(0044 and 0045)
Index - (YI
Mark - FF

Index = Index -1

Mark= Zero

End

10-16

Source Program:
The calling
calling program
program starts the Stack at memory
memory location
location 01 FF,
starting ad­
FF. sets the two starting
addresses to 0046
0046 and 0050
0050 respectively,
respectively, gets the string
string length
length from memory
memory location
location
0041, calls the pattern
pattern match
match subroutine,
subroutine, and places the result
memory location
location
0041.
It in memory
0040.
*=00
LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA
LDA
STA
LDY
LOY
JSR
STA
BRK
BRK

#$FF
#$FF

;PLACE
:PLACE STACK AT END OF PAGE
PAGE 1

#$46
$46
$42
#00
$43
#$
50
$50
$44
#00
$45
$41
PMTCH
$40

;SAVE
:SAVE STARTING
STARTING ADDRESS
ADDRESS OF STRING
STRING 1

;SAVE STARTING ADDRESS
:SAVE
ADDRESS OF STRING
STRING 2

:GET LENGTH
LENGTH OF STRINGS
STRINGS
CHECK FOR
:CHECK
FOR MATCH
:SAVE MATCH INDICATOR

subroutine determines
determines if the two strings
strings are the same.
The subroutine

PMTCH
CMPE

DONE
DONE

*=$20
$20
LDX
LOX
DEY
DEY
LDA
LOA
CMP
BNE
BNE
TYA
BNE
BNE
LDX
LOX
TXA
RTS
RTS

#$FF
#$FF

;MARK
:MARK== FF
FF (HEX)
(HEX) FOR
FOR NO MATCH

($42),
($42).Y
($44).Y
($44),Y
DONE
DONE

;GET
:GET CHARACTER
CHARACTER FROM STRING
STRING 1
;IS
:IS THERE
THERE A MATCH WITH STRING
STRING 2?
27
:;NO.
NO. DONE -— STRINGS
STRINGS DO NOT MATCH
;RESTORE
:RESTORESTATUS FROM
FROM INDEX

CMPE
#00

;MARK
:MARK== ZERO.
ZERO. STRINGS
STRINGS MATCH

1 0 -17

Subroutine Documentation:
Documentation:
Subroutine
SUBROUTINE PMTCH
PMTCH
;SUBROUTINE
PURPOSE: PMTCH DETERMINES
IF TWO
TWO STRINGS
MATCH
;PURPOSE
DETERMINES IF
STRINGS MATCH
INITIAL CONDITIONS: STARTING ADDRESSES
;INITIAL
ADDRESSES OF STRINGS
LOCATIONS 0042
0042 AND
AND 0043.
0043, 0044
0044 AND
AND 0045
0045
; IN MEMORY LOCATIONS
: LENGTH OF STRINGS IN INDEX REGISTER
REGISTERY
FINAL CONDITIONS: ZERO IN A IF STRINGS
MATCH.
;FINAL
STRINGS MATCH.
; FF IN A OTHERWISE
OTHERWISE
REGISTERS USED: A.
A, X.
X, Y.
Y, ALL FLAGS EXCEPT
EXCEPT OVERFLOW
.REGISTERS
0042, 0043.
0043, 0044,
0044, 0045
0045
;MEMORY LOCATIONS USED: 0042.

;SAMPLE CASE:
INITIAL CONDITIONS: 0046
0046 IN 0042
0042 AND 0043.
0043, 0050
0050
IN 0044
0044 AND 0045.
0045, (Y)
(Y) = 02
36. (0047)
(0047) == 39
39
(0046) == 36,
=36,
(0051)
=39
(0051)
= 39
(0050) = 36,
FINAL CONDITIONS: (A)
(A)== 0 SINCE
SINCE THE STRINGS
STRINGS MATCH

1010-18

Object Program:
Object
Program:

Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

1) Calling
Calling program
program
1)
0000
0001
0001
0002
0003
0004
0005
0006
0007
0008
0009
O00A
000A
000B
0008
OOOC
000D
000E
000E
000F
000F
0010
0011
0011
0012
0013
0014
0015
0016
0017
0018
0019
001A

oooc

2)
2)

A2
A2
FF
FF
9A
A9
A9
46
85
42
A9
A9
00
85
43
A9
A9
50
85
44
A9
A9
00
85
45
A4
41
41
20
20
00
85
40
00

LDX
LDX

#$FF

TXS
TXS
LDA
LDA

# $46

STA
STA

$42

LDA
LDA

#0

STA
STA

$43

LDA
LDA

# $500

STA
STA

$44

LDA
LDA

#0

STA
STA

$45

LDY
LDY

$41
$41

JSR
JSR

PMTCH
PMTCH

STA
STA

$40

BRK
BRK

Subroutine
Subroutine
0020
0021
0021
0022
0023
0024
0025
0026
0027
0028
0029
002A
002B
002B
002C
002D
002E
002E
002F
002F

A2
A2
FF
FF
88
B1
B1
42
D1
D1
44
DO
DO
05
98
DO
DO
F6
F6
A2
A2
00
8A
BA
60

1 0-19
9

PMTCH
PMTCH LDX
LDX

CMPE
CMPE

DONE
DONE

#$FF

DEY
DEY
LDA
LDA

($42).Y
($42),Y

CMP
CMP

($44).Y
($44),Y

BNE
BNE

DONE
DONE

TYA
TYA
BNE
BNE

CMPE
CMPE

LDX
LDX

#0

TXA
TXA
RTS
RTS

subroutine, like the preceding
preceding ones,
except Overflow.
Overflow. You
This subroutine.
ones. changes all the flags except
should generally
generally assume that
that a subroutine
subroutine call changes the flags unless it is specifically
specifically
stated otherwise.
otherwise. If the main program
program needs the old flag values (for later checking).
checking), it
calling the subroutine.
subroutine. This is accomplished
accomplished with
ith
must save them in the Stack before calling
the PHP
instruction.
PHP instruction.

zero. There are
This subroutine
subroutine uses all the registers ariu
anu ruur
rour memory
memory locations
locations on page zero.
three parameters -— twoo starting
starting addresses and the length
length of the strings.
The instruction
instruction TYA has no purpose other than to set the Zero flag according
according to the
contents
contents of Index Register Y. We could eliminate
inate the need for that
that instruction
instruction by
reorganizing
reorganizing the subroutine.
subroutine. One alternative
alternative would
would be to change
change the parameters so that
that
the addresses were both offset
offset by 1 (that is,
string addresses would
would actually
actually refer
is. both string
Remember. however.
to the byte immediately
immediately preceding
preceding the character
character string). Remember,
however, that the
obuser should be able to supply
supply parameters to the subroutine
subroutine in the simplest
simplest and most ob­
vious form possible. The user should not have to offset
offset addresses by one or make other
adjustments
numerous.
adjustments for the convenience
convenience of the subroutine:
subroutine; such practices
practices result in numerous,
annoying
errors. The program should make such rote adjustments
annoying programming
programming errors.
adjustments unless
time or memory
memory constraints
constraints are critical.
Another
nother alternative
alternative would
would be to decrement
decrement the index by 1 initially
initially to avoid the problem
of accessing beyond the end of the string. The end of the loop would
would then decrement
decrement
the index and branch back as long as the result was positive, i.e.,..
DEY
DEY
BPL
BPL

CMPE
CMPE

less than 130 bytes long. The
This approach would
would work as long as the string was less
limitation
itation occurs because the 6502 Sign flag is set if the result is an unsigned
unsigned number
number
greater than 127 (decimal).
(decimal).

10-20
10-20

M uitiple-Precision Addition
Addition
Multiple-Precision
Purpose: Add
Add two
tw o multiple-byte
m ultiple-byte binary
binary numbers.
numbers. The
The length
length of
of the
the numbers
numbers (in
(in bytes)
bytes)
Purpose:
is in
in Index
Index Register
Register Y,
Y, the
the starting
starting addresses
addresses of
of the
the numbers
numbers are
are in
in memory
memory
is
locations 0042
0042 and
and 0043
0043 and
and in
in 0044
0044 and
and 0045,
0045. and
and the
the starting
starting address
address of
of
locations
the result
result is
is in
in memory
memory locations
locations 0046
0046 and
and 0047.
0047. A
the numbers
numbers begin
begin w
ith
the
Alll the
with
the most
most significant
significant bits.
bits.
the
Sample Problem:
Problem:
Sample
(Y)
(Y)

= 04
04

length of
of numbers
numbers in
in bytes
bytes
length

6~}
(0044)
6g}starting address of second number
(0045) =

(0042)
(0042)
(0043)
(0043)

=

(0044)
(0045)

(0046)
(0046)
(0047)

48)
starting address of
of first
first nun
starting
number
0 0)
4C)
starting address of second
001

starting address of result
result
starting
= ~g}
001
= 2F MSBs of first
first number
number
50)

(0048)
(0049) = 5B
(004A) = A7
(004B)
(004B) = C3

Result:

LSBs of first
first number
number

(004C)
(004C)
(004D)
(004E)
(004E)
(004F)
(004F)

=
=
=
=

14 MSBs of second number
number
DF
35
B8 LSBs
number
LSBs of second number

(0050)
(0051)
(0052)
(0052)
(0053)
(0053)

=
=
=

44 MSBs of result
3A
DD
7B LSBs
LSBs of result

that is.
is.

2F5BA7C3
+
+ 14DF35B8

=

443ADD7B
443ADD7B

10-21
10-21

Flowchart:
Start

Index= IYI
Basel =
10042 and 00431
Base2 =

(0044 and 00451
Base3 =
(0046 and 004 71
Carry= 0

Index = Index - 1

(Base3+Indexl =
(Basel +Index) +
(Base2+Indexl +
(Carry)

End

10-22
10-22

This step also produces new Carry

Source Program:
Program:
Source
The calling
calling program
program starts
starts the
the Stack
Stack at
at memory
memory location
location 01 FF,
FF, sets
sets the
the starting
starting adad­
The
dresses of
of the
the various
various numbers
numbers to
to 0048,
0048, 004C,
004C, and
and 0050,
0050, respectively,
respectively, gets
gets the
the length
length
dresses
of the
the numbers
numbers from
from memory
memory location
location 0040,
0040, and
and calls
calls the
the m
ultiple-precision addition
addition
of
multiple-precision
subroutine.
subroutine.
*=
*=00
LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA
STA
STA
LDY
LOY
JSR
BRK
BRK

#$FF
#$FF

;PLACE STACK AT
AT END OF
OF PAGE 1
:PLACE

#$48
$48
$42
$42
#$4C
#$4C
$44
$44
#$50
$50
$46
$46
#00
$43
$45
$47
$40
MPADD

NUMBER
:SAVE STARTING ADDRESS OF FIRST
FIRST NUMBER

:SAVE STARTING ADDRESS OF SECOND NUMBER
;SAVE STARTING ADDRESS OF RESULT
RESULT
;SAVE PAGE NUMBER FOR
ALL ADDRESSES
:SAVE
FOR ALL
ADDRESSES

;GET
:GET LENGTH
LENGTH OF NUMBERS IN BYTES
BYTES
;MULTIPLE-PRECISION
;MULTIPLE-PRECISION ADDITION

subroutine performs
performs multiple-precision
ultiple-precision binary
binary addition.
addition.
The subroutine

MPADD
ADDB

*=$20
*=$20
CLC
DEY
DEY
LDA
LOA
ADC
STA
TYA
BNE
BNE
RTS
RTS

:;CLEAR
CLEAR CARRY TO START
($42),Y
($42).Y
($44),
($44).Y
($46),
($46).Y
ADDB

;GET
;GET BYTE
BYTE FROM
FROM FIRST
FIRST NUMBER
NUMBER
:ADD BYTE
BYTE FROM
FROM SECOND
SECOND NUMBER
NUMBER
;STORE
;STORE RESULT
RESULT
;ALL
:ALL BYTES
BYTES ADDED?
:NO.
;NO. CONTINUE
CONTINUE

Subroutine Documentation:
Documentation:
SUBROUTINE MPADD
;SUBROUTINE
PURPOSE:
:PURPOSE: MPADD ADDS TWO MULTI-BYTE
Tl-BYTE BINARY
BINARY NUMBERS
NUMBERS

:INITIAL CONDITIONS:
CONDITIONS: STARTING
STARTING ADDRESSES
ADDRESSES OF
OF NUMBERS
NUMBERS (MSB'S)
(MSB'S)
, IN
IN MEMORY
MEMORY LOCATIONS 0042 AND
AND 0043, 0044 AND 0045
; STARTING
STARTING ADDRESS
ADDRESS OF
OF RESULT
RESULT IN
IN MEMORY
MEMORY LOCATIONS
LOCATIONS 0046
0046 AND
AND 0047
: LENGTH
LENGTH OF
OF NUMBERS
NUMBERS IN INDEX
INDEX REGISTER
REGISTERY
Y
REGISTERS
:REGISTERSUSED:
USED: A,
A. Y,
Y. ALL
ALL FLAGS
FLAGS
;MEMORY LOCATIONS
LOCATIONS USED:
USED: 0042,
0042. 0043,
0043, 0044,
0044, 0045,
0045, 0046,
0046, 0047
0047

;SAMPLE CASE:
CASE:
INITIAL
INITIAL CONDITIONS:
CONDITIONS: 0048
0048 IN
IN 0042
0042 AND
AND 0043,
0043,
004C
004C IN
IN 0044
0044 AND
AND 0045,
0045, 0050
0050 IN
IN 0046
0046 AND
AND 0047,
0047,
(Y)
(Y) == 02,
02, (0048)
(0048) == A7,
A7. (0049)
(0049) == C3,
C3. (004C)
(004C) == 35,
35. (004D)
(004D) == B8
88
FINAL
FINAL CONDITIONS:
CONDITIONS: (0050)
(0050) == DD,
DD. (0051)
(0051) == 7B
7B

1023
10-23

Object Program:
Object
Program:
Memory Address
Memory
(Hex)
(Hex)

1)
1)

Instruction
Instruction
(Mnemonic)

Calling program

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
OOOB
000B
000C
oooc
000D
000E
OOOE
0
00F
OOOF
0010
0011
0012
0013
0014
0015
0016
0017
0018
0019
001A
001A
001BB
001C
001C
2)
2)

Memory Contents
Memory
(Hex)
(Hex)

A2
FF
FF
9A
A9
48
85
42
A9
4C
85
44
A9
50
85
46
A9
00
85
43
85
45
85
47
A4
40
20
20
00
00

LDX
LOX

#$FF

TXS
TXS
LDA
LOA

# $48
48

STA

$42

LDA
LOA

#$4C
#$4C

STA

$44

LDA
LOA

# $50
50

STA

$46

LDA
LOA

#00

STA

$43

STA

$45

STA

$47

LDY
LOY

$40

JSR
JSR

MPADD

BRK
BRK

Subroutine
Subroutine

0020
0021
0022
0023
0024
0025
0026
0027
0028
0029
002A
002B

18
88
B1
B1
42
71
71
44
91
91
46
98
DO
DO
F6
60

MPADD
ADDB

CLC
CLC
DEY
DEY
LDA
LOA

($42).Y
($42),Y

ADC

($44).Y
($44),

STA

($46).Y

TYA
BNE
BNE

ADDB

RTS
RTS

This subroutine
subroutine has four parameters -— three addresses and the length
length of the numbers.
Six memory locations on page zero and Index Register Y are used for passing
parameters.
parameters.
As with
ith the previous example, we could eliminate
eliminate the need for the TYA instruction
instruction by
offsetting the address parameters by 1.
reorganizing the program or by offsetting

1 0-24
4

PROBLEMS
PROBLEMS
Note that
that you
you are
are to
to w
rite both
both aa calling
calling program
program for
for the
the sample
sample problem
problem and
and aa properly
properly
Note
write
documented subroutine.
subroutine.
documented

1)
1)

ASCII to
to Hex
Hex
ASCII

Purpose: Convert
Convert the
the contents
contents of
of the
the Accum
ulator from
from the
the ASCII
ASCII representation
representation of
of aa
Purpose:
Accumulator
hexadecimal d
ig it to
to the
the actual
actual digit.
digit. Place
Place the
the result
result in
in the
the Accumulator.
Accumulator.
hexadecimal
digit
Sample Problems:
Problems:
Sample
a.
a.

(A) = 43
43
(A)

Result:
bb.

ASCII C
C
ASCII

0C
oc

(A) = 36
Result:

2)

(A) =

ASCII 6

06
(A) = 06

Length of a T ele ty
p e w rite r Message
essage
eletypewriter

Determine the length
length of an ASCII-coded teletypewriter
teletypewriter message.
start­
Purpose: Determine
message. The starting address of the string
string of
of characters
characters in which
hich the message is embedded
embedded is
memory locations
locations 0042
0042 and 0043. The message itself
itself starts with
ith an ASCII
in memory
STX character
character (0215)
(02-|g) and ends with
ith ASCII ETX
1 6>- Place the length
length of
ETX (03
(0315).
number of characters
characters between
between the STX and the ETX)
the message (the number
ETX) in the
Accumulator.
Accumulator.

Sample Problem:
(0042)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0048)
(0048)
Result:
Result:

3)

=
=
=
=
=
=
=

(A)
(A) =

44

| starting address of string
~~
00 } starting
49
02
47
4F
03

STX
STX
'G'
'G'
’O'
·o·
ETX
ETX

02

M inim um Value

Purpose:
Purpose: Find the smallest element in a block of unsigned binary numbers.
numbers. The
The length
of the
the block
block is
is in Index Register Y and the
the starting
starting address of the block is
is in
memory locations 0040 and
inimum value
and 0041.
0041. The minimum
value is
is returned
returned in
in the
the Ac­
Accumulator.
cumulator.
Sample
Sample Problem:
Problem:
(Y)
(Y) =

05
05

length
length of
of block
block

(0040)
(0040) _ 43
~~}^ starting address
address of
of block
block
(0041)
(0041) = 0 0 !
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)

Result:

=
=
=
=
=

(A)
(A) =

67
67
79
79
15
15
E3
E3
73
73
15,
15, since
since this
this isis the
the smallest
smallest of
of the
the five
five
unsigned
unsigned numbers
numbers

110-25
0-25

StringComparison
Comparison
4)4) String
Purpose:
o strings
Purpose:Compare
Comparetwtwo
strings ofofASCII
ASCIIcharacters
characterstotosee
seew hich
which isislarger
larger(i.e..
(i.e..which
which
follows
follows the
theother
otherinin"alphabetical"
"alphabetical" ordering).
ordering).The
Thelength
length ofofthe
thestrings
strings isisinin
Index
IndexRegister
RegisterY.Y,the
thestarting
startingaddress
addressofofstring
string 11isisininmemory
memorylocations
locations0042
0042
and
and0043,
0043, and
andthe
thestarting
starting address
addressofofstring
string 22isisininmemory
memory locations
locations0044
0044
and
ula­
and0045.
0045. IfIfstring
string 11isislarger
largerthan
thanororequal
equaltotostring
string 2,2.clear
clearthe
theAccum
Accumulator; otherwise,
otherwise, set
setthe
theA ccum
Accumulator
FF15.
tor;
ulator totoFF-|g.

Sample Problems:
Problems:
Sample
a.

Result:
Result:
b.

(Y)
(Y)

Result:
Result:

(0044)
(0044)
(0045)
(0045)

4A

(0046)
(0046)
(0047)
(0047)
(0048)
(0048)

43
43
41
41
54
54

'C'
'C'
'A'
'A'

(004A)
(004A)
(0048)
(004B)
(004C)
(004C)

42
42
41
41
54
54

'B'
'B'
'A·
'A'

00

00

| starting
starting address
address ofof string
string #1
#1
starting
2
starting address
address of
of string
string ##2

TT

TT

(A)
(A)

00.
00. since
since 'C
'CAT' is
is "larger"
"larger·· than
than 'B
'BAT'

(Y)
(Y)

03

length of strings
strings

(0044)
(0045)
(0045)

6~}
6i}
00

(0046)
(0046)
(0047)
(0048)
(0048)

43
41
54
54

'A'
'A'
T

(004A)
(004A)
(0048)
(004B)
(004C)
(004C)

43
43
41
41
54
54

'A'
'A'
TT

46 i
J- starting address of string #1
00 starting
4A[
j- starting
starting address of string
string #22

·c·
JC

'C'
'C'

(A)
(A)

00 , since
since the
the tw
strings are
are the
the same
same
00,
twoo strings

(Y)
(Y)

03
03

length of
of strings
strings
length

(0044)
(0044)
(0045)
(0045)

6~}
6i}

(0046)
(0046)
(0047)
(0047)
(0048)
(0048)

43
43 'C
41
41 'A
'A'
54
54 TT

(004A)
(004A)
(0048)
(004B)
(004C)
(004C)

43
43 'C'
'C'
55
55 V
54
54 TT

(0042)
(0042)
(0043)
(0043)

Result:
Result:

6~}
j6i}

46

(0042)
(0042)
(0043) =
(0043)

C.

03 length
03
length ofofstrings
strings

(0042)
(0042)
(0043)
(0043)

(A)
(A)

46

| starting address of string #1
00 starting address of string #1
4A

00

^ starting
starting address
address of
of string
string #2
#2

·c·

·u·
·cur

r

FF,since
since 'CUT' isis"larger"
"larger" than
than'CA
'CAT'
FF,

1
0-26
10-26

5)

Decimal Subtraction
Subtraction
Decimal

Purpose: Subtract
Subtract one multiple-digit
ultiple-digit decimal
decimal (BCD)
number from another. The length
(BCD) number
starting addresses of
of the numbers (in bytes) is in Index Register Y and the starting
numbers are in memory locations
locations 0042
0042 and 0043
0043 and 0044
0044 and 0045.
the numbers
Subtract the number
number with
ith the starting
starting address in 0044
0044 and 0045
0045 from the
Subtract
ith the starting
starting address in 0042
0042 and 0043. The starting
starting address of the
one with
memory locations 0046
0046 and 0047. All
All the numbers begin with
ith the
result is in memory
significant digits. The sign of the result is returned
returned in the Accum
ula­
most significant
Accumulato
positive, FF-]
q if it is negative.
torr -— zero if the result is positive.
FF15
Sample Problem:
(Y) =
(Y)

04

length of numbers in bytes
length

6~
}
6g}

(0042)
(0043)
(0043)

= 48 > , t .
..
,
- 00 ) starting
startln9 address
address of
of minuend
minuend

(0044)
= 4C )
starting address of subtrahend
(0045)
(0045) - 00 ) start'n9 address of subtrahend

Result:
Result:

(0046)
(0047)
(0047)

= 50 »
.
,,
,
- ~~
00 }) starting
startlng address
address of
of difference
difference

(0048)
(0049)
(004A)
(0048)
(004B)

= 36
= 70
= 19
19
= 85

significant digits
digits of minuend
minuend
most significant

(004C)
(004C)
(004D)
(004D)
(004E)
(004E)
(004F)
(004F)

= 12
12
= 66
= 34
= 59

most significant
significant digits
digits of subtrahend
subtrahend

(A) =
(A)
(0050)
(0050)
(0051)
(0051)
(0052)
(0052)
(0053)
(0053)

00
= 24
= 03
= 85
= 26

that is,
is.
+
+

significant digits
digits of minuend
minuend
least significant

least significant
significant digits
digits of subtrahend
subtrahend
positive resultIt
significant digits
digits of difference
difference
most significant

significant digits
digits of difference
difference
least significant

36701985
36701985
12663459
12663459
24038526
24038526

1010-27

REFERENCES
REFERENCES
1.

Other
S. Mazor and
Other examples
examples of this
this technique
technique (for the 8080
8080 microprocessor) are in S.
C. Pitchford.
Pitchford. "Develop
"Develop Cooperative
Cooperative Microprocessor
Microprocessor Subroutines,"
Subroutines," Electronic
Design, June
June 7, 1978, pp. 116-118.

2.

5. 1978,
1978.
J. T. O'Donnell.
O'Donnell, "6502
"6502 Routine
Routine Compares Character
Character Strings,"
Strings," rnH,
EDN, August
ugust 5,
p. 54.

10-28

Chapter 11
Chapter
INPUT/OUTPUT
INPUT/OUTPUT
input/output sections:
sections: one is how to inin­
There are twoo problems in the design of input/output
terface peripherals to the computer
computer and transfer
transfer data, status, and control sigsig­
terface
nals; the other
other is how to address I/O
devices so that
that the CPU can select
select a particuparticu­
1/0 devices
transfer. Clearly.
Clearly, the first
first problem
problem is both
both more complex
complex and more inin­
lar one for a data transfer.
teresting
We will
ill therefore
therefore discuss the interfacing
interfacing of peripherals
peripherals here and leave adad­
teresting. We
dressing to a more hardware-oriented
hardware-oriented book.
dressing
In theory.
theory, the transfer
transfer of data to or from an I/O
device is similar
1/0 device
to the transfer
transfer of data to or from memory. In fact, w e can con­
consider the memory
memory as just
st another
another I/O
memory is,
1/0 device. The memory
is,
however, special for the following
ing reasons:
however.

I/O
AND
1/0 AND
MEMORY
MEMORY

1)
2)

operates at almost
almost the same speed as the processor.
It operates
It uses the same type of signals as the CPU. The only circuits usually needed
to interface
interface the memory
memory to the CPU are drivers, receivers,
receivers, and level
level translatransla­
tors.
3) It requires no special formats
formats or any control signals besides a Read/Write
Read/Write
pulse.
atically latches
4) ItIt autom
automatically
latches data
data sent
sent to
to it.it.
5) Its
Its word
word length
length isisthe
the same
same as
as the
the computer's.
computer's.
Most
ost I/O
devices do not have such convenient
convenient features.
features. They
They may operate
operate at
1/0 devices
speeds much
much slower
slower than the processor;
processor; for example.
example, a teletypewriter
teletypewriter can transfer
transfer only
10 characters
characters per second.
second, while
hile a slow processor
processor can transfer
transfer 10.000
10,000 characters
characters per
wide -— sensors may provide
provide one reading
second. The range of speeds is also very wide
minute, while
hile video
video displays
displays or floppy
floppy disks may transfer
transfer 250.000
250,000 bits per second.
per minute.
Furthermore, I/O
devices may require continuous signals (motors or thermometers).
thermometers),
1/0 devices
Furthermore.
rather than voltages
voltages (teletypewriters).
(teletypewriters), or voltages
voltages at far different
different levels
currents rather
(gas-discharge displays). I/O
devices may also
than the signals used by the processor (gas-discharge
1/0 devices
require special
special formats.
formats, protocols.
protocols, or control
control signals. Their
Their word
word lengths
lengths may be much
require
shorter or much
much longer
longer than the word
word length
length of the computer.
computer. These variations
variations make
shorter
sections difficult
ifficu lt and mean that
that each peripheral presents
presents its own
the design of I/O
1/0 sections
interfacing problem.
special interfacing
however, provide a general description
description of devices
devices
We may, however,
interfacing methods. We may roughly separate
separate devices
devices
and interfacing
into three categories,
categories, based on their
their data rates:

I/O
1/0
CATEGORIES

1) Slow
Slow devices
devices that
that change
change state
state no
nomore
more than
than once
once per
per second.
second. Changing
Changing their
their
typically requires
requires milliseconds
milliseconds or longer. Such devices
devices include
include lighted
lighted disdis­
states typically
plays,
switches, relays,
mechanical sensors and actuators.
actuators.
plays. switches.
relays. and many mechanical

2) Medium-speed
Medium-speed devices
devices that
that transfer
transfer data
data at
at rates
rates of
of 11to
to 10,000
10,000 bits
bits per
persec­
second. Such devices
devices include
include keyboards.
keyboards, printers.
printers, card readers,
paper tape readers
readers. paper
and punches.
punches, cassettes.
cassettes, ordinary
ordinary communications
communications lines,
many analog
analog data acac­
lines. and many
quisition systems.
quisition

3)

High-speed devices
devices that
that transfer
transfer data at rates of over
over 10,000
10,000 bits per second.
High-speed
devices include
include magnetic
agnetic tapes,
magnetic disks.
disks, high-speed
high-speed line printers.
printers,
Such devices
tapes. magnetic
high-speed comm
unications lines,
video displays.
displays.
high-speed
communications
lines. and video

11-1

The interfacing
sigINTERFACING
interfacing of slow
slow devices
devices is simple. Few
Few control sig­
INTERFACING
nals are necessary unless the devices
devices are multiplexed,
ultiplexed, i.e....
SLOW DEVICES
several are handled
handled from one port.
port, as shown
shown in Figures 11-11 to
11-4. Input
for a
Input data from slow devices
devices need not be latched, since it remains stable for
long time
course. be latched. The only problems with
time interval.
interval Output
Output data must, of course,
input
data. One-shots,
One-shots.
input are transitions
transitions that
that occur
occur while
hile the computer
computer is reading the data.
cross-coupled
the transitions.
cross-coupled latches.
latches, or software
software delay routines
routines can smooth the
transitions.
A single port can handle several
11-1 shows a demultiplexer
several slow devices. Figure 11-1
demultiplexer
that
counting output
output
that automatically
autom atically directs
directs the next output
output data to the next device by counting
operations.
operations. Figure 11-2 shows a control
control port that provides
provides select inputs
inputs to a
demultiplexer.
order. but an additional
demultiplexer. The data outputs
outputs here can come in any order,
additional output
output
instruction
instruction is necessary to change the state of the control
control port. Output
utput demultiplexers
demultiplexers
are commonly
commonly used to drive several displays
displays from the same output
output port. Figures 11-3
and 11-4 show
show the same alternatives
alternatives for an input
input multiplexer.
multiplexer.
Note the differences
differences between
between input
input and output
output with
ith slow devices:

1)I Input
Input data
data need
need not
not be
be latched,
latched, since
since the
the input
input device
device holds
holds the
thedata
datafor
foran
anenor­
enorlength of time by com
puter standards. Output
utput data must be latched,
mous length
computer
latched. since
the output
CPU clock
output device
device will
ill not respond to data that is present
present for only a few CPU
cycles.
2) Input
Input transitions
transitions cause
cause problems
problems because
because of
oftheir
their duration;
duration; brief
brief output
output tran­
transitions cause no problems because the output devices (or the observers)
observers)
react
react slowly.
slowly.
3) The
The major
major constraints
constraints on
oninput
input are
are reaction
reaction tim
time
andresponsiveness,
responsiveness, the
the ma­
mae and
constraints on output
output are response time and observability.
observability.
jor constraints

Medium-speed devices
devices must be synchronized in some way
way
INTERFACING
Medium-speed
MEDIUM-SPEED
cannot simply
simply treat these
MEDIUM-SPEED
to the processor clock. The CPU
CPU cannot
DEVICES
devices as if they held their
their data forever
forever or could receive data
devices
at any time. Instead.
Instead, the CPU
must be able to determine
determine when
at
CPU must
device has new input
input data or is ready to receive output
output data. It must also have a way
a device
telling a device
device that
that new output
output data is available or that the previous input
input data has
of telling
has
accepted. Note that
that the peripheral
peripheral may be or contain
contain another
another processor.
been accepted.
processor.

I

I

The standard unclocked procedure is the handshake.
|HANDSHAK
The
handshake. Here the
HANDSHAKEe ]
sender indicates
indicates the availability
availability of data to the receiver and
sender
transfers the data:
data; the receiver
receiver completes
completes the handshake by acknowledging
acknowledging the recep­
transfers
recepreceiver may control
control the situation
situation by initially
initially requesting
requesting the data or
tion of the data. The receiver
or
indicating its readiness to accept
accept data; the sender then sends the data and com­
by indicating
completes the handshake
handshake by indicating
indicating that data is
either case,
pletes
Is available. In either
case. the sender
knows that
that the transfer
transfer has been completed
completed successfully
successfully and the receiver knows when
knows
when
new data is available.

11-2
11-2

..

Data Outputs 0

Data Bus

I

..

.

)

... Data

Output
Output

.)

Port
Port

F

Inputs
Inputs
Data Outputs 1
~

>

Strobe

£

Port
Logic
Port Selection logic

Demultiplexer
OemultiJ>'exer

I

Data Outputs 2
~

)

Clock
F

--

Counter

Select
Inputs
Inputs

Data Outputs
Outputs 3

.

= >)

The Counter
Counter controls
controls where the
the Demultiplexer
Demultiplexer sends
sends the data.
data.

Figure 11-1. An Output
utput Demultiplexer
ultiplexer Controlled
Controlled by a Counter
Counter

Data
Data Outputs
Outputs 0

Data
Data

Data
Data

Port
Port

Inputs
Inputs
Data
Data Outputs
Outputs 1

Data Bus
Demultiplexer
Demultiplexer
Data
Data Outputs
Outputs 2

i>
Control
Control

Select
Select

Port
Port

Inputs
Inputs

Data
Data Outputs
Outputs 33

£

The
The CPU
CPU sends
sendscontrol
controlinformation
informationto
to the
the Control
ControlPort;
Port: that
that port
port then
then determines
determines
where
where the
the Demultiplexer
Demultiplexersends
sendsthe
the data.
data.

Figure 11
utput Demultiplexer
ultiplexer Controlled
Controlled by aa Port
11-2. An O
Output

1 1-3

VV...

Inputs 0
. Data Inputs

Data Bus

c

(

-A

Input
Port

"

c
.

—

Data
Outputs
Outputs

~

"

-

5

Inputs 1
Data Inputs
-

IC
" =3

Enable
Enable
Selection Logic
Port Selection

1
»

~ —

K

l

Multiplexer
Multiplexer

''

!,

.

Inputs 2
Data Inputs

K'
C = 3\

Oock

--

Counter

-

"

Select

Inputs

.

K==3
Data Inputs 3

r-..
"

t

"

controls which input
input the Multiptexer
Multiplexer gates to the Input Port.
The Counter controls

Figure 11
Input Multiplexer
ultiplexer Controlled
Controlled by a Counter
Counter
11-3. An Input

. Data Inputs 0
Input Data
ln~ut
Data Bus
Bus

c

Data
Port

(

c"
-

K" = *

Data

~

Outputs
Outputs

.. Data Inputs l1

/■ -------------- )<.

....

Multiplexer
Multiplexer

.

Data Inputs 22

V

...

)

Output
Output Data Bus
Bus
5

.

..._

Select
Select

Control
Control
Port
Port

Inputs
""' Inputs

Data
Data Inputs 33
~

.. = >
IC
I(

The
information which
output operation)
The control
control information
which the
the CPU
CPU sends
sends to
to the
the Control
Control Port
Port (with
(with an
an output
operat10n)
determines
determines which
which input
input the
the Multiplexer
Multiplexer routes
routes to
to the
the Data
Data Port.
Port.

Figure 11-4. An Input
Input Multiplexer
ultiplexer Controlled
Controlled by a Port

11-4

~

show typical
typical input
input and output
output operations
operations using the handshake
Figures 11-5 and 11-6 show
method. The procedure whereby
whereby the CPU checks the readiness of the peripheral
method.
llin g ". Clearly.
Clearly, polling
polling can occupy
occupy a large
before transferring data is called "p olling",
amount of processor
processor timee if there are many I/O
several ways
ways of
amount
1/0 devices. There are several
providing the handshake signals.
Among these are:
signals. Among

• Separate
Separate dedicated
dedicated I/O
processor may handle
handle these as additional
additional I/O
1/0 lines. The processor
1/0
through special
special lines or interrupts.
interrupts. The 6502
6502 microprocessor
microprocessor does not have
ports or through
special serial I/O
but such lines are available
available on the 6520
6520 Peripheral
Peripheral Interface
Interface
1/0 lines,
lines. but
special
Adapter (or PIA).
PIA), the 6522
6522 Versatile
Versatile Interface
Interface Adapter
Adapter (or VIA).
VIA), and the 6532
6532 Pe­
Adapter
Peripheral Interface/Mem
ory (or Multifunction)
ultifunction) device.
ripheral
Interface/Memory
• Special
Special patterns
patterns on the I/O
single start
start and stop bits or entire
entire
1/0 lines. These may be single
characters or groups
groups of characters. The patterns
patterns must be easy to distinguish
distinguish from
characters
background noise or inactive
inactive states.
background
We often call a separate I/O
that indicates the availability
availability
We
1/0 line that
of data or the occurrence of a transfer
transfer a "s trobe".
b e ". A strobe
may, for example.
example, clock data into a latch or fetch data from a buffer.

| STROBE |
lSTROBE!

peripherals transfer
transfer data at regular intervals;
intervals; i.e.,.. synchronously.
synchronously. Here the only
Many peripherals
problem is starting
starting the process by lining
lining up to the first input
input or marking
marking the first output.
output.
problem
In some cases,
peripheral provides
provides a clock input
input from which
hich the processor can obob­
cases. the peripheral
tain timing
ing information.
information.

Transmission errors are a problem with
ith medium-speed
medium-speed
Several methods can lessen the likelihood of such
devices. Several
errors; they include:

REDUCING
TRANSMISSION
TRANSMISSION
ERRORS
ERRORS

• Sampling input data at the center
center of the transmission
interval in order to avoid edge effects;
effects; that is,
interval
is, keep away from the edges where
the data is changing.
changing.
• Sampling each input several
several times and using
using majority logic such
such as best three
out of five.1
.1
• Generating
Generating and checking parity; an extra bit is used that makes the number
number of 1
bits in the correct
correct data even or odd.
• Using other error detecting
detecting and correcting codes such as checksums, LRC
LRC
(longitudinal redundancy
redundancy check),
redundancy check).2
(longitudinal
check). and CRC
CRC (cyclic redundancy
High-speed devices that transfer
INTERFACING
transfer more than
than 10,000 bits per
second require special methods. The usual technique
technique is to
HIGH-SPEED
construct a special-purpose
special-purpose controller
controller that
DEVICES
construct
that transfers
transfers data
directly between the memory and the I/O
1/0 device. This process
directly
DIRECT
is called direct
direct memory access (DMA).
controller
(OMA). The DMA
OMA controller
MEMORY
MEMORY
must force the CPU
con­
CPV off the busses,
busses, provide addresses and conACCESS
ACCESS
trol
trol signals to the memory, and transfer
transfer the
the data.
data. Such a con­
controller
typically consisting
consisting of 50 to
troller will be fairly complex,
complex. typically
to 100
chips, although
although LSI
initially load
LSI devices are
are now available. 3 The CPU
CPU must initially
load the Address
and Data Counters in the controller
controller so that
controller will know where to
that the
the controller
to start and
how much to transfer.

1 1-5

Input
Acknowled~e
Data

Data Bus

1/0

CPU

Section

"

~

...

Penpheral

Data Ready

a)
al

Peripheral
computer I/O
Peripheral provides data and Data Ready
Ready signal to computer
1/0 section.

Input
Acknowledge
Data Bus

CPU

Data

1/0

'./

Section

"

K'.
...

Peripheral

~ata Ready

b)
bl

CPU
(this may be a hardware interrupt connection).
CPU reads
reads Data Ready
Ready signal
signal from I/O
1/0 section lthis
connect10n).

Input

Acknowledge
Data Bus

CPU

Data
Section

~

-

~

1/0

I(

Peripheral

...
Data Ready

c)
cl

CPU
CPU reads data from I/O
1/0 section.

Input
Acknowledge
Data Bus

CPU

.

Data

1/0

)

Section

-

.

I(

Peripheral
~

Data Ready

-

di CPU
d)
CPU sends
sends Input
Input Acknowledge
Acknowledge signal
signal to
to I/O
1/0 section,
section. which
which then
then provides
provides Input
Input Acknowledge
Acknowledge signal
signal
to
to Peripheral
Peripheral (this
{this may
may be
be aa hardware
hardware connection).
connection).

Figure 11-5.
11-5. An
An Input
Input Handshake
Handshake
Figure

11-6
11-6

Output Ready

-

.

CPU

Data Bus

.
.)

Data

1/0

..

IC

Section

Peripheral

Peripheral Ready

--

a)

Peripheral
Peripheral provides Peripheral
Peripheral Ready
Ready signal
signal to computer
computer I/O
1/0 section.
sectK>n.

-.

Output Ready
Data Bus

1/0

~

CPU

(

.

Data

.

Section

Peripheral

PeripheralReady

-

b)

CPU
CPU reads Peripheral
Peripheral Ready
Ready signal
signal from
from I/O
1/0 section (this may be a hardware interrupt connection).
connec·tion).

Output Ready
Data Bus
CPU

.

1/0

~

Section

Data

--

.

)

Penpheral

Peripheral Ready

-

c)
cl

CPU
CPU sends
sends data
data to Peripheral.
Peripheral.

Output Ready
Data Bus

CPU

.

.

Data

1/0
Section

.,,

Peripheral Ready

d)
d) CPU
CPU sends
sends Output
Output Ready
Ready signal
signal to
to Peripheral
Peripheral (this
(this may
may be
be aa hardware
hardware connection).
connection}.

Figure
Figure 11-6.
11-6. An
An Output Handshake
Handshake

11-7
11-7

Peripheral

T IMING
IN G INTERVALS (DELAYS)
(DELAYS)
that we will
ill face throughout
throughout the discussion
discussion of inin­
One problem that
USES OF
pu t/ou
tp u t is the generation
generation of timing intervals
intervals with
ith specific
put/output
TIMING
TIMING
intervals are necessary to debounce
debounce mechanical
mechanical
lengths. Such intervals
INTERVALS
INTERVALS
switches (i.e.,.. to smooth
smooth their
their irregular
irregular transitions).
transitions), to provide
provide
switches
ith specified
specified lengths
lengths and frequencies
frequencies for displays.
displays, and to provide
provide timing
ing for
pulses with
devices that
regularly (e.g.
(e.g., a teletypewriter
teletypewriter that
that transfer
transfer data regularly
that sends or receives one bit
every 9.1 ms).
ms).

We can produce timing intervals
intervals in several
several ways:
ways:
We
1)

2)

3)

METHODS FOR
METHODS
PRODUCING
hardware with
ith one-shots or monostable multivibraultivibra­
In hardware
TIMING
TIMING
tors. These devices produce
produce a single
single pulse of fixed duradura­
INTERVALS___
tion in response to a pulse input.
In a combination of hardware and software
are with
ith a flexx­
ible programmable timer
er such as those that
that are included
included in the 6522
6522 Versatile
Versatile InIn­
Adapter (to be described
described later in this chapter). The 6522
6522 timers can provide
terface Adapter
timing
ing intervals
intervals of various
various lengths
lengths with
ith a variety
variety of starting
starting and ending
ending conditions.
conditions.
In software
are with
ith delay routines. These routines
routines use the processor as a counter.
This use is
stable clock reference, but
but it clearly
Is possible since the processor has a stable
underutilizes the processor. However,
routines require no additional
additional hardhard­
underutilizes
However. delay routines
would otherwise
otherwise be wasted.
ware and often use processor time that would

The choice among these three methods depends on your apap­
CHOOSING
plication. The software
software method is
inexpensive but may overover­
Is inexpensive
A TIMING
TIMING
burden the processor.
METHOD
METHOD
processor. The programmable
programmable timers are relatively
relatively ex­
exinterface and may be able to handle many
pensive but are easy to interface
complex timing
ing tasks.
included in the 6522 Versatile
Versatile Interface
complex
tasks. The timers that are included
Adapter and in the 6530 and 6532 Multifunction
ultifunction Devices are available
available at no additional
additional
Adapter
somewhat more expenexpen­
cost as long as those parts are being used. These parts may be somewhat
sive than
simpler devices, but may be justifiable
justifiable as complete
complete packages.
ith
than simpler
packages. Such parts with
integral timers are used in many board-level
board-level microcomputers,
microcomputers, including
including the KIM.
integral
KIM, SYM,
SYM,
VIM.
AIM-65. The use of one-shots should be avoided whenever
whenever possible.
VIM, and AIM-65.

11
11-8

DELAY ROUTINES
A simple
simple delay routine
routine works as follows:
Step 1 - Load a register
value.
register with
ith a specified
specified value.
Step 2 -• Decrement
Decrement the register.

BASIC
BASIC
SOFTWARE
SOFTWARE
DELAY
DELAY

Step 3 - If the result of Step 2 is
Is not zero,
zero. repeat Step
Step 2.

This routine does nothing except
except use
use time. The amount
amount of time used
used depends
depends upon
upon
of the delay
delay is
is
the execution
execution time of the various
various instructions.
instructions The maximum length of
however. the entire routine
routine can be
be placed inside aa
limited by the size of the register; however,
similar
on.
similar routine
routine that
that uses another
another register.
register, and so on.
on the clock rate at w
which the
the pro­
proBe careful -— the actual time used depends on
cessor is running, the speed of memory accesses, and operating conditions such
such
as temperature,
loading which may affect the
the
temperature, power
power supply voltage, and circuit loading
speed at which
hich the processor executes
executes instructions.

ing example
example uses Index Registers X and Y to
TRANSPARENT
TRANSPARENT
The following
255 ms.
choice of registers is
DELAY
provide delays as long as 255
ms. The choice
DELAY
Is
arbitrary. You may find the use of the Accum
ulator or of
ROUTINE
ROUTINE
arbitrary.
Accumulator
memory locations
locations more convenient.
convenient. Remember,
however, that
memory
Remember. however.
6502 has no explicit
explicit Decrement
Decrement Accum
ulator instruction
instruction. We could produce aa
the 6502
Accumulator
routine that
that does not change
change the contents
contents of any user registers. The sequence
routine
PHP
PHP
PHA
TXA
PHA
TYA
PHA

;SAVE STATUS REGISTER
:SAVE
REGISTER
;SAVE ACCUMULATOR
ACCUMULATOR
;SAVE INDEX REGISTER
REGISTERX
;SAVE
:SAVE INDEX REGISTER
REGISTERY

would save the contents
contents of all the registers
registers initially
initially and the sequence
would

PLA
TAY
PLA
TAX
PLA
PLP

:RESTORE
;RESTORE INDEX REGISTER
REGISTERY
:RESTORE INDEX REGISTER
:RESTORE
REGISTERX
;RESTORE
ACCUMULATOR
;RESTOREACCUMULATOR
;RESTORE
:RESTORE STATUS REGISTER
REGISTER

would restore
restore the registers
registers at the end of the routine. A subroutine that
that does not affect
affect
would
registers or flags is said to be "transparent"
spa rent" to the calling program.
any registers
program. The in­
instruction sequences
sequences that
that save and restore the registers
registers must.
must, of course,
included in
struction
course. be included
time budget.
budget.
the time

11-9
11-9

DELAY PROGRAM
PROGRAM
DELAY
Purpose:
Purpose: The
The program
program provides
provides aa delay
delay of
of 11 ms
ms times
times the
the contents
contents of
of Index
Index Register
Register Y.
V.
F lo w
ch a rt:
Flowchart:
Stan

Count - MSCNT

Count = Count - 1

IY) = IY) -1

I

No

End
The value o f M
SCNT depends
em ory cycle
MSCNT
depends on the
the speed
speed ooff the
the CPU
CPU and
and the
the m
memory
cycle

Source Program:
Program:
DELAY
DELAY
DLY1
DLY1

LDX
LDX
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
RTS
RTS

#MSCNT
#MSCNT
DLY1
DLY1
DELAY

;GET
:GET COUNT
COUNT FOR
FOR 1 MS
MS DELAY
DELAY
COUNT == COUNT
COUNT -- 11
;COUNT
ZERO
;CONTINUE UNTIL
UNTIL COUNT
COUNT == ZERO
DECREMENT NUMBER
;DECREMENT
NUMBER OF
OF REMAINING
REMAINING MS
MS
ZERO
:CONTINUE UNTIL
UNTIL NUMBER
NUMBER OF
OF MS
MS == ZERO

11
-1 0
11-10

Object Program: (starting in location 0030)
Object
Memory Location
Memory
(Hex)
(Hex)

Memory Contents
Memory
(Hex)
(Hex)

0030
0031
0032
0033
0034
0035
0036
0037
0038

A2
MSCNT
MSCNT
CA
DO
DO
FD
FD
88
DO
DO
F8
60

Instruction
Instruction
(Mnemonic)
DELAY
DELAY

LDX
LOX

#MSCNT
#MSCNT

DLY1
DLY1

DEX
DEX
BNE
BNE

DLY1
DLY1

DEY
DEY
BNE
BNE

DELAY
DELAY

RTS
RTS

Time Budget:
Number of Times Executed
Executed

Instruction
Instruction
LDX
LOX
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
RTS
RTS

(Y)
(Y)
(Y) x MSCNT
(Y)
(Y)
(Y) xx MSCNT
MSCNT
(Y)
(Y)
(Y)
(Y)
11

#MSCNT
#MSCNT
DLY1
DLY1
DELAY
DELAY

speed, the
The total
total time used should be (Y) x 1 ms. If the memory is operating
operating at full speed,
instructions require the following
following numbers of clock cycles.
instructions
cycles.
Ignoring Page Boundaries
Ignoring
LDX
#MSCNT
LOX #MSCNT
DEX
DEX or DEY
BNE
BNE
RTS
RTS

22 or
or 3
22
2. 3,
3. or
or 44
2.
66

22
22
22 or 3
66

3

The alternative
alternative times for
for LDX
whether a page
LOX #MSCNT
#MSCNT depend on whether
page boundary is
is
crossed. The alternative
BNE depend on whether
crossed.
alternative times for BNE
whether the branch does not occur
(2). occurs to an address on the same page (3),
(3). or occurs to an address on a different
(2).
different
(4). A page is a set of 256 contiguous
same
page (4).
contiguous memory locations which
which have the same
eight
addresses. We will
eight most significant
significant bits (or page number) in their addresses.
ill assume that the
routine is located so that no page boundaries are crossed,
crossed. and we can use the rightmost
rightmost
ing purposes.
column of the last table for timing
purposes.

Ignoring the Jump-to-Subroutine
(JSR) and Return from Subroutine
(RTS) instructions
Jump-to-Subroutine (JSR)
Subroutine (RTS)
instructions
(which occur only once),
once). the program takes:
takes:
(Y) x (2 + 5 x MSCNT - 11++55)
(Y)
1 --11 clock cycles
BNE instruction
less time during
The -1 's are caused by the fact that the BNE
instruction requires less
during the
iteration when the Counter
Counter has reached zero and no branch occurs.
final iteration
occurs.
So. to make the delay 1 ms,
ms.
So.
5 + 5 x MSCNT = Nc
Ne
number of clock cycles per millisecond. At the standard 1 MHz 6502
1s the number
where Nc
Ne is
clock rate,
rate. Nc
Ne = 1000 so
5 x MSCNT = 995
MSCNT =
= 199 (C7-]g)
(C715) at a 6502 clock rate of 1 MHz

11-11

6502 DELAY
6502
LOOP
LOOP
CONSTANT
CONSTANT

502
PUT/OUTPUT
65
0 2 IN PU T/O
U TPU T CHIPS
chips. These devices
Most
ost 6502
6502 input/output
input/output sections are based on LSI interface chips.
combine latches, buffers, flip-flops, and other logic circuits needed for handshak­
handshaking and other
logic connections,
connections.
other simple interfacing
interfacing techniques. They
They contain many logic
certain
certain sets of which
which can be selected
selected according to the contents of programmable
registers. Thus the designer
designer has the equivalent
equivalent of a Circuit Designer's Casebook
under his or her control. The initialization
apinitialization phase of the program places the ap­
propriate values
invalues in registers
registers to select
select the required logic connections. An in­
put/output
handle many
put/output section
section based on programmable LSI interface chips can handle
different
different applications
applications and changes or corrections can be made in software
are rather
than by rewiring.
rewiring.
We
6502
We will
ill discuss the following
ing LSI interface chips that can be used with
ith the 6502
microprocessor:
microprocessor:
1)

6520 Peripheral Interface
Interface Adapter. This device contains
contains two 8-bitit I/O
The 6520
1/0 ports
four individual
individual control
control lines:
lines; it is exactly
exactly the same as the 6820 device used
and four
used
with
ith 6800-based
6800-based microcomputers.4
microcomputers.4

o 8 -b
it I/O
2) The
The 6522
6522 Versatile
Versatile Interface
Interface Adapter.
Adapter. This
This device
device contains
contains tw
two
8-b1t
1/0ports,
ports.
four individual
lines. twoo 16-bit
individual control
control lines,
16-bit counter/timers.
counter/timers, and an 8 -b1t
it shift register.

em ory or
ultifunction (Support)
3) The
The 6530
6530 Peripheral
Peripheral Interface/M
Interface/Memory
or M
Multifunction
(Support) Device.
Device.
device contains
contains twoo 8-bit
-b it I/O
-b it counter/tim
ith a prescaler.
This device
1/0 ports,
ports. an 8-bit
counter/timerer with
prescaler.
1024 bytes of ROM.
ROM. and 64 bytes of RAM.
RAM.
em ory or
ultifunction (Support)
4) The
The 6532
6532 Peripheral
Peripheral Interface/M
Interface/Memory
or M
Multifunction
(Support) Device.
Device.
device contains
contains twoo 8-bit
-b it I/O
8-bit counter/tim
ith a prescaler,
This device
1/0 ports,
ports. an 8-bit
counter/timerer with
prescaler.
bytes of RAM.
and 128 bytes
ing acronyms
acronyms are often used in describing
describing these devices: the 6520 PIA.
The follow
following
PIA. the
the
6522 VIA.
VIA, and the 6530
6530 or 6532 RIOT
combination).
J/Q.and IiTimer
mer combination)
6522
RIOT (for ROM
£lOM or RAM,
RAM. J/0,
Our 1/0
I/O examples
examples later in this chapter
chapter will
ill all use the 6522 Versatile
Versatile Interface
Interface Adapter.
6520 device
device can be found in 6800 Assembly
Assembly Language ProExamples of the use of the 6520
Program
m ing;5 those examples
examples can easily be adapted to the 6502 microprocessor
microprocessor
gramming:5
(remember the comparisons
comparisons of the instruction
instruction sets in
in Tables 3-6 and 3-7)
3-7).
{remember

11-12

THE 6 520
2 0 PERIPHERAL
PERIPHERAL INTERFACE
INTERFACE ADAPTER
diagram of a PIA. The device contains two
o nearly identical
identical 8Figure 11
11-7 is the block diagram
bit ports —
hich is usually
usually an input
input port.
port, and B,
hich is usually
usually an output
output port.
-A. A. which
B. which
Each port contains:

register that
that holds either
either input or
,• A Data or Peripheral register
output data. This register
register is latched
latched when
when used for output
output
output
but unlatched
unlatched when
but
when used for input.
Direction register. The bits in this register
register deterdeter­
• A Data Direction
hether the corresponding
corresponding data register
register bits (and
mine whether
(0) or outputs
pins) are inputs
inputs (0)
outputs (1).).

PIA
REGISTERS
AND CONTROL
LINES

register that
that holds
,• A Control register
holds the status signals required for handshaking, and
other bits that
that select
select logic connections within
ith in the PIA.
other
that are configured by the control registers. These lines can
• Tw
Twoo control lines that
be used for the handshaking
handshaking signals shown
shown in Figures 11
11-5 and 11-6.
The meanings
meanings of the bits in the Data Direction
Direction and Control
Control registers are related to the
underlying hardware
hardware and are entirely
entirely arbitrary
arbitrary as far as the assembly language
language propro­
underlying
grammer is concerned.
concerned. You must either
either memorize them or look them up in the apap­
grammer
propriate tables (Tables
through 11-6)
11-6).
propriate
(Tables 11-2 through

PIA
Each PIA occupies four memory addresses. The RS
RS (register
ADDRESSES
select) lines choose one of the four registers,
described in Table
registers. as described
11-1. Since there are six registers (two peripheral.
peripheral, two data direcdirec­
tion,
further bit is needed for addressing. Bit 2 of each
tion. and two control) in each PIA,
PIA. one further
control register
register determines
determines whether
whether the other address on that side refers to the Data
control
Direction register
register (0)
register (1).). This sharing
sharing of an external
external address
Direction
(0) or to the Peripheral register
means that:
1)
1)

A program
program must change
change the bit in the Control
Control register
register in order to use the register
that
that is not currently
currently being addressed.
addressed.

2)

The programmer
programmer must
must know the contents
contents of the Control
Control register
register in order to know
which register is being addressed. RESET
Control register
register and thus adad­
which
RESET clears the Control
dresses the Data Direction
Direction register.
Addressing 6520
6520 PIA Internal
Internal Registers
Table 11-1. Addressing
Control Register Bit

Address Lines
Lines

Register S ele ct
RS1
RS1

RSO
RSO

CRA-2

CRB-2

0

0

1

X

P e r ipheral R e gister A

0

0

0

X

D ata D ir e
c t io n R e gisterr A
ection

0

1

X

X

C o ntrol
tr o l R e gisterr A

1

0

X

1

P e r ipherall R e gister B

1

0
0

X

0

D ata D ir e c t io n
g is te B
ct1on,Reg1ster

1

1

X

X

C o ntrol
t r o l R e gisterr B

=

X = E ither 0
O or 1

1 1-13
13

\

iROA-1-----------------------~
DO -

Control

Interrupt
Interrupt
Status
Status

D
01 -

Register A
(CAA)
(CRA)

Control
Control A

CAl
-CA1
►CA2

D2
02 D3
03 -

Data
Data Bus
Bus

D4 04

Buffers
(DBB)
(DBBI

D5 05

Data
Direction
DlrectlOn

Register A
(DORA)
(DDRA)

c

Output E
Output
Bus

D6 06

21

D7 07
Output
Output

H

x>

PAO
* PAO

Register A
(ORA)

* PA1

PA2
►PA2

Bus Input
Register
Register

Penpheral
Peripheral

(BIR)
(BIR)

Interface
A

►PA3
►PA4

PAS
►PA5
PAS
►PA6

PA7
►PA7

cso
cs,

Output
Output

►PBO
PBO

Register 8
B

(ORB)
(ORB)

►PB1
PB1

CS2

PB2
►PB2
Chip

RSO
RSl

R/W

Select

Penpheral
Peripheral

a"d

Interface

R/W

B
B

PB3
►PB3
►PB4
P84

Control
►PB5
PBS

Enable

-PB6
PBS

Reset

►PB7
PB7

21

Input
Input EBus

c>

Data
Data
Direction
Direction

Control
Control

Register
Register B
8

Register
Register B
8

(DDRB)
(DDRB)

(CAB)
(CRB)

Interrupt
Interrupt

CB1
■ CB1

Status
Status
IRQB
IROB ◄...,_---------------------1

Control
Control B
8

Figure
Figure 11-7.
11-7. Block
Block Diagram
Diagram of
of the
the 6520
6520 Peripheral Interface
Interface Adapter
Adapter

11-14
11-

CB2
* CB2

PIA CONTROL REGISTER
REGISTER
PIA
CONTROL
REGISTER
BITS

Table 11-2 shows the
organization of the
the organization
the PIA Control registers. We
We
may describe the general purpose of each bit as
as follows:
follows:
Bit 7:
transitions on control
control line 1 and cleared by
7: status bit set by transitions
reading the Peripheral (Data)
(Data) register
Bit 6: same
same as
as bit
bit 77 except
except set
set by
by transitions
transitions on
on control
control line
line 22
Bit 5: determines
determines w
hether control
control line
line 22 isis an
an input
input (0)
(0) or
or output
output (1)
(1)
whether

Bit 4: Control
Control line
line 22 input:
input: determines
determines whether
whether bit
bit 66 isis set
set by
by high-to-low
high-to-low transitions
transitions
(0)
-to-high transitions
transitions (1)
control line 2
(0) or low-to-high
(1) on control
Control line 2 output:
output: determines
determines whether
whether control
control line 2 is
Control
Is a pulse (0)
(0) or a level
(1)
(1
Bit 3: Control
Control line
line 22 input:
input: ifif 1,
1. enables
enables interrupt
interrupt output
output from
from bit
bit 66
Control line 2 output:
output: determines
determines ending condition
handshake
Control
cond1t1on for pulse (0
(0 == handshake
acknowledgement lasting until
until next transition
transition on control
control line 1,. 1 == brief strobe
acknowledgement
lasting one clock cycle) or value of level
Bit 2: selects Data Direction
Direction register
register (0)
register (1)
(0) or Data register
(1)
determines whether
whether bit 7 is set by high-to-low
high-to-low transitions
transitions (0)
low-to-high trantran­
Bit 1:
1: determines
(0) or low-to-high
sitions
(1) on control
sitions (1)
control line 1
Bit 0: if
interrupt output
output from bit 7 of Control
Control register.
1f 1,
1, enables interrupt
Tables 11
through 11
describe the bits in more detail. Since Eis
is normally
normally tied to the
11-3 through
11-6 describe
02
clock, you can interpret
interpret "E" pulse as "clock
"clock pulse."
<1>2
Organization of the PIA Control
Control Registers
Table 11-2. Organization
7

6

IR Q
IAOAl1

IR Q
IAOA2

7

6

IR Q
B1
IAOBl

IR Q
B2
IA0B2

5

I 4 I 3
4

3

CAA
RA

DD
R
DDAA

CA2 C o ntrol
tr o l

5

I

4

I

CRB
CAB
CB2 C o n
tr o l
ontrol

11
-15
1-15

2

Acc
Access
3

2
DD
R
DDAB
Acc
Access

1
1

I 0
0

CA11 C o ntrol
tr o l

1
1

I 0
0

CBl1 C o n
tr o l
ntrol

Control of 6520
6520 PIA Interrupt
Interrupt Inputs
Inputs CA11 and CB11
Table 11-3. Control
C RA-1
-1

C RA-0

In te
r r u p t I nput
put
errupt

In te
r r u p t F lag
terrupt

(C RB-1)
-1 )

(C RB-01
-0)

CAl1 (CBl)
1)

C RA-7 (C RB-71
-7 )

0

0

i A ctive
tiv e

1

Set high
h on

1of CA11

[

(CBl)
(C
1)
tiv e
1 A ctive

1

0
0

[

I

| A ctive
tiv e

0
0

1

Set h igh on 1 of CAT1

I

Set h igh on | of CA11
(CBll
1)

I

1

1

\

f A ctive
tiv e

Request
R eq
!ROA
(!ROB)
IR
Q
(IRQ
B)
D is a
b le d —
IRQ re-­
isabled
-!RO
m ains h igh

(CBl)
(C
1)

1

MPU I n t e
rru p t
terrupt

f

Set h igh on J of CA11
(CBll
B1)

G o e s lo w when
h e n th e
interrupt
t e r r u p t fla g bit
it C R A -7
(C RB-7I
-7 ) g oes h igh

D is abled
le d -— IRO
Q re-­
m ains h igh

G oes low w hen
n the
in t e r
r u p t flag bit C RA-7
Interrup1
(C R
-7 ) g oes h ig
h
ICRB-7I
19h

N otes:

j

1
1

1.

| in d ic
a te s p o s1tIve
it iv e t r a n s
itio n ( low to h igh)
icates
nsItIon

2.

1 in d ic
a t e s n e gative
a tiv e t r a n s
it io n ( high to lo
w)
icates
sItIon
Jowl

3.

T he I n t errupt
r r u p t flag bit C RA-7 is
d of the A D ata R e gister, a nd
Is c le ared by an M PU R ead
C RB-7 is
d of t h
Is c le ared by an M PU R ead
the B D ata R e gister

]
4

If C RA-0 (C R
B -0 ) is low w hen
n an in t e
r r u p t o c curs ( In te
ht
R~s
errupt
Onterrupt d is abled) a nd is
Is later b r ought
h igh., IR
Q
(IR Q
B ) o c curs a fter C RA-0 (C R
B -0 ) is
t e n to a " o ne"
e”
!ROA
(!ROB)
(CRB-0I
Is w r it
itten

Table 11-4. Control
Control of 6520 PIA Interrupt
Interrupt Inputs
Inputs CA2 and CB2
CB2
C RA-5

CR
RA-4

CR
RA-3

B -4) (C R
B -3 )
(C R B
-5) (C R
RB-4I
(CRB-3I
(CRB-51

0

0

I

0
0

I n t errupt
r u p t I n put

I n t errupt
r r u p t F lag

CA2 (C B
2)
(CB2)

C RA-6 (C R
B -6 )
(CRB-6)

1A ctivee

Set h igh on j of C A2

[

1

(C
B2)
(CB21

00

00

11

tiv e
I Ac
Active

[

l

Set h igh on | of C A2
(C
B2)
(CB21

MPU I n t e
Interrupt
MP
upt
R e quest
IR Q
A (IRQ
B)
!ROA
(IROBI
D is abled — IRQ
IRO
r e mains h igh

Go
e s low w hen th
oes
the
in t e rrupt
r u p t flag bit C RA-6
(C R B
-6 ) g o
e s h igh
(CRB-61
goes

11

00

00

1

f Ac
Activee

Set h ig
n |J oof C A
high on
CA2
(C B
2)
(CB2I

11

00

11

1

| A
c tiv e
Active

I

S
e t h ig
n f oof C A
Set
high oon
CA2
(C
B2)
(CB2I

D is abled — IRQ
IRO
re mains h ig
high

Go
e s lo
e
oes
low w h
when th
the
in t e r
r u p t fla
interrupt
flag bit C R
RA-6
(C R
B -6 ) g o
(CRB-6I
goes h igh

N otes:
1.
1

jI in d ic
a te s p o s
itio n ( lo
1nd1cates
positivee t r a n s
transition
(low t o
to h ig
high)

2.
2

1in d ic
itio n ( h
w)
indicatess n e g a
negative t r a n s
trans1tIon
(high t o
to lo
low)

3.
3

Th
e In te r
p t fla
y aan
n MP
U Re
a d oof th
ta R e g
d CR
B -6
The
Interrupt
flag bbit C R
CRA-6 isIs c le a
cleared bby
MPU
Read
the AA D a
Data
Register a n
and
CRB-6

44

IfIf C R
B -3 ) is
n in t e r
p t occ
p t d is a b
CRA-3 (C R
(CRB-3I
Is lo
low w h
when aan
interrupt
occurs ( I n te
!Interrupt
disabled) a n
and isIs la
later b r o u
brought

is
n MP
U Re
ad ooff t h
ta R e g
is te r.
Is c le a
cleared bby aan
MPU
Read
the BB D a
Data
Register
h ig
h , IR Q
A (IR Q
B) o c c
A
(C R
B -3 ) is
e n to
high.
IROA
(IROB)
occurs a ft
after C R
CRA-3
(CRB-3I
is w r it
written
to aa " o n
"one""

1111-16

\

Table 11
11-5. Control
Control of 6520
6520 PIA CB2 Output
utput Line
CB2
C RB-5

C RB-4

CRB-3
CR
C le ared

1

0

0

Set

s,t,ve
s,t,on
L ow on the p o s
it iv e t r a n s
itio n of

H,gh
whenn th
the in t e
interrupt
flag bbit
H
ig w h
r r u p t fla

t he f irstt E p ulse f o llo
w in g
llowing

C RB-7 is
tiv e t r ans,s i­
,s set by an a ctive

MPU W r
Write
MP
it e

"B""
"B

an

D ata R e gister

t io
,on of the CB11 s ig
,gnal

o p e ration
tio n

1

0

1

L ow on the p o s,t,ve
it iv t r a n s
itio n of
s,t,on

H,gh
ig on the p o s
it iv e e dge of the
sItIve

the f ir
firstt E
E pu
pulse a ft
afterr aan M P
MPU
th

f irstt " E"" p ulse f o l lo
w in g an " E""
lowing

··s··

1

1

0
0

Write
W
r it e “ B " D ata R e gisterr o p eraa­

pulse w h
which
occurred
while
the
pu
ic h o c c u
rre d w h
ile th

tio
tIon.

part w
was d e s e
deselected
pa
le c te d

L ow w hen C RB-3 g oes low as a

A lways
a y s low as long as C RB-3 is
,s

rite
r e sult
lt of an M PU W r
it e in C on·­

low

trol R e g
Register " B
"B''
tr

Write
r it e

Will
i l go h igh on an M PU
in

C o ntrol
r o l R e gisterr " B""

t hat c h a nges C RB-3 to " one"
e"

1

1

1
1

A lways
a y s h igh as long as C RB-3 is
Is

High w hen C RB-3 g oes h igh as

h igh. Will
i l be c le ared w hen
n an

a r e sultlt of an M PU Write
r it e into

MPU W
Write
Control
Registerr " B
"B""
MP
r it e C o n
tro l R e g

C o ntrol
tr o l R e gister " B""

r e sults
lts

,n
in

c le aring
in g

C RB-3

to

"" z e
zero "

Table 11
11-6. Control
Control of 6520
6520 PIA CA2 Output
utput Line
CA2
C RA-5

C RA-4

C RA-3
Set

C le ared
1

11

1

0
0

0

1
1

0

1

0

High w h
whenn t h
the in t e
interrupt
flag bbit
H
r r u p t fla

L o w o n n e gative
a tiv e t r ans,t,on
n s itio n o f E
a ft err a n M P U R e ad
d "A"
A " D a ta

CRA-7 is
,s sset bby aan a c
act,ve
trans,CR
tiv e t r a
s i­

o p e ration.
tio

t,on oof th
the C
CA11 s ig
signal
t io

L ow on n e gative
tiv e t r a n s
itio n of E
nsItIon

High oon th
the n e g
negative
H
tiv e

afterr aan M P
MPU R e
Read
"A""
a ft
d "A

the f ir
firstt " E
"E"" p u
pulse w h
which
occurs
th
ic h o c c

Data
Da

edge oof
ed

oper
a tio n
ration

d u ring
in g a d e select
ct

L ow w hen
n C RA-3 g oes low as a

Always
low as
as lo
long aas C R
CRA-3 is
,s
A lw
a y s lo

r e sultlt of an M PU Write
it e to C on·­

low

Will
i l go h igh on an M PU

t rol R e gister "A""

Write
W r
it e

Control
Registerr " A
"A""
tto C o n
ro l R e g

that c h a n
changes C R
CRA-3 to
to " o
"one"
th
ne"
1

1

1

A lways
a y s h igh as long as C RA-3 is
,s

High w hen
n C RA-3 g oes h igh as

h igh. Will
i l be c le ared on an M PU

a r e sult of an M PU Write
it e to C on·­

Write
r it e

trol R e g
Register " A
"A""
tro

to C o ntrol
t r o l R e gisterr " A""

t hatt c lears C RA-3 to a " z e
ro "
ero"

1 1-17
17

CONFIGURING THE PIA
The program must select
select the logic connections in the PIA
before using
using it. This selection (or configuration)
configuration) is usually
part of the startup routine. The steps in the configuration
configuration are:

STEPS
STEPS IN
IN
CONFIGURING
CONFIGURING
AA PIA
PIA________

1)
1)

Address the Data Direction
Direction register
register by clearing
clearing bit 2 of the
Address
Control register. Since the Reset signal
signal clears all the internal
internal registers.
registers, this step is
Control
unnecessary in the overall
overall startup
startup routine.
unnecessary

2)

directions of the I/O
Direction register.
Establish the directions
1/0 pins by loading the Data Direction

3)

connections in the PIA by loading
loading the Control
Control register. Set
Select the required logic connections
bit 2 of the Control
Control register
register so as to address the Data register.

performed as follows:
follows:
Step 1 can be performed
LDA
LOA
STA

#00
PIACR
PIACR

LDA
LOA
AND
STA

PIACR
PIACR
11111011
#% 1
1111011
PIACR
PIACR

;CLEAR
:CLEAR PIA CONTROL
CONTROL REGISTER
REGISTER

or
;SELECT
:SELECT DATA DIRECTION
DIRECTION REGISTER
REGISTER

program has performed
performed Step 1.
ply a matter
atter of clearing
clearing each inin­
Once the program
1, Step 2 is simply
put bit position
position and setting
setting each output
output bit position
position in the Data Direction
Direction Register.
put
Register.
Some simple
simple examples
examples are:
1)
1)

LDA
LOA
STA

#00
PIADDR
PIADDR

:ALL LINES
LINES INPUTS
INPUTS

2)
2)

LDA
LOA
STA

#$FF
#$FF
PIADDR

;ALL LINES
LINES OUTPUTS
OUTPUTS

3)

LDA
LOA
STA

#$F0
#$FO
PIADDR

;MAKE LINES
LINES 4-7 OUTPUTS.
OUTPUTS, 0-3 INPUTS
INPUTS

Step 3 is clearly
clearly the difficult
ifficu lt part of the configuration.
configuration, since it involves
involves selecting
selecting the
connections in the PIA. Some points
points to remember
remember are:
logic connections
1)
1) Bits
Bits 66 and
and 77 of
of the
the Control
Control register
register are
are set
set by
by transitions
transitions on
on the
the control
control lines
lines and
and are
are
cannot change
change these bits by writing
riting data
cleared by reading the Data register. You cannot
into the Control
--Control register.
2)

Bit
Bit 22 of
of the
the Control
Control register
register must
must be
be set
set to
to address
address the
the Data
Data register.
register.

3)

Bit
high-to-low transi­
Bit 11 determines
determines w
which pulse
pulse edge
edge w
will set
set bit
bit 7.
7. Bit
Bit 11 is
is 0O for
for aa high-to-low
transition; bit 1 is 1 for a low-to-high
low-to-high transition.
transition.
tion:

.4)

Bit
interrupt enable
Bit 0O is
is the
the interrupt
enable for
for control
control line
line 1.
1. Remember
Remember that
that itit must
must be
be set
set to
to ena­
enable interrupts,
interrupts, unlike
unlike the 6502
6502 interrupt
interrupt bit. which
hich must
must be cleared to enable interinter­
rupts. Chapter
Chapter 12 describes
describes interrupts
interrupts in more detail.

5)

Bit
Bit 55 must
must be
be set
set ifif control
control line
line 22 is
is to
to be
be output.
output. Bits
Bits 33 and
and 44 then
then determine
determine how
how
control line 2 works. Remember that
that sides A and B differ.
differ, since side A can only propro­
control
hile side B can only produce
produce a write
rite strobe. Once the strobe
duce a read strobe while
option has been selected, the strobes autom
atically follow
follow each reading of Data
option
automatically
riting of Data Register B.
configure each side of each PIA
Register A or writing
B. You must configure
in the startup
startup program.

11-18
11-18

EXAMPLES OF PIA CONFIGURATION
1)
1)

simple input
input port
port with
ith no control
control lines (as needed for
for a
A simple
set of switches):
switches):
LDA
LOA
STA
STA
LDA
LOA
STA

#00
PIACR
PIACR
PIADDR
PIADDR
#%00000100
00000100
PIACR
PIACR

PIA
CONFIGURATION
CONFIGURATION
EXAMPLES
EXAMPLES

;CLEAR
;CLEAR OUT
OUT CONTROL
CONTROL REGISTER
REGISTER
;MAKE
:MAKE ALL LINES
LINES INPUTS
INPUTS
;SELECT
:SELECT DATA REGISTER
REGISTER

Control register
register must be set to address the Data register. The same se­
Bit 2 of the Control
sequence can be used if a high-to-low
high-to-TOw transition
transition (negative
(negative transition)
transition) on control
control line 1
quence
indicates Data Ready or Peripheral
Peripheral Ready.
indicates
Ready.
2)

A simple
simple output
output port with
ith no control
control lines (as
dis­
(as needed for a set of single LED
LED displays):
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA

3)

#00
PIACR
PIACR
#$FF
PIADDR
#%00000100
00000100
PIACR
PIACR

;CLEAR
:CLEAR OUT CONTROL
CONTROL REGISTER
REGISTER
;MAKE ALL LINES
LINES OUTPUTS
OUTPUTS
;SELECT
:SELECT DATA REGISTER
REGISTER

input port with
ith a control
control input
input that
that indicates
indicates DATA
DATA READY
ith a low-to-high
low-to-high
An input
READY with
transition (positive
(positive transition):
transition):
transition
LDA
##0
0 ;CLEAR OUT CONTROL
REGISTER
LOA
:CLEAR OUT
CONTROL REGISTER
STA
PIACR
PIACR
STA
PIADDR
;MAKE
:MAKE ALL
ALL LINES
LINESINPUTS
INPUTS
PIADDR
LDA
#%
00000110
;MAKE
LOW-TO-HIGH
:MAKE DATA
DATA READY
READYACTIVE
ACTIVE LOW-TO-HIGH
LOA
#%00000110
STA
PIACR
PIACR

The DATA READY
AVAILABLE line is tied to control
control line CA11 or CB11 Bit 1 of
READY or DATA AVAILABLE
Control register is set so as to recognize low-to-high
low-to-high transitions
transitions on control
control line 1.
the Control
1.
This configuration
configuration is suitable
suitable for most encoded
encoded keyboards.
4)

output port that
that produces
produces a brief strobe to indicate
indicate DATA
DATA READY
An output
READY or OUTPUT
OUTPUT
READY
could be used for multiplexing
ultiplexing displays
displays or for providing
providing a DATA
READY (this could
AVAILABLE signal
signal to a printer):
AVAILABLE
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA

#00
PIACR
PIACR
#$FF
PIADDR
PIADDR
#%00101100
00101100
PIACR
PIACR

;CLEAR
:CLEAR OUT CONTROL
CONTROL REGISTER
REGISTER
;MAKE
:MAKE ALL LINES
LINES OUTPUTS
OUTPUTS
;MAKE
:MAKE CONTROL
CONTROL LINE
LINE 2 A BRIEF
BRIEF STROBE
STROBE

control line 2 an output.
output, bit 4 = 0 to make it a pulse,
pulse. and bit 3 = 1 to
Bit 5 = 1 to make control
make it a brief
brief active-low
active-low strobe (one clock period in duration).
duration). The strobe will
ill autom
at­
automatfollow each instruction
instruction that
that writes
writes data into the B side of the PIA; for example.
example, the
ically follow
instruction
instruction
STA

PIADRB
PIADRB

will
ill both transfer
transfer data and cause a strobe. However,
ill produce
produce a strobe
However. the A side will
after a read operation.
operation. The sequence
only after
STA
LDA
LOA

PIADRA
PIADRA
PIADRA
PIADRA

;WRITE
;WRITE DATA
DATA
;PRODUCE
:PRODUCEAN
AN OUTPUT
OUTPUTSTROBE
STROBE

will
ill both transfer
transfer data and cause a strobe. The LDA
instruction is a "dum
m y read”
LOA instruction
"dummy
read";; it
has no effect
effect other than to cause the strobe (and waste some time). Other instructions
instructions
besides LDA
you should try to name some of them.
LOA could also be used —
-you

11-19
11-19

5)

An input
used to tell
tell
input port
port with
ith a handshake Input
Input Acknowledge
Acknowledge strobe that can be used
a peripheral
(and the computer
peripheral that
that the previous
previous data has been accepted (and
puter is ready
for more):
LOA
LDA
STA
STA
LOA
LDA

##0
0
PIACR
PIACR
PIADDR
PIADDR
#%00100100
#%
00100100

STA

PIACR
PIACR

;CLEAROUT
OUT CONTROL
CONTROLREGISTER
REGISTER
;CLEAR
;MAKE ALL
ALL LINES
LINESINPUTS
INPUTS
;MAKE
;CONTROLLINE
LINE22== HANDSHAKE
HANDSHAKE
;CONTROL
ACKNOWLEDGE
: ACKNOWLEDGE

Bit 5 = 1 to make control
pulse. and bit 3 = 0 to
control line 2 an output.
output, bit 4 = 0 to make it a pulse,
make it an active-low
acknowledgment
active-low acknowledgm
ent that remains low until
until the next active transition
transition
on control
1. The acknowledgm
acknowledgment
read operation on the
control line 1.
ent will
ill automatically
atically follow
follow a read
A side of the PIA:
PIA; for example.
example, the instruction
instruction
LDA
LOA

PIADRA
PIADRA

will
ill both read data and cause the acknowledgment
acknowledgment. However,
However. the B side will produce
an acknowledgm
acknowledgment
ent only after
after a write
write operation. The sequence
LDA
LOA
STA

PIADRB
PIADRB
PIADRB
PIADRB

;READ DATA
DATA
:READ
;PRODUCE
:PRODUCEACKNOWLEDGMENT
ACKNOWLEDGMENT

"dummy
will
ill both read data and produce
produce an acknowledgment
acknowledgment. The STA instruction
instruction is a "dum
my
acknowledgment
(and waste some
some time).
time).
write";
rite "; it has no other
other effect
effect than to cause the acknowledgm
ent (and
that the order of the sequence is reversed from the previous example. This con­
Note that
configuration
CRT terminals
handshake.
figuration is suitable
suitable for many CRT
terminals that require a complete
complete handshake.
6)

An output
level
output port
port with
ith a latched zero control
control bit (latched individual
individual output
output or level
output). Such an output
output can be used to turn the peripheral
peripheral on or off or to control its
output).
its
mode of operation.
LDA
##0
0
;CLEAR
LOA
;CLEAROUT
OUT CONTROL
CONTROLREGISTER
REGISTER
PIACR
STA
PIACR
LDA
#$FF
;MAKE
LOA
#$FF
;MAKEALL
ALL LINES
LINESOUTPUTS
OUTPUTS
PIADDR
STA
PIADDR
LDA
#% 00
1 101 0
;CONTROL
= LATCHED
LATCHED ZERO
ZERO LEVEL
LEVEL
LOA
%00110100
;CONTROL LINE
LINE 2 =
PIACR
STA
PIACR

control line 2 an output.
output, bit 4 = 1 to make it a level or latched bit,
bit. and
and
Bit 5 = 1 to make control
bit 3 = 0 to make the level zero.
output is not affected by operations on the Data
bit
zero. This output
Data
register; its value can be changed
changed by changing
changing the value of bit 3 of the PIA
register:
PIA Control
register, i.e..
register.
LDA
LOA
ORA
STA

PIACR
PIACR
#%00001000
00001000
PIACR
PIACR

;MAKE LEVEL
LEVEL ONE
ONE

LDA
LOA
AND
STA

PIACR
PIACR
#% 1
1110111
%11110111
PIACR
PIACR

;MAKE LEVEL
LEVEL ZERO
ZERO

configuration to produce
produce active-high
active-high strobes or to provide pulses with
You can use this configuration
software-controlled lengths
lengths
software-controlled

11-20
11-20

USING THE PIA TO TRANSFER DATA
Once the PIA has been configured, you may use its data
registers like any other
other memory locations. The simplest
plest in·
in­
transfer are:
structions for data transfer

PIA INPUT/
INPUT/
OUTPUT
OUTPUT

Load Accumulator,
Accumulator, which
which transfers
transfers eight
eight bits of data from the specified
specified input
input pins to
Accumulator.
the Accum
ulator, and
Store Accumulator,
Accumulator
Accumulator, which
hich transfers eight
eight bits of data from the Accum
ulator to the
specified
pins.
specified output
output pins.
You must be careful
careful in situations
situations where
where input
input and output
output ports do not behave like
memory locations.
locations. For example.
example, it often
often makes no sense to write
write data into input
input ports or
read data from output
output ports. Be particularly
particularly careful
careful if the input
input port is not latched
latched or if
Is not buffered.
the output
output port is

Other instructions that
that transfer
transfer data to or from memory can also serve as I/O
in­
Other
1/0 in·
structions. Typical examples
examples are:
Bit Test, which
hich sets the Zero flag as if the values of a set of input
input pins had been
logically
Accumulator.
logically ANDed
ANDed with
ith the contents
contents of the Accum
ulator. The Sign (Negative) flag is set to
the value of bit 7 of the input
input port and the Overflow
Overflow flag is set to the value of bit 6 of the
input port. This instruction provides a simple way
way to test
st the PIA status flags; that
input
is.
instruction
is. the instruction
BIT

PIACR
PIACR

1)
sets the Sign flag to the value of Control
Control register
register bit 7 (the status
status latch for control
control line 1)
and the Overflow
Overflow flag to the value of Control
Control register
register bit 6 (the status
status latch for control
control
line 2).
2).

Compare, which
hich sets the flags as if the values of a set of input
input pins had been
subtracted
subtracted from the contents
contents of the Accumulator.
Accumulator.

1/0 ports. Be particularly
Here also you must be aware of the physical
physical limitations
itations of the I/O
particularly
careful of instructions
instructions like shifts. Increment.
Increment, and Decrement.
Decrement, which
which involve
involve both read
careful
and write
rite cycles.
We cannot overemphasize
overemphasize the importance of careful documentation.
documentation. Often.
Often, comcom­
We
instructions with
ith no obvious
obvious functions
functions. You must
plex I/O
1/0 transfers can be concealed in instructions
describe
describe the purposes of such instructions
instructions carefully.
carefully. For example.
example, one could easily be
tempted to remove the dummy
m y read and write
rite operations
operations mentioned
mentioned earlier since they
tempted
do not appear to accomplish
accomplish anything.
anything.
Bit 7 of the PIA Control register
register often serves as a status bit,
such as Data Ready or Peripheral
Ready. You can check its value
Peripheral Ready.
following
with
ith either
either of the follow
ing sequences:
LDA
BMI

PIACR
PIACR
DEVRDY
DEVRDY

;ISREADY
READYFLAG
FLAG 1?
1?
;IS
;YES.
:YES. DEVICE
DEVICE READY
READY

BIT
BMI

PIACR
PIACR
DEVRDY
DEVRDY

:ISREADY
READYFLAG
FLAG 1?
17
;IS
:YES. DEVICE
DEVICE READY
READY
;YES.

PIA STATUS
STATUS
BITS

Note that
that you should not use the shift
shift instructions,
instructions, since they will
ill change
change the contents
contents
following
of the Control
Control register
register (why?). The follow
ing program
program will
ill waitit for the Ready flag to go
high:

WAITR

BIT
BPL
BPL

PIACR
PIACR
WAITR
WAITR

:ISREADY
READYFLAG
FLAG 11?
;IS
?
:NO.WAIT
WAIT
;NO,

How would
would you change
change these programs
programs so that they examine
examine bit 6 instead of bit 7?

11-21

The
read will
The only way
ay to
to clear
clear bit
bit 7 (or bit 6) is to read the Data register. A dummy
dumm y read
be necessary ifif a read operation
set.
operation is not normally
normally part of the response to the bit being set.
IfIf the port
port is used for output.
output, the sequence
STA
LOA
LDA

PIADR
PIADR
PIADR
PIADR

;SEND DATA
DATA
;SEND
;CLEAR READ
READ FLAG
FLAG
;CLEAR

10b. Note that
dummyy read is
1snecessary on either
PIA.
will
ill do the job.
that here the dumm
either side of the PIA.
The Bit
ithout
Bit Test instruction
instruction can also clear the strobe w ith
o u t changing
changing anything
anything except the
flags. Be particularly
CPU is not ready for input
has
particularly careful
careful in cases where the CPU
input data or has
no output
output data to send.

11-22
11-22

THE 6 522
2 2 VERSATILE INTERFACE ADAPTER
ADAPTER (VIA)
The 6522
6522 Versatile
Versatile Interface
Interface Adapter
Adapter is an enhanced version of the 6520
6520 Periph­
Periph7,8
eral Interface Adapter.6,
Adapter.®-?'®
6522 VIA
VIA contains the following (see
block diagram
diagram in
(see the block
The 6522
Figure 11-8):

6522 VIA
6522
FUNCTIONS

1) Two
Each pin
pin can
can be
be individually
individually
Two 8-b
8-bit I/O
1/0 ports
ports (A
(A and
and B).
B).Each
selected to be either
either an input
input or an output.
output.
selected
2) Four
ith each
Fourstatus
status and
and control
control lines
lines (two
(two associated
associated wwith
each port).
port).
3) Two
ers wwhich
hich can
Two 16-bit
16-bit counter/tim
counter/timers
can be
beused
used toto generate
generate or
orcount
count pulses.
pulses. These
These
timers can produce
produce single
single pulses or a continuous
continuous series of pulses.
timers
pulses.
4) An
it SShift
hift register
An 8-b
8-bit
register which
which can
can convert
convert data
data between
between serial
serial and
and parallel
parallel forms.
forms.
5) Interrupt
Interrupt logic
logic(to
(tobe
bedescribed
described ininChapter
Chapter 12)
12)so
sothat
that I/O
1/0can
can proceed
proceed on
onan
aninter­
interrupt-driven basis.
rupt-driven
basis.
Versatile Interface
Interface Adapter
Adapter provides
provides the functions
functions of the PIA plus two 16-bit
16-bit
Thus the Versatile
counter/tim
ers and an 8-bit
-b it Shift
Shift register. We will
ill describe
describe the use of the
counter/timers
counter/tim
ers later in this chapter.
chapter. The Shift
Shift register
register provides
provides a simple
simple serial I/O
1/0
counter/timers
capability that
that is only occasionally
occasionally useful:
useful; we will
ill not discuss
discuss it any further.
further.
capability

Each VIA occupies sixteen
sixteen memory addresses.
addresses. The RS
RS (register
select) lines choose the various
various internal
internal registers, as described
described in
ay that
that a VIA operates is determined
determined by the
Table 11-7 The way

VIA
ADDRESSES

contents of four registers.
1)

Data Direction Register A (DDRA)
determines whether
whether the pins on Port A are inin­
(DORA) determines
puts (Os)
(Os) or outputs
(1s).
sl.
outputs (1

2) Data
Data Direction
Direction Register
Register BB(DDRB)
(DDRB)determines
determines whether
whether the
the
pins on Port B are inputs
inputs (Os)
(Os) or outputs
outputs (1s).
s).

VIA
REGISTERS
REGISTERS
AND CONTROL
LINES

The Peripheral
Peripheral Control
Control register
register (PCR)
(PCR) determines
determines which
which
3) The
polarity of transition
transition (rising edge or falling
falling edge) is recognized
recognized
polarity
on the input
input status
status lines (CA
(CA11 and CB1)
other
1) and how the other
status lines (CA2 and CB2) operate. Figure 11-9 describes
describes the bit assignments
assignments in
status
the Peripheral
Peripheral Control
Control register:
register; as usual, the functions
functions and bit
bit positions
positions are arar­
bitrarily selected by the manufacturer
manufacturer. Note that
that the 6522
6522 Peripheral
Peripheral Control
Control
bitrarily
register does not contain
contain status
status bits (latches) like the 6520
6520 Control
Control register:
register; these
register
Interrupt Flag register
register (see
bits are located in the separate Interrupt
(see Figure 11-11).
4)

The Auxiliary
uxiliary Control register (ACR)
determines whether
whether the data ports are
(ACR) determines
latched and how the timers
timers and Shift
Shift register
register operate. These functions
functions are not prepre­
latched
6520 PIA.
describes the bit assignments
assignments in Auxiliary
Auxiliary ConCon­
sent in the 6520
PIA. Figure 11-10 describes
trol register.

Note that
that there is a data direction
direction register
register for each side but
but only one control
control register
register
6520, which
hich has a separate control
control register
register for each side). Ports A and Bare
are
(unlike the 6520,
virtually identical
identical. One important
portant difference
difference is that
that Port B can handle
handle Darlington
Darlington trantran­
virtually
sistors, which
which are used to drive solenoids
solenoids and relays.
ill use Port A for input
input and
relays. We will
Port B for output
output in our examples
examples later in this chapter.

1 1-23
23

,-----------------------------i► IRQ

Data

Bus

Interrupt Control

Port A Registers

Flags
IIFR)

Latch

Enable

Output

Buffers

IIERI

(ORAi

(PAI

Input

Data Dir.

Data

IDDRAI

Bus
Buffers

Function Control

Handshake Control

J...-------------

Peripheral

Port A

IPCRI
Auxiliary

,...

Port A

CAl

....... ------------i► CA2

Port B

(ACRI

,I>,

Timer 1

Latch
(TIL-HI

-----+

R/W
CLK

cs,
CS2
RSO
RSl
RS2
RS3

Counter

(TIC-HI

I

Latch

Shift Register

.......-+♦---------i► CBl

(TIL-LI

(SRI

....... -+----------i► CB2

Counter

Port B Registers

!TIC-LI

Chip

Input Latch

Access

Timer 2

Control
Latch

Output

Buffers

IT2L-LI

(ORB)

(PB)

Counter

Counter

(T2C-HI

(T2C-LI

Data Dir.
(DDRB)

Figure 11-8. Block Diagram
Diagram of the 6522
6522 Versatile
Versatile lnterf;ice
Interface Adapter
Adapter
Figure

Port B

Table 11-7. Addressing
Addressing 6522 VIA Internal
Internal Registers
Registers

Select Lines
Select
Lines
Label

...

Addressed Location
Location

m
C
o
NM r— 0
Cl)
Cl)
Cl)
Cl)
<
n U)
«0
<0
CC cc cc DC
I")

IC

IC

IC

IC

DEV
DEV
DEV+1
DEV+2
DEV+3
DEV+3
DEV+4
DEV+4

0
0
0
0
0

0
0
0
0
1

0
0
1
1
0

0
1
0
1
0

DEV+5

0

1

0

1

DEV+6
DEV+6
DEV+7
DEV+7
DEV+8
DEV+8

0
0
1

1
1
0

1
1
0

0
1
0

DEV+9
DEV+9

1

0

0

1

DEV+A
DEV+A
DEV+B
DEV+C
DEV+D
DEV+D
DEV+E
DEV+F

1
1
1
1
1
1

0
0
1
1
1
1

1
1
0
0
1
1

0
1
0
1
0
1

Output
utput register
register for I/O
1/0 Port B
Output
utput register
register for I/O
ith handshaking
handshaking
A. with
1/0 Port A.
I/O
Direction register
1/0 Port B Data Direction
I/O
Direction register
1/0 Port A Data Direction
Read
Timer 1 Counter
Counter low-order
low-order byte
Read Timer
Write
rite to Timer
Timer 1 Latch
latch low-order
low-order byte
Read
Timer 1 Counter
Counter high-order
high-order byte
Read Timer
Write
rite to Timer
Timer 1 Latch high-order
high-order byte and
initiate count
count
initiate
Access Timer
Timer 1 Latch low-order
low-order byte
Timer 1 Latch high-order
high-order byte
Access Timer
Read
low-order byte of Timer
Timer 2 and reset
Read low-order
Counter interrupt
interrupt
Counter
Write
rite to low-order
Timer 2 but do not
low-order byte of Timer
reset interrupt
interrupt
high-order byte of Timer
Timer 2;
Access high-order
2: reset
Counter interrupt
interrupt on write
write
Counter
Serial I/O
Shift register
register
1/0 Shift
Auxiliary Control
Control register
register
Auxiliary
Peripheral Control
Control register
register
Peripheral
Interrupt Flag register
register
Interrupt
Interrupt Enable register
register
Interrupt
Output
utput register
register for I/O
o u t handshaking
handshaking
1/0 Port A,
A. w ith
ithout

11
-25
1-25

7654321

-B it Number
-Peripheral
Peripheral Control register

I

0
interrupt on
on high-to-low}
high-to-low
0 Request
Request interrupt
transition
of CA1
transition of
CA l

On interrupt
interrupt request set

1 Request interrupt
interrupt on low-to-high
low-to-high

Interrupt Flag
Interrupt
Flag register bit 1

transition of CA11
transition
000
input mode
mode
OClOCA2
CA2 input
001 CA2 independent
independent input mode

interrupt on
f Request
Request interrupt
on
high-to-low CA2 transition
transition
f high-to-low

interrupt on
l Request
Request interrupt
low-to-high CA2 transition
transition
011 CA2 independent
independent input mode f low-to-high
010 CA2 input mode

l

On
interrupt
On interrupt

request set

Interrupt Flag
Flag
register bit 0

100
output low on CPU
write
100 CA2 output
CPU read or write
101
output low pulse on CPU
write
101 CA2 output
CPU read or write
110 Output
Output CA2 low
111
Output CA2,
111 Output
CA2. high
0
interrupt on
high-to-low
0 Request
Request interrupt
on high-to-low}

\

transition of CB
CB11
transition
1 Request
interrupt on low-to-high
low-to-high
Reque~t interrupt
transition of CB
CB11
transition

On interrupt
interrupt request set
Interrupt Flag
Interrupt
Flag register bit 4
interrupt on
l Request
Request interrupt

-0 0
0 CB2
OClO
CB2 input mode
001 CB2
CB2 independent input mode
010 CB2
CB2 input mode
0111 CB2
C82 independent input mode

high-to-low CB2
transition
r high-to-low
CB2 transition

On interrupt
request set
Interrupt Flag

l Request
Request interrupt on
}
low-to-high CB2
register bit 3
f low-to-high
C82 transition

100
output low on CPU
write
100 CB2
CB2 output
CPU write
101
output low pulse on CPU
write
101 CB2
CB2 output
CPU write
110
Output CB2
110 Output
CB2 low
111
Output CB2
111 Output
CB2 high

Figure 11-9. 6522 VIA Peripheral
Peripheral Control
Control Register Bit Assignments
Assignments

7

6

5 4

3 2

1

I I I I I I I I
I~

0
0 ....,_Bit

Bit Number
Auxiliary Control
Control register
register
Auxiliary

I~
>0
Disable input
input latch on Port A
O Disable
1 Enable input
input latch
latch on Port A
0 Disable
Disable input
input latch
latch on Port B
1 Enable input
input latch on Port B

~

000
0 0 Disable Shift
Shift register
register
001 Shift
Shift in at Counter
Counter 2 rate
010
1 0 Shift
Shift in at <t>2
clock rate
4>2 clock
011 Shift
Shift in at external clock
clock rate
1 00 Free-running
Free-running output
output at Counter
Counter 2 rate
101 Shift
Shift out at Counter
Counter 2 rate
1 110 Shift
Shift out at $
2 clock
clock rate
4>2
111 Shift
Shift out at external clock
clock rate
0 Decrement
Decrement Counter
Counter 22 on
on $
2 clock,
4>2
clock,ininone-shot
one-shotmode
mode
1 Decrement
Decrement Counter
Counter 22 on
on external
externalpulses
PB6
pulsesinput
inputvia
via PB6
0
0 Disable
Disable output
output via
via PB7^
PB7}
1 Enable output
output via PB7 1
0 One-shot
One-shot mode
mode
1 Free-running
Free-running mode
mode

>Counter
Counter 1 controls
controls
|

t

Figure 11-10. 6522 VIA Auxiliary
Control Register Bit Assignments
Auxiliary Control
Assignments

11-26

CONFIGURING THE VIA
IA
CONFIGURING
select the logic connections
connections in the VIA
VIA
The program must select
STEPS IN
selection (or configuration) is usually
before using it. This selection
CONFIGURING
CONFIGURING
startup routine. The steps are to establish
establish the
part of the startup
A VIA
directions of the I/O
loading the Data Direction
Direction register
register
directions
1/0 pins by loading
select the required
required logic
logic connections
connections in the VIA by loading
loading the Peripheral
Peripheral ConCon­
and to select
register and.
and, if necessary,
Auxiliary Control
Control register.
trol register
necessary. the Auxiliary
establish the directions
directions of the I/O
s:
You can establish
1/0 pins as follows:
' in a bit in the Data Direction
Direction register
register makes the
1)I A '0
·o•
corresponding pin an input. For example.
example, a O' in bit 5 of
Data Direction
Direction Register A makes pin PA5 an input.
input.

·o·

ESTABLISHING
ESTABLISHING
VIA PIN
VIA
DIRECTIONS
DIRECTIONS

2)
Direction register
register makes the
21 A '•V1' in a bit in the Data Direction
corresponding pin an output. For example.
example, a '1'
Direction Register
·1· in bit 3 of Data Direction
B makes pin PB3 an output.
output.
The directions
directions of almost
almost all I/O
after the initialization
initialization since most input
input and
1/O pins are fixed after
output lines transfer
transfer data in only one direction
direction (i.e.,.. the microprocessor
microprocessor will
ill never fetch
output
printer or send data to a keyboard).
data from a printer
Some simple
simple examples
examples of setting
setting directions
directions are:
1)
1)

LDA
STA

#00
;ALL LINES
LINES INPUTS
INPUTS
VIADDRA
VIADDRA

2)
2)

LDA
STA

#$FF
;ALL LINES
LINES OUTPUTS
OUTPUTS
VIADDRB

3)
3)

LDA
STA

#$F
;MAKE LINES
#$F00
LINES 4-7 OUTPUTS,
OUTPUTS. 0-3 INPUTS
INPUTS
VIADDRB

You can mix inputs and outputs
outputs on a single port by establishing
establishing the dii
directions of individual pins appropriately.
appropriately. Port B is buffered
buffered so that its contents
contents can be read correctly
correctly
dividual
even when it is being used for output;
output; Port A is not buffered
buffered so that its contents
contents can be
read correctly
correctly only if it is lightly
lightly loaded (or designated
designated as inputs).

Configuring the VIA is difficultlt because of its many funcfunc­
tions.
ost of the I/O
tions. Most
1/0 port functions are controlled by the
Peripheral Control register, and we shall discuss these first.
Some points to remember
remember are:

,------..
VIA PERIPHERAL
CONTROL
REGISTER
REGISTER

1)
1) Reset
Reset clears
clearsall
allthe
the VIA
VIA registers,
registers, making
making all
all lines
lines inputs
inputs and
anddisabling
disabling all
all inter­
interrupts. All edge detection
detection facilities
facilities are
trigger on falling
falling edges (high-to-low
(high-to-low
are set to trigger
transitions).
2)
21 Bits
Bits0-3
0-3 of
ofthe
the Peripheral
PeripheralControl
Controlregister
register are
areused
usedto
to establish
establish the
the logic
logiccon­
connections for control lines CA11 and CA2; bits 4-77 have the same purposes
purposes for
control lines CB1
CB1 and CB2.
3) Control
Control lines
lines CA1
CA 1 and
and CB1
CB1 are
are always
always inputs.
inputs. The
The only
only choice
choice isiswhether
whether the
the
corresponding status
(Interrupt Flag
see Figure
corresponding
status latches (Interrupt
Flag register bits 1 and
and 4 —
-see
11-11)
(high-to-low, or
11-11) are
are set on falling
falling edges (high-to-low.
or negative,
negative. transitions)
transitions) or on rising
rising
edges (low-to-high.
(low-to-high, or positive,
CA1,
positive. transitions).
transitions). For
For CA
1. bit 0 == 0 for
for falling
falling edges and
and
11 for
for falling
falling edges and 1 for
for rising edges.
edges.
for rising edges; for
for CB1,
CB1. bit
bit 4 = 0 for
4) Control
-8 and
Control lines
linesCA2
CA2 and
andCB2
CB2can
canbe
beeither
either inputs
inputsor
oroutputs
outputs (see
(seeTables
Tables 111-8
and
11-9).
output and
11-9). For
For CA2,
CA2. bit 33 == 11 to
to make
make it an output
and 00 to
to make
make it an
an input.

1111-277

11-8. Configurations
for 6522 VIA Control
Control Line
Line CB2
C82
Table 11-8.
Configurations for

PCR7

PCR6

PCR6
PCR5

Mode

0

0

0

Interrupt
Set CB2
CB2 Interrupt
Interrupt flag
flag
Interrupt Input Mode -— Set
(IFR3) on
on a negative transition
transition of
of the
the CB2
CB2 input
input
(IFR3)
signal. Clear IFR3
IFR3 on aa read
read or
or w
write of
of the
the Pe­
Pesignal.
register.
ripheral B Output
utput register.

0

0

1

Independent
-Set
IFR3on
on
Independent Interrupt
Interrupt Input Mode —
Set IFR3
the CB2
CB2 input signal.
a negative transition of the
Reading or writing
riting ORB
ORB does
does not clear the
the Inter­
Interflag.
rupt flag.

0

1

0

Interrupt flag
Input Mode -— Set CB2
CB2 Interrupt
flag on
on a posi­
positive transition
transition of the CB2
CB2 input signal.
signal. Clear the
the
CB2 Interrupt
Interrupt flag on a read
read or write of ORB.
ORB.

0

1

1

Independent Input Mode-Set
— Set IFR3
Independent
IFR3 on
on a posi­
positive transition
transition of the CB2
CB2 input signal. Reading
Reading or
or
writing
ritin g ORB
Interrupt
ORB does not clear the
the CB2
CB2 Interrupt
flag.
flag.

1

0

0

Handshake Output
utput Mode -— Set CB2
CB2 low on
on aa
write
rite ORB
ORB operation. Reset
Reset CB2
CB2 high with an ac­
active
transition of the CB1
tIve transition
CB1 input signal.
signal.

1

0

1

Pulse Output
utput Mode —
- Set CB2
CB2 low for one cycle
follow
ing a write
write ORB
following
ORB operation.

1

1

0

utput Mode -— The CB2
output is held
Manual Output
CB2 output
held
low in this mode.
mode.

1

1

1

Manual Output
utput Mode —
- The CB2
CB2 output
output is held
held
high in
In this mode.
mode.

11-28
11-28

Configurations for 6522
6522 VIA Control
Control Line CA2
Table 11-9. Configurations

Mode
Mode

PCR3

PCR2

PCR1
PCR1

0

0

0

Input Mode —
Interrupt flag (IFRO)
Input
-SetSet CA2 Interrupt
(IFRO)on a
transition of the input
input signal. Clear IFRO
negative transition
!FRO
on a read or write
rite of the Peripheral A Output
utput
register.

0

0

1

Independent Interrupt
Interrupt Input
Input Mode -— Set IFRO
Independent
IFROon
negative transition
transition of the CA2 input
input signal.
a negative
Reading or writing
ritin g ORA does not clear the CA2
Interrupt flag.
Interrupt

0

1

0

Input Mode -— Set CA2 Interrupt
Interrupt flag on a posi­
Input
positive transition
transition of the CA2 input
input signal. Clear IFRO
IFRO
with
ith a read or write
rite of the Peripheral A Output
Output
register.

0

1

1

Independent Interrupt
Interrupt Input
Input Mode -— Set IFRO
Independent
!FROon
a positive
positive transition
transition of the CA2 input
input signal.
Reading or writing
ritin g ORA does not clear the CA2
Interrupt flag.
Interrupt
flag.

1

0

0

Handshake Output
utput Mode -— Set CA2 output
output low
on a read or write
rite of the Peripheral A Output
utput
register. Reset
Reset CA2 high with
ith an active transition
transition
on CA1.

1

0

1

Pulse Oulput
utput Mode —
CA2 goes low for
-CA2
for one cy­
cycle following
ing a read
rite of the Peripheral A
read or write
Output
utput register.

1

1

0

utput Mode -— The CA2 output
output is held
Manual Output
low in this mode.
mode.

1

1

1

Manual Output
utput Mode -— The CA2 output
output is held
high in this mode.
mode.

111-29
1-29

6

4

3

2

0

~- Bit Number

.--IR-Q---T--1 --.--T-2 _____C_B_1
...--C-B-2--.--S-R--.-C-A--1__ C_A_2-i.--IRQ

T1

T2

CB1

1

2

3

4

5
6

6

7

SR

CA1

CA2

Sat
e By

Bit No.
No.

0

CB2

Interrupt Flag register

- Interrupt Flag register

Cleared By

Active transition
transition of the signal
Active
on the CA2 pin.

register (ORA)
01.
register
(ORA) using address
address 0 001.

Reading
writing the A Port Output
Reading or writing

Active transition
transition of the
the signal
Active

Reading or writing
writing the A Port Output
Output

on the CA11 pin.

register
register (ORA), using
using address
address 0 000 1l..

Completion of eight shifts.
shifts.
Completion

Reading
writing the
Reading or writing
~he Shift
register.

Active transition
transition of the signal
Active

Reading
writing the 8
B Port
Reading or writing

on the CB2 pin.

Output register.
register.
Output

Active transition
transition of the signal
Active
on the CB1
CB1 pin.

Reading
writing the B Port
Reading or writing

Output register.

Time-out"
e-out of Timer
er 2.

Reading
low-order counter or
Reading T2 low-order
writing T2 high-order
high-order counter.
writing

Time-out
e-out of Timer
er 1.
1.

Reading
T1 low-order
low-order counter or
Reading Tl

Active and enabled interrupt
interrupt
Active
condition.
condition.

Action which
which clear interrupt
interrupt
Action
condition.
condition.

writing T11 high-order
high-order latch
writing

Bits 0, 1,
interrupts is both active
1. 3, and 4 are the I/O
1/0 handshake signals. Bit 7 (IRQ)
(IRQ) is 1 if any of the interrupts
and enabled (see
(see Chapter 12).
21.

Figure 11-11
Interrupt Flag Register
11-11 The 6522 VIA Interrupt

1 1-30
30

follows:
Further functions are as follows:

CA2 Input
trigger on a rising edge, 0 to trigger
trigger on a falling
falling edge.
Bit 2 = 1 to trigger
edge.
Interrupt Flag register bitit 0
input status latch) independent
independent
Bit 1 = 1to make Interrupt
O (the CA2 input
of operations
operations on I/O
operations on I/O
1/0 Port A,
A. 0 to have that bit cleared by operations
1/0 Port
A.
A.
The independent
independent mode is useful when CA2 is being used for purposes (such as a real­
realthat are completely
completely unrelated to the data transfers through
through the I/O
time clock) that
1/0 port. The
when CA2 is being used as a handshaking
handshaking signal which
hich must be
regular mode is useful when
cleared to prepare for the next I/O
1/0 operation (see
(see Figures 11-5 and 11-6).
11-6).

CA2 Output
pulse
Bit 2 =
= 1 to make CA2 a level,
level. 0 to make it a pulse
If CA2 is a level,
level. bit 1 is its value
If CA2 is a pulse, bit
bit1 is Oto 1
is 0
to go
have
CA2
go low
when the
CPUdata
transfers
have
CA2
low
when
the CPU
transfers
to ordata
fromto or from
Port A and remain low until
until an active transition
transition occurs on CA1;
to have
have
1: bit 1 is 1 to
CA2 go low for one clock cycle after the CPU
CPU transfers data to or from Port A.
CB2 is handled exactly
exactly the same (using bits 7, 6, and 5 of the Peripheral Control
Control register
and bit 3 of the Interrupt
Interrupt Flag register) except
except that pulses are produced on CB2 only
ritten into Port B.
after data is written
B. To produce a pulse after reading data,
data. you must use a
"dummy
is:
"dum
m y write",
rite ", that is:
LDA
FROM FROM
PORT B
:GET DATA
PORT B
VIAORB;GET DATA
LOAVIAORB
STAVIAORB
STROBE
FROM FROM
PORT B
:PRODUCE
STROBE
PORT B
VIAORB;PRODUCE

VIA INPUT
The only I/O
function governed by the Auxiliary
Auxiliary Control
1/0 port function
LATCHES
input latching. Bit 0
(for Port
Port A)
A) or
or bit
bit 11
register (Figure 11-10) is input
O (for
LATCHES
(for port B)
must be set to latch the input
input data on
onthe
theactive
active transitransi­
Bl must
control line 1 (as
determined by the Peripheral Control register)
tion on control
(as determined
register!. Note the
following
ing features
features of the latching function:
1)
1)

RESET
input latches. The 6522 VIA then operates like the 6520 PIA.
PIA,
RESETdisables the input
which has no input
input latches.
which

2)

For Port A, the data that
that is latched will
ill always be the data on the peripheral
peripheral pins.
Since Port A is not buffered, that data may not be the same as the data in the Outut­
when the port is being used for output.
output.
put register when

3)

For Port B,
either the data on the peripheral
peripheral pins (for those
B, the data that is latched is either
pins defined
defined as inputs) or the contents
contents of the Output
utput register (for those pins defined
as outputs!.
outputs).

Some simple examples
examples of activating
activating the input latches are:
LDA
LOA
STA

#%
00000001
#%00000001
VIAACR
VIAACR

iACTIVATE LATCH
LATCH ON
:ACTIVATE
ON PORT
PORT A

A

LDA
LOA
STA

#%
00000010
#%00000010
VIAACR
VIAACR

ACTIVATE LATCH
LATCH ON
:ACTIVATE
ONPORT
PORT B

B

LDA
LOA
STA

#%
00000011
#%00000011
VIAACR
VIAACR

ACTIVATE LATCHES ON PORTS
AND B
:ACTIVATE
PORTS A AND

Note that
that 6522 output
output ports are autom
atically latched, just
just like 6520 output
output ports.
automatically
ports.

1 1 -31

EXAMPLES OF VIA CONFIGURATION
1)

(as needed for
A simple input port with
ith no control lines (as
a set of switches):
switches):
LDA
LOA
STA
STA

##0
VIAPCR
VIAPCR
VIADDRA
VIADDRA

VIA
VIA
CONFIGURATION
CONFIGURATION
EXAMPLES
EXAMPLES

;MAKE
;MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
:MAKE PORT
LINESA LINES
INPUTSINPUTS
;MAKEAPORT

Remember
Reset clears all the internal
Remember that
that Reset
internal registers so that
that this sequence may not
necessary. The same sequence can be used if a high-to-low
even be necessary.
high-to-low edge (falling
Ready.
edge) on control
control line CA11 indicates
indicates Data Ready or Peripheral
Peripheral Ready.
2)

A simple output
output port with
ith no control
control lines (as
dis­
(as needed for a set of single LED
LED displays):
LDA
LOA
STA
LDA
LOA
STA

3)

##0
VIAPCR
VIAPCR
#$FF
#$FF
VIADDRB
VIADDRB

;MAKE ALL CONTROL
:MAKE
CONTROL LINES
LINESINPUTS
INPUTS
;MAKE PORT
:MAKE
PORT B LINES OUTPUTS
OUTPUTS

An input
input port
port w
with an
an active
active low
low-to-high
TA READY
READY signal
signal attached
attached to
to CA
An
-to-high DA
DATA
CA11
(as needed for an encoded
(as
encoded keyboard):
LDA
LOA
STA
LDA
LOA
STA

##0
0
VIADDRA
VIADDRA
#1
#1
VIAPCR
VIAPCR

PORT A LINES
LINES INPUTS
INPUTS
:MAKE PORT
:MAKE RISING
RISING EDGE
EDGE ACTIVE

Peripheral Control
Control register
register is set so as to recognize
recognize low-to-high
-to-high transitions
transitions
Bit 1 of the Peripheral
1. Such a transition
(see
on control
control line CA1.
transition will
ill set bit 1 of the Interrupt
Interrupt Flag register
register (see
11-10): reading the data from the port will
(see the table associated
Figure 11
ill clear that bit (see
11-11).). Input
O of the Auxiliary
with
ith Figure 11
Input latching
latching can be provided
provided by setting
setting bit 0
Auxiliary ConCon­
trol register.

4) An
An output
output port
port that
that produces
produces aa brief
brief strobe
strobe to
to indicate
indicate DATA
DATA READY
READY or
or OUT­
OUTultiplexing displays
displays or for providing
providing a DATA
PUT READY (this could be used for multiplexing
AVAILABLE
AVAILABLE signal to a printer!:
printer):
LOA
LDA
STA
LDA
LOA
STA

#$FF
#$FF
VIADDRB
VIADDRB
#% 1
0100000
#%10100000
VIAPCR
VIAPCR

;MAKE
OUTPUTS
:MAKE PORT
PORT BLINES
LINES OUTPUTS

The brief
brief strobe on control
control line CB2 will
ill occur
occur after
after every output
output operation.
operation. Bit 7 of the
Peripheral Control
Oto
pulse.
Control register
register is 1 to make CB2 an output.
output, bit 6 is 0
to make CB2 a pulse,
bit 55 isis 11 toto make
make CB2
CB2 aa brief
brief (one
lone clock
clock cycle)
cycle) pulse
pulse follow
following each
each output.
output.
and bit

5) An
ith aa handshake
An input
input port
port wwith
handshake Input
Input Acknowledge
Acknowledge strobe
strobe that
that can
can be
be used
used to
to
tell a peripheral
peripheral that
that the previous data has been accepted
accepted (and that
that the comcom­
tell
puter
more)·
puter is ready for more):
LOA
LDA
STA
LOA
LDA

##0
0
VIADDRA
VIADDRA
#%00001000
#%
00001000

;MAKE
INPUTS
:MAKE PORT
PORT A
ALINES
LINES INPUTS
;CONTROL
:CONTROL LINE
LINE 22 = HANDSHAKE
HANDSHAKE
:; ACKNOWLEDGE
ACKNOWLEDGE

control line CA2 will
ill occur
occur after
after every input
input or output
output operation. It will
ill re­
The strobe on control
remain low until
until the next active
active transition
transition on control
control line CA1. Bit 3 of the Peripheral
Peripheral ConCon­
trol register
Oto
pulse. and bit 1 is 0
Oto
register is 1 to make CA2 an output.
output, bit 2 is 0
to make CA2 a pulse,
to
make CA2 an active-low
active-low acknowledgm
ent that
that lasts until
until the next active
active transition
transition on
acknowledgment
CA1. Note that
O of the Peripheral
that the active
active transition
transition on CA11 is a falling
falling edge since bit 0
Control
Is suitable
CRT terminals
Control register
register is 0. This configuration
configuration is
suitable for many CRT
terminals that require a
complete
complete handshake.
1 1-32
32

6)
6)

An output
output port
port with
ith a latched
latched active-low
active-low control
control b
(latched output
output or
or level
An
bitit (latched
output). Such
Such an output
output bit
bit can be used to
to turn
turn a peripheral
peripheral on or
or off
off or
or to control
control
output).
its mode
mode of
of operation.
operation.
its
LDA
LOA
STA
STA
LDA
LOA
STA
STA

#$FF
#$FF
VIADDRB
VIADDRB
#% 1
#%11000000
VIAPCR
VIAPCR

;MAKE
:MAKE PORT
PORT BLINES
LINESOUTPUTS
OUTPUTS
;CONTROL
LATCHED ZERO
ZERO LEVEL
LEVEL
:CONTROLLINE
LINE2 2 =
= LATCHED

Bit 7 = 1 to make control
control line
line CB2 an output.
output, bit
bit 6 == 1 to make it a level
level or latched
latched bit.
bit,
Bit
bit 5 = 0 to make the
the active
active level zero.
bit is not affected
affected by operations
operations on the
and bit
zero. This bit
I/O port
port or Output
utput register:
register; its value can be changed
changed by changing
changing bit
bit 5 of
of the Peripheral
Peripheral
1/0
Control register.
register, i.e.,
Control
..
LDA
LDA
ORA
STA
LDA
LOA
AND
AND
STA

VIAPCR
VIAPCR
#% 00
100000
%00100000
VIAPCR
VIAPCR
VIAPCR
#%11011111
% 1 1011111
VIAPCR

;MAKE LEVEL ONE
:MAKE

;MAKE
;MAKE LEVEL ZERO

You can use this configuration
configuration to produce
produce an active-high
active-high or active-low
active-low strobe or to propro­
ith software-controlled
software-controlled lengths.
vide pulses with

11-33

USING THE VIA TO TRANSFER DATA
configured, you may use its data registers
VIA INPUT/
INPUT/
Once the VIA has been configured.
VIA
other memory
memory location
location (just as with
ith the PIA).
common
like any other
PIA). The common
OUTPUT
transfer data,
status, and control
control are with
ith the instructions
instructions
ways to transfer
data. status.
Load Accum
ulator, Store Accum
ulator, Bit Test,
that Output
Output
Accumulator.
Accumulator.
Test. and Compare. Note that
ith handshaking
handshaking (address 1) and one
Register A can be addressed in two ways -— one with
w ith
o u t handshaking
handshaking (address F).
o u t handshaking
handshaking allows
allows you to use
ithout
F). The address w ith
ithout
independently of the peripheral
peripheral attached
attached to I/O
That control
control line could be
1/0 Port A. That
CA11 independently
used for an alarm,
input, control
control panel interface.
interface, or extra control
control input
input from
alarm. clock input.
another peripheral. The Interrupt
Interrupt flag for that input
input can be cleared directly
directly by clearing
another
the appropriate
appropriate bits in the Interrupt
Interrupt Flag register (see
alternate ad•
ad­
(see Figure 11-11). The alternate
dress for Output
utput Register A and the independent
independent modes for control
control lines CA2 and CB2
control lines w ith
o u t having to worry
worry about
about the autom
atic handshaking
allow use of control
ithout
automatic
features of the VIA.

1111-34

VIA INTERRUPT
INTERRUPT FLAG REGISTER
REGISTER
We have mentioned
mentioned the VIA Interrupt
Interrupt Flag register (see
VIA INTERRUPT
(see Figure
VIA
11-11) on severalI occasions. The table in Figure
ex­
Figure 11-11 exFLAG
FLAG REGISTER
REGISTER
plains the meanings of the various bits (bit 7 is a general inin­
terrupt request bit that is 1 if any interrupt
interrupt is both active and enabled).
terrupt
enabled).

Any of the flags in the Interrupt
Interrupt Flag register may be exp
licitly cleared by writing
riting
explicitly
procedure is useful when the concon­
a logic 1 into the corresponding
corresponding bit position. This procedure
independently of the data ports (as
independent input
input
trol lines are being used independently
(as in the independent
mode described in Tables 11-8 and 11-9) or when no data transfers are actually
actually re­
rexplicitly clearing the flags
quired in response to the flag being set.
set. Some examples of explicitly
are:
are:
LDA
STA

#%00000010
00000010
VIAIFR
VIAIFR

;CLEAR
CLEAR CA11 INTERRUPT
INTERRUPTFLAG
FLAG

LDA
STA

#%00001000
00001000
VIAIFR
VIAIFR

;CLEAR
CB2 INTERRUPT
;CLEAR C82
INTERRUPTFLAG
FLAG

LDA
STA

#% 1
1111111
%11111111
VIAIFR
VIAIFR

;CLEAR
;CLEAR ALL INTERRUPT
INTERRUPTFLAGS
FLAGS

The value written
ritten into bit 7 does not matter.
matter, since that flag cannot
cannot be explicitly
explicitly set or
cleared from the CPU.
CPU.
Bits 0,
Interrupt Flag
0. 1,
1. 3,
3. and 4 of the VIA Interrupt
Flag register often serve as handshake status bits
such as Data Ready
their values with
ith appropriate
appropriate
Ready or Peripheral Ready.
Ready. You can check their
shifting operations.
masking or shifting
LDA
AND
BNE
BNE

VIAIFR
VIAIFR
#%00000010
00000010
DEVRDY
DEVRDY

;IS CA11 FLAG
FLAG SET?
SET?
;YES.
;YES. DEVICE
DEVICE READY
READY

LDA
AND
BNE
BNE

VIAIFR
VIAIFR
#% 00
0 10000
00010000
DEVRDY
DEVRDY

;IS CB1
CB1 FLAG
FLAG SET?
SET?
;YES.
;YES. DEVICE
DEVICE READY
READY

The flag is then autom
atically cleared by reading or writing
riting the appropriate
appropriate port or by
automatically
explicitly
xplicitly clearing
clearing the bit in the Interrupt
Interrupt Flag register. The follow
ing program will
ill wait
wait
following
for a Ready flag attached
attached to input
input CA11 to go high:
WAITR

LDA
LDA
AND
BEQ
BEG

VIAIFR
VIAIFR
#%
00000010
#%00000010
WAITR
WAITR

;IS
SET?
;ISCA1
CA1 FLAG
FLAG SET?
;NO,
;NO.WAIT
WAIT

How would
would you change these programs to handle Ready lines attached
attached to CA2,
CA2. CB1,
1. or
CB2?
CB2?

that the flag will
ill remain set unless some operation clears it. If no operation is
Note that
actually required.
required, some dummy
m y operation (such as reading the port and discarding
discarding the
actually
data) will
ill be necessary simply
simply to clear the flag. Be particularly
particularly careful
careful in cases
cases where
the CPU
output data to send. Obviously.
Obviously, careful docudocu­
CPU is not ready for data or has no output
mentation is essential in cases
ob­
mentation
cases where the purposes of operations may be far from obvious.
vious.

1 1-35
35

VIA
TIMERS9,
V
IA TIM E
R S 9' 10
As
counter/timers.
As we
we noted
noted earlier.
earlier, the VIA
VIA contains
contains twoo 16-bit
16-bit counter/tim
ers.
These timers
timers are handled
handled as follows:
follows:

|!VIA
VIA TIMERS
TIMERS! |

1) They
They may
may be
be read
read or
or w
written as
as six
six memory
memory locations,
locations, four
four for
fortim
timer
andtw
two
er 11and
o
for
for timer
er 2 (see Table
Table 11-7).
2) Their
Their modes
modes of
of operation
operation are
are controlled
controlled by
by bits
bits 5,
5, 6,
6, and
and 77 of
of the
the Auxiliary
Auxiliary
Control
Control register
register (see Figure
Figure 11-10).
11-10),
3) Their
Their status
status may
may be
be determined
determined by
by examining
examining bits
bits 55 and
and 66 of
of the
the Interrupt
Interrupt
Flag register
(see Figure 11-11).).
register (see

timers can be used as follows:
follows:
The timers
1) To
To generate
generate aa single
single time
time interval.
interval. The
The tim
timer
must be
be loaded
loaded wwith
the number
number ofof
er must
ith the
clock
clock pulses that
that are required.
2) To
To count
count pulses
pulses on
on pin
pin PB6
PBS (timer
(timer 22 only).
only). The
The tim
timer
must be
be loaded
loaded wwith
the
er must
ith the
number
number of pulses
pulses to be counted.
counted. This use of PB6 takes precedence
precedence over its normal
use as an I/O
1/0 pin.

e intervals
3) To
To generate
generate continuous
continuous tim
time
intervals (timer
(timer 11 only)
only) for
for use
use inin real-time
real-time ap­
applications. The timer
er must
must be loaded with
ith the number
number of clock pulses per interval.
4) To
To produce
produce aa single
single pulse
pulse or
oraa continuous
continuous series
series of
of pulses
pulses on
onpin
pinPB7
PB7 (timer
(timer 11
er must be loaded with
ith the number
number of clock pulses per interval. This
only). The timer
This
precedence over its normal use as an I/O
use of PB7 takes precedence
1/0 pin.
pin.

1111-36

6522 VIA TIMER
TIMER 2
OPERATION OF 6522
Timer 2 is simpler than timer
er 1 and can be used only to generate
generate a single time inin­
Timer
terval (the one-shot
one-shot mode) or to count pulses on pin PB6. Bit 5 of the Auxiliary
Auxiliary ConCon­
terval
register selects the mode:
trol register
one-shot mode, 1 for pulse-counting
pulse-counting mode.
Bit 5 = 0 for one-shot
The 16-bit
16-bit timer
er occupies
occupies two memory
memory locations
locations (see
first address is
(see Table 11-7). The first
used to read or write
write the 8 least significant
significant bits;
bits: reading this address also clears the
timer
er 2 interrupt
interrupt flag (Figure 11-11).). The second address is used to read or write
rite the 8
significant bits; writing
ritin g into this address loads the counters,
counters, clears the timer
er 2 in­
most significant
interrupt flag, and starts the timing
ing operation.
operation. The completion
completion of the operation
operation sets the
terrupt
timer
er 2 interrupt
shown in Figure 11-11).
interrupt flag (bit 5 of the Interrupt
Interrupt Flag register
register as shown

er 2 operation are as follows:
s:
Examples of timer
1)
1)

Wait
a it for 1024 (040015)
(0400-|6> clock pulses to elapse.
elapse.

WAITD
WAITD

LOA
LDA

#00

STA
STA
LDA
LOA
STA
LDA
LOA
BIT
BEQ
BEO
LDA
LOA
BRK
BAK

VIAACR
VIAT2L
#44
VIAT2H
#% 00
100000
%00100000
VIAIFR
VIAIFR
WAITD
WAITD
VIAT2L
VIAT2L

;PUT
:PUT TIMER
TIMER 2 IN ONE-SHOT
ONE-SHOT MODE (BIT
(BIT
;: 5 ==00)
)
;MAKE PULSE
0400 HEX
PULSE LENGTH
LENGTH 0400
HEX
;START TIMING INTERVAL
;GET
;GET MASK FOR
FOR TIMER 2 INTERRUPT
INTERRUPT FLAG
FLAG
;IS TIMER
TIMER 2 FLAG SET?
SET?
;NO,
;NO, INTERVAL
INTERVAL NOT COMPLETED
COMPLETED
;YES,
;YES, CLEAR
CLEAR INTERRUPT
INTERRUPT FLAG
FLAG

Note the follow
ing steps in the program:
following
a)
a)

Putting the timer
er in the one-shot
one-shot mode by clearing
clearing bit 5 of the Auxiliary
Auxiliary Control
Control
Putting
register.

b)
er wwith
ith the
g) required
b) Loading
Loading the
the tim
timer
the initial
initial count
count (0400-)
(040015)
required to
to give
give the
the correct
correct inter­
interval. Loading
Loading the MSBs of the timer
er also starts the timing
ing operation.
c) W
aiting for
d
Waiting
for the
the interval
interval to
to be
be completed.
completed. AA tim
timeout sets
sets bit
bit 55 of
of the
the Interrupt
Interrupt Flag
register.
d)

Clearing the interrupt
interrupt flag so that it does not interfere
interfere with
ith other
other operations. The inin­
Clearing
struction LDA
VIAT2L performs
performs this function.
function.
struction
LOA VIAT2L

2) Generate
Generate aa delay
delay of
of length
length given
given by
by 10
10 pulses
pulses on
on pin
pin PB6.
PB6.

WAITC

LDA
LOA
STA
LDA
LOA

#00
VIADDRB
#% 0 0
1 00000
00100000

STA
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
BIT
BEQ
BEO
LDA
LOA
BRK
BAK

VIAACR
#10
10
VIAT2L
VIAT2L
#0
VIAT2H
#%00100000
% 0 0 100000
VIAIFR
VIAIFR
WAITC
VIAT2L
VIAT2L

;MAKE PORT
PORT B INPUTS
INPUTS
;PUT TIMER
TIMER 2 IN PULSE-COUNTING
PULSE-COUNTING MODE
(BIT
(BIT 5 = 1)
;MAKEPULSE
PULSE COUNT 10

;START PULSE
PULSE COUNTING
COUNTING
GET MASK FOR
INTERRUPT FLAG
;GET
FOR TIMER
TIMER 2 INTERRUPT
FLAG
;IS TIMER
TIMER 2 FLAG SET?
SET?
;NO, COUNT
COUNT NOT COMPLETE
COMPLETE
YES. CLEAR
;YES,
CLEAR INTERRUPT
INTERRUPT FLAG

program is the same as the previous
previous example, except
except that the mode of timer
er 2
This program
is different.
different. Here the input
input on pin PB6 could be a periodic
periodic clock line or a line that is
simply pulsed with
ith each occurrence
occurrence of some external
external operation.
simply
1 1-37
37

OPERATION
6522 VIA TIMER 1
OPERATION OF 6622
Timer 1 has four operating modes (see
Timer
(see Figure 11-10) which allow it to generate a
single time-interval
e-interval (one-shot mode)
(free-run­
mode) or a continuous series of intervals (free-runFurthermore, each loading operation can generate an output
output pulse on PB7
ning mode).
mode). Furthermore.
which
hich can be used to control
control external hardware. Bits 6 and 7 of the Auxiliary
Auxiliary Control
determine the mode of timer
er 2 as follows:
follows:
register determine
output pulses on pin PB7,
free-run­
Bit 7 = 1 to generate output
PB7, 0 to disable such pulses (in the free-runcounter reaches zero).
ning mode,
mode. PB7 is inverted each time the counter
zero).
free-running mode,
Bit 6 = 1 for free-running
mode. 0 for one-shot mode.
mode.

Timer 1 occupies four memory addresses (see
first twoo addresses
Timer
(see Table 11-7). The first
are used to read or write
rite the counters. Writing
ritin g into the second address loads the councoun­
ters, clears the timer
er 1 Interrupt
Interrupt flag, and starts the timing
ing operation. The next tw o ad­
addresses
rite into the latches w ith
o u t affecting
affecting the counters.
dresses are used to read from or write
ithout
generation of complex
complex waveforms
waveforms in the free-running
free-running mode.
riting
This allows the generation
mode. Writing
significant bits of the latches also clears the timer
er 1 interrupt
interrupt flag.
into the most significant
Examples of timer
er 1 operation are as follows:
1)
1)

Wait
ait for 4096
4096 (1000-|
q) clock
clock pulses to elapse before producing
producing an output
output on pin
(100015)
PB7.
PB7.

WAITD

LDA
LOA

#0

STA
STA
LDA
LOA
STA
LDA
LOA
BIT
BEQ
BEO
LDA
LOA
BRK
BRK

VIAACR
VIAT1L
# $10
10
VIAT1CH
#% 0
1000000
01000000
VIAIFR
VIAIFR
WAITD
VIAT1L

;PUT TIMER
TIMER 1 IN SINGLE
SINGLE PULSE,
PULSE.NO OUTPUT
OUTPUT
: MODE
MODE
:PULSE
;PULSE LENGTH
LENGTH =
= 1000 HEX
HEX
;START
;START TIMING INTERVAL
INTERVAL
;GET
;GET MASK FOR
FOR TIMER
TIMER 1 INTERRUPT
INTERRUPTFLAG
FLAG
;IS TIMER
TIMER 1 FLAG
FLAG SET?
SET?
;NO.
;NO. INTERVAL
INTERVAL NOT COMPLETED
COMPLETED
:YES,
;YES, CLEAR
CLEAR TIMER
TIMER 1 INTERRUPT
INTERRUPTFLAG
FLAG

The only changes from the program for timer
er 2 are the different
different addresses used to load
the pulse length
length and the different
different bit position
position (bit 6 instead of bit 5) that is examined for
the interrupt
interrupt flag.
2)

Produce an
interrupt every 2048 (080015)
1 g) clock pulses and produce a continuous
continuous
an interrupt
series of cycles on pin PB7 with
ith a half-w
idth of 2048 clock pulses.
half-width
pulses.
LDA
LOA
STA
LOA
LDA

#$FF
#$FF
VIADDRB
VIADDRB
#%
11000000
#%11000000

STA
LDA
LOA
STA
LDA
LOA
STA
BRK
BRK

VIAACR
VIAACR
#0
#0
VIAT1L
VIAT1L
##8
8
VIAT1CH
VIA
TIC H

;MAKE
;MAKE PORT
PORT B
B LINES
LINES OUTPUTS
OUTPUTS
;PUT
;PUT TIMER
TIMER 11 IN
IN CONTINUOUS
CONTINUOUS MODE
MODE WITH
WITH
:; OUTPUT
TO PB7
PB7
OUTPUT TO
;MAKE
;MAKE PULSE
PULSE LENGTH
LENGTH 0800
0800 HEX
HEX

:START
;START TIMING
TIMING INTERVALS
INTERVALS

This routine
routine will
ill produce a continuous
continuous series of intervals that
that will
ill be marked by the setset­
er 1 Interrupt
Interrupt flag (bit 6 of the Interrupt
Interrupt Flag
ting of the timer
Flag register). The main program
can look for the occurrence
occurrence of each interval
interval (with the waiting
aiting routine
routine from Example 1).).
or (more sensibly) the end of each interval
interval can produce an interrupt
interrupt (see
(see Chapter 12).
12).
The level on PB7
ill be inverted
inverted at the end of each timer
er interval
interval (it will
ill go low when
PB7 will
the first
first interval
interval starts). Timer 1 will
ill run continuously
continuously with
ith the values in the latches auau­
tomatically
atically being reloaded into the counters
counters each time the counters
counters reach zero.
zero.
1 1-38
38

THE 6 530
3 0 AND 6 532
3 2 MUL Tl
LTIFU N C
FUNCTION SUPPORT DEVICES
The 6530
6530 and 6532
6532 devices contain memory as welll as I/O
1/0
ports.
sometimes referred to as combination
ports. They are sometimes
ultifunction
pport
evices,
c hips,
ip s , m u lt if
u n c t io n s u p
p o rt d e v
ic e s , or ROM
ROM
(RAM)/1O/TIMER
has:
(RAMl/IO/TIMER chips (RIOTs). The 6530
6530 device has:
•
•
•

6530 AND 6532
6532
6530
MULTIFUNCTION
MUL Tl
FUNCTION
DEVICES

1024 bytes of ROM
64 bytes of RAM
Two
1/0 ports (A and B).
Bl. although
Two 8-bit
-b it I/O
although pins 5 through
through 7 of Port Bare
are often used for
chip
chip selects and an interrupt
interrupt output
output
One 8-bit
-b it timer

Figure 11-12 is a block diagram
diagram of the 6530
6530 device and Table 11-10 describes
describes its interinter­
nal addressing.
addressing. The 6532
6532 device
device has:
•
•

128 bytes of RAM
Two
1/0 ports (A and B),
B), although
Two 8-bit
-b it I/O
although pin 7 of Port A is often used as a strobe input
input
comparable
device.
comparable to pins CA11 or CB11 of a 6520
6520 or 6522
6522 device,
One 8-bit
8-bit timer

Figure 11-13 is a block diagram
11-11 describes
diagram of the 6532
6532 device
device and Table 11-11
describes its interinter­
nal addressing.
addressing. Note that
that 6532 devices contain
contain no ROM.
ROM.

The following
ing features
features of 6530
6530 and 6532
6532 devices should
should be noted:
1) Neither
Neither contains
contains any
any dedicated
dedicated I/O
1/0control
control lines,
lines, although
although pin
pin 77 of
of Port
Port AA on
on aa6532
6532
1)
device can be used for this purpose.
Both contain
contain aa single
single 8 -b
8-bit tim
timer
prescaler that
that allows
allows tim
timing intervals
intervals wwith
2) Both
er wwith
ith aa prescaler
ith
multiplying
ultiplying factors
factors of 1,
er can thus be used to
1. 8,
8. 64,
64. or 1024 clock pulses. The timer
provide intervals
intervals far longer
longer than the basic 256 clock counts.
provide
3)

ing interval
interval either
either causes an interrupt
interrupt or sets a flag which
which can be
The end of the timing
read.
read.

The 6530 and 6532 devices are used in such popular
popular single-board
single-board microcomputers
icrocomputers as
SYM, and A IM
IM-65.11-14
the KIM, VIM, SYM.
-65.11’ 14

11-39

~

j

,.

£

~

SS

"'

.• ~

•
1/0 Port A

........

., ,r

J

s

h

■15.

a o. cc d •c'lcc

0.

,,

'~

'

S3 S3

0

I ... |

-

I~

•

i

I

I/O
Port B
1/0 Pon
Control
and
Select logic
logic

I/O
Port A
1/0 Pon
Data Direction
Oireclion
register

§ .................o

~

,.,.

I/O
Port B
1/0 Pon
Data Direction
Direction
register

~

Interval
Timer

L" J
Data
Buffer
Buffer

64 Bytes

---- 1
r

,,
r

•
Data

1024
1024 Bytes

of
of

of

RAM
RAM

ROM
ROM

Figure 11-12. Block Diagram of the 6530 Multifunction
ultifunction Device

1 1 -40

Table 11-10. Internal
for the
the 6530 Multifunction
Device
Internal Addressing
Addressing for
ultifunction Device
Pimary
ary Select
elect

Accessed locations
Accessed
Locations

RAM
R
AM

1/0Timer
I/O
Tim er

Selecr
elect*

Select·
elect*

\1

X

X

AO - A9 directly
directly address
address one
one of
of 1024
1024 ROM
ROM bytes
bytes
AO

0

\1

0

AO - A5
AS directly
d1rectlyaddress
address one
one of
of 64
64 RAM
RAM bytes
bytes
AO

RSO
RSO

Secondary
Secondary
S elect

!

Interpretation
Interpretation

A3
3

A2
A2

A1
A1

AO
AO

0

0

1

X

0

0

0

0

0

\1

X

0

0

\1

Access
Access I/O
1/0 Port
Port A
A
Access
Access I/O
1/0 Port
Port A
A Data Direction
Dtreclion register
register

0
0
0
0
0
0
0
0
0
0

\1

X

0

Access
Access I/O0 Port
Port B

X

0

\1
\1

0

\1

Access
Access~I/O Port
Port B
B Data
Data Direction
D1rect1onregister
register

1W
\W

0

\1

X

\1
X

1W
\W

\1

\1

X

X

1W
\W

X

\1

0

0

Enable
Enable IRQ
IRQ
Write
Write to timer,
timer, then
then decrement
decrement every
every <t>2pulse
pulse

1W
\W

X

0

\1

\W
1W

X

\1
\1

\1

0

pulses
<t:>2
pulses
Write to timer,
timer, then
then decrement every
every 88 <t>2
pulses
Write to timer,
timer, then
then decrement
decrement every
every 64
64 <t>2
<1>2
pulses

1W
\W

X

1

\1

\1

Write to timer,
timer. then
then decrement
decrement every
every 1024
1024 <t>2
4>2pulses
pulses

1R
IA

X

\1

X

0

1R
\R

X

\1

X

\1

Read
Read timer
Read
Read interrupt flag
flag

0
0
0
0
0
0
0
0
0
0
0

j

Disable
Disable IRQ
IRQ

<P2

O s elect are 't r
u e ” if 1,
ls e '' if 0; true a nd false are
n s oof y o
•* R AM s elect a nd I /
1/0
"true"
1, or ' f a
"false"
are fu n c
functions
your
s p e c ific
a tio n . You s p ecify
ify the c o m bination
in a tio n of a d dress lines t hat c reate a "tru
e ” lin
e cond
ecification.
"true"
line
condition.
X
re p re
s e n ts " d
o n 't c are".
” . Bits may be 0 or 1.
presents
"don't
1.
n ts S elect d uring a re ad.
1R re p resents
1
W re p resents
n ts S elect d uring a w rite.
ite .
lW

11-41
11-41

PAO
PAO

PA
PA77

PBO
PBO

IRQ

1/0 Port A

PB7
P87

co
™1
^
(J UICE CC
ICC

I/O
1/0 Port B

Interrupt Logic

Control
Control

and
I/O
1/0 Port A
Data
Data Direction
D1rect1on
Register
Register

Interval
’

Select
Select Logic
Logic

I/O
1/0 Port
Port B

i

Timer

Data Oirectt0n
Direction
Data
Register
Register

Data
Buffer
Buffer

n

Data

AO

A6

T
128
128 Bytes
Bytes

07

00

of
RAM
RAM

Figure 11-13. Block Diagram of the 6532 Multifunction
ultifunction Device

Table 11-11

Internal Addressing
Addressing for the 6532 Multifunction
ultifunction Device
Internal

Primary Select
elect
RAM

I/O
Tim er
1/OTimer

Select

S
elect
Select

11
00

A3
A3

A2
A2

A1
Al

AO
AO

0

X

X

X

X

X

AO
AO - A6 directly addresses
addresses one of 128
128 RAM bytes
bytes

1

X

X
X

0

0

00

,
,,
,

00

1

X
X

X
X

0

0

,

Access
AccessI/O
1/0 Port
Port A
A Data
Data Direction
Directionregister
register

1

X
X

X
X

00

,

1

0

1

0

1

X
X

X
X

00

1

Access
AccessI/O
1/0 Port
Port B
8 Data
Data Direction
Directionregister
register

0

1W
tW

11

1

X

X

Disable
DisableIRQ

1W

,

0

1

,,

11

,
,
,,
,

11

,

Access
Access I/O
1/0 Port
Port B
B

00

1

X

X
X

Enable
EnableIRQ

iRo
iRa

1

X
X

1

00

00

1

X
X

1

00

,

Write to
to timer,
timer, then
then decrement every
every <t>2
4>2 pulse
pulse

00

,w
1W
,w
,w
1W

1

Write
pulses
Write to
to timer,
timer, then
then decrement
decrementevery
every 8 <t»2
<1>2
pulses

00

1W
1W

11

1

11

00

1

X
X

11

11

,

Write
pulses
Write to
to timer,
timer, then
then decrement
decrementevery
every64
64 <l>2
<1>2
pulses

1W

,

X
X

0

1

Write to
to timer,
timer, then
then decrement every
every 1024 4>2
4>2 pulses
pulses

0

1R
1R

X
X

X
X

11

00

X
X

X
X

1

X
X

,

Read
Read timer
timer

1R
1R

1

Read
Read interrupt
interrupt flags
flags

1W

00

X
X

,,
,,

X
X

00

1

X
X

00

00

00
00
00
00

X
X

Interpretation
Interpretation
A4

Access
Access I/O
1/0 Port
Port A

00

\

Secondary Select
elect
Secondary

,w

,w
1W
,w
1W
,w
,w
1W

00

X
X

11

X
X

,

Request
high-to-low PA77 transition
Request interrupt
interrupt on high-to-low
transittOn

1

Request
Request interrupt
interrupt on
on low-to-high
low-to-high PA7
PA7 transition
transition

00

X
X

1

00

X
X

Enable
EnabtePA7
PA7 interrupt
interruptrequest
request

00

X
X

1

11

X
X

Disable
PA77 interrupt
OisabtePA
interruptrequest
request

represents"don't
"don'tcare"
care”Bits
Bitsmay
maybebeO0oror1.1.
represents

1Rrepresents
1R
ReadRead
access.
1W lW
represents
WriteWrite
access.
represents
access.
represents
access.

1111-42

EXAMPLES
A Pushbutton
Pushbutton S witch
Purpose: To interface
interface a single pushbutton
pushbutton switch
switch to a 6502 microprocessor
microprocessor by means
means
of a 6522 Versatile
Versatile Interface Adapter. The pushbutton
pushbutton is
echani­
Is a single mechanical switch
switch that provides a contact
contact closure (logic level '0')
'O') while pressed
pressed
Figure 11-14 shows the circuitry
circuitry required to interface
interface the pushbutton.
pushbutton. It uses
uses one bit of
a 6522 VIA, which
hich acts as a buffer; no latch is needed since the
pushbutton remains
the pushbutton
closed for many CPU
button grounds
grounds the VIA input
input bit. The
CPU clock cycles. Pressing the button
pullup resistor ensures that the input
input bit is T
button is
pressed.
pullup
'1' if the
the button
Is not being pressed

+55 vV

)

►

• ►
• ►

To CPU

6522
VIA

----1
)

P\Jshbutton

l

Pushbutton Circuit
Circuit
Figure 11-14. A Pushbutton

11
-43
11-43

~

.)

Programming Examples:
Examples:
Programming
W
perform tw
ith this
this circuit.
circuit. They
They are:
Wee w
willill perform
twoo tasks with
a)
al

memory location
location based on the
the state
state of the button
button.
Set a memory

b)
bl

Count the
the number
number of
of times
times that
that the
the button
button is pressed.
pressed.
Count

Task 1: Determine
Determine S w
itch Closure
Task
witch
memory location
location 0040
0040 to one ifif the button
button is not
not being
being pressed.
pressed, and to
Purpose: Set memory
being pressed.
zero if it is being

Sample Cases:
1)

Button open (i.e.,.. not
not pressed)
Button
Result== (0040) = 001
1

2)

Button closed
closed (ie
(i.e.,.. pressed)
Button
Result== (0040) = 00

Flowchart:
Flowchart:
Start

100401= 0

Input and mask
pushbutton
data

10040) • I

End

Source Program:
Program:

DONE

LDA
STA
STA
STA
STA
STA
STA
LDA
AND
AND
BEQ
BEO
INC
INC
BRK
BRK

##0
VIAPCR
VIAPCR
VIADDRA
VIADDRA
$40
$40
VIAORA
VIAORA
#M
ASK
#MASK
DONE
DONE
$40
$40

;MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
:MAKE PORT
PORT A
A LINES
LINES INPUTS
INPUTS
MARKER
;MARKER== ZERO
ZERO
READ BUTTON
;READ
BUTTON POSITION
POSITION
;IS
BUTTON CLOSED
CLOSED (LOGIC
(LOGIC ZERO)?
ZERO)?
IS BUTTON
YES,
;YES. DONE
DONE
NO, MARKER
;NO.
MARKER =1
=1

11-44
11-44

Object Program:
Program:
Memory Location
(Hex)
(Hex)
0000
0001
0001
0002
00031
0003}
0004)
0005
0006)
0006}
00071
0008
0009
000A
OOOA
000B)
0008}

A9
00
8D
8D

oooct
oooc

VIAORA
VIAORA

000D
OOOE
000E

29
MASK
FO
FO
02
E6
E6
40
00

OO
OF
OOF
0010
0011
0011
0012
0013

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
(Hex)
(Hex)

LDA
LOA

#0

STA
STA

VIAPCR
VIAPCR

STA
STA

VIADDRA

STA

$40

LDA
LOA

VIAORA
VIAORA

AND

#MASK
ASK

BEQ
BEO

DONE
DONE

INC
INC

$40

VIAPCR
VIAPCR
8D
VIADDRA
85
40
AD

DONE
DONE

BRK
BRK

The addresses
addresses VIAPCR
VIAPCR (Peripheral
(Peripheral Control register).
register), VIADDRA (Data
(Data Direction Register
Register
A),
A). and VIAORA (Output Register A) depend on how the VIA is connected in your
microcomputer. The VIA control lines are not used in this example; the contents
contents of the
microcomputer.
Peripheral Control register are thus irrelevant
irrelevant but we have cleared that register as a pre­
precaution against spurious operations. We have assumed (as
(as is usually the case)
case) that the
addresses are not on page zero.
zero.
VIA addresses
MASK depends on the bit to which
hich the pushbutton
pushbutton is connected;
connected; it has a one in the
button position and zeros
button
zeros elsewhere.
elsewhere.

Mask
Mask

Button Position
(Bit Number)

Binary

Hex
Hex

0
1
2
3
4
5
6
7

00000001
00000001
00000010
00000010
00000100
00000100
00001000
00001000
00010000
00010000
00100000
00100000
01000000
01000000
10000000
10000000

01
02
04
08
10
20
40
80

11-45
11-45

IfIf the
the button
button is attached
attached to bit
bit 6 or bit
bit 7 of the VIA input
input port.
port, the program
program can use a Bit
Test
Test instruction
instruction to set the
the Overflow
Overflow or Sign bits
bits and thereby
thereby determine
determine the button's
button's
state.
state. For example.
example,
Bit
Bit 7
BIT
BIT
BPL

VIAORA
VIAORA
DONE
DONE

;IS BUTTON
BUTTON CLOSED
;IS
CLOSED (LOGIC
(LOGIC ZERO)?
ZERO)?
;YES. DONE
DONE
;YES,

Bit
Bit 6
BIT
BIT
BVC

VIAORA
VIAORA
DONE
DONE

;IS BUTTON
BUTTON CLOSED
;IS
CLOSED (LOGIC
(LOGIC ZERO)?
ZERO)?
;YES. DONE
DONE
:YES.

Note
Note the
the use of BVC or BVS to check
check the value
value of bit 6.
We
0. 6,
6, or 7.
7. TheseWe could
could also
also use shift
shift instructions
instructions if the button
button is attached
attached to bits 0,
se­
quence
O is:
quence for
for bit
bit 0
LSR
BCC

VIAORA
VIAORA
DONE
DONE

;IS BUTTON
BUTTON CLOSED
:IS
CLOSED (LOGIC
(LOGIC ZERO)?
ZERO)?
;YES,
;YES. DONE
DONE

instructions ASL or ROL can be used with
ith bits 6 or 7. Do the contents
contents of the VIA
The instructions
register actually
actually change?
change? Explain your answer.
Data register

11-46

Task 2:
2: Count
Count S w
itch Closures
Closures
Task
Switch
Purpose: Count
Count the
the number
number of
of button
button closures
closures by
by incrementing
Incrementing memory
memory location
location 0040
0040
Purpose:
after each
each closure.
closure.
after
Sample Case:
Case:
Sample
Pressing the
the button
button ten
ten times
times after
after the
the start
start of
of the
the program
program should
should give
give
Pressing
(0040) == 0A
0A
(0040)
SWITCH
Note: In
In order
order to
to count
count the
the number
number of
of times
times that
that the
the button
button has
has
SWITCH
Note:
been pressed.
pressed, we
we must
must be
be sure
sure that
that each
each closure
closure causes
causes aa single
single
I BOUNCE
BOUNCE
been
transition. However.
However, aa mechanical
mechanical pushbutton
pushbutton does
does not
not produce
produce aa
transition.
single transition
transition for
for each closure.
closure, because the
the mechanical
mechanical contacts
contacts bounce
bounce back
back and
and
single
forth before
before settling
settling into
into their
their final
final positions.
positions. Wee can use hardware
hardware to
to eliminate
eliminate the
the
forth
bounce or we
we can handle
handle itit in software.
bounce
DEBOUNCING
program can debounce
debounce the pushbutton
pushbutton by waiting
aiting after
after it
DEBOUNCING
The program
IN SOFTWARE
SOFTWARE
finds a closure. The required
required delay is called
called the debouncing
debouncing
IN
finds
timee and is part
part of the specifications
specifications of the pushbutton
pushbutton. It is
typically a few milliseconds
milliseconds long. The program
program should
should not examine
examine the pushbutton
pushbutton dur·
dur­
typically
ight mistake the bounces
bounces for new closures. The program
ing this period because it might
may either
either enter
routine like the one described previously
simply per­
enter a delay routine
previously or may simply
per·
form other
other tasks for the specified amount
amount of time.
Even
after debouncing.
debouncing, the program must still wait
ait for the present closure to end before
Even after
looking for a new closure. This procedure avoids double
double counting.
counting. The following
following propro­
gram uses
ant to try
uses a software delay of 10 ms to debounce
debounce the pushbutton.
pushbutton. You may want
varying the delay or eliminating
inating it entirely
entirely to see
what happens.
see what
happens. To run this program,
program.
you must also enter the delay subroutine
subroutine into memory starting
starting at location 0030.

Flowchart:
Start

Count= 0

Count = Count + 1

Debounce button
with 10 ms
wait

11-47
11-47

Source Program:

CHKCL

CHKOP
'.:HKOP

LDA
LDA
STA
STA
STA
LDA
LOA
AND
AND
BNE
INC
LOY
LDY
JSR
LDA
LOA
AND
AND
BEO
BEQ
BNE

#0
#0
VIAPCR
VIAPCR
VIADDRA
VIADDRA
$40
$40
VIAORA
VIAORA
#M A
SK
#MASK
CHKCL
CHKCL
$40
$40
#100
DELAY
DELAY
VIAORA
VIAORA
#MASK
#M
ASK
CHKOP
CHKOP
CHKCL
CHKCL

;MAKE
:MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
;MAKE
:MAKE PORT
PORT AA LINES
LINES INPUTS
INPUTS
;COUNT
:COUNT== ZERO
ZERO INITIALLY
INITIALLY
;IS
:IS BUTTON
BUTTON BEING
BEING PRESSED?
PRESSED?
;N0.
AIT UNTIL
:NO. W
WAIT
UNTIL IT
IT IS
IS
;YES.
:YES. ADD
ADD 11 TO
TO CLOSURE
CLOSURE COUNT
COUNT
:WAIT
;W
AIT 10 MS TO DEBOUNCE BUTTON

:IS
:IS BUTTON
BUTTON STILL
STILL BEING
BEING PRESSED?
PRESSED?
:YES. W
WAIT
FOR RELEASE
RELEASE
; YES.
AIT FOR
;NO,
:NO. LOOK
LOOK FOR
FOR NEXT
NEXT CLOSURE
CLOSURE

11-48
11-

Object Program:
Program:
Object
Memory
Memory Location
Location
(Hex)
(Hex)
0000
0000
0001
0001
0002
0002
00031
0003}
00
00044 1
0005
0005
0006)
0006}
0007)
0007
0008
0009
000A
OOOA
000B)
000B}
oooc
000C)
000D
0000
000E
OOOE
000F
OOOF
0010
0011
0012
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018
0019)
0019}
001AA)
001BB
001C
001C
001D
0010
001E
01E
001F
01F
0020
0020

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)
A9
A9
00
00
8D
80

LDA
LOA

##0

STA
STA

VIAPCR
VIAPCR

STA
STA

VIADDRA
VIADDRA

STA
STA

$40

LDA
LOA

VIAORA

AND
ANO

#MASK
ASK

BNE
BNE

CHKCL
CHKCL

INC
INC

$40

LDY
LOY

# 100

JSR
JSR

DELAY

LDA
LOA

VIAORA

AND

#MASK
#MASK

BEQ
BEG

CHKOP
CHKOP

BNE
BNE

CHKCL

VIAPCR
VIAPCR
8D
80
VIADDRA
VIADDRA
85
40
40
AD
AD

CHKCL
CHKCL

VIAORA
29
MASK
MASK
DO
DO
F9
F9
E6
E6
40
AO
AO
OA
OA
20
30
00
AD

CHKOP
CHKOP

VIAORA
29
MASK
MASK
FO
FO
F9
DO
E9
E9

three instructions
instructions beginning
beginning with
ith the label CHKOP
determine when
when the
The three
CHKOP are used to determine
switch
switch reopens.
Clearly we
we do not
not really
really need a VIA for
for this
this simple
simple interface
interface. An addressable
addressable tri-state
tri-state
Clearly
buffer would
ould do the job
far lower
lower cost.
buffer
Job at far

11-49
11-49

itch
A Toggle Sw
Switch
Purpose: To interface
interface a single-pole.
single-pole, double-throw
double-throw (SPDT)
toggle switch
switch to a 6502
6502
(SPDT) toggle
microprocessor. The toggle
toggle is a mechanical
mechanical device
device that
that is
either in the nornor­
microprocessor.
Is either
mally
(NC) position
(NO) position.
mally closed (NC)
position or the normally
normally open (NO)
Circuit
ircuit Diagram:
Diagram:
DEBOUNCING
Figure 11-15 shows
shows the circuitry
circuitry required to interface
interface the
DEBOUNCING
WITH
switch. Like the pushbutton.
pushbutton, the switch
switch uses one bit of a 6522
WITH
switch.
CROSS-COUPLED
that serves as an addressable
addressable buffer. Unlike the button.
button, the
CROSS-COUPLED
VIA that
NANO
switch may be left in either
either position.
position. Typical
Typical program
program tasks are
NAND GATES
switch
to determine
determine the switch
switch position
position and to see if the position
position has
Either a one-shot
one-shot with
ith a pulse length
length of a few milliseconds
illiseconds or a pair of crosschanged. Either
crosscoupled
(see Figure 11-16) can debounce
coupled NAND gates (see
debounce a mechanical
mechanical switch.
switch.

+5 V

To CPU
Debounce
C1rcu1t

6522
VIA

NO

Figure 11-15. An Interface for a Toggle Switch
Switch

+5 V

To 1/0 port (VIA)

Figure
Circuit Based
Figure 11-16.
11-16. A
A Debounce
Debounce Circuit
Based on
on Cross-coupled
Cross-coupled NAND
NANO Gates
Gates

11-50
11-50

or pulse in response
response to
to aa change
change in
in switch
switch posi­
posiThe circuits
circuits will
ill produce a single step or
tion even if the switch
settling into its new position.
switch bounces before settling

Programming Examples:
Programming
We will
involving this circuit. They are:
are:
ill perform two tasks involving
1)
1)

is closed.
closed.
Set a memory location to one when the switch is

2)

the state of the switch changes.
changes.
Set a memory location to one when the

Task 1: Wait
witch
Close
ait for S w
itch to Close
Is closed and
and then
then is
is set
set to
to
Purpose: Memory
Purpose:
Memory location
location 0040 is zero until
until the switch is
one: that is.
is. the processor clears memory location 0040,
0040. waits
waits for
for the
the switch
switch
one;
closed. and then sets memory location 0040 to one.
one.
to be closed,
The switch
the
itch could be marked Run/Halt.
Run/Halt, since the processor will not proceed until the
switch
itch is closed.

Flowchart:
Flowchart:
Start

10040); 0

10040);

1

End

Source Program:

WAITC

LDA
LOA
STA
STA
STA
LDA
LOA
AND
BNE
INC

#00
VIAPCR
VIADDRA
VIADDRA
$40
$40
VIAORA
#M
ASK
#MASK
WAITC
WAITC
$40
$40

;MAKE ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
;MAKE PORT
PORT A LINES
LINES INPUTS
INPUTS
MARKER = ZERO
ZERO
;MARKER=
;READ SWITCH POSITION
POSITION
;IS SWITCH CLOSED
CLOSED CO')?
('O')?
WAIT
:NO. WAIT
YES. MARKER
MARKER = ONE
ONE
;YES.

BRK
BAK

11
51
11-51

Object Program:
Program:
Memory
MemoryLocation
Location
(Hex)
(Hex)
0000
0000
0001
0001
0002
0002
0003)
0003}
0004)
0005
0005
0006)
0006}
0007)
0008
0008
0009
0009
000A
OOOA
OOOB)
000B}
OOOCi
000D
0000
000E
OOOE
000F
OOOF
0010
0011
0011
0012
0013

oooc

Memory
MemoryContents
Contents
(Hex)
(Hex)
A9
A9
00
8D
80

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LDA
LOA

#0

STA
STA

VIAPCR
VIAPCR

STA
STA

VIADDRA
VIADDRA

STA
STA

$40

VIAPCR
VIAPCR
8D
80
VIADDRA
VIADDRA
85
85
40
AD
AD

WAITC
WAITC LDA
LOA

VIAORA
VIAORA

AND
AND

#M
ASK
#MASK

BNE
BNE

WAITC
WAITC

INC
INC

$40

VIAORA
VIAORA
29
29
MASK
MASK
DO
DO
F9
F9
E6
E6
40
00

11
-52
1-52

BRK
BRK

Task 2: Wait
ait for Sw
itch to Change
Switch
Purpose: Memory
Memory location
location 0040
0040 remains zero until
until the switch
switch position
position changes
changes and is
i.e., the processor
processor waits
waits until
until the switch
itch changes
changes position.
position, then
then set to 1;
1. ie.
sets memory
memory location
location 0040
0040 to 1.
1.
Flowchart:
Flowchart:
Start

(0040) = 0

Old data =
Sw,tch position

New data =
Switch pos1t1on

(0040) = 1

End

Source Program:
LDA
LOA
STA
STA
STA
LDA
LOA
AND
STA
WAITCH LDA
WAITCH
LOA
AND
CMP
BEQ
BEO
INC
BRK
BRK

#0
VIAPCR
VIADDRA
VIADDRA
$40
VIAORA
VIAORA
#MASK
ASK
$41
VIAORA
VIAORA
#MASK
ASK
$41
WAITCH
WAITCH
$40

:MAKE ALL CONTROL LINES INPUTS
:MAKE PORT
PORT A LINES INPUTS
:MARKER = ZERO
ZERO
SWITCH POSITION
:GET OLD SWITCH

SWITCH POSITION
:GET NEW SWITCH
AND OLD POSITIONS THE SAME7
:ARE NEW AND
YES, WAIT
AIT
:YES.
NO, MARKER== ONE
;NO.

1 1-53
53

Object Program:
Object
Program:
Memory Location
Location
Memory
(Hex)
(Hex)

0000
0001
0002
0003)
0003}
0004)
0004
0005
0006)
0006}
0007)
0007
0008
0008
0009
000A
OOOA
000B)
000B}
000C1
oooc
000D
OOOE
OOOE
OOOF
OOOF
0010
0010
0011
0012)
0012}
0013)
0013
0014
0014
0015
0016
0016
0017
0018
0019
001A
001A
001BB
001C

Memory Contents
Contents
Memory
(Hex)
(Hex)
A9
00
8D

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LDA
LOA

#00

STA

VIAPCR

STA

VIADDRA

STA

$40

LDA
LOA

VIAORA

AND

#MASK
ASK

STA

$41

VIAPCR
8D
VIADDRA
VIADDRA
85
40
AD
VIAORA
29
MASK
85
41
AD

WAITCH LDA
WAITCH
LOA

VIAORA

AND

#MASK
ASK

CMP

$41

BEQ
BEO

WAITCH

INC
INC

$40

VIAORA
29
MASK
C5
41
FO
FO
F7
E6
E6
40
00

BRK
BRK

A Subtract
Subtract or Exclusive OR
instruction in the program. Either
OR could replace the Compare instruction
instructions would.
would, however.
however, change
change the contents
contents of the Accumulator.
Accumulator. The
of these instructions
Exclusive OR
would be useful if several switches
switches were attached
attached to the same VIA.
VIA, since
OR would
would produce
produce a one bit for each switch
switch that
that changed
changed state. How would
would you rewrite
rewrite
it would
that it debounces
debounces the switch
switch in software?
software?
this program so that

1 1-54
54

A Multiple-Position
ultiple-Position (Rotary,
(Rotary, Selector, or Thumbwheel) Switch
Purpose: To interface
interface a multiple-position
ultipie-position switch
switch to a 6502
6502 microprocessor.
microprocessor. The lead
lead
corresponding
switch position
hile the other
corresponding to the switch
position is grounded,
grounded. while
other leads are
ones).
high (logic ones)
Circuit Diagram:
Circuit
Figure 11-17
circuitry required to interface
interface an 8-position
8-position switch.
switch. The switch
switch
17 shows the circuitry
uses all eight
eight data bits of one port of a VIA. Typical
Typical tasks are to determine
determine the position
itch and to check whether
whether or not that
that position
position has changed. Two special situasitua­
of the switch
must be handled:
tions must
1)
temporarily between
are grounded.
grounded.
1) The
The sw
switch is
is temporarily
between positions
positions so
so that
thatnonoleads
leads are
2) The
The sw
switch has
has not
not yet
yet reached
reached its
its final
final position.
position.
The first
first of these situations
situations can be handled by waiting
aiting until
until the input
input is not all 'l's.
'Vs. i.e....
until a switch
itch lead is grounded.
grounded. W e can handle the second situation
examining the
until
situation by examining
switch again after
after a delay (such as 1 or 2 seconds) and only accepting
accepting the input
input when it
switch
ill not affect
affect the responsiveness of the system to the
remains the same.
same. This delay will
switch. We can also use another
another switch
switch (i.e.,.. a Load switch)
switch) to tell the processor when
switch.
the selector
selector switch
itch should
read.
Id be read.

Programming Examples:
We will
ill perform
perform two tasks involving
involving the circuit
circuit of Figure 11-17. These are:
a)
onitor the
the position
position and
a) M
Monitor
the switch
switch until
until itit isisininaadefinite
definite position,
position. then
thendetermine
determine the
store its binary
binary value in a memory
memory location.
location.
b)
bl

Wait
ait for the position
position of the switch
switch to change.
change, then store the new position
position in a
memory location.
memory

If the switch
switch is in a position.
position, the lead from that
that position
position is grounded
grounded through
through the comcom­
mon line. Pullup
Pullup resistors on the input
input lines avoid problems
problems caused by noise
noise.

7

PA 7

::: 6

t=
:::

5
4

::.

C~J

i=2
::: 1

-o

-

PA5
PA 5
PA 4
PA 3
PA 2
PA 1

To CPU

6522
VIA

~
-v

PAo

Common

Interface for a Multi-Position
ulti-Position Switch
Switch
Figure 11-17.
17. An Interface

1 1-55
55

l

Task 1:: Determine
Determine S w
itch Position
witch
Purpose:
aits for the switch
switch to be in a specific
specific position
position and then stores
Purpose: The program waits
the position
position number
number in memory
memory location
location 0040.
contains the data inputs
inputs corresponding
corresponding to the various switch
switch positions.
Table 11-12 contains

Table 11-12. Data Input
Input vs.
Switch Position
vs. Switch

Data Input
Switch
w itch Position
0
1
2
3
4
5
6
7

Binary

Hex
Hex

11111110
11111110
11111101
11111101
11111011
11111011
11110111
11101111
11011111
10111111
01111111
01111111

FE
FE
FD
FB
F7
EF
EF
DF
OF
BF
BF
7F

eight bits to distinguish
distinguish among
11 requires eight
This scheme
scheme is inefficient.
inefficient since it
eight different
different positions.
eight

A TTL or MOS encoder
encoder could reduce the number
number of input
input bits
USING
A TTL
needed. Figure 11-18 shows a circuit
circuit using the 74LS148
74LS148 TTL 8ENCODER
ENCODER
to-3 encoder.15
encoder.15 We
v\/e attach
attach the switch
switch outputs
outputs in inverse order,
since the 74LS148
active-low inputs
inputs and outputs.
74LS148 device
device has active-low
outputs. The
output of the encoder
encoder circuit
circuit is a 3-b,t
-b it representation
representation of the switch
switch position.
position. Many
output
switches include
include encoders so that their outputs
outputs are coded.
coded, usually
usually as a BCD digitit (in
switches
negative logicl.
logic).
negative

7
:::: 6

=

5

F4
-.:..::..3

i:::::
2
:::,

- T,io
-::- '213

:::::o

-

14

74LS148

15

8-to-3

15
17

Encoder

02

-

Oo

-

~,

PA2
::. PA1
PAo

To CPU

6522
VIA

µ

Common

-ultiple-Position Switch
Switch with
ith an Encoder
Figure 11-18. A Multiple-Position

1 1-56
56

The
The encoder
encoder produces
produces active-low
active-low outputs,
outputs. so.
so. for
for example,
example. switch
switch position
position 5,
5. which
which is
is
attached
output of
attached to
to input
input 2,
2. produces
produces an
an output
of 22 in
1nnegative
negative logic
logic (or
(or 55 in
in positive
positive logic).
logic).
You
You may
may w
want to
to verify
verily the
the double
double negative
negative for
for yourself.
yourself.

Flowchart:
Flowchart:
Start

Deta S'f"l'itchposition

Position:=0

Shift data
right 1 bit

Yes

PositK>n=
PositK>n+ 1

(0040) = Pos1t1on

End

Source Program:
LDA
LDA
STA
STA
STA
CHKSW
CHKSW LDA
LDA
CMP
CMP
BEQ
BEO
LDX
LDX
CHKPOS ROR
ROR
BCC
BCC
INX
INX
JMP
JMP
DONE
DONE
STX
STX
BRK
BRK

#00
VIAPCR
VIADDRA
VIADDRA
VIAORA
VIAORA
#$FF
#$FF
CHKSW
CHKSW
#00
A
DONE
DONE
CHKPOS
$40
$40

MAKE ALL
ALL CONTROL LINES INPUTS
:MAKE
MAKE PORT A LINES INPUTS
:MAKE
IS SWITCH
SWITCH IN A
A POSITION?
:IS
NO, WAIT
AIT UNTIL
UNTIL IT
IT IS
IS
:NO.
SWITCH POSITION =
= ZERO
ZERO
:SWITCH
IS NEXT BIT
BIT GROUNDED
GROUNDED POSITION?
POSITION?
:IS
YES, SWITCH
SWITCH POSITION
POSITION FOUND
:YES.
NO, INCREMENT
INCREMENT SWITCH
SWITCH POSITION
POSITION
:NO.
SAVE SWITCH
SWITCH POSITION
POSITION
:SAVE

11
-57
11-57

Object Program:
Program:
Memory Address
Memory
Address
(Hex)
(Hex)

0000
0001
00
0002
0003)
0003}
0004 (
0005
00
06)
0006}
0007)
0007
0008
00091
0009}
000A)
OOOA
000B
OOOC
oooc
000D
000E
OOOE
000F
OOOF
00
0010
00
0011
00
0012
0013
0014
0014
0015
0016
0017
0018
0018
0019
0 0
1 A
001A
0000
0001

Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

A9
00
88D

LDA
LOA

# 0

STA

VIAPCR
VIAPCR

STA

VIADDRA

LDA
LOA

VIAORA

CMP
CMP

#$FF

BEQ
BEO

CHKSW

LDX
LOX

#0

#0

00

VIAPCR
VIAPCR
8 D

8D

VIADDRA
CHKSW
CHKSW

AD
VIAORA
C9
FF
FF
FO
FO
F9
F9
A2
000
6
6A
90
04
ES
8
4C
11
11
0
00
8
86
40
0
00

CHKPOS
CHKPOS ROR
ROR
BCC
BCC

DONE
DONE

# 0

A
DONE
DONE

INX
JMP

CHKPOS
CHKPOS

STX

$40

BRK
BRK

faulty switch
itch or defective
defective VIA results in the input
input always
always being FF-|
0
Suppose that a faulty
FF15.
How could you change
change the program
program so that it would
would detect
detect this error?
could easily be restructured
restructured to make it
shorter and faster -— and relocatrelocat­
This program could
11 shorter
option would
would be to replace JMP CHKPOS
ith BCS CHKPOS;
why is
able as well. One option
CHKPOS with
CHKPOS: why
this possible and what
hat improvements
improvements result'
result? Another
Another option
option would
would be to change
change the
initial conditions
conditions so that only one jumpp instruction
instruction was required. How would
would you
initial
accomplish that? Hint:
Hint: start
start with
ith FF-|g
ent X before
accomplish
FF15 in Index Register X and increm
increment
shifting the Accumulator.
Accumulator.
shifting
example assumes that
that the switch
switch is debounced
debounced in hardware
hardware How would
would you
This example
change the program
program to debounce
debounce the switch
switch in software?
software?
change

11
-58
1-58

ait For S w
itch Position To Change
Task 2: Wait
witch
Purpose: The program
program waits
waits for the switch
switch position
position to change
change and places
places the new
position (decoded)
(decoded) into
into memory
memory location
location 0040.
0040. The program
program waits
waits until
until the
position
switch
itch reaches
reaches its neOv
position.
ne-lv position.

Flowchart:
Flowchart:
Start

Old data=

Position = - 1

Switch position

Shift data right 1 bit

New data=

Position=
Position+ 1

Switch pos1t1on

10040) = Position

End

Source Program:
LDA
LOA
STA
STA
CHKFST LDA
LOA
CMP
BEQ
BEO
TAX
CHKSEC LDA
LOA
CMP
BEQ
BEO
CPX
BEQ
BEO
LDX
LOX
CHKPOS INX
ROR
ROR
BCS
STX
BRK
BRK

#00
VIAPCR
VIADDRA
VIADDRA
VIAORA
VIAORA
#$FF
#$FF
CHKFST
VIAORA
VIAORA
#$FF
#$FF
CHKSEC
CHKSEC
VIAORA
VIAORA
CHKSEC
CHKSEC
#$FF
#$FF
A
CHKPOS
$40

MAKE ALL CONTROL LINES INPUTS
;MAKE
:MAKE PORT
PORT A LINES INPUTS
SWITCH IN A POSITION?
;IS SWITCH
NO. WAIT
AIT UNTIL IT IS
;NO,
:SAVE OLD POSITION
:IS SWITCH IN A POSITION?
NO. WAIT
AIT UNTIL IT IS
:NO,
:IS POSITION SAME AS BEFORE?
BEFORE?
YES. WAIT
AIT FOR
:YES,
FOR IT TO CHANGE
SWITCH POSITION AT -1
:NO, START SWITCH
SWITCH POSITION = SWITCH
SWITCH POSITION +
:SWITCH
+1
;IS NEXT BIT GROUNDED?
,NO, KEEP
KEEP LOOKING
STORE SWITCH
SWITCH POSITION
:STORE

11-59
11-59

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

LDA
LOA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

LDA
LOA

VIAORA

CMP

#$FF
#$FF

BEQ
BEO

CHKFST
CHKFST

TAX
CHKSEC
CHKSEC LDA
LOA

VIAORA

A9
00
8D

0000
0000
0001
0002
0002
0003)
0003}
0004)
0004
0005
0005
0006)
0006}
0007t
0007
0008
0008
0009)
0009}
000A)
OOOA
OOOB
000B
000C
oooc
000D
000E
OOOE
000F
OOOF
0010
0010
0011)
0011}
0012)
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018)
001B}
0019)
0019
001A
001A
001BB
001C
01C
001D
0010
001EE
001F
001F
0020
0020
0021
0022
0022
0023
0023
0024
0024

VIAPCR
8D
VIADDRA
VIADDRA
CHKFST

AD
VIAORA
C9
FF
FF
FO
FO
F9
AA
AD

VIAORA
C9
FF
FF
FO
FO
F9
EC
EC

CMP

#$FF
#$FF

BEQ
BEO

CHKSEC
CHKSEC

CPX

VIAORA

BEQ
BEO

CHKSEC
CHKSEC

LDX
LOX

#$FF
#$FF

VIAORA
FO
FO
F4
A2
FF
FF
E8
6A
BO
BO
FC
86
40
00

CHKPOS INX
ROR
ROR
BCS
STX

A
CHKPOS
CHKPOS

$40

BRK
BRK

alternative method
method for determ
ining if the switch
switch is in a position
position is:
An alternative
determining

CHKSW

INC
BEQ
BEO

VIAORA
VIAORA
CHKSW
CHKSW

Why
hy does this work?
work? What
hat happens
happens to the input
input data? Rewrite
Rewrite the program
program to use the
alternative method:
method; how much
much less memory
memory is required?
required?
alternative

1 1-60
60

Single LED
A Single
Purpose: To
To interface
interface a single
single light-em
itting diode
diode to a 6502
6502 microprocessor.
microprocessor. The LED
Purpose:
light-emitting
attached so that
that either
either aa logic
logic zero or a logic
logic one
one turns
turns itit on.
on.
can be attached
Circuit Diagram:
Diagram:
Circuit
Figure 11-19
11-19 shows
shows the
the circuitry
circuitry required
required to interface
interface an LED.
Figure
LED. The
LED
lights when
when its anode
anode is positive
positive w
ith respect
respect to its cathode
cathode
LED lights
with
CONTROL
CONTROL
Therefore, you can either
either light
light the LED by groundground­
(Figure 11-19a). Therefore.
cathode and having
having the com
puter supply
supply a one to the anode (Figure 11-19b)
11-19b) or
ing the cathode
computer
connecting the anode
anode to +55 volts
volts and having
having the com
puter supply
supply a zero to the
by connecting
computer
cathode (Figure 11-19c).
-19 c). Controlling
Controlling the cathode
cathode is the most
most common
common approach.
approach. The
cathode
LED is brightest
brightest when
when it operates
operates from
from pulsed
pulsed currents
currents of about
about 10 or 50 mA applied
applied a
hundred times
times per second. LEDs have a very
very short
short turn-on
turn-on time (in the microsecond
microsecond
few hundred
range) so they
they are well
well suited
suited to multiplexing
ultiplexing (operating
(operating several from a single
single port). LED
circuits usually
usually need peripheral
peripheral or transistor
transistor drivers
drivers and current-lim
iting resistors. MOS
circuits
current-limiting
devices normally
normally cannot
cannot drive
drive LEDs directly
directly and make them bright
bright enough
enough for easy
devices
viewing.
viewing.
output latch on each port. However.
However, the B port
port is normally
normally used
Note: The VIA has an output
output, since it has somewhat
somewhat more drive
drive capability.
capability. In particular.
particular, the B port
port outputs
outputs
for output.
are capable
capable of driving
driving Darlington
Darlington transistors
transistors (providing
(providing 3.0 mA m inim
um at 1.5 V).
inimum
V).
Darlington transistors
transistors are high-gain
high-gain transistors
transistors capable of switching
switching large amounts
amounts of
Darlington
current at high speed;
driving solenoids.
solenoids, relays,
current
speed: they are useful in driving
relays. and other devices.

116
11-61

Anode
de
Anodo^ ^ C a t h o
Cathode

R

+svo
f5
V Q-

8

-W V -

a)
a) Basic
Basic LED
LEOcircuitry.
circuitry. The
The resistor
resistor RR should
should limit
limit the
the maximum
maximum current
current to
to 50
50 mA
mA and
and
the
the average
averagecurrent
current to
to 10
10mA.
mA.

l

From CPU

6522

Driver

VIA

MD

+5V
b)
b)

Interfacing an
an LED
LED with positive logic. A logic •'1'
1· from the CPU
CPU turns the LED
LEO on.
on.

+5V

R
From CPU
6 522

Driver
Driver

VIA

MD

c)
cl

·o·

Interfacing an LED with
with negative
negative logic.
logic. A logic
logic '0 ' from
from the
the CPU turns
turns the
the LED on. The
The drrver
driver 01
or the
the
Interfacing
CPU may invert the
the logic
logic levels.
levels.

Figure 11-19. Interfacing
Interfacing an LED
Figure

11
-62
11-62

Task: Turn the Light On or Off

Purpose: The program
program turns
turns a single
single LED
either on or off.
LED either
A.

Send a Logic
Logic One to the LED (turn a positive
positive display
display on or a negative
negative display
display off).

Source Program:
initially)
(form data initially)
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA
BRK
BRK

#0
VIAPCR
#$FF
#$FF
VIADDRB
#MASKP
#MASKP
VIAORB

;MAKE
:MAKE ALL CONTROL LINES
LINES INPUTS
;MAKE PORT
:MAKE
PORT B LINES
LINES OUTPUTS
;GET
DATA FOR
:GET DATA
FOR LED
;SEND
DATA TO LED
:SEND DATA
LED

The B side of the VIA is used because of the buffering.
buffering. The CPU can therefore
therefore read the
output port.
data from the output

(update
(update data)
LDA
LOA
ORA
STA
BRK
BRK

VIAORB
#MASKP
#MASKP
VIAORB

;GET
:GET OLD DATA
;TURN
LED
:TURN
ONON
LED
BITBIT
;SEND DATA
DATA TO
TO LED
LED
:SEND

position and zeros elsewhere
elsewhere. Logically
Logically ORing with
ith
MASKP has a one bit in the LED position
affect the other
other bit positions,
positions, which
hich may contain
contain values
values for other
other
MASKP does not affect
LEDs.
that we can read the VIA Output
utput (Data) Register
Register even when
when the pins are
LEDs. Note that
assigned as outputs.
outputs.
assigned

11-63

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

(form
(form data initially)
initially)

B.
B.

0000
0000
0001
0002
0002
00031
0003}
0004)
0004
0005
0005
0006
0006
0007
0007
0008)
0008}
0009)
0009
000A
OOOA
000B
0008
OOOC
oooc
000DI
0000}
000E)
OOOE
000F
OOOF
(update data)

A9
00
80
8D

00

BRK
BRK

0010
0010
0011)
0011}
0012)
0012
0013
0013
0014
0014
0015
0015
0016)
0016}
0017)
0017
0018
0018

AD

LDA
LOA

VIAORB
VIAORB

ORA
ORA

#MASKP
#MASKP

STA
STA

VIAORB
VIAORB

LOA
LDA

#0

STA

VIAPCR
VIAPCR

LOA
LDA

#$FF

STA

VIADDRB

LDA
LOA

#MASKP
#MASKP

STA

VIAORB
VIAORB

VIAPCR

A9
FF
FF
80
8D
VIADDRB

A9
MASKP
8D
80
VIAORB

VIAORB
09
MASKP
8D
80
VIAORB
VIAORB
00

BRK
BRK

Send a Logic Zero to the LED
LED (turn a positive display off or
or a negative display on).
on).

The differences
differences are that MASKP must be replaced by its logical complement
complement MASKN
MASKN
#MASKP must be replaced by AND #MASKN.
#MASKN. MASKN has
and ORA #MASKP
has a zero
zero bit
bit in
in the
the
LED position
position and ones elsewhere. Logically
Logically ANDing with
ith MASKN does not
not affect the
the
other bit
bit positions.
other

1111-64

Seven-Segment
Seven-Segm
ent LED Display
Purpose:
LED display
disPurpose: To interface
interface a seven-segment
seven-segment LED
display to a 6502
6502 microprocessor.
microprocessor. The dis­
play
play may be either
either common-anode
common-anode (negative logic) or common-cathode
common-cathode
(positive
(positive logic).
Circuit
Circuit Diagram:
Diagram:

COMMON-ANODE
Figure
COMMON-ANODE
Figure 11-20
11-20 shows
shows the circuitry
circuitry required
required to interface
interface a
OR
seven-segment
one. two,
two.
OR
seven-segment display. Each segment
segment may have one,
COMMON-CATHODE
COMMON-CATHODE
or more LEDs .attached
attached in the same way. There are two
DISPLAYS
DISPLAYS
ways
ways of connecting
connecting the displays. One is tying
tying all the
cathodes
(see Figure 11-21a):
cathodes together
together to ground
ground (see
a); this is a
"common-cathode"
lights a segment. The other is
is
"com m on-cathode" display.
display, and a logic one at an anode lights
tying
(see Figure 11
11-21b);
bl: this is a
tying all the anodes together
together to a positive
positive voltage
voltage supply
supply (see
"common-anode"
"com m
on-anode" display.
display, and a logic zero at a cathode
cathode lights
lights a segment. So the common-cathode
mon-cathode display
display uses positive
positive logic and the common-anode
common-anode display
display negative logic.
Either
Either display
display requires
requires appropriate
appropriate drivers
drivers and resistors
resistors.
The Common
Common line from the display
display is tied either
either to ground or to +5 volts. The display
segments
customarily
segments are custom
arily labelled:
labelled:
a

b

f

9
e

c

d

seven-segment display
display is widely
idely used because it contains
contains the smallest num-­
Note: The seven-segment
separately controlled
controlled segments
segments that
that can provide
provide recognizable
recognizable representations
representations of
ber of separately
decimal digits
digits (see
Seven-segment displays can
all the decimal
(see Figure 11
11-22 and Table 11-13). Seven-segment
produce some letters
letters and other
other characters
characters (see
representa­
also produce
(see Table 11-14).
11-141. Better representa16 Since
tions require
require a substantially
substantially larger number
number of segments
segments and more circu
itry.1®
tions
circuitry.
seven-segment displays
displays are so popular.
popular, low-cost
low-cost seven-segment
seven-segment decoder/drivers
decoder/drivers have
seven-segment
have
become widely
idely available. The most popular
popular devices are the 7447 common-anode
common-anode driver
become
driver
7448 common-cathode
common-cathode driver;
river;17 these devices have Lamp Test inputs (that
and the 7448
turn all the segments
segments on) and blanking
blanking inputs
inputs and outputs
outputs (for blanking
blanking leading or
turn
or trail­
trailing zeros).
zerosl.

1111-65

De
Os
04

From CPU

~
---v

6522
VIA

MO

~

Di
o,

-

-- 9

-

-

--

-

f

Oriva's

-

e

d

Dilplly

- b
C

Co

0

Common

J__
Ll
1)

SV

+5V
PB7 may be used for a decimal point LED.

(Common-

(Common-

Cathode)

Anode)

Figure 11-20. Interfacing a Seven-Segment Display

Table 11-13. Seven-Segment
Seven-Segment Representations of Decimal Numbers

Hexadecimal
Hexadecimal Representation
Representation
Number
0
1
2
3
4
5
6
7
8
B
9

Common-cathode

Common-anode

3F
3F
06
5B
4F
66
6D
60
70
7D
07
7F
7F
67

40
79
24
30
19
12
12
02
7B
78
00
1B
18

Bit 7 is always zero
in decreasing order of
zero and the others are
are g.
g. f,f. e,
e. d.
d. c.
c. b,
b. and a in
significance.
significance.

11-66

a)

Common-cathode
Common-cathode

gO----------------- V A ( 0 ------------------------<W V- e

eO

W

r

d o ------------------------------- v w

-

co

-

w > -

b o --------------------- w v -

aO

W

r

b) Common-anode
Common-anode

+5V
5V

Q

g0

W

r

fO -------------------- v w eO

............

d o ------------------------------ v w

-

c o --------------------- w v -

bO--------------vw OO

V Ar

Seven-Segment Display
Display Organization
Organization
Figure 11-21. Seven-Segment

11-67

Segments f,f, e,
e, d.
d, c,
c. b,
b, •a ~
on
0: Segments

3: Segments
Segments g, d,
d, c, b,
b, a ~
on
3:

aa

aa

f

b

ee

c
C

b
b

9
c
C

d
d

d
d

1:
c, b
n
1: Segments
Segments c,
b o~

4: Segments
nts g,
on
g. f, c, b ~

b
b

ff

b

lb
9
cC

c
C

2:
a on
2: Segments g,
g, e,
e, d,
d, b.
b,12!!

5:
5: Segments
Segments g,
g, f, d.
d, c, aa on
~

a

a

ff

b
b

g9

g9

ee

cC

dd

dd

Figure
Figure 11-22
11-22. Seven-Segment
Seven-Segment Representations
Representations of
of Decimal
Decimal Digits
Digits

11-68
11-68

Segments g,
g, f,f, e.
e, d,
d, c,
c, aa on
~
6: Segments

8: Segments
Segments g,
g, f,f, e.
e, d,
d, c,
c, b,
b, aa on
~
8:

a

aa

bb

fI

f

9g

9

e

e

C
c

d
d
Note that the alternate
j^ ooff may
alternate representation
representattOnwith..!.
may
reserved for the lower case
case letter 'b'.
be reserved

cC

d
d
This
Lamp Test.
This is
is the
the same
same as
as lamp
Test.

9:
Segments g, f.f. c.
c, b.
b, aa on
2!'
9: Segments

7: Segments c, b, a ~
on

aa

a

f

b

bb

9
c
C

cC

An
An alternate
altemate has
has segment
segment d on
on also.
also,

Seven-Segment Representations
Representations of Decimal Digits (Continued)
Figure 11-22. Seven-Segment

Table 11-14. Seven-Segment
Seven-Segment Representations of Letters and Symbols
Table

Lower-case Letters
Letters
Lower-case
and Special Characters

Upper-case Letters
Letters
Upper-case

Letter
Letter

A
C
E
F
H
H
I
J
L
00
pP

uU
yY

Hexadecimal
Hexadecimal
Representation
Representation
Commoncathode

Commonanode

77
39
79
71
76
06
1E
38
3F
73
73
3E
66

08
46
06
0E
OE
09
79
61
47
40

Character
Character

b
c
C

d
h
n
00

r
u
-

OC
oc

??

41
19

11
-69
11-69

Hexadecimal
Hexadecimal
Representation
Representation
CommonCommonanode
cathode
7C
58
58
5E
5E
74
74
54
5C
50
1C
1C
40
40
53
53

03
03
27
27
21
21
0B
OB
2B
28
23
2F
2F
63
63
3F
3F
2C
2C

Task 1:1: Display
Display aa Decimal
Decimal Digit
Digit
Task
Purpose:
Purpose: Display
Display the
thecontents
contents ofof memory
memory location
location 0040
0040 on
onaaseven-segment
seven-segment display
display ifif
itit contains
contains aadecimal
decimal d ig
digit. Otherwise,
Otherwise. blank
blank the
the display.
display.

Sample Problems:
Problems:
Sample
a.a

(0040) == 05
05
(0040)
Result isis 55 on
on display
display
Result

66
(0040) ==66
b.b. (0040)
ResuIt isis aa blank
blank display
display
Result

Flowchart:
Flowchart:
Sten

Code= Blank
Data = 100401

Code = ISSEG +
Data)

Send code

to display

End

11
-70
11-70

Source Program:

DISPLY

LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
LDX
LOX
CPX
BCS
BCS
LDA
LOA

#00
VIAPCR
#$FF
#$FF
VIADDRB
#BLANK
#BLANK
$40
#10
10
DSPLY
SSEG.X
SSEG,X

STA
BRK
BRK

VIAORB

;MAKE ALL CONTROL LINES
:MAKE
LINES INPUTS
MAKE PORT
:MAKE
PORT B LINES OUTPUTS
GET BLANK CODE
:GET
:GET DATA
DATA 10 OR MORE?
:IS DATA
MORE?
YES. DISPLAY BLANKS
:YES,
DATA TO SEVEN-SEGMENT
.NO. CONVERT
CONVERT DATA
SEVEN-SEGMENT
: CODE
CODE
:SEND CODE
CODE TO DISPLAY

common-cathode display,
display, FF for a common-anode
common-anode display.
display. An alteralter­
BLANK is 00 for a common-cathode
native procedure
procedure would
would be to put
put the blank code at the end of the table and replace all
native
improper
proper data values with
ith 10, i.e., the instructions
instructions after
after STA VIADDRB are:

CNVRT

LDX
LOX
CPX
CPX
BCC
BCC
LDX
LOX
LDA
LOA

$40
#10
#10
CNVRT
#10
10
SSEG.X
SSEG,X

;GET
:GET DATA
;IS
DATA 10 OR MORE?
:IS DATA
MORE?
;YES.
:YES. REPLACE
REPLACE IT WITH 10
iCONVERT
DATA TO SEVEN-SEGMENT
:CONVERT DATA
SEVEN-SEGMENT CODE
CODE

either the common-cathode
common-cathode or common-anode
common-anode representation
representation of the
Table SSEG
SSEG is either
decimal digits
Table 11-13.
decimal
d1g1tsfrom Table

11-71
1171

Object Program:
Object
Program:
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004
004)
0005
0005
0006
0006
0007
0007
00
0 8)
0008}
0009)
0009
000A
000A
OOOB
000B
OOOC
oooc
000D
000E
000F
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015)
0015}
00161
0017
0017

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

A9
00
8D

LDA

#00

STA

VIAPCR

LDA

#$FF

STA

VIADDRB

LDA

#BLANK
#BLANK

LDX

$40

CPX
CPX

#100

BCS
BCS

DSPLY

LDA

SSEG.X
SSEG.X

STA

VIAORB

VIAPCR

A9
FF
FF
8D
VIADDRB
A9
BLANK
A6
40
EO
E0
OA
0A
BO
BO
02
B5
20
8D

DSPLY

VIAORB
BRK
BRK

00
SSEG
SSEG

0020-0029
0020-0029

(seven-segment
(seven-segment
code table)

displays may be multiplexed.
multiplexed, as shown
shown in Figure 11-23. A brief
brief strobe
strobe on concon­
Several displays
clocks the counter
counter and directs
directs data to the next display.
display. RESET
trol line CB2 clocks
RESET starts the
decimal counter
counter at 9 so that
that the first
first output
output operation
operation clears the counter
counter and directs
directs
decimal
first display.
display.
data to the first
ing program
program uses the delay routine
routine to pulse each of ten common-cathode
common-cathode
The follow
following
displays for 1 ms.
displays
ms.

1 1 -72
2

Task 2:
2: Display
Display Ten
Ten Decimal
Decimal Digits
Digits
Task
Purpose: Display
Display the
the contents
contents of
of memory
memory locations
locations 0040
0040 through
through 0049
0049 on
on ten 7-seg7-seg­
ment displays
displays that
that are multiplexed
ultiplexed with
ith aa counter
counter and a decoder.
decoder. The most
most
ment
significant d
ig it is in 0049.
0049.
significant
digit

Sample Problem:
(0040) = 66
(0041) = 3F
(0042) = 7F
(0043) = 7F
(0044) = 06
(0045) = 5B
(0046) = 07
(0047) = 4F
(004B) = 6D
(0048)
(0049) = 7D
displays read 653721
6537218804
The displays
B804
The cIrcuIt
circuit in
in Figure 11-23 uses the VIA handshake signal CB2 as a brief
brief output
output strobe
to indicate
occurrence of a data transfer.
1nd1catethe occurrence

Source Program:
Program:

SCAN
DSPLY

LDA
STA
LDA
STA
LDX
LDA
STA
JSR
JSR
DEX
DEX
BNE
BNE
BEQ
BEO

#$FF
VIADDRB
#% 1
0100000
10100000
VIAPCR
VIAPCR
#10
10
$3F,X
$3F.X
VIAORB
VIAORB
DELAY

.PROVIDE DATA READY
READY STROBE
STROBE
;PROVIDE
;NUMBER OF DISPLAYS== 10
;NUMBER
;GET
;GET DATA FOR
FOR DISPLAY
DISPLAY
;SEND DATA TO DISPLAY
;SEND
;WAIT
AIT 1 MS

DSPLY
DSPLY
SCAN
SCAN

;COUNT
:COUNT DISPLAYS
DISPLAYS
;START
;START ANOTHER
ANOTHER SCAN
SCAN

.MAKE PORT
PORT B LINES
LINES OUTPUTS
OUTPUTS
;MAKE

Peripheral Control
Control register bit 7 = 1 to
output, bit 6 = 1 to make it a pulse,
to make CB2
CB2 an output.
pulse.
that subroutine
DELAY
and bit 3 = 1 to make it a brief strobe. We have assumed here that
subroutine DELAY
has
modified to
transparent 1 ms
has been modified
to provide a transparent
ms wait.

1111-73

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

;

0000
0001
0002
0003)
0003}
00041
0005
0006
0007
0007
00081
0008}
0009
0 9'
000A
000A
000B
0008
OOOC
oooc
000D
000E
000F)
000F}
00101
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

LDA

#$FF

STA

VIADDRB
VIADDR8

LDA

#% 1
0100000
10100000

STA

VIAPCR

SCAN

LDX

#100

DSPLY
DSPLY

LDA

$3F,X

STA

VIAORB
VIAOR8

JSR
JSR

DELAY

DEX
DEX
BNE
8NE

DSPLY

BEQ
SEO

SCAN

A9
FF
FF
8D
VIADDRB
VIADDR8
A9
AO
AO
8D
VIAPCR
VIAPCR
A2
OA
0A
B5
85
3F
·8D
VIAORB
VIAOR8
20
30
00
CA
DO
DO
F5
FO
F0
F1
F1

11
-7 4
1-74

0D,
, C.
C, B.
B, and
and A (D
ID most
most significant.
significant, A
A
least
'east significant)
significant) are
are the
the 4-bit
4-bit output
output

DO

from
from the
the counter. These
Tilese 44 bits
bits activate
actrvate
the
the correspondingly
correspondingly numbered output
output
from
from the
the decoder,
decoder.and
and hence the
the cor
co,.
respondingly
respondingly numbered
numbe.-.ld display.

D1

D2

D3

D4

From CPU

6522
VIA
D5

06

D7

D8

09

9 88 77 66 55 4 4 3 32 2 1 0

D
Oock

7 4900

Decade
Counter
rR9

7 4422

C

4 to 10
Decoder/Driver
Decoder/Driver

B

A

Reset

Interfacing Multiplexed
ultiplexed Seven-Segment
Seven-Segment Displays
Figure 11-23. Interfacing

11
-75
11-75

PROBLEMS
n-O ff Pushbutton
Pushbutton
1) An On-Off
Purpose: Each closure
closure of the pushbutton
pushbutton complements
complements (inverts) all the bits in memory
memory
location 0040. The location
location initially
initially contains
contains zero. The program
program should
should concon­
location
tinuously examine
examine the pushbutton
pushbutton and complement
complement location
location 0040
0040 with
ith each
tinuously
complement a display
display output
output port instead.
instead, thus
closure. You may wish to complement
making the results easier to see.
making
see.
Sample Case:
Location 0040
0040 initially
initially contains
contains zero
zero.
Location
first pushbutton
pushbutton closure
closure changes
changes location
location 0040
0040 to FF15.
1 g, the second changes it
The first
back to zero,
third back to FF
1 q, etc. Assume
that the pushbutton
debounced in
zero. the third
FF15.
Assume that
pushbutton is debounced
would you include
include debouncing
debouncing in your
your program?
program?
hardware. How would

2)

Debouncing a S witch
itch in S o ftw
are
ftware

Purpose: Debounce
Debounce a mechanical
mechanical switch
switch by waiting
aiting until
until two readings,
de­
readings. taken a dethat the debounce
debounce time (in
bounce time apart,
apart. give the same result. Assume that
ms)
memory location
location 0040
0040 and store the switch
itch position
position in memory
ms) is in memory
location 0041.
location
Sample Problem:
(0040) = 03 causes the program to wait
ait 3 ms between
between readings.

3)

Control for a Rotary S witch
itch

Purpose:
nother switch
switch serves as a Load switch
switch for a four-position
four-position unencoded
unencoded rotary
Purpose: Another
switch. The CPU
waits for the Load switch
switch to close (be zero),
switch.
CPU waits
zero), and then reads
reads
the position
position of the rotary switch.
switch. This procedure
procedure allows the operator
operator to move
switch to its final position
position before the CPU
the rotary switch
CPU tries to read it. The pro­
program should place the position
position of the rotary switch
switch into memory location
0040. Debounce
Debounce the
switch in software.
the Load switch
Sample Problem:
Place rotary switch
itch in position
position 2.
2. Close Load switch.
Result:

(0040) == 02

1111-76

4)
4)

Record S w
itch Positions
Positions on
on Lights
Lights
Record
Switch

Purpose: AA set
set of
of eight
eight switches
switches should
should have
have their
their positions
positions reflected
reflected on
on eight
eight LEDs.
LEDs.
Purpose:
That is
is to
to say.
say, ifif the
the switch
switch is
is closed
closed (zero).
(zero), the
the LED
LED should
should be
be on.
on, otherwise
otherwise
That
the
the LED
LED should
should be
be off.
off. Assume
Assume that
that the
the CPU
CPU output
output port
port is
is connected
connected to
to the
the
cathodes of
of the
the LEDs.
LEDs.
cathodes
Sample Problem:
Problem:
Sample
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
Result:
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED

00
11
22
33
4
5
6
77

CLOSED
CLOSED
OPEN
OPEN
CLOSED
CLOSED
OPEN
OPEN
OPEN
OPEN
CLOSED
CLOSED
CLOSED
CLOSED
OPEN
OPEN

0
1
2
3
4
5
6
7

ON
OFF
OFF
ON
OFF
OFF
OFF
OFF
ON
ON
OFF
OFF

How would
ould you change the program so that a switch
switch attached
attached to bit 7 of Port A of VIA
#2 determines
determines whether
whether the displays are active (i.e
(i.e.,.. if the control
control switch
itch is closed,
closed. the
displays attached to Port B reflect the switches
switches attached to Port A;
A: if the control switch
open. the
the displays are
are always off)? A control switch is
is useful when the displays may
may
is open,
distract the
distract
the operator, as in an
an airplane.
airplane.
How would you change the
the program
program so
so that
that it makes
makes the control
control switch
switch an
an on-off
pushbutton; that
pushbutton:
that is,
is, each
each closure inverts
inverts the
the previous state
state of the
the displays?
displays? Assume
Assume
that the
the displays
displays start
start in
in the
the active
active state
state and
and that
that the
the program examines
examines and
and debounces
debounces
the
pushbutton before
the pushbutton
before sending
sending data
data to
to the
the displays.
displays.

5)
5)

Count on a Seven-Segm
ent Display
Seven-Segment

Purpose:
to 99 continuously
Purpose: The
The program
program should
should count
count from
from 0Oto
continuously on
on aa seven-segment
seven-segment dis­
display.
play, starting
starting w
with zero.
zero.
Hint:
hat happens.
Hint: Try
Try different
different tim
timing lengths
lengths for
for the
the displays
displays and
and see
see w
what
happens. W
When does
does
the
the count
count become
become visible?
visible? W
What happens
happens ifif the
the display
display is
is blanked
blanked part
part of
of the
the time?
time?

11-77
11-77

MORE COMPLEX I/O
1/0 DEVICES
complex I/O
devices differ
differ from simple
simple keyboards.
keyboards, switches.
switches, and displays
displays in that:
More complex
1/0 devices
1)
1)
2)
3)

transfer data at higher
higher rates.
They transfer
their own
own internal
internal clocks and timing.
timing.
They may have their
produce status
status inform
ation and require
require control
control information.
information, as well
well as
They produce
information
transferring data.
transferring

their high data rates,
cannot handle
handle these I/O
devices casually. If the
Because of their
rates. you cannot
1/0 devices
provide the appropriate
appropriate service.
service, the system may miss input
input data or
processor does not provide
produce erroneous
erroneous output
output data. You are therefore
therefore working
working under
under much
much more exacting
exacting
produce
constraints than in dealing
dealing with
ith simpler
simpler devices. Interrupts
Interrupts are a convenient
convenient method for
constraints
handling complex
complex I/O
devices, as we shall see in Chapter
Chapter 12,
handling
1/0 devices.
12.
keyboards, teletypewriters.
teletypewriters, cassettes,
SYNCHRONIZING
Peripherals such as keyboards.
cassettes.
SYNCHRONIZING
and floppy
floppy disks produce
produce their
their own internal
internal timing.
timing. These
WITH I/O
WITH
1/0
devices provide
specific tim-­
DEVICES
provide streams of data,
data. separated by specific
ing intervals. The computer
puter must
must synchronize
synchronize the initial
initial inin­
output operation
operation with
ith the peripheral
peripheral clock and then provide
provide the proper
proper interval
interval
put or output
between subsequent
subsequent operations. A simple
simple delay loop like the one shown previously
previously can
between
produce
ing interval. The synchronization
produce the timing
synchronization may require one or more of the follow
follow-­
ing procedures:
procedures:
1)
1) Looking
Looking for
for aa transition
transition on
on aaclock
clock or
or strobe
strobe line
line provided
provided by
by the
the peripheral
peripheral for
for tim
tim-­
ing purposes. The simplest
simplest method
method is
control line and wait
ait
Is to tie the strobe to a VIA control
u ntil
til the appropriate
appropriate bit of the VIA Interrupt
Interrupt Flag register
register is
Is set.
set.
2)

Finding the center
center of the time interval
interval during
during which
hich the data is stable. We would
would
Finding
prefer to determine
determine the value of the data at the center
center of the pulse rather than at
the edges,
changing. Finding the center
center requires a delay of
edges. where the data may be changing.
one-half of a transmission
transmission interval
interval (bit time) after the edge. Sampling
Sampling the data at
one-half
the center
center also means that small timing
ing errors have
little effect
effect on the accuracy
accuracy of
have little
the reception.

3) Recognizing
Recognizing aa special
special starting
starting code.
code This
This isiseasy
easy ifif the
the code
code isIsaasingle
single bit
bit or
or ifif we
we
have some timing
ing information.
information. The procedure
procedure is
complex if1f the code is long
Is more complex
and could start at any time. Shifting
Shifting will
ill be necessary to determine
determine where the
transm
itter is starting
starting its bits,
characters, or messages (this is
transmitter
bits. characters.
Is often called a search
for the correct
correct "fram
ing").
"framing").
4)
4)

Sampling the data several times. This reduces the probability
receiving data in­
Sampling
probab1l1ty of receiving
incorrectly from noisy lines.
ajority logic (such
correctly
lines. Maiority
(such as
as best 3 out of 5 or 5 out of 8)
8) can
be used to
to decide on the actual data value.
value.

lt than transmission.
transmission, since the
peripheral con­
Reception is,
Is. of course,
course. much more d ifficu
1ff1cult
the peripheral
controls
reception and the computer
puter must interpret
interpret tim
ing information
ation generated by
trols the reception
timing
the peripheral. In transmission,
computer provides the
ing and
atting
transmission. the
the computer
the proper timing
and formatting
for
for a specific peripheral.
Peripherals may
ation besides
CONTROL
may require or provide
provide other information
data and tim
ation transm
itted by
AND STATUS
timing. We refer to other information
transmitted
the
puter as
"control inform
ation"; itIt may select modes of
the computer
as "control
information";
INFORMATION
INFORMATION
operation,
operation. start
start or
or stop processes,
processes. clock
clock registers,
registers. enable
buffers,
buffers. choose formats
formats or
or protocols,
protocols. provide operator
operator displays,
displays. count operations,
operations. or
identify the
priority of
ation transmitted
transmitted
identify
the type
type and
and priority
of the
the operation.
operation. W
We refer to
to other inform
1nformat1on
by the
peripheral as
"status inform
ation"; itit may indicate
indicate the
the peripheral
as "status
information";
the mode of
of operation,
operation. the
the
readiness
conditions, the
at of
readiness of
of devices,
devices. the
the presence
presence of
of error
error conditions.
the form
format
of protocol
protocol in use.
use. and
and
other
conditions.
other states
states or
or conditions.

1111-78

information
The computer
puter handles control
control and status inform
ation just
just like data. This information
information
seldom changes,
though actual data may be transferred at a high rate. The control
control
changes. even though
information
or status inform
ation may be single bits.
bits, digits.
digits, words.
words, or multiple
ultiple words. Often single
bits or short fields are combined
combined and handled by a single input
input or output
output port.
Combining status and control
control information
ation into bytes reduces the total number
number of I/O
Combining
1/0
port addresses required by the peripherals. However,
However. the combination
bination does mean that
individual status input
input bits must be separately interpreted
interpreted and control
control output
output bits must
individual
resetbe separately determined.
determined. The procedures for isolating
isolating status bits and setting
setting or reset­
control bits are as follows:
follows:
ting control

Separating Out Status Bits

SEPARATING
STATUS
INFORMATION
INFORMATION

1)
Step 1)

Read status data from the peripheral
Read

2)
Step 2)

Logical AND with
ith a mask (the mask has ones in bit
sitions
examined
pos
itio n s thatt must
ust be exam
ined and zeros
elsewhere)

Step 3)

Shift the separated bits to the least significant
significant bit positions
Shift

------

BIT TEST
Is unnecessary if the field is a single bit,
bit. since the Zero
Step 3 is
INSTRUCTION
complement
flag will
ill contain
contain the complem
ent of that bit after Step 2 (try it!).
A Shift
Shift or Load instruction
instruction can replace Step 2 if the field is
Is a
single bit and occupies
occupies the least significant.
significant, most significant.
significant, or next to most significant
significant
bit position (positions 0,
0. 7,
7. or 6).
6). These positions
positions are often reserved for the most frefre­
quently
sequently used status information.
information. You should try to write
write the required instruction
instruction se­
particular, the use of the Bit Test instruction.
instruction.
quences for the 6502 processor.
processor. Note,
Note. in particular.
instruction performs a logical AND between the contents
contents ofofthe
ulator and
This instruction
the Accum
Accumulator
and
the flags are
are set
set as
the contents
contents of a memory location but does not save the result:
result; the
as
follows:
result. 0 if it does not.
Zero flag== 1 if the logical AND produces a zero result,
Sign flag = bit 7 of the contents
contents of the memory location (independent
(independent of the value in
the Accumulator).
Accumulator).

Overflow
Overflow flag = bit 6 of the contents
contents of the memory location (independent
(independent of the value
in the Accumulator!.
Accumulator).

COMBINING
COMBINING
CONTROL
Read
information
Read prior
prior control
control information
INFORMATION
INFORMATION
Step 2)
Logical AND
AND w
ith mask to clear bits
bits (mask has zeros
2) Logical
with
zeros
in bit positions
positions to be cleared.
cleared, ones elsewhere)
OR with
(mask has ones in bit positions
set. zeros
zeros
Step 3) Logical
Logical OR
ith mask to set bits (mask
positions to be set,
elsewhere)
Step 4) Send
Send new
new control
control information
ation to peripheral

Setting and Clearing Control
Control Bits
Step 1)

bit and
Here again the procedure is simpler
simpler if the field is a single
single bit
and occupies
occupies aa position
position at
at
either
either end of the byte.

11
-79
1-79

Someexamples
examplesofofseparating
separating and
andcom
combining
statusbits
bitsare:
are:
Some
bining status
1)1) AA3-bit
uput (Data)
3-bit field
field ininbit
bit positions
positions 22through
through 44ofofaaVIA
VIAOOuput
(Data)register
register isisaascaling
scaling
factor. Place
Placethat
that factor
factor into
into the
theAccumulator.
Accumulator.
factor.

;READ
READSTATUS
STATUSDATA
DATA FROM
FROMINPUT
INPUTPORT
PORT
LDA
LDA

VIAOR
VIAOR

;READ STATUS DATA
;READ STATUS DATA

:MASK
MASK OFF
OFFUNWANTED
UNWANTED BITS
BITSAND
AND SHIFT
SHIFTRESULT
RESULT
AND
AND
LSR
LSR
LSR
LSR

*%00011100
#% 000
1
AA
AA

:MASKSCALING
SCALINGFACTOR
FACTOR
;MASK
:SHIFT
TO NORMALIZE
:SHIFT TWICE
TO TWICE
NORMALIZE

2) The
The Accum
Accumulator
contains aa2-bit
2-bit field
field that
that must
must be
be placed
placed inin bit
bit positions
positions 33 and
and 44
2)
ulator contains
of aa VIA
VIA Output
Output (Data)
(Data) register.
register.
of

$0040
TEMP== $0040
TEMP
MASK == %
%11100111
11100111
MASK
: MOVE
MOVE DATA
DATA TO
TO FIELD
FIELD POSITIONS
POSITIONS
ASL
ASL
ASL
ASL
ASL

AA
AA
AA

;SHIFT DATA
DATA TO
TO BIT
BIT POSITIONS
POSITIONS 33 AND
AND 44
:SHIFT

AND
STA
STA

#% 00
0 1000
*%00011000
TEMP
TEMP

;CLEAR
:CLEAR OUT OTHER
OTHER BITS
BITS

COMBINE NEW FIELD
FIELD VALUE WITH OTHER
OTHER DATA
COMBINE
DATA
LDA
LDA
AND
AND
ORA
ORA
STA
STA

VIOADR
HMASK
HMASK
TEMP
TEMP
VIOAR
VIOAR

;CLEAR FIELD
FIELD TO BE
BE CHANGED
CHANGED
:CLEAR
;COMBINED NEW
NEW DATA
DATA WITH
WITH OLD
OLD
:COMBINED
;OUTPUT COMBINED
COMBINED DATA
DATA
:OUTPUT

Documentation
Documentation 1s
is aa serious
serious problem
problem 1n
in handling
handling control
control and
and
DOCUMENTING
DOCUMENTING
status
status information.
information. The
The meanings
meanings of
of status
status inputs
inputs or
or control
control
STATUS AND
AND
STATUS
outputs
outputs are
are seldom
seldom obvious.
obvious. The
The programmer
programmer should
should clearly
clearly inin­
CONTROL
CONTROL
dicate
dicate the
the purposes
purposes of
of input
input and
and output
output operations
operations in
in the
the comcom­
TRANSFERS
TRANSFERS
ments,
ments, e.g,
e.g., "CHECK
"CHECK IF
IF READER
READER IS
IS ON,"
ON," "CHOOSE
"CHOOSE EVEN
EVEN
PARITY
PARITY OPTION,"
OPTION, or
or "ACTIVATE
ACTIVATE BIT
BIT RATE
RATE COUNTER."'
COUNTER." The
The Logical
Logical and
and Shift
Shift instrucinstruc
tions
willill otherwise
difficult
tions w
otherwise be
be very
very d
ifficu lt to
to remember,
remember, understand,
understand, or
or debug.
debug.

1
1-80
11-80

EXAMPLES
EXAMPLES
An Unencoded Keyboard
Purpose: Recognize a key closure from an unencoded
unencoded 3 xx 33 keyboard and place the
number
that was pressed into the Accumulator.
Accumulator.
number of the key that
Keyboards
(see Figure 11
11-24). Small numbers of keys
keys are
are
Keyboards are just
just collections
collections of switches
switches (see
easiest to handle
1feach key is attached
handle if
attached separately
separately to a bit of an input
input port. Interfacing
Interfacing
the
the keyboard
keyboard is then the same as interfacing
interfacing a set of switches.
MATRIX
Keyboards
MATRIX
Keyboards with
ith more than eight
eight keys require more than one input
input
port
KEYBOARD
port and therefore
therefore multibyte
ultibyte operations. This is particularly
particularly
wasteful
terwasteful if the keys are logically
logically separate.
separate, as in a calculator
calculator or ter­
minal
minal keyboard
keyboard where
where the user will
ill only strike one at a time. The number
number of input
input lines
required
matrix. as shown in Figure
required may be reduced
reduced by connecting
connecting the keys into a matrix,
11-25.
11-25. Now
Now each key represents
represents a potential
potential connection
connection between
between a row and a column.
The keyboard
+ m external
lines. where
Is the number
keyboard matrix
atrix requires
requires n +
external lines,
where n is
number of rows and
m is the number
sepanumber of columns.
columns. This compares
compares tonn x m external
external lines if each key is sepa­
rate. Table 11-15
11-15 compares
compares the number
number of keys required
required by typical
typical configurations.
configurations.

KEYBOARD
A program
program can determine
determine which
hich key has been pressed by using
SCAN
the external
external lines from the matrix. The usual procedure
procedure is a
.."keyboard
keyboard scan
... We ground
scan."
ground Row 0 and examine the column
column
lines. If any lines are grounded.
pressed, causing a row-togrounded, a key in that
that row has been pressed,
column connection.
connection. We can determine
determine which
which key was pressed by determ
ining which
which
column
determining
columnn line is grounded:
Is zero.
zero. If no column line is
Is
colum
grounded; that
that is, which
hich bit of the input
input port is
grounded, we proceed to Row 1 and repeat the scan.
grounded,
scan. Note that we can check to see
see if1f
grounding all the rows at once and examining
examining the
any keys at all have been pressed by grounding
the
columns.
columns.
keyboard scan requires
requires that
that the row lines be tied to an output
output port and the column
column
The keyboard
lines to an input
CPU can ground a par­
parinput port. Figure 11-26 shows the arrangement.
arrangement- The CPU
ticular row by placing
placing a zero in the appropriate
appropriate bit of the output
output port and ones
ticular
ones in the
the
other bits.
other
determine the state of a particular
particular column
column by examining
examining the appropriate
appropriate
The CPU can determine
bitit of the input
input port.

Table 11-15. Comparison
Comparison Between
Between Independent
Independent Connections
Connections
Table
atrix Connections
Connections for Keyboards
and Matrix

Keyboard Size
Keyboard

Number of Lines with
ith
Number
Independent Connections
Independent

Number of Lines with
Number
Ma
trix Connections
atrix

3 xX 33
4x4
x4
4x6
x6
5 xX 55
6 xX 66
6 xX 88
8x8
x8

9
16
24
25
36
48
64

6
8
10
10
12
14
16

1 1-81
81

+5V

------------0

I

Key 1

J_

+5V

Key 2

f

J_

------------0

r

--------4I

Key 3

J_
o

....______

Each key is a switch just like a pushbutton and grounds an input bit if it is pressed.

Figure 11-24. A Small Keyboard

mn 1
Colu
Column

Colu
mn 0
Column

J

Key 0 .

AowO

>
'

“ > < /

*

K 9v4' y

Z 5
Ksy 3 v

Rowl

Colu
mn 2
Column

(

w
/>

Key 6 v

►

c/

i

)

^

Key 8

►

w
/

Row 2

Each
w 11 to
nee, key
Each key
key now
now serves
serves to
to connect
connect aa rov
row to
to aa column.
cotumn. For
For insta
instance.
key 44 connects
connects ro
row
to column
column 1.
1.

--------------------Figure 11-25.
11-25. A
A Keyboard
Keyboard Matrix
11-82
11-82

Column 0

C~umn 1

Cotumn2

Datallul
(from CPU)

VIA

Output
Port

01 1--------+--------+----IJ---+--Row

1

VIA
Input

Port

Data Bus Ito CPU)

Figure 11-26. I/O
Arrangement for
1/0 Arrangement
for a Keyboard
Keyboard Scan
Scan

11-83
11-83

Task
1:: Determine
Task 1
Determine Key
Key Closure
Closure
Purpose:
ait for
Wait
for aa Key
Key to
to be
be Pressed.
Pressed.
Purpose: W
The
The procedure
procedure is
is as
as follows:
follows:
1)
output bits.
1) Ground
Ground all
all the
the rows
rows by
by clearing
clearing all
all the
the output
bits.
2)
2)

Fetch the
column inputs
the column
inputs by
by reading
reading the
the input
input port.
port.

3)
3)

Return to
column inputs
to Step
Step 11 ifif all
all the
the column
inputs are
are ones.
ones.

WAITING
WAITING
FOR
FOR A
KEY
KEY CLOSURE
CLOSURE

Flowchart:
Flowchart:
Start

Ground all
keyboard rows

End

Source Program:

WAITK

LDA
STA
LDA
STA
STA
STA
LDA
AND
CMP
BEQ
BEO
BRK

#$FF
VIADDRB
#0
VIAPCR
VIADDRA
VIADDRA
VIAORB
VIAORA
#% 0 0
0 0 0 1 11
00000111
#% 00
0 0 0 1 11
00000111
WAITK
WAITK

;MAKE PORT
PORT B LINES OUTPUTS
;MAKE ALL CONTROL LINES INPUTS
;MAKE PORT
PORT A LINES INPUTS
;GROUND ALL KEYBOARD ROWS
COLUMN DATA
DATA
;GET KEYBOARD COLUMN
MASK COLUMN
COLUMN BITS
:MASK
ANY COLUMNS
COLUMNS GROUNDED?
:ARE ANY
NO, WAIT
AIT UNTIL ONE IS
:NO.

11
-84
11-84

Object Program:
Object
Program:
Memory Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0003)
0003}
00041
0005
0005
0006
0006
0007
0007
0008)
0008}
0009)
0009
000A
000A
000
B)
0008}
000C)
oooc
000D
000EI
000E}
000F)
0010
0010
0011)
0011}
00121
0013
0013
0014
0014
0015
0016
0017
0018
0018
0019
0019

Memory Contents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
FF
FF
8D
SD

LDA

#$FF

STA

VIADDRB

LDA

#00

STA

VIAPCR
VIAPCR

STA

VIADDRA

STA

VIAORB

LDA

VIAORA

AND

#% 00
000 1
00000111

CMP

#% 00
000 1
00000111

BEQ
BEO

WAITK

VIADDRB
A9
00
8D
SD
VIAPCR
VIAPCR
8D
SD

VIADDRA
8D
SD

VIAORB
VIAORB
AD

WAITK

VIAORA
29
07
C9
07
FO
F0
F7
00

BRK
BAK

VIA Port B Is
output port and Port A is the input
input port.
is the keyboard output
Masking off all but the column
column bits eliminates
eliminates any problems
problems that could
could be caused by
Masking
input lines
lines.
the states of the unused input
We could
could generalize the routine
routine by naming the output
output and masking
maskingpatterns:
patterns:
ALLG
OPEN
OPEN

=%11111000
=%
11111000
=%00000111
=%00000111

These names could then be used in the actual
actual program;
program; a different
different keyboard would
would re­
redefinitions and a
and a
re-assembly.
quire only a change in the definitions
re-assembly.
Of course, one port of a VIA is all that
that isisreally
reallynecessary
necessaryfor
foraa33x 3 or
or44 x 4 keyboard.
riting the proqram
program so that it uses
Try rewriting
lIses only Port A.

11-85

Task 2: Identify
Identify Key
Purpose:
Accumulator.
Purpose: Identify
Identify a key
key closure by placing the number of the
the key into the
the Accumulator.
The procedure is as follows:
follows:
1)
1)

Set
output port to all ones except for
Set key number to
to -1. keyboard output
for a zero
zero in bit 0,
0,
and
counter to number of rows.
and row counter
rows.

2)
2) Fetch
Fetch the
the column
column inputs
inputs by
by reading
reading the
the input
input port
port.
3)
3) IfIf any
any column
column inputs
inputs are
are zero,
zero. proceed
proceed to
to Step
Step 7.7.
4)
4)

Add the number of columns to the key number
number to reach next row.
row.

5)
5) Update
Update the
the contents
contents of
of the
the output
output port
port by
by shifting
shifting the
the zero
zero bit
bit left
leftone
oneposition.
position.
6)
other­
6) Decrement
Decrement row
row counter.
counter. Go
Go to
to Step
Step 22 ifif any
any rows
rows have
have not
not been
beenscanned,
scanned. otherto Step 9.
9.
wise go to
7)
7) Add
Add 11 to
to key
key number.
number. Shift
Shift column
column inputs
inputs right
right one
one bit.
bit.
8)
return to
to Step
Step 7.7.
8) IfIf Carry
Carry == 1,1, return
9)
9) End
End of
of program.
program.

Flowchart:
Flowchart:
Start

Key Number = • 1
Counter = Number
of rows
Keyboard output port
=11111110 (binary)

Yes

Key Number=
Key Number + 1
Shift column inputs
right 1 bit

Update keyboard
output port by
shifting contents
left arithmetically

Key Number=
Key Number+
Number of Columns
Counter=Counter ~ 1

Yes

End

11
-86
1-86

Source Program:
Program:
Source

FROW
FROW

FCOL

LDA
STA
STA
STA
STA
LDA
STA
STA
TAX
TAX
LDA
LDA
STA
LDY
LDY
LDA
AND
CMP
BNE
BNE
TXA
TXA
CLC
ADC
TAX
ASL
DEY
BNE
BAK
BRK
INX
LSR
BCS
BAK
BRK

#0
#0
VIAPCR
VIAPCR
VIADDRA
VIADDRA
#$FF
#$FF
VIADDRB
VIADDRB
##%11111110
% 1 1111110
VIAORB
VIAORB
#3
#3
VIAORA
VIAORA
#%00000111
#%00000111
#%00000111
#% 000
0 1 11
FCOL
FCOL

;MAKE ALL
ALL CONTROL
CONTROLLINES
LINESINPUTS
INPUTS
;MAKE
:MAKE PORT
PORTAA LINES
LINESINPUTS
INPUTS
;MAKE
:MAKE PORT
PORTBBLINES
LINESOUTPUTS
OUTPUTS
;MAKE
;KEY
:KEYNUMBER
NUMBER==-1-1
;STARTBY
BYGROUNDING
GROUNDINGROW
ROWZERO
ZERO
:START
;COUNTER
:COUNTER== NUMBER
NUMBEROF
OFROWS
ROWS
;GET
:GETCOLUMN
COLUMN INPUTS
INPUTS
;ISOLATE
:ISOLATECOLUMN
COLUMNBITS
BITS
;ARE
:AREANY
ANY COLUMNS
COLUMNS GROUNDED?
GROUNDED?
;YES,
:YES.GO
GODETERMINE
DETERMINEWHICH
WHICH ONE
ONE
;NO.
:NO. MOVE
MOVE KEY
KEYNUMBER
NUMBERTO
TONEXT
NEXT ROW
ROW

#3
#3

;BY
;BY ADDING
ADDING NUMBER
NUMBER OF
OFCOLUMNS
COLUMNS

VIAORB
VIAORB
FROW
FROW

;UPDATE
:UPDATE SCAN
SCAN PATTEN
PATTEN FOR
FORNEXT
NEXTROW
ROW
;HAVE
:HAVE ALL
ALL ROWS
ROWS BEEN
BEENSCANNED?
SCANNED?
;NO,
;NO. SCAN
SCAN NEXT
NEXT ONE
ONE

AA
FCOL
FCOL

;KEY
KEY NUMBER
NUMBER ++ 11
:KEY NUMBER
NUMBER ==KEY
;IS
.ISTHIS
THIS THE
THECOLUMN
COLUMN GROUNDED?
GROUNDED?
;NO,
:NO. EXAMINE
EXAMINE NEXT
NEXT ONE
ONE

11
-87
11-87

Object Program:
Object
Program:
Memory
MemoryAddress
Address
(Hex)
(Hex)
0000
0001
0001
0002
0003)
0003}
0004)
0005
0006)
0006}
0007)
0008
0009
000A
OOOA
000
B)
000B}
000C)
000D
000E
OOOE
OOOF
OOOF
0010
00111
0011}
0012)
0013
0014
0015
0016)
0016}
0017)
0018
0019
001A
001
001B
001C
001D
0010
001E
001F
0020
0021
0021
0022
0023
0024)
0024}
0025)
0026
0027
0028
0029
002A
002B
002B
002C
002C
002D
002D
002E
002E

oooc

Memory
MemoryContents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
A9
00
8D
VIAPCR
VIAPCR
8D

LDA
LOA

#0

STA
STA

VIAPCR
VIAPCR

LD
LD
STA
STA

A,00001111B
A.00001111
VIADDRA
VIADDRA

LDA
LOA

#$FF

STA
STA

VIADDRB
VIADDRB

TAX
TAX
LDA
LOA

#% 1
1111110
11111110

STA
STA

VIAORB
VIAORB

LDY
LOY

#3

LDA
LOA

VIAORA
VIAORA

AND
AND

# % 0 0 000111
1 11

CMP
CMP

# % 0 0 000111
1 11

BNE
BNE

FCOL
FCOL

TXA
TXA
CLC
CLC
ADC
ADC

#3

TAX
TAX
ASL
ASL

VIAORB
VIAORB

DEY
DEY
BNE
BNE

FROW
FROW

BRK
BRK
INX
LSR
LSR
BCS
BCS

A
FCOL
FCOL

VIADDRA
VIADDRA
A9
A9
FF
FF
8D
VIADDRB
VIADDRB
AA
AA
A9
A9
FE
FE
8D
VIAORB
VIAORB
AO
AO
03
AD
AD

FROW
FROW

VIAORA
VIAORA
29
07
C9
C9
07
DO
DO
OC
8A
BA
18
18
69
03
AA
AA
OE
OE

oc

VIAORB
VIAORB
88
DO
DO
EC
EC
00
E8
E8
4A
BO
BO
FC
FC
00

FCOL
FCOL

BRK
BRK

1 1-88
88

Wee have included
included a CLC instruction
instruction for clarity.
clarity, but
but it is not
not actually
actually necessary. The only
which the BNE instruction
instruction does not cause a branch
branch is the one in which
hich the two
case in which
operands used in CMP are equal. In that
that case,
always set to indicate
indicate
operands
case. the Carry flag is always
that no borrow
borrow has been generated.
generated. So we could
could replace
replace the sequence
sequence
that
CLC
ADC

##3
3

;BY
;BY ADDING
ADDING NUMBER
NUMBER OF
OF COLUMNS
COLUMNS

with
ith the single
single instruction
instruction

ADC

#2
#2

;BY
;BY ADDING
ADDING NUMBER
NUMBER OF
OF COLUMNS
COLUMNS (NOTE
(NOTE
; CARRY== 1)
1)

Each
fails, we must
must add the number
number of columns
columns to the key number
number to
Each timee a row scan fails.
current row (try the procedure
procedure on the keyboard
keyboard in Figurt
Figure 11-26).
move past the current
What
hat is the result
result of the program
program if no keys are being
being pressed? Change
Change the program
program so
that it starts the scan over again in that
that case.
could insert
insert an extra INX instruction
instruction
that
case. We could
first BRK.
a t would
would the final
final value be in Index Register X if no keys were
before the first
BRK. What
ould it be different
different from the case in which
hich the highest
highest numbered
numbered key
being pressed? Would
that the Zero flag could also be used to distinguish
distinguish the case
was being pressed? Note that
where no keys were pressed. Can you explain
explain how?
where
how7
An alternative
alternative is to use the bidirectional
bidirectional capability
capability of the VIA. The procedure
procedure would
would be:
2)

1)
1)

columns and save the row inputs.
Ground all the columns
column inputs.
Ground all the rows and save the column

3)

Use the row and column
inputs together
number from a table.
column inputs
together to determine
determine the key number

write a program
program to implement
implement this procedure.
Try to write
This program
program can be generalized
generalized by making the number
number of rows,
number of colcol­
rows. the number
umns,
pattern into named parameters
parameters with
ith EQUATE
pseudo­
umns. and the masking pattern
EQUATE (=) pseudooperations.

1111-89

An Encoded Keyboard18
Keyboard18
Purpose: Fetch data,
when it is available,
data. when
available. from an encoded keyboard that provides a
ith each data transfer.
strobe along with
An encoded keyboard provides a unique
unique code for each key.
internal electronics
electronics
key. It has
has internal
scanning and identification
identification procedure
procedure of the previous example. The
that perform the scanning
tradeoff is between
between the simpler
simpler software required by the encoded keyboard and the
tradeoff
unencoded keyboard.
lower cost of the unencoded
Encoded keyboards may use diode matrices,
matrices. TTL encoders,
encoders. or MOS encoders. The
codes may be ASCII,
encoding
ASCII. EBCDIC,
EBCDIC. or a custom code.
code. PROMs
PROMs are often part of the encoding
circuitry.
circuitry.
The encoding
encoding circuitry
circuitry may do more than
just encode key
^ROLLOVER]
tha-n just
!ROLLOVER!
closures.
debounce the keys and handle "rollover."
"rollover," the
closures. It may also debounce
problem of more than one key being struck at the same time. Common ways of
handling rollover
rollover are: "2-key
"2-key rollover,"
rollover," whereby
whereby two keys (but not more) struck at the
handling
same time are resolved into separate closures,
"n-key rollover."
rollover," whereby
whereby any
closures. and "n-key
number of keys struck at the same time are resolved into separate closures.
closures.
The encoded keyboard also provides a strobe with
ith each data transfer. The strobe sigsig­
nals that a new closure has occurred. Figure 11
interface between
between an enen­
11-27 shows the interface
coded keyboard and the 6502 microprocessor. The 6522
6522 Versatile
Versatile Interface
Interface Adapter
Adapter
input latching
latching on both Ports A and B:
setting bit
provides input
B; these latches are enabled by setting
I1 (for Port B)
Auxiliary Control
Control register
register (see
B) or bit 0
O (for Port A) of the Auxiliary
(see Figure 11-10). In
this mode,
input pins is latched when the Interrupt
Interrupt flag is set and wil
mode. the data on the input
not change until
until the Interrupt
Interrupt flag is cleared. Note that
that the latching
latching works somewhat
somewhat
differently on the B side,
contents of the Output
utput register
register are latched if the pin
differently
side. where the contents
is programmed
programmed as an output.
The keyboard strobe is tied to input
input CA1.
transition on the strobe line causes InterInter­
1. A transition
Control register (see
O of the Peripheral Control
(see Figure
rupt Flag Register bit 1 to go high. Bit 0
II
determines whether
whether the VIA recognizes high-to-low
high-to-low transitions
transitions on CA11 (bit 0
O = 0)
0)
11-9) determines
or low-to-high
low-to-high transitions
transitions (bit 0
contains an edge-sensitive
edge-sensitive latched
O = 1). Thus the VIA contains
contains an inverter
inverter that can be used to handle
status port as well as a data port. It also contains
strobes of either
either polarity. A VIA can replace many simple circuit
circuit elements;
elements: you can
make corrections
corrections in circuit
circuit logic by changing
changing the contents
contents of the Control
Control registers (in
software) rather than by rewiring
rewiring a breadboard. For example.
example, changing
changing the active edge
requires the changing
changing of a single program bit. whereas it might
ight require additional
additional parts
and rewiring
rewiring on a breadboard.

p~

Data Bus (
to CPU

I(

.
~ Keyboard Data Inputs

PA7

'

CA 1

-

6522

'

VIA

Keyboard Strobe

Figure 11-27. 1/0 Interface for an Encoded Keyboard

11-90
11
90

Task: Input
Input from
from Keyboard
Keyboard
Task:

Purpose: W
a it for
tor an
an active-low
active-low strobe
strobe on
on VIA
VIA control
control line
line CA
CA1 and
and then
then place
place the
the
Wait
Purpose:
data
Accumulator.
data from
from Port
Port AA into
into the
the Accum
ulator. Note
Note that
that reading
reading the
the data
data from
from the
the
Output
bitit in
O
utput (Data)
(Data) register
register clears
clears the
the status
status b
in the
the Interrupt
Interrupt Flag
Flag register
register (this
(this
circuitry is
is part
part of
of the
the 6522
6522 VIA).
VIA).
circuitry
Flowchart:
Flowchart:
Start

Read Interrupt Flag
Register

Read Output
(Data) Register

End

The hardware must hold the
control lines in
'1' state during reset to
prevent the
the control
In a logic T
to prevent
the
accidental setting
setting of status flags.
initial read
accidental
flags. An initial
read of the Data (Output) registers in the
startup routine may be used to
to clear the status flags.
flags. As
As noted earlier,
earlier. you can also clear
bits in the
Interrupt Flag
ritin g logic
'1's into them.
the 6522
6522 Interrupt
Flag register
register by
by w
writing
logic Ts
them.

Source
Source Program:
Program:
LDA
LOA
STA
STA
STA
STA
LDA
LOA
STA
STA
LDA
LOA
KBWAIT
KBWAIT BIT
BIT
BEQ
BEG
LDA
LOA
BRK
BAK

##0
VIAPCR
VIAPCR
VIADDRA
VIADDRA

;MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
;MAKE
;MAKE PORT
PORT A
A LINES
LINES INPUTS
INPUTS
;MAKE

#%00000001
#%00000001
VIAACR
VIAACR

#%00000010
#%00000010
VIAIFR
VIAIFR
KBWAIT
KBWAIT
VIAORA
VIAORA

;ENABLE LATCHING
LATCHING ON
ON PORT
PORT AA
ENABLE
;GET PATTERN
PATTERN FOR
FOR EXAMINING
EXAMINING CA
FLAG
GET
CA11 FLAG
;IS THERE
THERENEW
NEW KEYBOARD
KEYBOARD DATA?
DATA7
IS
;NO. W
WAIT
UNTIL THERE
THEREIS
IS
NO.
AIT UNTIL
YES.
;YES. FETCH
FETCHDATA
DATA

1 191
11-91

Object Program:
Object
Program:
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003
0003} >
0004)
0004
0005
0005
0006)
0006}
0007)
0007
0008
0008
0009
0009
000A
OOOA
000
BI
OOOB}
000C)
oooc
000D
0000
000E
OOOE
000F
OOOF
0010)
0010}
0011)
0011
0012
0012
0013
0013
0014
0014
0015)
0015}
0016)
0016
0017
0017

Memory Contents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
00
8D
80

LDA
LOA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

LDA
LOA

#%00000001
00000001

STA

VIAACR

LDA
LOA

#%00000010
00000010

BIT

VIAIFR

BEQ
BEO

KBWAIT
KBWAIT

LDA
LOA

VIAORA

VIAPCR
8D
80
VIADDRA
VIADDRA
A9
01
8D
80
VIAACR
A9
02
2C

KBWAIT
KBWAIT

VIAIFR
FO
FO
FB
FB
AD

VIAORA
BRK
BRK

00

status bit
bit respond to low-to-high
-to-high transitions
transitions on CA1,
must set bit 0
(J of
To make the status
1, you must
the Peripheral
Peripheral Control
Control register.
other handshake
handshake status
status flags are bits 0
CB2). and 4 (for CB1)
The other
O (for CA2),
CA2). 3 (for CB2l.
1I of the
Interrupt Flag register.
Interrupt
Show that
that reading
reading the Output
utput (Data)
register clears the status
status flag. Hint: save the concon­
Show
(Data) register
Interrupt Flag register
register in memory
memory before the instruction
instruction LDA
ex­
tents of the Interrupt
LOA VIAORA is exhat happens
happens if you replace LDA
ith STA? How about
about CMP, INC,
ecuted. What
LOA with
INC. ROL?
ROL? Note
that either
either reading
reading or writing
ritin g the Output
utput (Data)
register clears the status
status bit. What
hat haphap­
that
(Data) register
pens if you read Port A from the non-handshaking
non-handshaking address (see
hat hap­
(see Table 11-7)?
11-7)7 What
hapith LDA
pens if you replace LDA
LOA VIAORA with
LOA VIAORB?7

1 1-92
92

nalog C onverter19
22
A Digital-to-A
Digital-to-Analog
Converter19-22
Purpose: Send
Send data
data to
to an 8
-b it digital-to-analog
digital-to-anaiog converter,
converter, which
which has
has an
an active-low
active-low
Purpose:
8-bit
latch enable.
latch
Digital-to-analog converters
converters produce
produce the continuous
continuous signals
signals required
required by motors.
motors,
Digital-to-analog
actuators, and
and other
other electrical
electrical and mechanical
mechanical output
output devices. Typical
Typical converconver­
heaters, actuators,
ters consist
consist of
of switches
switches and resistor
resistor ladders with
ith the appropriate
appropriate resistance
resistance values. You
ters
must generally
generally provide
provide a reference
reference voltage
voltage and some other
other digital
digital and analog
analog circuitry.
circuitry,
must
although complete
complete units
units are becoming
becoming available
available at low
low cost.
although
Figure 11-28
11-28 describes
describes the 8-bit
-b it Signetics
Signetics NE5018 D/A
/A converter,
converter, which
which contains
contains an
Figure
on-chip 8-bit
-b it parallel
parallel data input
input latch. A low
low level on the LE (Latch Enable) input
input gates
on-chip
input data into
into the latches.
latches, where
where it remains
remains after
after LE goes high.
the input
Figure 11-29
11-29 illustrates
illustrates the interfacing
interfacing of the device
device to a
Figure
D/A
D/A CONVERTER
6502 system. Note that
that the B side of the VIA autom
atically
6502
automatically
INTERFACE
produces the active-low
active-low strobe
strobe required
required to latch the data
produces
into the converter:
converter; CB2 acts as an Output
utput Ready signal. Remember
Remember that
that CB2 autom
at­
into
automatically goes low for one cycle follow
ing a write
write operation
operation on the B port
(Data)
ically
following
port O
Output (Data)
register if ifCB2
CB2 is in the pulse output
output mode (see
register
(see Table 11-9). The Peripheral
Peripheral Control
Control
register bits are:
register
output
Bit 7 = 1 to make CB2 an output
Bit 6 = 0 to make CB2 a pulse
brief Output
utput Ready strobe (one clock
Bit 5 = 1 to make CB2 a brief
clock cycle
cycle
in duration).
ration).
Note that the VIA contains
contains an output
output latch. The data therefore remains stable during
during
and after
after the conversion.
conversion. The converter
microseconds to
converter typically
typically requires only a few microseconds
produce an analog output.
output. Thus, the converter
converter latch could be left enabled if the port
produce
were not used for any other purpose.
purpose.
In applications
applications where eight
eight bits of resolution
resolution are not enough, 10- to 16-bit
16-bit converters
converters
can be used.
used. Additional
Additional port logic is required to pass
pass all the data bits; some converters
converters
provide part of this logic.
The VIA here serves
control port. CB2
serves both as a parallel data port and as
as a control
CB2 is a pulse
that lasts one clock cycle after the data is latched into the VIA. This pulse is long
enough to
to meet the
the requirements
requirements (typically
(typically 400 ns)
ns) of the NE5018 converter.

1111-93

DB7
MSB

DBS

DB4

DB2

DBI

DBO

Digital
GND

LSB

latches and
S'Nitch Drivers

Sum

Vee

Node

A
INT VAEF
VREF

VOut

Out

1 1 -9 4

'

(0
.j>,

OAC Current
Output

Amp
Comp

VREF
Adi

Analog
OAC Switches

VREF
In

-

GND

R

Bipoar

Offoet

Vee

All R values equal 5 kn and are thermally matched

Figure 11-28. Signetics
D/A Converter
Converter
Figure
S1gnet1es NE5018 D/A

Analog

Data Bus
Bus
from CPU

2i

...

6522

r

VIA

)>

PB7
PBo
PB0

-

)
V

r

CB2

NE5018
NE5018

Output

D/A
Converter

LE
i:e

cb2

f+

I

_
_
_
_
_

Interface for an 8-bit
8-bit Digital-to-Analog
Digital-to-Analog Converter
Converter
Figure 11
11-29 Interface

11-95
11-95

--

-

Task: Output to Converter
Converter

Purpose:
Purpose: Send
Send data from
from memory location 0040 to the
the converter.
Flowchart:

(
C

Start

)

i
Data -= (0040)

•
•"
C E
♦

Send
Send data to
to

converter
converterand
and

1

latch
latch itit

End

J)

Source Program:
LDA
STA
LDA
STA
LDA
STA
BRK
BAK

#$FF
#$FF
VIADDRB
VIADDRB
#% 1
0100000
10100000
VIAPCR
$40
VIAORB

;MAKE
;MAKE PORT
PORT B LINES OUTPUTS
;PROVIDE BRIEF
BRIEF LATCH ENABLE STROBE
STROBE
;GET DATA
DATA
:SEND
DATA TO DAC AND LATCH
;SEND DATA

11-96
11-96

Object Program:
Object
Program:
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004)
0004
0005
0005
0006
0006
0007
0007
00081
0008}
0009)
0009
000A
OOOA
0
00B
OOOB
oooc
oooc
000D|
000D}
000EI
OOOE
000F
OOOF

Memory Contents
Contents
Memory
(Hex)
(Hex)

A9
FF
FF
8D

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LDA
LOA

#$FF
#$FF

STA

VIADDRB

LDA
LOA

#% 1
0100000
10100000

STA

VIAPCR

LDA
LOA

$40

STA

VIAORB

VIADDRB
A9
A0
AO
8D
VIAPCR
A5
40
8D
VIAORB
00

BRK
BRK

The pulse for the Latch Enable input
input is produced
produced autom
atically when
when data is stored in
automatically
Output
utput (Data) Register B.
however, that
that the pulse is a fairly
fairly brief
brief one. lasting
lasting only
B. Note,
Note. however.
one clock cycle;
cycle; this may be insufficient
insufficient for some applications.
applications.
Wee could use the level (manual) output
output from CB2 if the Latch
Latch Enable signal
signal were acac­
tive-high
length were
were greater. The program
program would
would then be.:
tive-high or if the required
required length
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
STA
LDA
STA
LDA
STA
BRK
BRK

#$FF
#$FF
VIADDRB
#%11000000
11000000
VIAPCR
$40
VIAORB
#% 1
1100000
%11100000
VIAPCR
#% 1
1000000
%11000000
VIAPCR

;MAKE PORT
PORT BE
BE LINES
LINES OUTPUTS
OUTPUTS
;MAKE LATCH ENABLE A LEVEL
LEVEL (LOW)
(LOW)
:MAKE
;GET
;GET DATA
;SEND DATA
DATA TO DAC OUTPUT PORT
PORT
;OPEN
:OPEN DAC LATCH (ENABLE
(ENABLE HIGH)
HIGH)
;LATCH
DATA (ENABLE
:LATCH DATA
(ENABLE LOW)

Here bit
bit 6 of the Peripheral
Peripheral Control
Control register
register is set to make CB2 a level with
ith a value given
by bit 5 of the Peripheral
Peripheral Control
Control register. This is referred to as the Manual
Manual Output
utput mode
in 6522
6522 literature
literature. Note how many more instructions
instructions are required
required to pulse the Latch
Enable than in the previous
previous example.
example, since no automatic
automatic pulse is provided.
provided. An inverter
inverter
could also be used to invert
invert the polarity
polarity of the strobe.
gate could
In the Manual
Manual mode,
completely independent
independent of the parallel
parallel data port. It is
mode. CB2 is completely
simply a control
control output
output that
that is available
available for any purpose. The only problem
problem involved
involved in
simply
that you must
must not accidentally
accidentally change
change any of the other
other bits in the Peripheral
Peripheral
using it is that
Control register.
register, since they may have unrelated
unrelated functions.
functions.
Control

11-97

Analog-to-Digital
Analog-to-D
igital Converter19-23
onverter19-23
Purpose: Fetch data from an 8-bit
-b it analog-to-digital
analog-to-digital converter
converter that
Purpose:
that requires a Start
Conversion pulse to start the conversion process and provides an End of
output to indicate
indicate the completion
completion of the process and the
Conversion output
availability of valid data.
availability
Analog-to-digital converters
converters handle the continuous
continuous signals produced by various types
Analog-to-digital
of sensors and transducers. The converter
converter produces the digital
digital input
input which
hich the comcom­
puter requires.
puter
requires.
analog-to-digital converter
converter is the successive approxim
ation device.
device, which
which
One form of analog-to-digital
approximation
makes a direct
direct 1-bit
1-bit comparison
comparison during
during each clock cycle. Such converters
converters are fast but
have little noise immunity.
immunity. Dual slope integrating
integrating converters
converters are another
another form of
analog-to-digital converter. These devices take longer but are more resistant
resistant to noise.
analog-to-digital
noise.
techniques, such as the incremental
incremental charge balancing
balancing technique.
technique, are also used.
Other techniques.
used.
Analog-to-digital
nalog-to-digital converters
converters usually require some external
external analog and digital
digital circuitry.
circuitry,
although complete
complete units
units are becoming
becoming available at low cost.
although
Figure 11-30 contains
contains a general description
description and a timing
ing diagram for the National
MM5357
M5357 8-bit
-b it A/D converter. The device contains
contains output
output latches and tristate
tristate data outout­
puts. A pulse on the Start Conversion (STRT
conversion of the analog
(STRT CONV)
CONV) line starts conversion
input; after
after about
about 40 clock cycles (the converter
converter requires a TTL level clock with
ith a
input:
m inim
um pulse width
id th of 400 ns),
ill go to the output
output latches and the End of
inimum
ns). the result will
Conversion (EOC)
output will
ill indicate
indicate this by going high. Data is read from the latches
(EOC) output
by applying
applying a T
'V to the Output
utput Enable input. Figure 11-31 shows the connections
connections for
the device and some typical
typical applications
applications circuits.
circuits.
Figure 11-32 shows the interface
interface for the 6502 processor
A/D CONVERTER
A/0
and the 5357 A/D converter. Control
Control line CA2 is used in the
INTERFACE
utput mode to provide a Start Conversion
Manual (Level)
(Level) Output
pulse (active-high)
(active-high) of sufficient
sufficient length. The End
control
End of Conversion signal is tied to control
line CA11 so that EOC
ill set bit 1 of the Interrupt
Interrupt Flag register. The imporimpor­
EOC going high will
low-to-high edge,
which indicates
indicates the
tant edge on the End of Conversion line is the low-to-high
edge. which
completion of the conversion. Note that we are using the 6522
6522 device to handle both
completion
control input
input and control
control output.
output, since the converter
converter interface
interface involves a complete
complete
control
handshake. The Output
utput Enable pin on the converter
converter is tied high,
plac­
high. since we are not placing the data directly
directly on the processor's tri-state
tri-state data bus.
bus. Note (see
(see Figure 11-30) that
the converter
converter data outputs
outputs are complementary
complementary binary (all zeros
zeros is full-scale).

11-98

NATIONAL
ATIONAL
MM
5 3 5 7 8-bit
-b it /I
M5357
General Description
Description
The M M5357
5 3 5 7 is an
monolithic A/0
/D converter using P-channel ion-implanted
technology. It contains
an 8-bit
8-bit monolithic
ion-implanted MOS technology.
a high input impedance comparator,
comparator, 2 5 6 series
output latches.
series resistors and analog switches,
switches, control logic and output
Conversion is performed
performed using a successive approximation
approximation technique where the unknown analog voltage is
compared to the resistor tie points using analog switches.
switches. When the appropriate
appropriate tie point
point voltage matches the
unknown voltage, conversion is complete
complete and
complementary binary word
and the digital outputs contain an 8-bitit complementary
corresponding
output is tri-state
tri-state to permit bussing on common
common data lines.
corresponding to the unknown. The binary output

Features
■
■
■
■
■
■
■
■

Low cost
±55 V, 10 V input ranges
ranges
No
No missing codes
High input impedance
Ratiometric conversion
Ratiometric
Tri-state outputs
Tri-state
Contains output latches
TTL compatible
compatible

Key Specs
■

Resolution

■

Linearity
Conversion speed
speed
Input impedance
Supply voltages
Clock range
range

■
■
■
■

8 bits
±1/
2 LSB
1/2
LSB
40/xs
40µs
> 1 00 MO
ft
+5 V, -12 V, GND
GNO
5.0 kHz
kHz to 2.0 MHz
MHz

Timing
ing Diagram::

v-n

j \Ua Ua UA a a a a a a a j

Clock +
+5 V — j

n

n

fl

ovJ

Input
Input

0 V

+5v-r7..
Start + 5 V

Z T Y
V
ov-l

Conversion

0

~1-------------------~

+ 55 V

EOC +

/11------<1..,
- 4 0 X (l1 / f ) -

V \l-\44-------440
0 V

— la—

•

--------------·,--------------.!

VOutput ++ 5 V
Output
Enable
Enable

ov---------~~---•1

0 V -

+ 55 V -

Data +

(Tri-state)

V - ~i~~eJ.

ov

- -

-s -

- ~•,----M
-J?-

0 V Enable___
Enable
Delay
Delay
Data
complementary binary (full scale is "Os"
"Os" output).
Data is complementary

□

r

Disable _
Delay
Delay

Description and Timing
Timing Diagram
Diagram for the National
National 5357 A/D
Figure 11-30. General Description
Converter
Converter

1 1 -99
99

Connection Diagram
Diagram
Connection

2-4
2-“ .
2-3
-3 2-2
-2 .
IMSBI
(MSB) 2·' 1
1-

1B
17
17
16
1R
15
10
14
14
13
1^
12
11
11

- Voo
V DD

10

" vVss
ss

2·1
2
'1
22-2

MSB

2
2
3

4
5
6
7
8
9

R Network
Network STRT C O
NVSTAT
ONV
Output Enable
EnableOutput

VGG "
VG
E OC -

M M5357
5357
A/0
/D
Converter

2-5
-2-5

- 2·6
2-6
+VAEF
"+
REF
-2 2-7
2-8 (LSB)
ILS81
- 2‘

VIN
-V |
Clock
"Clock

Typical Application
Application
Typical

+55 V-

15 M

+ V REF

10

2
-6
2-3

-5 V

R NET

2-4

Digital

Vq
g M M5357
357
GG
VIN
,N
A/0
/D

22·-b5

Output
Output

CK

SC
SC

2-7
2-B
2-8

■ LSB
LSB

OE
OE

EOC

End of Conversion
Conversion
• End

O

GND
GND

O

vss
>

+55 V

-12 V

12
Analog Input
11
Clock
6*

Start Conversion
Conversion

Output Enable
Enable

7*

2
2·-b6

2-1

Converter

/

+ 5 V < V iN < -5 V

Connection Diagram and Typical
Typical Application
Application for
Figure 11-31. Connection
for the
the National 5357
5357
A/D Converter

Data Bus
Bus

Analog
Analog

to
to CPU
CPU

c

,

.

....

6 5 222

PA
p
a 77

VIA

N --------------------PA
q
PA(J

National
National

Input
Input

55357
357
A
/D
AID
Converter
Converter
STRT
STAT

C
A,
CA1

C
A2
CA2

EOC
EOC

CONV
CONV

Figure 11-32. Interface for
Analog-to-Digital Converter
for an
an 8-b,tit Analog-to-Digital
Converter

1111-100

Task:
Task: Input from Converter
Converter
Purpose:
conversion process,
ait for End
Conversion to
process. Wait
End of Conversion
to go low and then
Purpose: Start the conversion
high,
memory location
location 0040.
high. and then read the data and store it in memory
F lo wchart:
Start

Pulse Start
Conversion
Line

Read data from
Data Input port

(00401 = Data

End

that here the VIA serves as a parallel
parallel data port.
port, a status
status port,
control port.
Note that
port. and a control
Source Program:
Program:

WTEOC

LDA
LOA
STA
LDA
LOA
STA

#00
VIADDRA
VIADDRA
#%00001101
#%00001101
VIAPCR

LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
AND
BNE
LDA
LOA
EOR
EOR
STA
BRK
BRK

#% 00
0 1 111
%00001111
VIAPCR
#%00001101
#%00001101
VIAPCR
VIAIFR
#%
00000010
#%00000010
WTEOC
VIAORA
VIAORA
#% 1
%111111111
$40
$40

;MAKE PORT
PORT A LINES INPUTS
;BRING START CONV LOW,
EOC
;BRING
LOW. ENABLE EOC
; LOW TO HIGH
;PULSE START CONVERSION HIGH
iPULSE
;PULSE START CONVERSION LOW

;IS CONVERSION COMPLETE?
COMPLETE-?
WAIT
;NO. WAIT
;YES,
DATA FROM CONVERTER
;YES. FETCH
FETCH DATA
CONVERTER
iCOMPLEMENT DATA
DATA FOR
;COMPLEMENT
FOR TRUE VALUE
DATA
;SAVE CONVERTER
CONVERTER DATA

11-101
1-101

Object Program:
Object
Program:
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004)
0004
0005
0005
0006
0006
0007
0007
0008)
0008}
0009)
0009
000A
OOOA
000B
OOOB
000C
oooc
000D)
OOOD}
000E)
OOOE
OOOF
OOOF
0010
0010
0011
0012)
0012}
0013)
0013
0014
0014
0015)
0015}
0016)
0016
0017
0018
0019
001A
01A
001BB
001C)
001C}
' 0010D)
001E
001E
001F
001F
0020
0021
0022

Memory Contents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
00
8D

LDA

#00

STA

VIADDRA
VIADDRA

LDA

#% 00
0 0 101
%00001101

STA

VIAPCR

LDA

#%0000111111
#%00001

STA

VIAPCR

LDA

#% 00
0 0 101
00001101

STA

VIAPCR

LDA

VIAIFR

AND

#%00000010
00000010

BNE
BNE

WTEOC

LDA

VIAORA

EOR
EOR

# %11111111
1 1111111

STA

$40

VIADDRA
VIADDRA

A9
OD
8D
VIAPCR
A9
OF
OF
8D
VIAPCR
A9
OD
OD
8D
VIAPCR
AD

WTEOC

VIAIFR
29
02
DO
DO
F9
AD
VIAORA
49
FF
FF
85
40
00

BRK
BRK

The VIA Peripheral
Peripheral Control
Control register
register bits are:
are:
Bit 3 = 11 to
output
to make CA2 an output
Bit 2 = 1 to
utput mode)
to make CA2 a level (Manual Output
mode)
Bit 11 = value of level on CA2
Bit 0O = 1 to set Status flag
flag on a low-to-high
low-to-high transition
transition on CA1
CA 1
Note that
Postindexed mode. The starting
starting address of
that VIAs can be
be addressed using the
the Postindexed
the VIA
locations on page zero:
VIA (VIAORB)
(VIAORB) is placed in tw
two memory locations
zero: all
all VIA registers can
then
ith appropriate
appropriate offsets in
then be
be reached with
in Index
Index Register Y.
Y.

1102
11-102

A T ele ty
p e w rite r (TTY)
eletypewriter
Purpose: Transfer
Transfer data to and from a standard
standard 10-character-per10-character-perteleypewriter.
second serial teleypewriter.

TTY
INTERFACE

common teletypewriter
teletypewriter transfers data in an asynchronous
asynchronous
The common
procedure is as follows:
follows:
serial mode. The procedure
normally in the one state.
The line is normally
Start bit (zero
A Start
(zero bit) precedes each character.

STANDARD
STANDARD
TTY

3)

The character
character is usually
usually 7-bit
7-bit ASCII with
ith the least significant
significant
itted first.
bit transm
transmitted

CHARACTER
FORMAT
FORMAT

4)

The most significant
significant bit is a Parity bit. which
which may be even,
odd, or fixed at zero or one.
one.
Two stop bits (logic one)
follow each character.
Two
one) follow

1)
1)
2)

5)

Figure 11-33 shows the format. Note that each character
character requires the transmission
transmission of
eleven bits, of which
hich only seven contain
contain information.
information. Since the data rate is ten characcharac­
ters per second, the bit rate is 10 x 11,
therefore has a width
id th of
11, or 110 Baud. Each bit therefore
1/110 of a second, or 9.1
milliseconds. This w idth
th is an average: the teletypewriter
teletypewriter
1/110
9.1 milliseconds.
does not maintain
maintain it to any high level of accuracy.

One stat __

_

Zero state

~...._ ·o·
'1'

_____

'1'

Brt

·o·

____

......,,,,,,,..

·o·

·o·

'O'
_,,,"-::~~
..._
'1'

7 Data Bits

Parity

Stop

Stop

Bit

Bit

Bit

O,aroctor is ASCII 'E' with odd parity (45 hex).
Remember that the ttan11miuionorder is Start bit

l"O'l.bit o,bit 1, bit 2, bit 3, bit 4, bit 5, bit 6, Parity
bit, Stop bit ('1'), Stop bit l'1'1.

Figure 11-33. Teletypewriter Data Format

For a te le typ
e w rite r to communicate
communicate properly with
ith a computer, the following
ing pro­
letypewriter
procedures are necessary.
Receive (flowcharted
(flowcharted in Figure 11-34):
Step 1)
1) Look
Look for
for aa Start
Start bit
bit (a
(a logic
logic zero)
zero) on
on the
the data
data line.
line
Step 2)
2)

Center
aiting one-half bit
Center the
the reception by
by waiting
bit time,
time, or
or 4,55
4.55
milliseconds.

TTY
RECEIVE
RECEIVE
MODE

Step 3)
aiting one
3) Fetch
Fetch the
the data
data bits,
bits, wwaiting
one bit
bit time
time before
before each
each one.
one.Assemble
Assemblethe
thedata
data
bits into a word by first
shifting the
circularly shifting
shifting
first shifting
the bit to the
the Carry
Carry and
and then
then circularly
the data with the
significant bit
the Carry.
Carry. Remember that
that the
the least significant
bit is
is received
first.
first.
Step 4)
4)

Generate
itted Parity.
Generate the received Parity
Parity and check it against
against the transm
transmitted
Parity. If
they
indicate aa "Parity
"Parity error."
they do not
not match,
match, indicate

Step
Step 5)
5)

Fetch the Stop
Stop bits
bits (waiting
(waiting one
one bit
bit tim
time between
between inputs).
inputs). IfIf they
they are
are not cor­
correct (if
ing error."
(if both
both Stop bits
bits are
are not
not one),
one). indicate
indicate aa "fram
"framing
error."

11-103
11-

Start

Get input data
(i.e., is parity =
received parity ?)

Parity
error

Wait one-half

Count = 2

bit time

Count

8

Data

0

Wait one bit time

Wait one bit time

Get input data

Get input data
Carry = Input data
Shift data right
with Carry

Framing

Count = Count-1

error

Count = Count - 1

Generate
received parity

End

Figure 11-34. Flowchart
Flowchart for Receive Procedure
Procedure

1,
_, 04
11-104

Task 1. Read Data
Fetch data from a teletypewriter
teletypewriter through
through bit
bit 7 of a VIA data
data port
port and place
Purpose: Fetch
into memory
memory location
location 0060.
0060. For procedure.
procedure, see Figure
Figure 11-34.
the data into

Source Program:
(Assume
Is bit 7 of the VIA and that
framing
Is
(Assume that
that the serial
serial port
port is
that no parity
parity or fram
ing check
check is
necessary)

WAITS
WAITS

TTYRCV

LDA
LOA
STA
STA
LDA
LOA
BMI
JSR
LDA
LOA
JSR
ROL
ROL
ROR
ROR
BCC
BCC
STA
BRK
BRK

#00
VIAPCR
VIADDRA
VIADDRA
VIAORA
VIAORA
WAITS
WAITS
DLY2
#%10000000
10000000
DELAY
PIADRA
A
TTYRCV
$60

:MAKE ALL CONTROL LINES INPUTS
MAKE PORT
.MAKE
PORT A LINES INPUTS
BIT?
.IS THERE
THERE A START BIP
.NO. WAIT
WAIT
,YES. DELAY HALF BIT TIME TO CENTER
CENTER
WITH BIT IN MSB
.COUNT WITH
W
AIT 1 BIT TIME
.WAIT
DATA BIT
.GET DATA
ADD DATA
.ADD
DATA BIT TO DATA
DATA WORD
.CONTINUE IF COUNT BIT NOT IN CARRY
CARRY

(Delay program)
program)

DLY2
DELAY
DLY1
DLY

LDY
LOY
BNE
BNE
LDY
LOY
LDX
LOX
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
RTS
RTS

#5
DLY1
DLY1
#10
10
#$B
#$B44

.COUNT FOR
FOR 4.55
55 MS
.COUNT FOR
FOR 9.11 MS
:GET
FOR 0.91 MS
GET COUNT FOR

DLY
DLY1
DLY1

Remember that bit 0
received first.
Remember
O of the data is
Is received

11-105
11105

Object Program:
Program:

MemoryAddress
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0001
0002
0002
0003
0003})
0004)
0005
0005
0006)
0006}
0007)
0008
0008
0
009)
0009}
OOOA)
OOOA
000B
0008
OOOC
OOOD
000D
000E
OOOE
000F
OOOF
0010
0010
0011
0011
0012
0012
0013
0013
0014
0014
0015
0015
0
016)
0016}
0017)
0018
0018
0019
0019
001A
0 018
B

oooc

:

MemoryContents
Contents
Memory
(Hex)
(Hex)
A9
A9
00
8D

LDA
LOA

#0

STA
STA

VIAPCR
VIAPCR

STA
STA

VIADDRA
VIADDRA

LDA
LOA

VIAORA
VIAORA

BMI
BMI

WAITS
WAITS

JSR
JSR

DLY2
DLY2

LDA
LOA

# % 10000000
0000000

VIAPCR
VIAPCR
8D
8D
VIADDRA
VIADDRA
AD
AD

WAITS
WAITS

VIAORA
VIAORA
30
FB
FB
20
30
00
A9
A9
80
20
34
00
2E
2E

TTYRCV
TTYRCVJSR
JSR

DELAY
DELAY

ROL
ROL

VIAORA
VIAORA

ROR
ROR
BCC

sec

A
TTYRCV
TTYRCV

STA
STA

$60
$60

VIAORA
VIAORA

001D
0010

6A
90
F7
F7
85
85
60
00

0030
0030
0031
0031
0032
0032
0033
0033
0034
0034
0035
0035
0036
0036
0037
0037
0038
0038
0039
0039
003A
003A
0038
003B
003C
003C
003D
003D
003E
003E

AO
AO
05
DO
DO
02
AO
AO
OA
OA
A2
A2
B4
84
CA
CA
DO
DO
FD
FD
88
DO
DO
F8
F8
60

001C
001
c

Instruction
Instruction
(Mnemonic)
(Mnemonic)

BRK
BRK

DLY2
DLY2

LDY
LOY

#5

BNE
BNE

DLY1
DLY1

DELAY
DELAY LDY
LOY

#10

DLY1
DLY1

LDX
LOX

#$84
B

DLY
DLY

DEX
DEX
BNE
BNE

DLY
DLY

DEY
DEY
BNE
BNE

DLY1
DLY1

RTS
RTS

1 1-106
06

This program
program assumes
assumes that
that the
the Stack
Stack can be
be used for
for subroutine
subroutine calls.
calls, i.e.,
that the
This
.. that
m
onitor has already
already initialized
initialized the
the Stack
Stack Pointer.
Pointer. Otherwise
Otherwise you w
have to
to initialize
initialize
monitor
willill have
the Stack
Stack Pointer
Pointer as shown
shown in
in Chapter
Chapter 10.
the
The constants
constants for
for the
the delay
delay routine
routine were
were calculated
calculated just
just as
as shown
shown earlier
earlier in this
this chapter.
chapter.
The
You might
ight try
try determ
ining them
them for
for yourself.
yourself. The delays
delays do
do not
not have to be highly
highly accuaccu­
You
determining
the reception
reception is centered.
centered, the messages are short.
short, the bit
bit rate is low.
low, and
rate because the
teletypewriter is not
not highly
highly accurate
accurate itself.
the teletypewriter
How would
would you extend
extend this
this program
program to check
check parity?
parity?
How

111-107
1-107

Ta
2: W r
ite Da
Task 2:
Write
Dataa

Purpose: Transmit
Transmit data to a teletypewriter
teletypewriter through
through bit
bit 0 of
of a VIA
VIA O
utput (Data)
Purpose:
Output
(Data)
register. The
The data is in
in memory
memory location
location 0060.
0060.
register.
Transmit (flowcharted
(flowcharted in Figure
Figure 11-35)
Transmit
Transmit a Start bit (i.e
(i.e... a logic zero).
Step 1) Transmit
zero)
ith the
the least
least
Step 2) Transmit the
the seven
seven data bits,
bits. starting
starting w
with
significant bit.
significant
Step 3) Generate
Generate and
and transm
transmit the
the Parity
Parity bit.
bit.
Transmit two Stop bits (i.e
(i.e.,.. logic ones).
Step 4) Transmit
ones).

TTY
TTY
TRANSMIT
TRANSMIT
MODE
MODE

transmission routine
routine must
must wait
a it one bit
bit timee between
between each operation.
The transmission

Start

=

start

data
Shift data left

t

Get output

circu6erty
with Carry
Count; 11

Send data to
Output Port

Shilt data right
circu4artywith Carry
Carry ; 1 (stop bit)

Wait l bit time

Count = Count . 1

End

Figure
Figure 11-35.
11-35. Flowchart
Flowchart for
for Transmit
Transmit Procedure
Procedure

1111-1088

Source Program
(Assume that
that parity
parity need not be generated)

TBIT

LOA
LDA
STA
STA
LOA
LDA
STA
LOA
LDA
LOX
LDX
JSR
SEC
SEC
ROR
ROR
ROL
ROL
DEX
BNE
BRK
BRK

#0
VIAPCR
VIAORB
#$FF
VIADDRB
$60
#11
DELAY

LINES INPUTS
INPUTS
;MAKE ALL CONTROL LINES
;FORM START
START BIT
BIT
;FORM
;MAKE PORT
PORT B LINES
LINES OUTPUTS
OUTPUTS
;GET
GET DATA
COUNT
;COUNT== 11
11 BITS
BITS IN
IN CHARACTER
CHARACTER
;WAIT
BIT TIME
W
AIT 1 BIT
SET CARRY
;SET
CARRY TO FORM
FORM STOP
STOP BIT
BIT
GET NEXT
:GET
NEXT BIT OF
OF CHARACTER
CHARACTER
:SEND NEXT
NEXT BIT TO
TO TTY
TTY

A
VIAORB
TBIT

The DELAY subroutine
subroutine used here must
ulator and Index Register X.
The
must preserve the Accum
Accumulator
X.
Remember that
that bit
bit 0
must be transm
itted first.
Remember
O of the data must
transmitted

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004)
0004
0005
0005
0006)
0006}
0007)
0007
0008
0008
0009
0009
000A
OOOA
000BI
OOOB}
oo
o c)
oooc
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017)
0017}
0018)
0018
0019
0019
001A
01A
001B
001B
00
001Cc

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

A9
00
8D
80

LDA
LOA

#0

STA

VIAPCR

STA

VIAORB

LDA
LOA

#$FF

STA

VIADDRB

LDA
LOA

$60

LDX
LOX

#11

JSR
JSR

DELAY

SEC
SEC
ROR
ROR
ROL
ROL

A
VIAORB
VIAORB

DEX
BNE

TBIT

VIAPCR
8D
80

VIAORB
A9
FF
FF
8D
80
VIADDRB
A5
60
A2
OB
20
30
00
38
6A
2E

TBIT

VIAORB
CA
DO
F5
00

BRK
BRK

11-109
11-109

actual applications.
applications, you will
ill find It
it necessary to place a one on the teletypewriter
teletypewriter line
In actual
after configuration.
configuration, since that
that line should
should normally
normally be in
after
In the mark (one)
(one) state.
Each character
character consists
consists of 11 bits, with
ith a Start
Start bit
bit (zero)
ending with
ith twoo Stop bits
(zero) and ending
(ones).
(ones).
Note that you can generate
generate parity
parity by counting
counting bits
bits as shown
shown in Chapter
Chapter 6. The program
program
is:

CHBIT
CHKZ
CHKZ

LDY
LOY
LDA
LOA
BPL
BPL
INY
ASL
BNE
BNE
BRK
BRK

#00
$60
CHKZ
CHKZ
A
CHBIT

;BIT COUNT== ZERO
ZERO
GET DATA
;GET
DATA BIT 1?
;IS NEXT DATA
;YES,
YES, ADD 1 TO BIT COUNT
;EXAMINE NEXT BIT POSITION
POSITION
UNLESS ALL BITS
;UNLESS
BITS ARE
ARE ZEROS
ZEROS

contains the number
number of T
significant bit of
Index Register Y contains
'1' bits in the data. The least significant
therefore an even Parity bit.
Index Register Y is therefore

!

These procedures
procedures are sufficiently
sufficiently common
common and complex
complex to merit a
IUART!
UART |
special
device: the UART,
niversal Asynchronous
syn ch ro no u s
special LSI device·
UART. or Universal
4 The UART will
Receiver/Transmitter.24
ill perform
perform the reception
reception procedure
procedure and provide
Receiver/Transmitter
the data in parallel form and a Data Ready signal. It will
ill also accept data in parallel
form, perform the transmission
transmission procedure.
procedure, and provide a Peripheral
Peripheral Ready signal when
itIt can handle more data. UARTs
UARTs may have many other
other features,
features. including:
including:
1)
1)

A bility
ility to handle various bit lengths
lengths (usually 5 to 8),
parity options.
options, and numbers
numbers of
8). parity
1-1/2, and 2).
Stop bits (usually 1.
1, 1-1/2.
2).

2)
2)

Indicators for framing
ing errors,
"overrun errors" (failure to read a
Indicators
errors, parity errors,
errors. and "overrun
character before another
another one is received).
character
received).
RS-23225 compatibility,
patibility: 1e
i.e.,.. a Request-to-Send
Request-to-Send (RTS)
output signal that indicates
indicates
Rs-23225
(RTS) output
the presence of data to comm
unications equipment
equipment and a Clear-to-Send
Clear-to-Send (CTS)
communications
(CTS) in­
input signal that indicates.
indicates, in response to RTS,
communications
RTS. the readiness of the communications
equipment. There may be provisions
equipment
provIsIons for other RS-232 signals,
signals. such as Received
Received
Signal Quality,
Quality. Data Set Ready,
Terminal Ready
Ready.
Ready. or Data Terminal

3)
3)

4)

outputs and control
control compatibility
patibility with
ith a microprocessor.
Tristate outputs

5)
5)

Clock options that allow the
the UART
UART to sample incoming
IncomIng data several times in
In order
to detect
detect false Start bits and other errors.
errors.

6)
6)

Interrupt facilities
facilities and controls.
Interrupt

UARTs
input data port,
output data port,
UARTs act as
as four parallel ports: an input
port. an output
port. an input
status port,
output control
control port. The status bits include
include error indicators
indicators as
port. and an output
as well
as
control bits select various options. UARTs
inexpensive ($5
as Ready
Ready flags. The control
UARTs are inexpensive
($5 to
$50, depending
depending on features)
features) and easy
easy to use.
use.

1111-110

THE 6 850
5 0 ASYNCHRONOUS
ASYNCHRONOUS C O M M U N
IC A T IO N S INTERFACE
MUNICATIONS
ADAPTER (ACIA)26.
(ACIA)26, 27
27
The 6850
6850 ACIA, or Asynchronous Communications InterInter­
6850 ACIA
6850
face Adapter
Adapter (see
REGISTERS
(see Figure 11-36) is
is a UART specifically
REGISTERS
designed for use
6800- and 6502-based
6502-based microcom­
use in 6800microcomputers. It occupies two memory addresses and
and contains two read-only registers
(received data and status) and two write-only
rite-only registers (transmitted
(transmitted data and con­
control). Tables 11-16 and 11-17 describe the contents
contents of these registers.
registers.
Note the follow
ing special features of the
following
the 6850 ACIA:
1)
rite cycles
1) Read
Readand
and wwrite
cycles address
address physically
physically distinct
distinct registers.
registers
Therefore, you cannot
cannot use the ACIA registers as
Therefore.
as addresses
for instructions
Decrement. or Shift,
Shift. which
for
instructions like Increment.
Increment, Decrement,
which
involve both read
read and write
cycles.
rite cycles.

------

SPECIAL
FEATURES
OF 6850
6850 ACIA

2)
ill have
2) The
The ACIA
ACIA Control
Control register
register cannot
cannot be
be read
read by
by the
the CPU.
CPU.You
You wwill
have to
to save
save aa copy
copy
of the Control
Control register in
In memory if the program needs its value.
3)
3) The
The ACIA
ACIA has
hasno
no Reset
Reset input.
input. ItIt can
can be
be reset
reset only
only by
by placing
placing ones
ones in
in Control
Control register
register
bits 0 and 1.
procedure (called MASTER
1. This procedure
MASTER RESET)
RESET)is
Is necessary before the ACIA
is used,
starting character.
used. in order to avoid having a random starting
4) The
The RS-232
RS-232 signals
signals are
are all
all active-low.
active-low Request-to-Send
Request-to-Send (RTS),
(RTS).in
in particular,
particular. should
should
be brought
brought high to make it
inactive if
It inactive
1f itIt is
Is not in use.
5) The
The ACIA
ACIA requires
requires an
an external
external clock.
clock. Typically
Typically 1760
1760 Hz
Hz isIssupplied
supplied and
and the
the ++ 16
16
register bit 1 = 0,
ill use the clock to
mode (Control register
0. bit 0 = 1)
1) is used. The ACIA will
center the reception
reception in
center
In order to avoid false Start bits caused by noise on the lines.
lines.
6)
6) The
The Data
Data Ready
Ready (Receive
(Receive Data
Data Register
Register Full,
Full. or
or RDRF)
RDRF)flag
flag isIs bit
bit 00 of
of the
the Status
Status
register. The Peripheral Ready (Transmit Data Register Empty,
Empty. or TDRE)
TORE) flag is
Is bit 1
of the Status register.

11111
11-111

Table 11-16. Definition
Definition of 6850
6850 ACIA Register Contents

Buffer Address
Data
Bus
Line
Line
Number
Number

RS-R/W
RS•R/W
Transmit
Transmit
Data
Register

RS-R/W
RS•R/W
Receive
Data
Register
Register

RS-R/W
RS·R/W

RS-R/W
RS•R/W

Control
Register

Status
Status
Register

(Write
rite Only) (Read Only)

Only)
(Write
rite Only)

(Read Only)

0

Data Bit 0*
o•

Data Bit 0

Counter Divide
Counter
Select 1 (CRO)
(CRO)

Receive Data Register
(RDRF)
Full (RDRF)

1

Data Bit 1

Data Bit 1

Counter Divide
Counter
Select 2 (CR1)
(CR1)

Transmit Data Register
Transmit
Empty (TDRE)
(TORE)

2

Data Bit 2

Data Bit 2

Word
ord Select 1
(CR2)
(CR2)

Data Carrier Detect
(DCD)
(DCD)

3

Data Bit 3

Data Bit 3

Word
ord Select 2
(CR3)
(CR3)

Clear-to-Send
(CTS)
(CTS)

4

Data Bit 4

Data Bit 4

Word
ord Select 3
(CR4)
(CR4)

Framing Error
(FE)
(FE)

5

Data Bit 5

Data Bit 5

Transmit
Transmit Control
Control 1
(CR5)
(CR5)

Receiver Overrun
(OVRN)
(OVRN)

6

Data Bit 6

Data Bit 6

Transmit
Transmit Control
Control 2
(CR6)
(CR6)

Parity Error (PE)
(PE)

7

Data Bit 7""..' Data Bit 7 .."

Receive Interrupt
Interrupt
(CR7)
Enable (CR7)

Interrupt
Interrupt Request
(IRQ)
(IRQ)

•* Leading bit = LSB = Bit 0
"•• Data bit will
ill be zero in 7-bit
7-bit plus parity
parity modes
*•·•
'* Data bit is "don't
o n 't care" in 7-bitit plus parity modes

1 1·112
-1 1 2

Table 11-17. Meaning
Meaning of the 6850 ACIA Control Register Bits
Bits

CR6

CRB
CR&

Function

0
0
1
1

0
1
0
1

RTS
itting Interrupt
Interrupt Disabled
ITT== low,
low. Transm
Transm1tt1ng
RTS
itting Interrupt
RTS = low. Transm
Transmitting
Interrupt Enabled
RTS
ittin
In te
rru p t Disabled
ITT== high,
high. T ra n sm
nsm1tt1ng
Interrupt
RTS
Transmits a Break
Break level on the
RTS = low. Transmits
Transmit Data Output. Transmitting
Transmit
Transm1tt1ng
"Interrupt Disabled
-fnterrupt

R'
CR4

CR3
CR3

CR2
CR2

Function

0
0
0
0
1
1
1
1

0
0
1

0
1
0

7 Bits + Even
Even Parity + 2 Slop
Stop Bits
7 Bits + Odd Parity + 2 Stop Bits
7 Bits + Even
Even Parity + 1 Stop Bit
7 Bits + Odd Parity + 1 Stop Bit
8 Bits++ 2 Stop Bits
8 Bits + 1 Stop Bit
8 Bits + Even
Even Parity + 1 Stop Bit
8
B Bits + Odd Parity + 1 Stop Bit

:r
CR1

CRO
CRO

Function

0
0
1
1

0
1
0
1

1
16
+ 64
7
Master Reset
Master
Reset

1

1

0
0
1
1

0
1
0
1

+
7

+
7

11
-1 1 3
11-113

Transmit

Clock

Panty

Clock

Gen

Gen

Enable

Read/Wrtte
Ch,p Select 0
Chip Select 1
Chip Select 2

Transmit

Chip
Select

Transmit

and

Data

Read/Write

Register

Data

Control

Transmit

Aegrster

Control

Select

Clear-toSend

Status
Register

DO
D1
D2

Interrupt

Interrupt

Log,c

Request

D3

Data

Data°
~

D4

Bus
Butters

Detect

D5
D6

Requestto- Send

D7
Receive
Control

Panty
Check

Receive
Data
Register
Receive

Shift
Register

Receive _____________________

_..,.

Clock

Clock
Gen

Sync

Receive

Logic

Data

11-36. Block
Block Diagram
Diagram of
of the
the 6850
6850 ACIA
ACIA
Figure 11-36.
11-114
11-114

typewriter
through a 6860
and store
store the
the data
data
Task: Receive data from a te le typ
e w rite r through
6850 ACIA and
in memory location 0060
0060
Program:
Source Program:

WAITD
WAITD

LOA
LDA
STA
LOA
LDA

#%00000011
#%00000011
ACIACR
#%01000101
01000101

STA
LDA
LSR
LSR
BCC
BCC
LOA
LDA
STA
BRK
BRK

ACIACR
ACIASR
ACIASR
A
WAITD
WAITD
ACIADR
$60

;MASTER RESET
RESETACIA
;MASTER
:CONFIGURE
;CONFIGUREACIA
ACIA FOR
FOR TTY
TTY WITH
WITH ODD
ODD
PARITY
; PARITY

;GET
STATUS
GET ACIA STATUS
;HAS DATA BEEN
BEEN RECEIVED?
RECEIVED?
;NO.
NO, WAIT
YES, FETCH
;YES.
FETCH DATA FROM
FROM ACIA
;SAVE DATA

Object Program:
Object
Program:
Memory
Memory Address
Address
(Hex)
(Hex)

.

0000
0000
0001
0002
0002
0003)
0003}
0004)
0004
0005
0005
0006
0006
0007
0007
0008)
0008}
0009)
0009
000A
OOOA
0008)
0008}
o o o c)
oooc
000D
000E
OOOE
000F
OOOF
0010
0010
0
011)
0011}
0012
012)
0013
0013
0014
0014
0015
0015

Instruction
Instruction
(Mnemonic)

Memory Contents
Memory
(Hex)
(Hex)
A9
03
8D

LDA

#% 000
000 1
00000011

STA
STA

ACIACR
ACIACR

LDA
LOA

#%01000101
#%01000101

STA

ACIACR
ACIACR

LDA

ACIASR
ACIASR

LSR
LSR
BCC
BCC

A
WAITD

LDA

ACIADR

STA

$60

ACIACR

A9
45
8D
ACIACR
AD

WAITD
WAITD

ACIASR

4A
90
FA
AD
ACIADR

85
60
00

BRK
BRK

The program
program must
must reset the
theACIA
ACIAoriginally
originallybybyplacing
placingones
onesininControl register
Controlregister
The
bits 0
The ACIA
ACIA does have an
an internal
internal power-on
power-on reset
resetwhich
which holds theholds
thein
ACIA
and 1. The
ACIA
the
reset state
state until
until Master
Master Reset is applied.
applied.
reset
The program
program configures
configures the ACIA
ACIA Control
Control Register as
The
follows:
follows:
Bit 7 == 00 to disable
disable the receiver
receiver interrupt
interrupt
Bit
Bit 6 = 1 to make Request-to-Send
Request-to-Send (RTS)
(RTS) high (inactive)
Bit

EXAMPLE
EXAMPLE
OF
OF 6850
6860 ACIA
ACIA
CONFIGURATION
CONFIGURATION

Bit 5 = 00 to disable
disable the transmitter
transm itter interrupt
interrupt
Bit
Bit 44 = 00 for
for 7-bit
-b it words
words
Bit
Bit 33 = 00, Bit
Bit 2 == 1for
forodd
oddparity
parity w ith
with 22Stop
Stopbits
bits
Bit
Bit 1 = 0.
0. Bit
Bit O
0 == 1 for+
for -s-1616clock
clock(1760
(1760Hz
Hzmust
mustbebesupplied)
supplied)
Bit

11115
11-116

bits 0
inthe

The Received
Received Data
Data Status
Status flag
flag isis Status
Status register
register bit
bit 0.0. Suppose
Suppose we
we tried
tried toto replace
replace
The
LOA
LDA
LSR
LSR

ACIASR
ACIASR
A A

with the
the single
single instruction
instruction
w
LSR
LSR

ACIASR
ACIASR

What would
would happen?
happen?
W
Remember
Remember that
that the
the Status
Status and
and Control
Control registers
registers share
share an
an address
address but
but are
are physically
physically dis­
distinct.
tinct.

Try adding
adding an
an error-checking
routine to
to the
the program.
program Set.
Set.
Try
error-checking routine

=

no errors
errors occurred
occurred
(0061) = 00 if11no
(0061)
parity error
error occurred
occurred
== 11 if11aa parity
1)
(Status register
register bit
bit 66 == 1)
(Status
an overrun
overrun error
error occurred
occurred
= 22 if11an
1)
(Status register
register bit
bit 55 == 1)
(Status
framing error
error occurred
occurred
== 33 ifif a fram
1)
(Status register bit 44 == 1)
Assume that
priority of the
that the priority
the errors is
,s from
from MSB
MSB to
to LSB
LSB in
,n the
the ACIA
ACIA Status
Status register
register
(i.e.,
priority over overrun
(1
e. parity errors have
have priority
overrun errors
errors which,
which. in
In turn,
turn. have
have priority
priority over
over
than one error has
has occurred)
occurred)
framing
ing errors if11more than

11 1
,_,- 1 1
166

Task: Send data from memory location 0060
teletypewriter
through aa 6850
6850
0060 to a te le typ
e w rite r through
ACIA
Source Program:

WAITR

LDA
STA
LDA

00000011
#% 0 0
00 011
ACIACR
#%01000101
01000101

STA
LDA
BIT
BEO
BEQ
LDA
STA
BRK
BAK

ACIACR
#%00000010
00000010
ACIASR
WAITR
$60
ACIADR

;MASTER RESET
RESETACIA
;MASTER
;CONFIGURE ACIA FOR
FOR TTY
TTY WITH
WITH ODD
ODD
iCONFIGURE
; PARITY
PARITY

;IS
IS ACIA READY
READY FOR
FOR DATA?
TA?
AIT UNTIL IT IS
;NO. WAIT
IS
;YES.
GET DATA
YES, GET
;AND TRANSMIT IT
IT

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
00031
0003}
0004>
0005
0005
0006
0006
0007
0007
0008)
0008}
0009)
0009
000A
000A
000B
OOOC
oooc
000D)
000D}
000E)
000E
000F
0010
0010
0011
0012
0012
0013
0013
00141
0014}
0015)
0015
0016
0016

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)
A9
03
8D
BD

LDA

#% 00
00 011
00000011

STA

ACIACR
ACIACR

LDA

#%01000101
#%01000101

ACIACR
A9
45
8D
SD

STA

ACIACR

ACIACR

A9
02
2C

WAITR

LDA

#%00000010
00000010

BIT

ACIASR

BEQ
BEO

WAITR

LDA

$60

STA

ACIADR

ACIASR
FO
F0
FB
A5
60
8D
SD

ACIADR
BRK
BAK

00

The Transm
itter Status
Status flag is Status
Status register
register bit
bit 1. How could
could you modify
odify the receive
The
Transmitter
program to use
use the Bit
Bit Test
Test Instruction?
Instruction?
program

11-117

THE 6551 ASYNCHRONOUS C O M M U N
IC A T IO N S INTERFACE
MUNICATIONS
INTERFACE
ADAPTER (ACIA)
(ACIA)
The 6551 ACIA
ACIA is a variation of the 6850
6850 device that
that can also
6551 ACIA
REGISTERS
REGISTERS
be used in 68006800- or 6502-based
6502-based systems. Figure 11-37 is a
tie
diagram of this device. It has most of the features
features of the
block diagram
6850 ACIA and also has an on-chip baud rate generator
generator that can provide
6850
provide 15
programmable
1.8432 MHz
MHz external
external crystal.
programmable baud rates derived from a standard 1.8432
Thus the 6551
6551 ACIA can provide virtually any of the common baud
out
baud rates w ithout
an external
external timer
er or baud rate generator. The device has four internal
internal registers
addressed as described
described by Table 11-18. Its operation
operation is controlled
controlled by two registers:
1)
1)

The Control
Control register
register (see
controls the baud rate generator, the word
(see Figure 11-38) controls
length, the number
number of stop bits, and the receiver clock source.
length.

2)

EXAMPLE OF
The Command
Command register
register (see
controls parity
parity
(see Figure 11-39) controls
6551 ACIA
checking and generation.
generation, interrupt
interrupt enabling.
enabling, and the
checking
CONFIGURATION
CONFIGURATION
RS-232 handshake signals. Note that
that the program may
reset the 6551 ACIA at any time by writing
ritin g any data into
the address of the Status
Status register (see
example, the following
following
(see Figure 11-40). For example.
configures it for a 10 character
character per second
program resets a 6551 ACIA and configures
teletypewriter with
ith odd parity
parity and two stop bits:
teletypewriter

--------

LDA
STA
STA

#% 1
0110011
#%10110011
ACIASR
ACIASR
ACIAMR
ACIAMR

LDA
STA

#% 001
00011
#%00100011
ACIACR
ACIACR

;RESET
:RESET6551
6551 ACIA
ACIA
;CONFIGURE
:CONFIGUREMODE
MODE FOR
FOR TTY (7
(7 BITS,
BITS, 22 STOP
STOP
BITS)
: BITS)
;CONFIGURE
:CONFIGUREFOR
FORODD
ODD PARITY,
PARITY, NO
NO
; INTERRUPTS
INTERRUPTS

Control (Mode)
We have given the name ACIAMR to the Control
(Mode) Register.
Register.
The program configures
configures the 6551 ACIA Control
Control (Mode)
register as follows:
follows:
(Mode) register
for 22 stop
stop bits
bits
1 1for
Bit 7 =7 =
7-bitwords
words
0.0,bitbit5 5= =1 1forfor7-bit
Bit 6 =6 =
generate receiver clock from the on-board
on-board baud rate generator
generator
Bit 4 = 1 to generate
Bits 0-3 = 0011 for 109.92 Baud (10 characters
characters per second) from the internal
internal
baud rate generator
generator
The program configures
configures the 6551 ACIA Command
Command register
register as follows:
follows:
O.bit 6 = 0, bit 5 = 1 for odd parity
parity on both receiver and transm
itter
transmitter
Bit 7 = 0.bit
characters are not autom
atically echoed back through
through the
Bit 4 = 0 so characters
automatically
transm
itter
transmitter
itter interrupt
interrupt and bring RTS
transmitter
RTS high
Bit 3 = 0, bit 2 = 0 to disable the transm
(inactive)
to disable
disable the
the receiver
receiver interrupt
interrupt (this is a mask bit)
Bit 1 =1 =11to
enable the
the Receiver/Transmitter
Receiver/Transmitter
Bit 0 0
= =1 1toto enable

11 - 1 1
118

Transmit
Transmit

CTS

Control

<t>
2
<1>2

^

R/W
/W —

►

Transmit
Transmit
Data
Register

Select
and
Control
Logic

CS0 “
CSo

c s ] ------ ►
cs,
RSo
q

►

RS i1

= >

Transmit
Shilt
Shift
Register

Status

Interrupt
Interrupt

Register

Logic

TxO

IRQ

RES -------►

DCD
DCD

^

DSR
------ DSR

RxC

Baud
Baud

Control
Register

Rate
Rate

XTAL
XTAL11

Generator
Generator

Receive

XTAL2
XTAL2

^

Receive
Receive

Data
Data
Data

^

Register

cN

Shift
Shift

RxD
►— RxD

Register
Register

Bus
Bus

Buffers

o

Command
Command

Receive
Receive

Register
Register

Control
Control

._ _____________

·om

'----------------RTS

-► R T S

Figure 11-37. Block Diagram of the 6551 ACIA
ACIA
Addressing 6551 ACIA Internal Registers
Table 11-18. Addressing
Registers
RS
RS t

RS
q
RSo

0
0

0
0

Transmit
Transmit Data
Data Register
Register

Receiver
Receiver Data
Data Register
Register

00

1
1

Programmed Reset
"Don't Care")
Reset (Data
(Data is
is "Don't
Care")

Status
Status Register
Register

1
1

00

Command
Command Register
Register

11

00

Control Register
Control
Register

1

W
rite
Write

Read
Read

The
The table
table shows
shows that
that only
only the
the Command
Command and
and Control
Control registers
registers are
are read/write.
read/write. The
The Programmed
Programmed Reset
Resetoperation
operation
does
does not
not cause
cause any
any data
data transfer,
transfer, but
but is
is used
used to
to clear
clear the
the S Y 6
SY6551 registers.
registers. The
The Programmed
Programmed Reset
Reset is
is slightly
slightly
different from
different
from the
the Hardware
Hardware Reset
Reset (RES)
{RES) and
and these
these differences
differences are
are described
described in
in the
the individual
individual register
register defini­
definitions.
tions.

111,_,
- 1 119
9

m

7 6 5 4 3 2 1 0 ..,__

Bit Number
Number

I I

Control
Control Register
Register

-j

I I I I I
'

e
•~
--c_Baud

'--------Receiver

Rate Generator
Generator
-B aud Rate
16x External
External Clock Baud
Baud

0

0

0

0

0

0

0

1

50

0

0

1

0

75

0

0

1

1

1 0 9.92
.9 2

0

1

0

0

134
.5 8
4.58

0

1

0

1

1 50

0

1

1

0

3 00

0

1

1

1

6 00

1

0

0

0

1 200

1

0

0

1

1 800

1

0

1

0

2 4000

1

0

1

1

3 6000

1

1

0

0

4 800
00

1

1

0

1

7 2000

1

1

1

0

9 6000

1

1

1

1

1 9,200
00

- Receiver Clock
Clock Source
Source
0 = External Receiver Clock
1 =
= Baud
Baud Rate
Rate Generator
Generator
■ Word Length
Length
Bit
Data Word
Bit
Length
6 5

'---------

~----------Stop

~

~

000

8

011

7

10

6

1 1

5

Bits
Stop Bits
0 =~11 Stop Bit

~

1 = 2 Stop Bits
1 Stop Bit if Word Length
Length
'A
it transmission
•Allows for 9 -bit
transmission

=
= 8 Bits
Bits and
and Parity*
Parity•
Vt

1 1/2 Stop Bits
Bits if Word Length
Length
= 5 Bits
Bits and No Parity.
Parity.

(8 data bits plus
plus parity).
parity).
7
7 66

5
5 44 33 22

1
1 00 .,__Bit -B it Number
Number

-H ardw are Reset
~Hardware
Reset
0 0
0 0 0 0 0 0
~“ Program
Program Reset
Reset

Definition of 6551 ACIA Control
Control Register Contents
Contents
Figure 11-38. Definition

1 1 -120
120

I

I

g;

7 6 5 4

I I II

3 2 1 0 *.,._Bit

I

I I

Bit Number
register
Command register
I

-D a
ta Terminal Ready
Data
Ready

I

0 = Disable Receiver/Transmitter
Receiver/Transmitter (DTR high)
1 = Enable Receiver/Transmitter
Receiver/Transmitter (DTR low)
low)
Interrupt Enable
'-----Receiver -R eceiver Interrupt
0 = IRQ
Interrupt Enabled from
from Bit 7
IAQ Interrupt

I

I

Controls
'------Transmitter -Transm itter Controls

I

3

2

Transmit
Transmit
Interrupt
Interrupt

0

0

Disabled

High

0

1

Enabled
Enabled

Low

1

0

Disabled

Low

-—

1

1

Disabled
Disabled

Low

Transmit BRK
Transmit
BRK

RTS
ATS
Level
Level

Other

-—
-—

• Normal/Echo
Normal/Echo Mode for Receiver

'--------

0 = Normal
1 =
- Echo
Echo

'----------Parity

- Parity Check Controls
Bit
Bit
7
6 __5_
2-§__2..
--------- 0

Operation
0 Parity
Disabled
- No
Parity
Bit Bit
Parity
Disabled
- No
Parity

0

00

11

0

1 1 11

1

00

11

Mark
Mark Parity
Parity Bit
81tTransmitted,
Transmitted.

1

1 1 11

Space
Space Parity
Panty Bit
Bit Transmitted,
Transm,tted.

Generated - No
No Parity Bit Received
Received
Odd
Odd Parity
Parity Receiver
Receiver and
and Transmitter
Transmitter
Even
EvenParity
Parity Receiver
Receiver and
and
Transmitter
Transmitter

Parity Check
Check Disabled
Disabled

Parity Check Disabled
77 6 55 44 3 22 11 0 -4--Bit -B it Number
Number
0

o

1°
I~,~
I~
I~
,~t:=;;~:::eR:::~t

1°1°

1 o

olo

0

1 0

- Hardware Reset

0

1 0

- Program Reset

Figure 11-39. Definition
Definition of 6551 ACIA Command
Command Register Contents
Contents

11-121
11-121

I

I

I
I

Status Register
of Status
1 = IRQ Interrupt
Interrupt Disabled

Bit
Bit

I

7 6
6 55 4 33 22 11 00 ..,._Bit -B it Number
7

IClI II II II II II II I

l

Il I

I'

Il

-S ta
tu Register
Register
Status

'
■ Parity Error*
Error•
0 = No Parity Error
1 = Parity Error Detected

-----

“ Framing Error*
Error•
0 = No Framing Error
1 = Framing Error Detected

,_ _____

■ Overrun•
Overrun*
0 = No Overrun
Overrun
1 = Overrun Has
Has Occurred
■ Receiver Data Register Full
Full

-------

0 = Not Full
Full
1 = Full
Full

,_ _______

Transmitter Data
Empty
- Transmitter
Data Register
Register Empty
0 = Not Empty
1 = Empty

..__________

Data Carrier
Detect (DCD)
(DCD)
- Data
Carrier Detect
0 = DCD
DCD low (Detect)
(Detect)
1 = DCD
DCD high (Not Detected)

'----------

■ Data Ready
Ready (DSR)
(DSR)
0 = DSR
DSRlow (Ready)
(Ready)
1 = DSR
DSR high (Not Ready)
* Interrupt
Interrupt (IRQ)
(IRQ)

'-----------

0 = No
No Interrupt
*No
interrupt occurs for these conditions.
conditions.
•No interrupt

7

6

5 4

3

2

1 0 >

1 = Interrupt Has
Has Occurred

-B it Number
-H ardw are Reset
-Program Reset

Figure 11-40. Definition
Definition of 6551 ACIA Status Register Contents

1 1 -1
11-122

LOGICAL AND
D PHYSICAL
PHYSICAL DEVICES28
An important
portant goal in writing
ritin g 1/0
I/O routines is to make them
them j!LOGICAL
LOGICAL DEVICES!|
independent of particular
particular physical hardware.
hardware. The routines
independent
can then transfer
transfer data to or from 1/0
I/O devices,
devices, with
ith the actual
actual addresses being supsup­
1/0 device that
plied as parameters.
parameters. The I/O
that can actually
actually be accessed through a particpartic­
interface is referred
referred to as a physical device. The 1/0
I/O device to which
which the propro­
ular interface
gram transfers
transfers data is referred
referred to as a logical device.
device. The operating system
system or
devices on to physical
supervisor program must provide a mapping of logical devices
devices, thatt is, assign actual
actual physical 1/0
I/O addresses and characteristics
characteristics to be
devices,
used by the I/O
1/0 routines.
Note the advantages
advantages of this approach:
1)
1)

The operating
operating system can vary the assignments
assignments under
under user control. Now the user
can easily substitute
substitute a test panel or a development
development system interface
interface for the actual
I/O
maintenance as well
well as in debugging
debugging and testing.
1/0 devices. This is useful in field maintenance
Furthermore.
1/0 devices for different
Furthermore, the user can change the I/O
different situations:
situations: typical
directing intermediate
intermediate output
output to a video display
display and final output
output to a
examples are directing
printer
communications
printer or obtaining
obtaining some input
input from a remote comm
unications line rather than
from a local keyboard.

2)

1/0 routines can handle several identical
The same I/O
identical or similar
ilar devices. The operating
system or user only has to supply
supply the address of a particular
particular teletypewriter.
teletypewriter, RS-232
RS-232
terminal, or printer.
printer, for example.
terminal.

3)
3)

Changes,
corrections, or additions
additions to the I/O
configuration are easy to make since
Changes. corrections.
1/0 configuration
only the assignments
assignments (or mapping) must be changed.

On the 6502 microprocessor.
microprocessor, either
either the Preindexed (Indexed Indirect) or Postindexed
(Indirect Indexed) addressing mode can be used
indepen­
(Indirect
used in the I/O
1/0 routines to provide indepenaddresses. Preindexing is convenient
dence of specific
specific physical addresses.
convenient since itIt allows the
choice of a physical device address from a table
table.
If a table of I/O
maintained on page zero,
I/O
1/0 addresses
addresses is maintained
zero. all that
1/0 DEVICE
TABLE
an I/O
TABLE
1/0 routine needs is
Is an
an index into that table. It can then ac­
access
cess the I/O
1/0 device by using the Preindexed (or
(or Indexed In­
Indirect) addressing mode.
number is in memory location DEV,
mode. If. for example,
example. the device number
DEV.
the program to calculate
calculate the index would be:
be:
LDA
LOA
ASL
TAX

DEV
DEV
AA

:GET
;GET DEVICE
DEVICENUMBER
NUMBER
:;MULTIPLY
MULTIPLY BY
BY 22 FOR
FOR2-BYTE
2-BYTE ADDRESS
ADDRESS TABLE
TABLE

to or from
from the
the appropriate
1/0 device with the
the instructions
Data may now be transferred to
appropriate I/O
instructions
LDA
DATA
:GET
LOA
DATA
:GET DATA
DATA
STA
(IOTBL.X)
:SEND
STA
(IOTBL.X)
:SENDTO
TO LOGICAL
LOGICAL I/O
1/0DEVICE
DEVICE
or
LDA
LOA
STA

(IOTBL.X)
(IOTBL.X)
DATA
DATA

:GETDATA
DATA FROM
FROMLOGICAL
LOGICALI/O
1/0 DEVICE
DEVICE
:GET
:SAVE
:SAVE DATA
DATA

same I/O
1/0 routine
routine can transfer
transfer data to
to or
or from
from many different
1/0 devices merely by
by
The same
different I/O
indexes. Compare
Compare the
the flexib
flexibility
this approach w
with the
the
being supplied with different
different indexes.
ility of this
inflexibility of I/O
inflexibility
1/0 routines
routines that
that use
use direct
direct addressing
addressing and
and are
are therefore
therefore tied
tied to
to specific
physical addresses.
addresses.

11-123
11123

STA N D
AR D INTERFACES
STANDARD
INTERFACES
Other
Other standard
standard interfaces
interfaces besides
besides the
the TTY
TTY current-loop
current-loop and
and
RS-232
icrocom­
RS-232 can
can also
also be
be used
used to
to connect
connect peripherals
peripherals to
to the
the m
microcomputer. Popular
Popular ones
ones include:
include:
puter.

STANDARD
STANDARD
INTERFACES
INTERFACES

1)
1)

Theserial
serial RS-449.
RS-449, RS-422.
RS-422, and
and RS-423
RS-423 interfaces.29
interfaces.29
The

2)
2)

The 8
-b it parallel
parallel General
General Purpose
Purpose Interface
Interface Bus.
Bus, also
also known
The
8-bit
known as IEEE-488
IEEE-4B8 or
Hewlett-Packard Interface
Interface Bus
Bus (HPIB).30
(HPIB).30
Hewlett-Packard

3)
3)

TheS-100
S-100 or
or A
ltair/lm sai hobbyist
hobbyist b
u s31
.^ This
This isisalso
also an
an 8-bit bus. 8 -b it bus.
The
Altair/lmsai
bus.

4)
4)

TheIntel
Intel M
ultibus.32 This
This ,sisanother
another 8
-b it bus
bus that
that can.
can, however.
however,be
The
Multibus.32
8-bit
be expanded
expanded to
handle 16
16 bits
bits in
in parallel.
parallel.
handle

11
-1 2 4
11-124

PROBLEMS
PROBLEMS
Separating Closures
Closures from
from an
an Unencoded
Unencoded Keyboard
Keyboard
1) Separating
Purpose: The
The program
program should
should read
read entries
entries from
from an unencoded
unencoded 3 xx 33 keyboard
keyboard and
Purpose:
them in an array. The number
number of entries
entries is in memory
memory location
location 0040
0040 and
save them
the array starts
starts in memory
memory location
location 0041.
the
closure from
from the next
next by w
aiting for
for the
the current
current closure
closure to
to end. Remember
Separate one closure
waiting
debounce the
the keyboard (this can be sim
ply a 1 ms wait).
to debounce
simply

Sample Problem:

= 04
(0040) =
7, 2.
2, 2.
2, 4
Entries are 7.
Result:
It: (0041) = 07
(0042) = 02
(0043) = 02
(0044) = 04
a a
Sentence
from
an an
Encoded
Keyboard
2)Read
Read
Sentence
from
Encoded
Keyboard
Purpose: The
ith aa zero
zero
The program
program should
should read
readentries
entries from
from an
anASCII
ASCIIkeyboard
keyboard (7(7bits
bits w
with
until it receives an ASCII
Parity bit) and place them in an array until
ASCII period 2E-|g.
2E15.
memory location
location 0040. Each entry is marked by
by aa strobe
strobe
The array starts in memory
as in the example given under
under An Encoded Keyboard.
Sample Problem:
Entries are H,
O,
H. E.
E. L. L,
L. 0.
Result:

(0040)
(0041)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)

=
=
=
=
=
=

48 H
45 E
4C L
4C L
4F 0
O
2E
2E

11-125
11-

3)

A Variable
Variable Amplitude
plitude Square W a
v e Generator
Generator
ave

Purpose: The program
program should generate
generate a square wave.
wave, as shown
shown in the next figure.
figure.
D/A converter.
converter. Memory
Memory location
location 0040
0040 contains
contains the scaled amplitude
amplitude
using a D/A
of the wave.
wave, memory
cycle in milliseconds,
memory location
location 0041 the length
length of a half cycle
milliseconds.
memory location
location 0042
0042 the number
number of cycles.
and memory
Assume that
that a digital
digital output
output of 8 0
-| 6 to the converter
converter results
results in an analog output
output of zero
Assume
016
general, a digital
digital output
output of D results in an analog output
output of (D-80)/80
(D-80)/80 X -VREF
ref
volts. In general.
volts.

Sample Problem:
(0040)
(0041)
(0042)

=
=
=

AO (hex)
(hex)
A0
04
03

Result:
+ VAEF
ref |I
I

ref jI
➔■•VAEF
Output
Output
Voltage

r----F— h -- -\-- ---f-I
II
l

4o |-----40
-VAEF

- 4
4-1

- -\--- - -1----\--- --J-

--VAEFFl
V rff L
!I

I1

4 ms

I

Time
Time---------------------------------------------------------- ►

T he b ase v o ltage
g e is
- |g == 0 v olts. Full s cale is 1 0 015
-|q = - V p
^ p v olts.
,s 8 015
REF
So A 016
- |g = ( A 0 - 8
0 )/8 0 X - V r
e p = -V p p
p/
-80)/80
REF
REF/4

The program produces
produces 3 pulses of amplitude
plitude Vp{Ep/4
ith a half cycle length
length of 4 ms.
VREF/4 with
ms.

4)

Averaging Analog Readings
Averaging
Readings

program should
should take four readings
readings from an A/D
A/D converter
converter 10 milliilli­
Purpose: The program
seconds apart
apart and place the average in memory
memory location
location 0040.
0040. Assume
Assume that
seconds
the A/D conversion
conversion time can be ignored.

Sample Problem:
89, 81.
81, 84
Readings are (hex)
(hex) 86,
86. 89.
Result: (0040) = 85

5)

A 30 Character-per-Second
Character-per-Second Terminal
inal

Purpose: Modify
odify the transm
routines of the example
example given under
under A
transmitit and receive routines
Teletypewriter to handle
handle a 30 cps terminal
terminal that
that transfers
transfers ASCII data with
ith one
Teletypewriter
bit and even parity. How could
could you write
rite the routines
routines to handle either
either
stop bit
terminal depending
depending on a flag bit in memory
memory location
location 0060;
0060: e.g.,.. (0060) = 0
terminal
for the 30 cps terminal.
terminal. (0060) = 1 for the 10 cps terminal?
terminal?

11126
-126

REFERENCES
1.
1.

J. Barnes,
Microprocessors to Enhance Performance
Performance with
ith
Barnes, and V. Gregory, "Use Microprocessors
Data," EDN,
ugust 20, 1976,
-72.
Noisy Data,"
EON, August
1976. pp. 71
71-72.

2.
Communications
2. J.
J. E.
E. McNamara,
McNamara, Technical
Technical Aspects
Aspects of
of Data
Data Communications
Mass.: Digital
Digital Equipment
Equipment Corporation,
Corporation, 1977), Chapter
Chapter 13.
13.

(Maynard,
(Maynard,

R.
Swanson,"Understanding Cyclic
Cyclic Redundancy
Redundancy Codes," Computer
puter Design,
R. Swanson,"Understanding
November
--November 1975, pp. 93-99.
J. Wong,
Wong, et al.,.. "Software
"Software Error Checking
Checking Procedures for Data Communications
Communications
Protocols," Computer
Computer Design, February 1979, pp. 122-125.
122-125.
Protocols,"
The last article
article contains
contains some 6800
6800 assembly language
language programs
programs for CRC
genera­
CRC generation.
3. For
For example,
example. the
the 6844
6844 Direct
Direct Memory
Memory Access
Access Controller
Controller for
for 68006800- or
or 6502-based
6502-based
microcomputers is described
described in An Introduction
Introduction to Microcomputers:
Microcomputers: Volume
Volume 2 microcomputers
Some Real
Microprocessors, pp. 9-106
9-106 through
through 9-123.
Real Microprocessors,
4.

A. Osborne, et al.,.. An Introduction
Introduction to Microcomputers:
Microcomputers: Volume
Volume 2 - Some Real
Real
Microprocessors, pp. 9-45 through
through 9-54.
Microprocessors,
J. Gilmore, and R.
Huntington, "Designing
"Designing with
ith the 6820 Peripheral
Peripheral Interface
R. Huntington.
Adapter," Electronics,
Electronics. December
December 23, 1976, pp. 85-86.
Adapter,"

5.

L.
Leventhal. 6800
6800 Assembly
Assembly Language
Language Programming,
Programming, pp. 11-31 through
through 11-47,
L. Leventhal.
11
through 11
11-49 through
11-74.

6.

A. Osborne,
Introduction to Microcomputers:
Microcomputers: Volume
Volume 2 - Some Real
Osborne. et al.. An Introduction
Real
Microprocessors, pp. 10-29 through
through 10-47.
Microprocessors,

7. R6500
puter System
R6500 M icrocom
Microcomputer
System Hardware
Hardware Manual
Manual (Anaheim,
(Anaheim, Calif.:
Calif.: Rockwell
Rockwell InInternational), pp. 1-65 through
through 1-97.
ternational!,
8. W.
W C.
C.Mavity,
Mavity, "M e g
"Megabitit Bubble
Bubble Modules
Modules in
in on
on Mass
Mass Storgage,"
Storgage." Electronics.
Electronics, March
March
29, 1979,
1979, pp.
pp. 99-103.
99-103.
9. J,J. Gieryic,
icro. April
11:31
Gieryic, "SYM-1
"SYM-1 6522-Based
6522-Based Timer."
Timer," M
Micro,
April 1979,
1979, pp.
pp. 11
:31 through
through
Micro is dedicated
dedicated exclusively
exclusively to 6502-based
6502-based personal com-­
11:32. The magazine Micro
puters; it
available (monthly
(monthly publication)
publication) from the COMPUTERIST,
O. Box
puters:
It is available
COMPUTERIST, Inc.,.. P.
P. 0.
3,
Chelmsford, MA 01824.
3. South Chelmsford,
10.
icro, March
10. M.
M. L.L.DeJong,
DeJong, "A
"A Simple
Simple 24-Hour
24-Hour Clock
Clock for
for the
theAIM
AIM 65,"
65," MMicro,
March 1979,
1979. pp.
pp.
-10:5 through
through 10:7.
11.
icrocomputers: Volume
11. A.
A. Osborne
Osborne et
et al..
al .. An
An Introduction
Introduction toto MMicrocomputers:
Volume 22 -- Some
Some Real
Real
Microprocessors, pp. 10-47 through
through 10-55.
Microprocessors.
12.
puter: 6502
12. C.
C. Foster,
Foster. Programming
Programming aa M icrocom
Microcomputer:
6502 (Reading,
(Reading. Mass.:
Mass.: AddisonAddisonWesley, 1978). This is a very elementary
elementary introduction
introduction to computers
computers based on the
Wesley.
KIM
microcomputer.
KIM microcomputer.
13. R.R.C.C Camp,
puter Systems
Camp, etet al.,
al.. M icrocom
Microcomputer
Systems Principles
Principles Featuring
Featuring the
the 6502/KIM
6502/KIM
Matrix Publishers.
Publishers, 1978).
(Portland: Matrix
14.
puter for
14. A.
A. Caprihan,
Caprihan, etet al.,
al .."A
"A Simple
Simple M icrocom
Microcomputer
for Biomedical
Biomedical Signal
Signal Processing,"
Processing."
Annual Conference
Conference on Industrial
Industrial Applications
Applications of Microprocessors.
Microprocessors, 1978,
4th Annual
1978. pp.
pp.
Proceedings (since 1975) are available from IEEE,
18-23. Proceedings
IEEE.445 Hoes Lane,
Lane. Piscataway, NJ 08854.
08854.
way.

1127
11-127

15.

ents Inc., P.
The TTL Data Book for Design Engineers, Texas Instrum
Instruments
P. 0. Box 5012,
75222, 1976, pp. 7-151 through
through 7-156.
Dallas, TX 75222,

16.

E.
Dilatush, "Special
"Special Report: Numeric
Numeric and Alphanum
eric Displays,"
Displays," EDN,
Febru­
E. Dilatush,
Alphanumeric
EON, February 5,
5. 1978, pp. 26-35.
--

17.

See Reference 15, pp. 7-22 through
through 7-34.

18.
18.

M. L. DeJong, "6502
"6502 Interfacing
Interfacing for Beginners: an ASCII Keyboard Input
Input Port."
Port,"
through 9-13.
Micro. February 1979, pp. 9-11 through

19.

E.
Handbook of D/A
/A and A/D
/D Converters
Converters (New York: Wiley,
E. R.
R. Hnatek, A User's Handbook
1976).
1976),

20.

J. Kane et al..
Introduction to Microcomputers:
Microcomputers: Volume
Volume 3 -• Some Real
al., An Introduction
Real Support Devices,
Devices. Section E..

21.

M. L.
nalog and Analog-Digital
Analog-Digital Conversion Using the KIM-1,"
L. DeJong, "Digital-A
"Digital-Analog
Micro, Volume
Volume 1,
The Best of Micro.
1. pp. 30-33.

22.

P.
Microprocessors and M inicom
puters (Reston,
P. H.
H. Garrett,
Garrett. Analog Systems for Microprocessors
inicomputers
(Reston,
VA.:.: Reston Publishing
Publishing Co., 1978.
1978).

23.

G.
"Remote Failure Analysis
Analysis of Micro-based
Micro-based Instrum
enta­
G. L.
L. Zick and T. T.
T. Sheffer. "Remote
Instrumentation," Computer. September
September 1977, pp. 30-35.
tion:·

24.

For a discussion
discussion of UARTs,
"The Bugbook lla,"
Instru­
UARTs. see
see P.
P. Rony et al.,
al., "The
Ila.'' E and L Instruments Inc..
06418 or D. G.
Inc., 61 First Street,
Street. Derby, CT.
CT. 06418
G. Larsen et al.,
al..
"INW
AS: Interfacing
ith Asynchronous
Asynchronous Serial Mode."
"INWAS:
Interfacing with
Mode." IEEE
IEEETransactions
Transactions on In­
Industrial Electronics and Control Instrum
entation, February 1977, pp. 2-12.
dustrial
Instrumentation,
12. See
See
also McNamara,
McNamara. Reference 2.
2.

-,

25.

The official
official RS-232 standard is available as
"Interface Between Data Terminal
as "Interface
Equipment and Data Communications
Communications Equipment
Equipment Employing
Employing Serial Binary Data
Equipment
Interchange" EIA
August 1969. You can find introductory
introductory descriptions
descriptions
Interchange"
EIA RS-232C
RS-232C August
of RS-232 in G.
h o ’s Afraid
Afraid of RS-232?", Kilobaud.
G. Pickles,
Pickles. "Who's
Kilobaud, May 1977, pp.
pp. 50-4
and in C.
puter Buses
i-M icro Systems,
Systems. July
C. A. Ogdin, "M icrocom
icrocomputer
Buses - Part II." M ini-Micro
1978, pp. 76-80. Ogdin
Ogd1n also describes the new RS-449
RS-449 standard. ---

26.

A.
Introduction to Microcomputers:
Microcomputers: Volume 2 - Some Real
A. Osborne et al..
al., An Introduction
Real
Microprocessors, pp. 9-55 through 9-61.

27.

K.
Fronheiser, "D evice
vice Operation
Operation and System Im plem
entation of the
K. Fronheiser.
plementation
Asynchronous
ProAsynchronous Communications
Communications Interface Adapter,"
Adapter," Motorola
otorola Semiconductor
iconductor Pro­
Application Note AN-754.
AN-754, 1975.
ducts Application
1975.

28.
28.

C.
puter Organization and
Programming 2/E
C. W. Gear.
Gear, Computer
and Programming
2/E (New York: McGrawHill, 1974),
1974), Chapter 6.
6.

29.
29.

D.
D. Morris,
Morris. "Revised Data
Data Interface Standards,"
Standards." Electronic Design, September 1,
1,
1977, pp.
pp. 138-141.
--

30.
30.

Institute of
Digital Interface
Institute
of Electrical and Electronics Engineers.
Engineers, "IEEE
'"IEEEStandard Digital
for Programmable
Instrumentation.''
IEEE Std488-1978,
IEEE, 445 Hoes
Hoes Lane,
Lane,
for
Programmable Instrum
entation," IEEE
Std488-1978, IEEE,
Piscataway, NJ
NJ 08854.
J.
Microcomputer-Based Design (New York: McGraw-Hill.
McGraw-Hill, 1977).
J. B.
B. Peatman,
Peatman. Microcomputer-Based
1977).

D. C.
C. Loughry, and M.
M. S.
S. Allen,
Allen. "IEEE
··IEEEStandard 488 and Microprocessor
SynergD.
Microprocessor Synerg­
ism," £roceedin
2
S_ofJhe_[EBE,
Proceedings
of the
IEEE,February 1978,
1978. pp.
pp. 162-172.
162-172.

11-128
11-

31.

G. Morrow.
Morrow, and H. Fullmer.
Fullmer, "Proposed
"Proposed Standard
Standard for the S-100 Bus."
Bus," Computer.
1978, pp. 84-89.
May 1978.
Smith, "Build
uild Your
Your Own Interface."
Interface," Kilobaud.
Kilobaud, June
June 1977.
1977, pp. 22-28.
M. L.
L. Smith.

32.

T. Rolander,
ultibus Interfacing."
Interfacing," Intel Application
Application Note AP-28,
Cor­
Rolander. "Inte
"Intell Multibus
AP-28. Intel Corporation, Santa Clara,
Introduction to MicrocomMicrocomporation.
Ciara. CA,
CA. 1977. See also An Introduction
Volume 3 - Some Real
support Devices. Section J.
puters: Volume
Real support

1111-129

Chapter 12
INTERRUPTS
Interrupts are inputs that
that the CPU examines as part of each instruction
Instruction cycle.
cycle.
These Inputs
inputs allow the CPU to react to asynchronous
asynchronous events
events in
In a more
more efficient
manner than polling
polling each device. The use of interrupts generally involves more
more
hardware than does ordinary
ordinary (programmed)
(programmed) I/O,
1/0, but interrupts provide a faster and
more direct response.1
Why
hy use interrupts?
interrupts? Interrupts allow events such as alarms,
alarms.
REASONING
amount of time, and periphperiph­
power failure, the passage
passage of a certain amount
BEHIND
erals having data or being ready to accept data to get the
INTERRUPTS
INTERRUPTS
attention of the CPU. The program
immediate attention
program does not have to
examine (poll)
(poll) every
every potential
potential source,
source, nor need the programmer w orry about the
system completely missing
interrupt system is like the bell on a
missing events. An interrupt
when a call is received so that
that you don
telephone -— it rings when
don't't have to pick up the
occasionally to see if someone is on the line. The CPU
about its normal
receiver occasionally
CPU can go about
business (and get a lot more done).
something happens, the interrupt
interrupt rouses the
done). When something
CPU
input before resuming normal operations. Of course,
CPU and forces it to service the input
course,
this simple description
description becomes more complicated
complicated (just like a telephone switchboard)
switchboard)
interrupts of varying importance
portance and there are tasks that cannot
when there are many interrupts
be interrupted.
interrupted.
The implementation
implementation of interrupt
interrupt systems varies greatly.
Among the questions
questions that
that must be answered to charactercharacter­
Among
ize a particular
particular system are:
are:

CHARACTERISTICS
OF INTERRUPT
SYSTEMS
SYSTEMS

1)
1)

How many interrupt
interrupt inputs
inputs are there?

2)

How does the CPU
interrupt?
CPU respond to an interrupt?

3)

How does the CPU
determine the source of an interrupt
interrupt if the number
number of sources
CPU determine
exceeds the number
number of inputs?

4)

Can the CPU
differentiate between important
portant and unim
portant interrupts?
interrupts?
CPU differentiate
unimportant

5)
5)

How and when is the interrupt
interrupt system enabled and disabled?

different answers to these questions. The aim of all the implementaimplementa­
There are many different
tions, however,
however. is to have the CPU respond
respond rapidly to interrupts and resume normal
normal
activity
c tiv ity afterwards.

The number of interrupt inputs on the CPU chip determines the number of
different responses
that the CPU can produce
o u t any additional hardware or
different
responses that
produce w ithout
input can produce a different
different internal
internal response.
Unfortunately, most
Each input
response. Unfortunately,
software. Each
microprocessors have a very small number
number (one or two, typically)
typically) of separate interrupt
interrupt
microprocessors
inputs.

1 2-1

The
The ultimate
ate response of the CPU to an interrupt
interrupt must be to transfer
transfer control to the
correct
Program
correct interrupt
interrupt service routine and to save the current value of the Program
Jump-to-Subroutine
Counter. The
The CPU must
must therefore
therefore execute
execute a Jum
p-to-Subroutine or Call instruction
instruction
address. This action will
~ave
with
ith the
the beginning
beginning of the interrupt
interrupt service routine
routine as its address.
ill save
the return
return address in the Stack and transfer
transfer control
control to the interrupt
interrupt service routine. The
amount
Some
amount of external
external hardware
hardware required to produce
produce this response varies greatly. Some
CPUs internally
hardinternally generate
generate the instruction
instruction and the address; others require external hard­
ware
ware to form them. The CPU can only generate a different
different instruction
instruction or address for
each separate input.
If
POLLING
If the number of interrupting
interrupting devices exceeds
exceeds the number of
POLLING
inputs, the CPU will
ill need extra hardware or software
are to ideniden­
VECTORING
tify the source of the interrupt. In the simplest case, the s oftft­
ware
ware can be a polling routine which
which checks the status of the
devices
such a system over nor­
nordevices that
that may be interrupting. The only advantage of such
mal polling is that
that the CPU knows that
that at least one device is active. The alternaalterna­
c­
tive solution is for additional hardware to provide a unique
unique data input (or
(or "vector")
r") for each source. The twoo alternatives
alternatives can be mixed; the vectors can identify
groups of inputs from which
hich the CPU can identify
identify a particular one
one by polling.
polling.

!

interrupt system that
that can differentiate
differentiate between
between important
| PRIORITY!
PRIORITY*)
An interrupt
unimportant interrupts is called a "p riority
rity interrupt
and unimportant
system
Internal hardware can provide as many priority levels as there are in­
system."." Internal
inputs.
puts. External
External hardware
hardware can provide
provide additional
additional levels
levels through
through the use of a Priority
Priority
register and comparator.
comparator. The external
external hardware
hardware does not allow
allow the interrupt
interrupt to
register
reach the
the CPU unless
unless its priority
priority is higher
higher than
than the contents
contents of the Priority
Priority
reach
register. A priority
priority interrupt
interrupt system
system may need a special
special way
ay to handle low-priority
-priority
register.
interrupts that
that may be ignored
for long periods
interrupts
ignored for
periods of time.
time.
Most
ost interrupt
interrupt systems can be enabled or disabled.
disabled. In fact,
ENABLING
atically disable interrupts when a RESET
most CPUs automatically
RESET is
is
AND
performed (so that the programmer
programmer can configure
configure the interrupt
interrupt
DISABLING
system) and on accepting an interrupt
interrupt (so
INTERRUPTS
(so that the interrupt
interrupt w ill
interrupt its own service routine). The programmer
programmer may wish
not interrupt
to disable interrupts
interrupts while
hile preparing or processing data,
performing a tim
data. performing
timing loop,
loop, or
or
executing a multi-byte
ulti-byte operation.
executing
that cannot be disabled (sometimes called a
An interrupt that
"non-maskable in terrupt")
rrup t") may be useful to warn of power
"non-maskable
obviously must take precedence over all
all
failure, an event that obviously
other activities.
activities.
other

NON-MASKABLE
NON-MASKABLE
INTERRUPT

The advantages
advantages of interrupts
interrupts are obvious, but there are
are also
also
disadvantages:
disadvantages:

DISADVANTAGES
DISADVANTAGES
OF
OF INTERRUPTS
INTERRUPTS

1)
1) Interrupt
Interrupt systems
systems may
may require
require aa large
large amount
amount of
of extra
extra
hardware.
2) Interrupts
Interrupts still
still require
require data
data transfers
transfers under
under program
program control
control through
through the
the CPU.
CPU.There
is no speed advantage as
as there is w ith DMA.
OMA.
3) Interrupts
ifficult. Errors
Interrupts are
are random
random inputs,
inputs. which
which makes
makes debugging
debugging and
and testing
testing ddifficult.
Errors
may occur sporadically,
sporadically, and therefore may be
be very hard
hard to
to find.2
find.2
4) Interrupts
Interrupts may
may involve
involve aalarge
large amount
amount of
ofoverhead
overhead ifif many
many registers
registersmust
mustbe
be saved
and the source must be determined
determined by polling.

12
12-2

65
0 2 INTERRUPT SYSTEM
602
The 6602
6502 microprocessor's
moderately comcom­
microprocessor's internal response
response to an interrupt is moderately
plex. The interrupt system consists of:
6502
An active-low
active-low maskable interrupt input (IRQ)
ORO) and an ac­
ac6602
tiv e-low
-lo w nonmaskable
(NMI).
INTERRUPT
nonmaskable interrupt input (NMI).
INPUTS
2)
21 An interrupt disable (or mask)
mask) bit which disables the
maskable interrupt. If the Interrupt
Interrupt Disable bit is 1,
1, no
interrupts are allowed:
allowed; the I bitit is stored in bit 2 of the Processor Status
maskable interrupts
(or P)
P) register.
1)

6502 checks the current status of the interrupt system at
The 6602
the end of each instruction. If an interrupt is active and
enabled, the response
response is as follows:

6502
6602
INTERRUPT
RESPONSE
RESPONSE

1)

The CPU saves the Program
Program Counter (most significant bits
first) and the Status register in the Stack. Figure 12-1 shows the order in which
which
firstl
these registers are saved.
that the Accum
ulator and Index registers are not
saved. Note that
Accumulator
saved automatically.
automatically.
2)
that is,
21 The CPU disables the maskable interrupt (IRQ); that
is. it sets bit 2 of the
Status register.
3) The
The CPU
CPU fetches
fetches an
an address
addressfrom
from aa specified
specified pair
pair of
of memory
memory addresses
addressesand
and
puts thatt address
contains the pairs of adad­
address in the Program
Program Counter. Table 12-1 contains
dresses assigned to the various inputs
inputs and to the Break instruction.
instruction.
Note the follow
ing special features of the 6502 interrupt
interrupt
following
system:
1)
1)

---------,

SPECIAL FEATURES
FEATURES
OF 6502
6502 INTERRUPT
SYSTEM

The 6502 autom
atically saves
Counter
automatically
saves the Program Counter
and the Status register
register in the Stack. Remember that
the Status register includes
includes the Interrupt
Interrupt Disable flag and the Break Command flag.

2) The
The 6502
6502 provides
provides no
no external
external signals
signals to
to indicate
indicate that
that itit has
hasaccepted
accepted an
an interrupt
interrupt
other than the address that
that it places on the Address
Address Bus.
other
Bus.
3)

The 6502
6502 has no special internal
internal provisions for determ
ining the source of an interinter­
determining
rupt when
when there are several sources tied to the same input.
rupt

The 6502
6502 has the follow ing special instructions to manipulate its interrupt
system:
1)

CLI (Clear Interrupt
Interrupt Disable Bit) clears bit 2 of the Status register and thus ena­
enables the maskable interrupt.
interrupt.
Interrupt Disable Bitl
Bit) sets bit 2 of the Status register and thus disables
2) SEI (Set Interrupt
the maskable interrupt.
interrupt.
3) BRK (Force
Counter and
(Force Break)
Break) sets the Break Command flag,
flag. saves the Program Counter
interrupt, and places the concon­
Status register in the Stack,
Stack. disables the maskable interrupt.
tents of addresses FFFE
FFFE and FFFF
FFFF in the Program Counter.
4) RTI (Return from Interrupt) restores the Status register and the Program
41
Program
Counter from the Stack. The result
result is that
that the old values are returned
returned to the Pro­
Program Counter
Counter and the Status register (including
(including the Interrupt
Interrupt bit). RTI
differs from
RT! differs
RTS
Subroutine) in that
that RTI
register as well as the
RTS (Return from Subroutine)
RT! restores the Status register
Program Counter
Counter and RTI does not add 1 to the return address
address as RTS does
(see
Chapter 11 for a discussion
discussion of
RTS).
(see Chapter
o!RTS).

1 2-3

After

Before
Before

0lss
1 s -4

0lsss -4
-4
01

0lsss -3
-3 -------1
01
0lss
01ss -2
01 ss -1 ----

01
01 ss
ss t-----t~Stack
j

01ss +l
+1
0lss
01ss
ss +2

T
“ T”

t----➔

T

Stack

01 ss -3

0lsss -2
01
t3C
Pointer
Pom,er

pp
PP

01ss
-1
01
ss -1

PCL
PCL

01ss
01ss
01
1
lss s ++1
01 ss +2

PCH
PCH

I

Stack

Ste ck

original contents
contents of Stack Pointer
ss = original
pp = original
(Pl register
original contents
contents of Status (P)
PCH = original
original contents
contents of 8 higher
higher order bits of Program Counter
PCL
original contents
contents of 8 lower
lower order bits of Program Counter
PCL =original

Microprocessor in the
Figure 12-1. Saving the Status of the Microprocessor
the Stack
Memory Map for 6502 Addresses Used
Table 12-1. Memory
Used in
Response to Interrupts
Interrupts and Reset
Reset

|

Source
Source

Address Used
af)
Uaed (H exadecim
exadoclmall

Interrupt Request (IRQ)
Instruction
Interrupt
(IRQ) and BRK
BAK Instruction
Reset (RESET)
(RESET)
Nonmaskable Interrupt
Interrupt (NMI)
Nonmaskable
(NMI)

FFFC
FFFCand
and FFFD
FFFD

FFFE
FFFEand
and FFFF
FFFF
FFFA
FFFA and
and FFFB
FFFB

The addresses are stored in the usual 6 502
0 2 fashion
fashion with
with the least significant
significant bits at
at the lower
lower address.
address.

BRK
exactly
The BRK (Force Break) instruction produces almost exactly
BRK
INSTRUCTION
interrupt input (IRQ). The only
the same response as an interrupt
INSTRUCTION
difference is that
that the Break Command flag (bit 4 of the Status
difference
differentiate between
between a BRK
register) is set. Thus a service routine can differentiate
BRK instruction
instruction
and an IRQ input by examining bit 4 of the top byte in the Stack (remember Figure
typical program
program would
ould be:
12-1).). A typical
PLA
AND
BNE

#%
00010000
#%00010000
BREAK
BREAK

;GET
;GET STATUS
STATUS REGISTER
REGISTERFROM
FROM STACK
STACK
;IS
:IS BREAK
BREAKCOMMAND
COMMAND FLAG
FLAGSET?
SET?
;YES,
;YES,GO
GOTO
TO BREAK
BREAKROUTINE
ROUTINE

instruction is useful for debugging
debugging (see
Chapter 14)
returning control
The BRK
BAK instruction
(see Chapter
14) and for returning
control
onitor or operating
operating system. See Chapter 3 for more inform
ation about the BRK
to a monitor
information
BAK in­
instruction.
struction.

interrupt is an edge-sensitive
edge-sensitive in­
NON-MASKABLE
The non-maskable interrupt
InNON-MASKABLE
therefore reacts only to the edge of a
INTERRUPT
put. The processor therefore
ill not interrupt
interrupt its
pulse on this line, and the pulse will
own service
service routine. Non-maskable
Non-maskable interrupts
interrupts are useful for applications
own
applications that must res­
respower (i.e.. must
must save data in a low-power
low-power memory or switch
switch to a back­
pond to loss of power
backTypical applications
applications are comm
unications equipm
ent that must retain codes
up battery). Typical
communications
equipment
partial messages,
ent that must keep track of partially
partially completed
and partial
messages. and test equipm
equipment
tests. Wee will
ill not discuss the non-maskable
non-maskable interrupt
ill assume that
interrupt any further.
further. W e will
that
interrupt inputs
inputs are tied to IRQ.
all interrupt
IRO.

12-4

65
6200 PIA Interrupts3
lnterrupts3
6520 PIA
Most 6502 interrupt
interrupt systems involve programmable
programmable interface
6620
chips or multifunction
ultifunction devices such as
INTERRUPTS
as the 6520 Peripheral Inter­
InterINTERRUPTS
face Adapter, the 6522 Versatile Interface Adapter, or the 6530
and 6532 Multifunction
ultifunction Devices.
6520 PIA has
Devices. Each
Each side
side of the 6620
has the following
features for use
use with interrupts:
interrupts:
1)
1)
2)
3)

An active-low
-lo w interrupt output.
output.
Interrupt enable bits (bit 0 of the Control register for control line 1,
1. bit 3 for con­
control line 2).
2).
Interrupt status bits (bit 7 of the Control register for control line 1.
1, bit 6 for control
2).
line 2).

Bits
hether a rising
Bits 1 and
and 4 of the Control register determine whether
rising edge (low-to-high
transition) or falling
falling edge (high-to-low
(high-to-low transition)
transition) on the control
control line causes an inin­
transition)
terrupt.
terrupt.
Note that:
that:
Note
1)
1)
2)
3)

4)

interrupt enable
enable bits
bits have the opposite
opposite polarity
polarity from
from the 6502
In­
The PIA interrupt
66021I (or Interrupt Disable)
Disable) flag:
flag; that is,
'V to enable an interrupt.
interrupt.
is. they must be T
terrupt
RESET
clears the PIA Control
Control registers
registers and thus
thus disables
disables all the interrupts.
interrupts.
RESET
clears
The CPU can check
check bits
bits 6 and 7 of the Control
Control register
register to see if a PIA has an
interrupt pending.
remain set
set until
until the CPU
pending. Once set, these bits will remain
CPU reads
reads the
interrupt
PIA Data register.
ill remember an interrupt
interrupt that
that occurs
occurs w h
ile PIA interrupts
interrupts are dis­
The PIA will
hile
disabled and will
ill output
output an interrupt
interrupt request
request as soon as the PIA interrupt
interrupt is
enabled.
enabled.

1 2-5

6522 VIA INTERRUPTS
6522
6522 Versatile
Versatile Interface
Interface Adapter
Adapter may also be used as a
6522 VIA
The 6522
6522
source of interrupts. This device has an Interrupt
Interrupt Enable
INTERRUPTS
register (IER)
hich can be used to enable the various interrupt
interrupt
register
(IER) which
sources and an Interrupt
Interrupt Flag register
register (IFR)
which contains
contains the status of the various
(IFR) which
sources.
positions of the various enabling
enabling bits in the Interrupt
Interrupt
sources. Figure 12-2 shows the positions
Enable register and Figure 12-3 describes the Interrupt
Interrupt Flag register.
An interrupt
interrupt source can be enabled by setting
setting the correscorres­
ponding enable bit. Note that
that the most significant
significant bit
it concon­
other enable bits are affected:
affected:
trols how the other

"'E"'N""A.,,...,,,B""L""'IN""G.,...A,....N,..,.
ENABLING AND
DISABLING
DISABLING
6522 VIA
VIA
6522
INTERRUPTS

1)
1)

If IER7
c h '1' in a bit position
position clears an enable bit
IER7 =
=00., e aach
and thus disables that
that interrupt.
interrupt.

2)

If IER7
position sets an interrupt
interrupt bit and thus enables that
IER7 = 1,
1. each 'V
'1' in a bit position
interrupt.
interrupt.

Zeros in the enabling
enabling bit positions
positions leave the enable bits unchanged.
unchanged.
Some examples of enabling
enabling and disabling
disabling 6522 VIA interrupts
interrupts are:
are:
1)
1)

Enable CA11 interrupt.
interrupt, disable all others.
others.
LDA
LOA
STA
LDA
LOA
STA

#% 01
111101
#%01111101
VIAIER
VIAIER
#%
10000010
#%10000010
VIAIER
VIAIER

;DISABLE
:DISABLEALL
ALL OTHER
OTHERINTERRUPTS
INTERRUPTS
:ENABLE
:ENABLECA1
CA1 INTERRUPT
INTERRUPT

The first
first operation
operation sets IER7
'1's in bit positions
positions 0. 2,
IER7 to zero,
zero. so that the Ts
2. 3,
3. 4,
4. 5,
5. and 6
corresponding enable bits and thus disable those interrupts.
interrupts. The second
clear the corresponding
corresponding enable
operation sets IER7
IER7 to one,
one. so that the· "V
1• in bit position 1 sets the corresponding
bit (CA
(CA11 interrupt)
interrupt) and thus enables that
that interrupt.
interrupt.
2)

Enable CB1
interrupts, disable all others.
CB1 and CB2 interrupts.
others.
LDA
LOA
STA
LDA
STA

#% 01
100111
#%01100111
VIAIER
VIAIER
#%
10011000
#%10011000
VIAIER
VIAIER

;DISABLE
:
DISABLEALL
ALL OTHER
OTHERINTERRUPTS
INTERRUPTS
:ENABLE
:ENABLECB1,
CB1. CB2
CB2 INTERRUPTS
INTERRUPTS

The first operation
operation sets IER7
positions 0,
IER7 to zero,
zero. so that the· 'V1•ss in bit positions
0. 1,
1. 2,
2. 5,
5. and 6 clear
the corresponding
corresponding enable bits and thus disable those interrupts.
interrupts. The second operation
sets IER7
that the 'V
positions 3 and 4 set the corresponding
corresponding enable
IER7 to one,
one. so that
Tss in bit positions
bit 4 for CB1)
interrupts.
bits (bit 3 for CB2,
CB2. bit
CB1) and thus enable those interrupts.
Besides
conditions described in Figure 12-3. the bits in the Interrupt
Interrupt Flag register
register
Besides the conditions

can also be cleared by writing
ritin g '1's
's into the required bit positions in that
that address.
address.
procedure is useful for clearing
clearing flags that
that are being used in the independent
independent modes
This procedure
and for eliminating
inating undesired interrupts
interrupts that may have been caused accidentally
accidentally during
reset or startup. Note that the Interrupt
Interrupt Flag register bit positions
positions are the same as the
Interrupt Enable register
register bit positions
positions so that we can easily extend the previous
Interrupt
examples to eliminate
inate stray interrupts.
interrupts. This can be done with
ith either
either enabling
enabling or disabdisab­
operations, since the value of bit 7 does not matter. The extended
extended examples are:
ling operations.
1)
1)

Enable CA1 interrupt.
interrupt, disable all others,
interrupt flag.
others. clear CA1
CA1 interrupt
LDA
STA
LDA
STA
STA

#% 01
111101
01111101
VIAIER
VIAIER
#% 1
0000010
10000010
VIAIFR
VIAIFR
VIAIER
VIAIER

;DISABLE
:DISABLE ALL OTHER
OTHER INTERRUPTS
INTERRUPTS

;CLEAR
:CLEAR CA11 INTERRUPT
INTERRUPTFLAG
FLAG
:ENABLE
:ENABLE CA11 INTERRUPT
INTERRUPT

1 2-6
6

7

66

5

44

3

2

1

0

CB1

CB2

SR

CA1

CA2

Bit Number

.................T

Set
clear
control

T11

T2

tt

T

Interrupt
Interrupt Enable
Enable register
register

i t

Designated interrupt
'-----41.,_---41.,_-◄--•----<.,_----4.,_----Des,gnated
interrupt enable
enable
11 -- Interrupt
Interrupt enabled
enabled
00 -- Interrupt
Interrupt disabled
disabled
Set or
or clear
clear bits
b,ts 0O--6 6

'-------------------------Set

11 -- W
riting 11 sets
Wnting
sets bit
bit to
to 11
00 -- W
riting 11 sets bit
Wnt1ng
bit to
to 0O
See
interrupt names
names.
See Figure
Figure 1 2
12-3 for
for meaning
meaning of
of interrupt

Writing 0O to
Writing
to any
any of
of

Bit
explained further
further in
Bit 77 is
is explained
in the
the main
main text
text

bits
effect
bits 0O --66 has
has no
no effect

Figure 12-2.
Description of the
Interrupt Enable
12-2. Description
the 6522 VIA Interrupt
Enable Register

IRQ

6

5

4

3

T1

T2

CB1

CB2

0
SR

CA1

CA2

- Bit
Number
~
811Number

.__IR_Q_,_T_1_...__T_2_._c_B_l _.__c_0_2_._s_R_,_c_A_l
.....,_C_A_2_.i.---

-Interrupt Flag register

Interrupt Flag register

Bit 7 indicates
indicates the status of the IRQ output.
output. This bit corresponds
corresponds to the following
following logic
logic function:
function:
IRQ =
IER6) V (IFR5
IER5) V (IFR4
(IFR4 A IER4)
IER4) V (IFR3
(IFR3 A IER3)
IER3) V 0FR2
(IFR2 A
IER2) V (IFR1
A IERl)
IER1) V
- (IFR6
(IFR6 A IER6)
(IFR5 A IER5)
/\ IER2)
(IFRl II
(IFROA IER0)
IERO)
(IFRO
which are set and cleared as follows:
follows:
Bits 0
O - 6 are latches which

0

1

2

3

4

65

66

C leared
a re d by

Sett by

Bitit No.

CA2 pin.
on the CA2

writing the A Port Output
Output
Reading or wntmg
register (ORAi
(ORA) using address 0 001
01.
register

Active transition
transition of
of the
the signal
Active
CA1 pm
pin.
on the CAl

writing the A Port Output
Output
Reading or wntmg
register (ORA), using address
address 0 0
01.
0001
register

Completion of
of eight
eight shifts
shifts.
Completion

writing the
the Shift
Shift
Reading or wntIng
register.
register

Active transition
transition of
of the
the signal
Active
the CB2
CB2 pm
pin.
on the

Reading or writing
writing the
the B Port
Reading
Output register
register.
Output

Active transIt1on
transition of
of the
the signal
Active
the CB1l pin
pin.
on the

Reading or writmg
writing the
the B Port
Readmg
Output register
register
Output

Time-out of
of Tim
er 2.
Time-out
Timer

Reading T22 low-order
low-order counter
counter or
Reading
writing T
high-order counter
counter.
writing
T22 high-order

Tim
e-out of
of Tim
er 1.
Time-out
Timer

Reading Tl
T1 low-order
low-order counter
counter or
Reading

Active transition
transition of the signal
Active

writing T11 high-order
high-order latch
latch.
writing

Figure 12-3.
12-3. Description
Description of
of the
the 6522
6522 VIA
VIA Interrupt
Interrupt Flag
Flag Register
Register
Figure

12
-7
12-7

2)

Enable CBl
CB1 and CB2 interrupts.
interrupts, disable all others.
others, clear CBl
CB1 and CB2 flags.
LDA
STA
LDA
STA
STA

#% 01
#%01100111
VIAIER
VIAIER
#% 1
0011000
#%10011000
VIAIFR
VIAIFR
VIAIER
VIAIER

;DISABLE
OTHER
INTERRUPTS
:DISABLEALL
ALL OTHER
INTERRUPTS

;CLEAR
:CLEARCB1,
CBl. CB2
CB2INTERRUPT
INTERRUPTFLAGS
FLAGS
;ENABLE
INTERRUPTS
:ENABLECB1.
CBl. CB2 CB2
INTERRUPTS

that bit 7 of the Interrupt Flag register and bit 7 of the Interrupt Enable
Note that
Enable
register are both special.
Interrupt Flag register indicates the status of
special. Bit 7 of the Interrupt
the IRQ output-— that is,
interrupts are both active and enabled. Bit
is. it is 1 if any of the interrupts
7 of the Interrupt
Interrupt Enable
Set/Clear control mentioned earlier.
Enable register is the Set/Clear
earlier. Note
Interrupt Flag register cannot
cannot be cleared directly:
directly; it can only be cleared
that bit 7 of the Interrupt
by either clearing all the active interrupt
interrupt flags or by disabling
disabling all the active interrupts.

Note the following about VIA interrupts:
1)
6502 I (or
11 The VIA interrupt enable bits have the opposite
opposite polarity from the 6502
Interrupt Disable)
Disable) flag; that
is. they must be 'V
'1' to enable an interrupt.
that is,
2) RESET
RESET disables all the interrupts.
interrupts.
3)
Interrupt Flag register to see if any interrupts
31 The CPU can check bit 7 of the Interrupt
are both active and enabled. That bit will
ill remain set until
until no interrupt
interrupt is both ac­
active and enabled.
4)
ill remember an interrupt that
that occurs
41 The VIA will
occurs when VIA interrupts are dis­
disabled and will
ill output a request via IRQ as the VIA is enabled.
enabled.
There are several examples of VIA interrupts
interrupts later in this chapter.

12-8

6 530
3 0 and 6 532
3 2 Multifunction
ultifunction Device Interrupts
The 6630
6530 device can provide an interrupt from its interinter­ "'6""6""3"!e'O""'A"""N""0,-6""'6"""3""2---.
6530 AND 6532
val timer. The IRQ
output is also pin PB7 from Port B and
IRO output
MULTIFUNCTION
TIFUNCTION
DEVICE INTERRUPTS
input if it is to be used to cause an
should be set up as an input
interrupt. The interrupt
interrupt can be enabled by writing
riting to the
interrupt.
timer
er with
ith address line A3 high. The interrupt
interrupt can be disabled by writing
riting to the timer
with
ith address line A3 low. It can be cleared by reading or writing
riting the timer
er after
after an interinter­
rupt has
has occurred.
6532 device can provide a timer
er interrupt like the 6630
6530 device. It can also
The 6632
provide
provide an interrupt based on the occurrence
occurrence of an edge on PA7; PA7 thus operates
much like CA11 or CB11 on a 6520
6520 PIA or a 6522 VIA. The interrupt
interrupt can occur
occur either
either on a
low-to-high transition
transition (positive edge)
high-to-low transition
transition (negative edge).
low-to-high
edge) or on a high-to-low
edge).
6532
reading from
6632 interrupts are controlled and examined by w ritingg to and reading
specific addresses
description of the addresses in a 6532 device).
addresses (see
(see Table 12-2 for a description
Note the follow
ing:
following:
1)
1)

To control
control the PA7 interrupt.
interrupt, you simply
simply write
rite any data whatsoever
whatsoever into the ad­
address in the 6532 1/0
I/O section given by:
RS
activate I/O
RS = 1 to activate
1/0 rather than the on-board RAM
1. A4 = 0
A2 = 1,

The two least significant
significant address bits (not the data) then control
control the PA7 mode as
follows:
A1 = 1 to enable PA7 interrupt.
interrupt, 0 to disable it
AO = 1 for a positive (low-to-high)
detect, 0 for a negative (high-to-low)
(high-to-low) edge
(low-to-high) edge detect.
detect.
2)

To read and clear the Interrupt
Interrupt flags,
flags. read from the address in the 6532 I/O
1/0 section
given by:
RS
activate I/O
RS = 1 to activate
1/0 rather than the on-board RAM
A2 = 1,
1. AO== 1

Timer Interrupt
Interrupt flag and bit 6 is the PA7 Interrupt
Interrupt flag. These can easily be
Bit 7 is the Timer
read by means of the Bit Test instruction
instruction (Bit 7 is transferred to the Sign flag and bit 6 to
the Overflow
Overflow flag).

ACIA Interrupts
The 6860
6850 ACIA can also serve as a source
source for interrupts. You
should
should note the following features of the 'ACIA in interruptbased systems:
1)
2)
3)
4)

6850 ACIA
6860
INTERRUPTS
INTERRUPTS

The transmitter
itter interrupt (ACIA is ready for data) is enabled only if Control
register bit 6 = 0 and Control register bit 5
6 = 1.
receiver interrupt (ACIA has received new data) is enabled only if Control
The receiver
register bit 7 = 1.
Master reset does not affect
affect the interrupt enable bits.
Master
Bit 7 of the Status register is set if an interrupt has occurred.
occurred. This bit can be
cleared either
either by reading data from the ACIA or by writing
ritin g data into the ACIA.

12-9

Table 12-2. Addressing
Addressing the 6532
6532 M
ultifunction Device
Table
Multifunction
S
election Lines
Lines
Selection
Address Mode
ode
Address
S
3
~

R/W
R/W

A4
A4

A
A33

A2
A2

A1

AO
AO

00

1(0)
1101

X

X

X
X

X

X

RAM
A M Addressing
Addressing
(Write) RAM. AO - A66 select RAM address.
Read IWr;tel
I/O Addressing
Addressing
1/0

11
1
1
1
1

1(0)
1101
1(0)
1101
1(0)
1101
1(0)
1101

X
X
X
X
X
X

X
X
X
X
X

0
0
0
00

0
0
1
11

0
1
0
1

Read IWr;tel
(W rite) Port
Port A data
Read
(Write) Port A Data Direction
Direction Register
Read (Write)
Read (Write)
(Write) Port
Port B data
data
Read
(Write) Port B Data Direction
Direction Register
Read {Write)
E dge-D
etection Control
Control
dge-Detection

11
1
1
1
1
1

0
0
0
0
0
0
0

0
0
0
0

X
X
X
X

1
1
1
1

0
1
X
X

X
X
0
1

1
1

1

X

X

1

X

1

Disable interrupt
interrupt from
from PA7
PA7
Disable
Enable interrupt
interrupt from
from PA7
Enable
Negative edge detect
detect
Negative
Positive edge detect
detect
Positive
Read and Clear
Clear Interrupt
Interrupt Flags
er Flag
Bit 7 is the Timer
Flag
Bit 6 is the
the PA7
PA7 Flag
B,t
Write
rite Count
ount to Inte
rva l Tim
er
Interval
Timer

11

0
0

1

0

1

X

X

11

0

1

1

1

X

X

disable timer
timer interrupt
interrupt
and disable
enable timer
timer interrupt
interrupt
and enable

<P2

11

0

1

X

1

0

0

and decrement every ct>2pulse

i1

0
0

1

X

1

0

1

and decrement every 8 <t>2
4>2 pulses

11

0

1

X
X

1

1

0

and decrement every 64 <t>2
¢12 pulses

11

0
0

1

X

1

1

1

and decrement every 1 0244 4>2
4>2 pulses
pulses

CS2

For all operations
, CS2 = 0.
operations CS1 ==11,
Logic levels: 0
O means
means low level
level
1 means high level
level
X means
means level
level of that signal
signal does not matter (either 0O or 1)
1)

121
12-10

65
0 2 Polling
602
Polling Interrupt Systems
Most
ost 6602
6502 interrupt systems must poll
poll each PIA, VIA.
VIA, ACIA,
or other device to determine which one
one caused an interrupt.
The polling
polling method is:
is:
1)
1)

Check each PIA by examining Control register bits 6 and 7:
BIT
BIT
BMI
BMI
BVS
BVS

2)

POLLING
POLLING
INTERRUPTS

PIACR
PIACR
INT1
INT1
INT2
INT2

;CHECK
:CHECKPIA
PIA STATUS
STATUS BITS
BITS
;BRANCH
:BRANCHTO
TO INTERRUPT
INTERRUPT11 IF
IF BIT
BIT 77 SET
SET
; BRANCH
:BRANCHTO
TO INTERRUPT
INTERRUPT22 IF
IF BIT
BIT 66 SET
SET

Check each VIA by examining Interrupt
Interrupt Flag
Flag register bit 7:
BIT
BIT
BMI
BMI

VIAIFR
VIAIFR
INTV
INTV

;ARE
VIA?
:AREANY
ANY INTERRUPTS
INTERRUPTSACTIVE
ACTIVE ON
ONTHIS
THIS VIA?
;YES,
:YES,GO
GOEXAMINE
EXAMINE ALL
ALL OF
OFFLAG
FLAG REGISTER
REGISTER

You must still examine the Interrupt
Interrupt Flag
Flag register if there is more than one potential in­
interrupt source from a particular
particular VIA. All that bit 7 tells you is that at least one source is
terrupt
both active and enabled.
enabled.

3)

Check each ACIA by examining Status register bit 7:
BIT
BIT
BMI
BMI

ACIASR
ACTIVE
ACIASR ;ARE
:AREANY
ANY INTERRUPTS
INTERRUPTS
ACTIVEON
ONTHIS
THISACIA?
ACIA?
INTA
;YES. GO
GO DETERMINE
WHICH ONE
ONE IF
IF NECESSARY
INTA
:YES.
DETERMINEWHICH
NECESSARY

The interrupt
interrupt could still be either a receiver or a transmitter
itter interrupt.

The important features
features of a 6602
6502 polling system are:
1)

interrupt examined has the highest priority, since
The first interrupt
since the remaining in­
interrupts will
ill not be examined
examined if the firs t one is active. The second interrupt
interrupt has
has
the next highest priority.
priority, and so on.
on.
2) The service routine m ust clear the interrupt flags from PIAs, VIAs.
VIAs, ACIAs.
ACIAs, or
21
automatically.
other devices if the clearing is not performed automatically.
The programmer should
should be particularly careful of:
output ports.
PIAs being used as interrupting output
ports.
A dummy
m y read of the port is necessary,
Interrupt flag is not cleared autoauto­
necessary. since the Interrupt
matically when data is written
ritten into the port. PIA Status (Interrupt) flags are cleared
matically
only when
when the Data registers are read.
read.

•

VIAs being used in the independent
independent input mode or through addresses that
that do
VIAs
not affect
affect the Interrupt
Interrupt flags.
The Interrupt
Interrupt flag must then be explicitly
explicitly cleared by writing
riting a logic ·1
'V• into the appropriappropri­
Interrupt Flag register.
ate bit of the Interrupt
Polling routines are adequate
adequate if there are only a few
w inputs.
However, if there are many inputs, polling routines are
However,
kw ard because:
slow and aw
awkward

DISADVANTAGES
DISADVANTAGES
OF POLLING
INTERRUPTS

1)
1)

number of polling
polling operations increases
The average number
increases
ith the number
number of inputs. On the average,
you'll have to poll
linearly with
average. of course,
course. you'll
inputs before finding
finding the correct
correct one.
half of the inputs
one. You can reduce the average num-­
polling operations
operations somewhat
somewhat by checking
checking the most frequent
frequent inputs
inputs first.
ber of polling
2) PIA,
VIA, and ACIA addresses are rarely consecutive
consecutive or evenly spaced: therefore,
PIA, VIA.
separate instructions
instructions are necessary to examine each input. Polling
Polling routines are
u lt to expand. Tables of I/O
could be used by placing
placing the
therefore d iffic
ifficult
1/0 addresses could
post-indexed addressing mode or by placplac­
base address on page zero and using the post-indexed
entire table on page zero and using the pre-indexed
pre-indexed addressing mode.
ing the entire
mode.

3)

Interrupts that
that are polled first may shut
shut out
out those that
that are polled later unless the
Interrupts
polling is varied. However.
However, the lack of consecutive
consecutive addresses makes varyvary­
order of polling
ing the order of polling
polling difficult.
difficult.
1 2 -1 1
12-11

65
0 2 Vectored Interrupt Systems
602
polling in 6502-based
6502-based systems has typically
typically been
6502
The problem of polling
6502
solved by special methods.
methods, unique
unique to a particular
particular application
application or
VECTORED
VECTORED
microcomputer. Note that
that there is no way
ay to know that
that the
microcomputer.
INTERRUPTS
INTERRUPTS
6602 has accepted an interrupt other than by recognizing
6602
recognizing the
addresses
when they
they appear on the Address Bus.
addresses FFFE
FFFE and FFFF
FFFF when
Bus. Special hardware
can then substitute the vector
vector provided by the actual source.4 We will
ill not discuss
interrupt systems any further.
6502 vectored interrupt

1 2 -12

EXAMPLES
A Startup Interrupt
Purpose: The computer
puter w
interrupt to
starting actual opera­
waits for a VIA
VIA interrupt
to occur before starting
operations.
inactive u ntil
til the
operator actually
actually starts them
until a Data
Many systems remain inactive
the operator
them or until
Ready
initialize the Stack Pointer,
Ready signal is received. On RESET,
RESET,such systems must initialize
Pointer. ena­
enable the startup
startup interrupt.
interrupt, and execute an endless loop or jump-to-self
p-to-self instruction.
instruction.
Remember that RESET
interrupt (by setting
setting I to 1)
RESETdisables the processor interrupt
1) as well as
as all
the
interrupts (by clearing
clearing all the VIA interrupt
interrupt enable bits). In the flowchart.
flowchart, the
the VIA interrupts
decision as to whether
hether startup
startup is active
active is made in hardware
hardware (i.e
(i.e.,.. by the CPU
examining
decision
CPU examining
the interrupt
interrupt input
input internally)
internally) rather
rather than in software.

Flowchart:
Flowchart:

(

Star,
Start

)

Initialize Stack
Pointer
Pointer
Enable
Enable startup
interrupt
interrupt on
on VIA
Enable
Enable CPU
CPU interrupt

End

Source Program:
Main
Main Program:

HERE
HERE

LDX
TXS
LDA
STA
LDA
STA
STA
CLI
JMP

#$FF
#$FF
#0
VIAPCR
#% 1
0000010
10000010
VIAIFR
VIAIER
HERE
HERE

;PUT
:PUT STACK AT END OF PAGE
PAGE 1

:MAKE ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
;CLEAR
:CLEAR CA11 INTERRUPT
INTERRUPT FLAG
:ENABLE
;ENABLE CA11 INTERRUPT
INTERRUPT
lENABLE
:ENABLE CPU INTERRUPT
INTERRUPT
:WAIT
AIT FOREVER
FOREVER

Interrupt Service
Service Routine:
Routine:
•=INTRP
*=INTRP
# %10000010
10000010
LDA
VIAIFR
STA
#$FF
LDX
#$FF
TXS
START
JMP

;CLEAR
:CLEAR CA11 INTERRUPT
INTERRUPT FLAG
:REINITIALIZE
:REINITIALIZE STACK POINTER
POINTER

12-133
12

Object Program:
Object
Program:
Memory Address
Address
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Main Program:
Program:
Main
0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006)
0006}
0007)
0007
0008
0008
0009
0009
000A
OOOA
OOOBt
000B}
OOOCt
oooc
000D
0000
000EI
OOOE}
000F)
OOOF
0010
0010
0011
0012
0012
0013

A2
FF
FF
9A
A9
00
8D
80

LDX
LOX

#$FF
#$FF

TXS
LDA
LOA

#00

STA

VIAPCR

LDA
LOA

#% 1
0000010
#%10000010

STA

VIAIFR

STA

VIAIER

CLI
CLI
JMP

HERE
HERE

LDA
LOA

#%10000010
10000010

STA

VIAIFR

LDX
LOX

#$FF

TXS
JMP

START
START

VIAPCR

A9
82
8D
80
VIAIFR
8D
80
VIAIER
58
4C
11
11
00

HERE
HERE

Interrupt Service Routine:
Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+31
INTRP+3~
INTRP+4)
INTRP+4
INTRP+5
INTRP+6
INTRP+7
INTRP+8
INTRP+9
INTRP+9} I
INTRP+A)
INTRP+A

A9
82
8D
80
VIAIFR
A2
FF
FF
9A
4C
START
START

1212-14

The exact location
location of the interrupt
interrupt service routine
routine varies
INTERRUPTS ON
with
ith the microcomputer.
microcomputer. If your m icrocom
puter has no
icrocomputer
PARTICULAR
monitor, you can simply
simply place whatever
whatever address you want
want
monitor.
MICROCOMPUTERS
MICROCOMPUTERS
in memory locations FFFE
whatever locations
FFFEand FFFF
FFFF (or
lor whatever
addresses). You must then start the interrupt
respond to those addresses).
interrupt service routine at the adad­
chose. Of course,
course. you should place the routine so that it does not interfere
dress you chose.
with
ith fixed addresses or with
ith other programs.
If your
your m icrocom
puter has a monitor.
monitor, the monitor
onitor will
ill occupy
occupy ad­
INTERRUPT
icrocomputer
addresses FFFE
FFFEand FFFF.
FFFF.Those addresses will
dresses
ill either contain
contain a startstart­
HANDLING
HANDLING
BY MONITORS
MONITORS
ing address at which
hich you must place your interrupt
interrupt service
routine,
ill contain
routine. or will
contain the starting
starting address of a routine that allows
you to choose the starting
starting address of the interrupt
interrupt s;i:vice
service routine. A typical
typical monitor
monitor
routine would
ould be:
routine
be:
MONINT JMP

(USRINT)
(USRINT)

;JUMP
USER SUPPLIED
SUPPLIED INTERRUPT
INTERRUPTADDRESS
ADDRESS
JU
P TO USER

You must then place the address of your service routine
routine in memory locations USRINT
USRINT
and USRINT+1. Remember that MONINT is an address in the monitor
onitor program and its
FFFE and FFFF.
FFFF.
value is in addresses FFFE
You can include
include the loading of memory locations USRINT
USRINT and USRINT+1
USRINT+1 in your main
program.
LDA
LOA
STA
LDA
LOA
STA

#USRL
#USRL
USRINT
USRINT
#USRM
#USRM
USRINT+1
USRINT+1

;LOAD LSB'S OF USER
:LOAD
USER INTERRUPT
INTERRUPTADDRESS
ADDRESS
:LOAD MSB'S OF USER
;LOAD
USER INTERRUPT
INTERRUPTADDRESS
ADDRESS

These instructions
instructions must precede the enabling
enabling of the interrupts.
interrupt from the startup
startup VIA. We have assumed
The main program only enables the interrupt
that the startup
startup line is attached
attached to VIA input
input CA11 and that the active edge is the trailing
trailing
one (i.e.... a high-to-low
high-to-low transition). Other configurations
configurations would
would merely require different
different
values in the VIA Peripheral Control
Control register.
Note that
that the VIA interrupt
interrupt is enabled and the Stack Pointer
Pointer is loaded before the CPU
CPU
interrupt
interrupt is enabled (by clearing
clearing the I bit). What
hat would
would happen if you cleared the I bit
before loading the Stack Pointer? This will
ill not be a potential
potential problem if the monitor
monitor
already places a value in the Stack Pointer.
In this example, the return address and Status register that
that the 6502 stores in the Stack
on accepting
accepting an interrupt
interrupt are not useful. Thus the service routine simply
simply reinitializes
reinitializes the
Stack Pointer.

HERE instruction
Note that
that we could replace the JMP HERE
instruction with
ith a conditional
conditional branch that
provided a guaranteed jump,
BNE HERE.
HERE.The Zero flag is not zero since the last
p, such as BNE
operation was the one that enabled the CA11 interrupt.
interrupt. This shortcut
shortcut is often helpful to
operation
addressmake up for the fact
fact that
that the 6502 has no unconditional
unconditional branch with
ith relative address­
ing.
ing.

Remember
RESET and accepting an interrupt automatically
disable the interRemember that
that RESET
atically disable
inter­
rupt system. This allows the real startup routine to configure all the
•the VIAs and
interrupt sources w ith
o u t being interrupted. Note that you must explicitly
explicitly
other interrupt
ithout
Interrupt flag or else it will
ill interrupt
interrupt again as soon as the interrupt
interrupt system
clear the CA11 Interrupt
is re-enabled. You could also clear the flag by reading the VIA's
VIA's Output
utput Register A from
(see Table 11-7).
11-7).
the handshaking
handshaking address (see

12-15
12-

A Keyboard Interrupt
Purpose:
computer waits
aits for a keyboard
keyboard interrupt
interrupt and places
Purpose: The computer
keyboard into
into memory
memory locaton
locaton 0040.
0040.
the data from the keyboard

KEYBOARD
KEYBOARD
INTERRUPT

Sample Problem:
Keyboard data
Keyboard
Result: (0040)

=
=

06
06

Flowchart:

c

Start

I

Initialize Stack
Pointer
Enable keyboard
interrupt on VIA
Enable CPU interrupt

10040) ~ data

End

Source Program:
Program:
Program:
Main Program:

HERE
HERE

LDX
LOX
TXS
LDA
LOA
STA
STA
LDA
LOA
STA
STA
CLI
CLI
JMP

#$FF
#$FF

#0
#0
VIAPCR
VIADDRA
VIADDRA
#%10000010
#%10000010
VIAIFR
VIAIER
HERE
HERE

;PUT STACK AT END OF PAGE
PAGE 1

;MAKE ALL CONTROL LINES
LINES INPUTS
:MAKE
PORT A LINES INPUTS
;MAKE PORT
:CLEAR KEYBOARD INTERRUPT
INTERRUPT FLAG
:ENABLE KEYBOARD INTERRUPT
INTERRUPT FROM VIA
ENABLE CPU
CPU INTERRUPT
;ENABLE
INTERRUPT
DUMMY MAIN PROGRAM
;DUMMY
PROGRAM

Interrupt Service
Service Routine:
Routine:
Interrupt
*=INTRP
*=INTRP
PHA
LDA
LOA
VIAORA
STA
$40
PLA
RTI
RTI

ACCUMULATOR IN STACK
:SAVE ACCUMULATOR
DATA
:GET KEYBOARD DATA
DATA
;SAVE KEYBOARD DATA
RESTORE ACCUMULATOR
ACCUMULATOR FROM STACK
;RESTORE

12-16
12
16

Object Program:
Program:
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

Main Program:
OOOU
0000
0001
0002
0003
0004
0005
0006)
0006}
00071
0008
00091
0009}
000A
OOOAt
0008
0B

OOOC
oooc
000D
000E)
OOOE}
0
00Fl
OOOF
0010
0011)
0011}
00121
0013
0014
0015
0016

A2
FF
FF
9A
A9
00
8D

LDX
LOX

#$FF

TXS
LDA
LOA

#00

STA

VIAPCR
VIAPCR

STA

VIADDRA

LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR
VIAIFR

STA

VIAIER
VIAIER

VIAPCR
VIAPCR
8D
VIADDRA

A9
82
8D
VIAIFR
VIAIFR
8D
VIAIER
VIAIER

cu

58
4C
14
00

HERE
HERE

CLI
JMP

HERE
HERE

PHA
PHA
LDA
LOA

VIAORA

STA

$40

Interrupt Service Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+1
INTRP+2)
INTRP+2}
INTRP+3)
INTRP+4
INTRP+5
INTRP+6
INTRP+7

48
AD
VIAORA
85
40
68
40

PLA
RTI
RTI

You must configure
configure the VIA completely
completely before enabling
enabling the interrupts. This includes
establishing the directions
directions of ports,
ining the transitions
transitions to be recognized on
establishing
ports. determ
determining
strobe lines,
that setting bit 0
Auxiliary Control
lines. and enabling latches (remember that
O of the Auxiliary
register enables the Port A latch).
latch).
The JMP HERE
instruction that
that is used to represent the
HEREis an endless loop (jump-to-self) instruction
main program. After
After interrupts
interrupts are enabled in a working
working system,
system. the main program goes
til an interrupt
interrupt occurs and then resumes execution after the interinter­
about its business until
rupt service routine is completed.

12-17

instruction at the end of the service routine
routine transfers
CHANGING THE
The RTI
RT! instruction
CHANGING
control back to the JMP instruction
instruction in the main program. If you
INTERRUPT
control
want
ant to avoid this.
this, you can simply
RETURN
simply change the Program
Counter in the Stack. Remember that
that the Stack is always
always lo­
ADDRESS
Counter
lo0100 - 01 FF),
Pointer
cated on page 1 (addresses
(addresses 0100
FF). the Stack Pointer
contains the address of the next empty
empty location.
location, and the interrupt
interrupt response places the
contains
Program Counter
following pro­
proCounter in the Stack underneath
underneath the Status register. Thus the following
gram will
ill increment
increment the Program Counter in the Stack
Stack without
ithout removing it.

DONE
DONE

TXS
INC
$0102,X
$0102.X
BNE
DONE
BNE
DONE
INC
$0103,X
$0103.X
instruction)
(next instruction)

;MAKE STACK
STACK POINTER
POINTER INTO INDEX
INDEX
INCREMENT
:INCREMENTLSB'S
LSB'SOF
OFRETURN
RETURNADDRESS
ADDRESS
;AND
:AND CARRY
CARRYTO
TOMSB'S
MSB'SIFIFNECESSARY
NECESSARY

6502 does not autom
atically save its registers (other than the Status register),
Since the 6502
automatically
register).
you can use them to pass parameters
parameters and results between
between the main program
program and the in­
interrupt service routine. So.
could leave the data in the Accum
ulator instead of in
terrupt
So. you could
Accumulator
location 0040. This is,
however, a dangerous
dangerous practice
practice that
that should be avoided
memory location
is. however.
in all but the most trivial
trivial systems. In most applications.
applications, the processor is using its
during normal program
program execution:
execution; having the interrupt
interrupt service routines
routines ran­
registers during
randomly change
change the contents
contents of those registers would
would surely cause havoc. In general, no
domly
register unless that register's
register's con­
interrupt service routine should ever alter any register
contents have been saved prior to its alteration
alteration and will
ill be restored at the completion
tents
of the routine.
explicitly re-enable
re-enable the interrupts
interrupts at the end of the service
Note that you need not explicitly
routine. The reason is that
that the RTI instruction automatically
automatically restores the old Status
(P)
ith the Interrupt
Interrupt Disable bit in its original state.
state. In fact.
fact, you will
ill have
(Pl register with
to alter
alter the Interrupt
Interrupt Disable bit in the Stack (bit 2 of the top location) if you do not want
want
the interrupts
interrupts to be re-enabled.
Using the Stack is the most general approach to saving and restoring registers.
The instruction PHA saves the contents of the Accumulator
Accumulator in the Stack and the
Accumulator from the Stack. This
instruction PLA restores the contents of the Accumulator
indefinitely (as long as there is room in the Stack) since
method can be expanded indefinitely
ill not destroy the data saved by the earlier routines.
nested service routines will
You can save all the registers in the Stack (remember that
that Status is autom
atically
automatically
saved)
ith the sequence:
saved) after an interrupt
interrupt with
PHA
TXA
PHA
TYA
PHA

;SAVE
:SAVE ACCUMULATOR
ACCUMULATOR
;SAVE
;SAVE INDEX
INDEX REGISTER
REGISTERX
;SAVE
:SAVE INDEX
INDEX REGISTER
REGISTERY

Note that there is no direct
direct way
ay to transfer data betw
een the Stack and the Index
Note
between
registers. The contents
contents of the Accumulator
Accumulator must be saved first (why?).
You can restore the register;
atically restores
register. from the Stack (remember that
that RTI
RTI autom
automatically
Status) after
after an interrupt
interrupt se vice routine
routine by removing
removing the data from the Stack in the opop­
which it .^as
posite order from which
.Jas entered:
PLA
TAY
PLA
TAX
PLA

;RESTORE
:RESTOREINDEX REGISTER
REGISTERY
;RESTORE
:RESTOREINDEX REGISTER
REGISTERX
;RESTORE
ACCUMULATOR
:RESTOREACCUMULATOR

12
-1 8
2-18

that the Accum
ulator is saved first
first and restored last.
Note that
Accumulator
alternative approach
approach would
ould be for the interrupt
interrupt routine
routine to
An alternatwe
maintain control
entire line of text
string
maintain
control until
until it received
received an entire
text (e.g.,
(e.g.. a string
characters ending
ending with
ith a carriage
carriage return). The main program
program
of characters
would be:
would

FILLING A
BUFFER VIA
INTERRUPTS

Program:
Main Program:

HERE
HERE

LDX
TXS
LDA
STA
STA
STA
LDA
STA
STA
CLI
CL!
JMP

#$FF
#$FF
#00
VIAPCR
VIADDRA
VIADDRA
$40
#% 1
0000010
10000010
VIAIFR
VIAIER
HERE
HERE

;PUT STACK AT END OF PAGE
PAGE 1

:MAKE ALL CONTROL LINES
LINES INPUTS
MAKE PORT
PORT A LINES
LINES INPUTS
INPUTS
:MAKE
:CLEAR BUFFER
BUFFER INDEX TO START
;CLEAR KEYBOARD
KEYBOARD INTERRUPT
INTERRUPT FLAG
FLAG
ENABLE KEYBOARD
;ENABLE
KEYBOARD INTERRUPT
INTERRUPT FROM
FROM VIA
;ENABLE CPU
CPU INTERRUPT
INTERRUPT
DUMMY MAIN PROGRAM
;DUMMY
PROGRAM

Interrupt Service
Service Routine:
Routine:
Interrupt

ENDL

*=INTRP
*=INTRP
PHA
TXA
PHA
LDX
LDA
STA
CMP
BEQ
BEG
INC
PLA
TAX
PLA
RTI
RTI
JMP

ACCUMULATOR IN STACK
;SAVE ACCUMULATOR
;SAVE INDEX REGISTER
REGISTERX IN STACK

$40
VIAORA
$41,X
$41.X
#CR
ENDL
ENDL
$40

GET BUFFER
;GET
BUFFER INDEX
GET KEYBOARD
DATA
:GET
KEYBOARD DATA
DATA IN BUFFER
;SAVE DATA
BUFFER
DATA A CARRIAGE
;IS DATA
CARRIAGE RETURN?
RETURN?
YES, END OF LINE
;YES.
LINE
NO, INCREMENT
;NO.
INCREMENT BUFFER
BUFFER POINTER
POINTER
RESTORE
;RESTORE INDEX REGISTER
REGISTERX FROM
FROM STACK
RESTORE ACCUMULATOR
ACCUMULATOR FROM
FROM STACK
;RESTORE

LPROC
LPROC

PROCESS LINE WITHOUT
WITHOUT INTERRUPTS
;PROCESS
INTERRUPTS

program fills a buffer
buffer starting
starting at memory
memory location
location 0041 until
until it receives a carriage
This program
return character
character (CR).
Memory location
location 0040
0040 holds the current
current buffer
buffer index.
return
(CR). Memory
When
hen the processor
processor receives a carriage
carriage return.
return, it leaves the interrupt
interrupt system disabled
disabled
while it handles
handles the line.
while
An alternative
alternative approach
would be to fill
fill another
another buffer
buffer while
hile hanhan­
approach would
dling the first
first one:
one; this approach
approach is called double
double buffering.
buffering.
dling

DOUBLE
BUFFERING

processing routine
routine is begun at address LPROC
ith interrupts
interrupts disabled.
disabled, and
The line processing
LPROC with
with
ith the original
original register
register contents
contents (P,
return address in the Stack.
(P, A, and X) and the return
In a real application,
application, the CPU could
interrupts. It could,
could perform
perform other
other tasks between
between interrupts.
could. for
instance, edit.
edit, move, or transm
buffer while
hile the interrupt
interrupt was filling
filling
instance.
transmitit a line from one buffer
another buffer.
another

1 2 -19

Interrupt
A Printer Interrupt
The com
puter waits
waits for
for a printer
printer interrupt
interrupt and sends
sends the data from
from memory
memory
Purpose: The
computer
location 0040
0040 to the printer.
printer.
location
Sample Problem:
Problem:
Sample

(0040)
Result:

=

5116
if
Printer receives
receives a 5115
1 1 6 (ASCII 0)
Q) when
when it is ready.
Printer

Flowchart:
Flowchart:
Start

Initialize Stack Pomter
Enable pnnter
interrupt on VIA

Data - (0040)

Enable CPU interrupt

Send data to pnnter

End

Source Program:
Program:
Main Program:
LDX
LOX
TXS
STX
STX
LDA
LOA
STA
LDA
LOA
STA
STA
CLI
JMP

cu

HERE
HERE

#$FF

:PUT STACK AT END
END OF
OF PAGE
PAGE 1

VIADDRB
#0
VIAPCR
#%10000010
#%10000010
VIAIFR
VIAIFR
VIAIER
VIAIER

;MAKE
:MA!(E PORT
PORT B LINES
LINES OUTPUTS
OUTPUTS

HERE
HERE

;MAKE
:MAKE ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
CLEAR PRINTER
:CLEAR
PRINTER INTERRUPT
INTERRUPT FLAG
FLAG
:ENABLE PRINTER
PRINTER INTERRUPT
INTERRUPT FROM
FROM VIA
:ENABLE CPU
CPU INTERRUPTS
INTERRUPTS
DUMMY MAIN PROGRAM
:DUMMY
PROGRAM

Interrupt Service
Interrupt
Service Routine:
"=INTRP
*=INTRP
PHA
LDA
$40
LOA
$40
STA
VIAORB
VIAORB
PLA
RTI
RT/

ACCUMULATOR IN STACK
:SAVE ACCUMULATOR
STACK
GET DATA
:GET
SEND DATA TO
:SEND
TO PRINTER
PRINTER
RESTORE
ACCUMULATOR FROM
:RESTORE ACCUMULATOR
FROM STACK
STACK

12
12-20

O bject P ro g
ra m :
rogram:

Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

Main Program:

0000
0001
0002
0003
00041
0004}
00051
0006
0007
0008
0008
0009)
0009}
000A)
OOOA
OOOB
000B
000C
oooc
000D
0000
000E)
OOOE}
0
00F)
OOOF
0010
0010
0011)
0011}
0012)
0012
0013
0013
0014
0014
0015
0016
0016

A2
A2
FF
FF
9A
8E
SE

LDX
LOX

#$FF

TXS
TXS
STX
STX

VIADDRB
VIAOORB

LDA
LOA

#0

STA

VIAPCR
VIAPCR

LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR

STA

VIAIER
VIAIER

CLI
CLI
JMP

HERE
HERE

PHA
LDA
LOA

$40

STA

VIAORB

VIADDRB
VIAOORB
A9
00
8D
80
VIAPCR
A9
82
8D
80
VIAIFR
VIAIFR
8D
80
VIAIER
VIAIER
58
4C
14
00

HERE
HERE

Interrupt Service
Service Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+2
INTRP+3
INTRP+3
INTRP+4)
INTRP+4}
INTRP+51
INTRP+6
INTRP+6
INTRP+7
INTRP+7

48
A5
40
8D
80
VIAORB
68
40

12-21
12-21

PLA
RTI
RTI

Here, as
as w
ith the
the keyboard.
keyboard, you
you could
could have
have the
the printer
printer continue
continue to
to
Here.
with
interrupt until
until itit transferred
transferred an
an entire
entire line
line of
of text.
text. The
The main
main propro­
interrupt
gram and
and the
the service
service routine
routine would
would be:
be:
gram

EMPTYING
EM
PTYING A
BUFFER
ITH
BUFFER W
WITH
INTERRUPTS

Main Program:
Program:
Main
LDX
LOX
TXS
STX
STX
LDA
STA
STA
LDA
LOA
STA
STA
CLI
JMP

cu

HERE
HERE

#$FF
#$FF
VIADDRB
VIADDRB
#00
VIAPCR
$40
$40
#%
10000010
#%10000010
VIAIFR
VIAIER
HERE
HERE

;PUT STACK
STACK AT
AT END OF PAGE
PAGE 1
;PUT
:MAKE PORT B
B LINES
LINES OUTPUTS
:MAKE
;MAKE ALL
ALL CONTROL LINES INPUTS
:MAKE
;INITIALIZE BUFFER
:INITIALIZE
BUFFER INDEX TO ZERO

:CLEAR PRINTER
PRINTER INTERRUPT
INTERRUPT FLAG
:ENABLE
PRINTER INTERRUPT
INTERRUPT FROM VIA
;ENABLE PRINTER
VIA
:ENABLE CPU INTERRUPT
;ENABLE
INTERRUPT
;DUMMY MAIN
MAIN PROGRAM
:DUMMY

Interrupt Service
Service Routine:
Interrupt
Routine:

ENDL

*=INTRP
*=INTRP
PHA
TXA
PHA
LDX
LOX
LDA
STA
CMP
BEQ
BEO
INC
PLA
TAX
PLA
RTI
RTI
JMP

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
:SAVE
:SAVE
REGISTERX IN STACK
;SAVE INDEX REGISTER

$40
$4
1.X
41,X
VIAORB
#CR
ENDL
$40

:GET BUFFER
BUFFER INDEX
GET A BYTE OF DATA
DATA FROM BUFFER
:GET
BUFFER
DATA TO PRINTER
:SEND DATA
PRINTER
DATA A CARRIAGE RETURN?
:IS DATA
RETURN?
YES, END OF LINE
:YES.
NO, INCREMENT BUFFER
:NO.
BUFFER POINTER
POINTER
RESTORE
:RESTORE INDEX REGISTER
REGISTERX FROM
FROM STACK
;RESTORE ACCUMULATOR
FROM STACK
;RESTORE
ACCUMULATOR FROM

LCOMP

:HANDLE COMPLETED
COMPLETED LINE
LINE
:HANDLE

Again, double
double buffering
buffering could
could be used to allow
allow I/O
processing to occur
occur at the same
Again.
1/0 and processing
time w ith
o u t ever halting
halting the CPU.
ithout
CPU.

12-22
12-22

56
A Real-Time
eal-Tim e Clock lnterrupt
Interrupt5,6
•
Purpose: The computer
Purpose:
puter waits
waits for an interrupt
interrupt from a real-time
clock.

REAL-TIME
CLOCK
CLOCK

A real-timee clock simply provides a regular series of pulses.
een
pulses. The interval between
Real-time clock interrupts can be
the pulses
pulses can be used as a time reference. Real-time
counted to give any multiple of the basic time interval. A real-time
real-time clock can be propro­
dividing down the CPU
programmable
duced by dividing
CPU clock, by using a separate timer or a programmable
timer
er like the ones available in the 6522 VIA or in the 6530
6530 or 6532 Multifunction
ultifunction
devices (see
(see Chapter
11). or by using external sources such as the AC line frequency.
Chapter 11),
Note the tradeoffs involved in determining the frequency
frequency of
FREQUENCY
Note
the real-timee clock. A high frequency
(say 10 kHz)
kHz) allows the
frequency (say
OF REAL-TIME
creation
creation of a wide range of time intervals
intervals of high accuracy. On the
CLOCK_______
other hand,
involved in counting
counting real-time
real-time clock
other
hand. the overhead involved
interrupts
interrupts may be considerable, and the counts will
ill quickly
quickly exceed the capacity
capacity of a
-b it register or memory location. The choice of frequency
frequency depends on the precipreci­
single 8-bit
sion and timing
ing requirements
requirements of your application.
application. The clock may, of course, consist
partly of hardware; a counter
interrupt the pro­
procounter may count
count high frequency
frequency pulses andinterrupt
measure time
time to
cessor only occasionally. A program will
ill have to read the counter
counter to
to measure
high accuracy.
One problem is synchronizing operations with
ith the realreal­
time clock. Clearly, there will
ill be some effect
effect on the precipreci­
sion of the timing
ing interval
interval if the CPU
CPU starts the measure­
measurement randomly
period. rather than exactly
randomly during
during a clock period,
exactly at
are:
the beginning.
beginning. Some ways to synchronize operations
operations are:

SYNCHRONIZATION
SYNCHRONIZATION
WITH
ITH REAL-TIME
CLOCK
CLOCK

1)
1)

startup interrupt
interrupt can start the clock as
Start the CPU
CPU and clock together. RESET
RESETor a startup
well as the CPU.
CPU.
CPU to start and stop the clock under program control.
2) Allow
llow the CPU
less than one clock period will
3) Use a high-frequency
high-frequency clock so that an error of less
ill be
small.
measure4) Line up the clock (by waiting
aiting for an edge or interrupt)
interrupt) before starting
starting the measure­
ment.
PRIORITY
A real-tim
real-timee clock interrupt should
should have very high priority,
OF REAL-TIME
since the precision of the timing intervals will be affected
affected by
CLOCK
CLOCK
any delay in servicing the interrupt. The usual practice
practice is to
make the real-time
real-time clock the highest
highest priority
priority interrupt
interrupt except
except for
power failure.
failure The clock interrupt service routine is generally kept
kept extrem
ely short
extremely
so that it does not interfere
interfere with
ith other CPU activities.
activities.

12-23
1

a)
ait for Real-Time Clock
al Wait
Source Program:
Program:
Main Program:
Program:

HERE
HERE

LDX
LOX
TXS
TXS
LDA
LOA
STA
STA
LDA
LOA
STA
STA
STA
STA
CLI
CLI
JMP
JMP

#$FF
#0
VIAPCR
VIAPCR
# %10000010
10000010
VIAIFR
VIAIFR
VIAIER
VIAIER
HERE
HERE

;PUT STACK
STACK AT END
END OF
OF PAGE
PAGE 1
;PUT

;MAKE
:MAKE ALL CONTROL
CONTROLLINES
LINES INPUTS
INPUTS
CLEAR
:CLEARCLOCK
CLOCK INTERRUPT
INTERRUPTFLAG
FLAG
:ENABLECLOCK
CLOCK INTERRUPT
INTERRUPTFROM
FROM VIA
ENABLE
ENABLE
:ENABLECPU
CPU INTERRUPT
INTERRUPT
:DUMMY MAIN PROGRAM
PROGRAM

Interrupt Service
Service Routine:
Routine:
*=INTRP
"=INTRP
PHA
PHA
LDA
#%10000010
LOA
#%10000010
STA
VIAIFR
VIAIFR
STA
PLA
PLA
BRK
BRK

;SAVE
:SAVE ACCUMULATOR
ACCUMULATORIN STACK
STACK
:CLEAR
:CLEAR CLOCK
CLOCK INTERRUPT
INTERRUPTFLAG
FLAG
:RESTOREACCUMULATOR
ACCUMULATORFROM
FROM STACK
STACK
;RESTORE

1 2-24

O bject P ro g
ra m :
gram:

Memory Acdress
Address
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

Memory Contents
Memory
(Hex)
(Hex)

Main Program:
0000
0001
0002
0003
0004
0005
00061
0006}
0007)
0007
0008
0009
000A
OOOA
000BI
0008}
000C)
oooc
000D
0000
000E)
OOOE}
000F)
OOOF
0010
0011
0012
0013

A2
FF
FF
9A
A9
00
8D
80

LDX
LOX

#$FF

TXS
LDA
LOA

#00

STA

VIAPCR
VIAPCR

LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR
VIAIFR

STA

VIAIER
VIAIER

CLI
CLI
JMP

HERE
HERE

PHA
LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR
VIAIFR

VIAPCR
VIAPCR
A9
82
8D
80
VIAIFR
VIAIFR
8D
80
VIAIER
VIAIER
58
4C
11
11
00

HERE
HERE

Interrupt Service Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+1
INTRP+2
INTRP+3
INTRP+4)
INTRP+4}
INTRP+5)
INTRP+5
INTRP+6
INTRp+7

48
A9
82
8D
80
VIAIFR
VIAIFR
68
00

PLA
BRK
BRK

If bit 0
interrupt will
ill occur
occur on the high-tohigh-toO of the VIA Peripheral Control register is 0,
0. the interrupt
low (falling) clock edge.
that bit is 1.
interrupt will
ill occur on the low-to-high
low-to-high (ris­
edge. If that
1. the interrupt
(rising) clock edge.
edge.
The Clock Interrupt
Interrupt flag must be explicitly
explicitly cleared in the interrupt
interrupt service routine since
no I/O
still be used for data as long as that
1/0 transfer is required. Note that Port A could still
data was transferred using the address that does not affect
affect the interrupt
interrupt flags (see
(see Ta­
Table 11-7)
11-7).

1 2-25
5

We could.
could, of course.
course, generate
generate the pulse itself
itself using one of the 6522
6522 timers. The follow
follow-­
example uses timer
er 1 to produce
produce a single
single pulse 5000
5000 (1388
1 6> clock cycles in
ing example
(138815)
Remember the following:
following:
length. Remember
1)
1)

er 1 counters
counters are loaded from twoo memory
memory locations
locations (VIAT11L and
The timer
loading the most significant
significant bits of the timer
er count
count into VIAT1CH
VIAT1CH);
CH): loading
CH starts
er and clears the T1 Interrupt
Interrupt flag (bit 6 of the Interrupt
Interrupt Flag register).
the timer

2)

operation of timer
er 1 is controlled
controlled by bits 6 and 7 of the Auxiliary
Auxiliary ConCon­
The mode of operation
register:
trol register:
continuous operation
operation
bit 6 = 0 for a single pulse and 1 for continuous
disable output
output pulses on PB7 and 1 to generate
generate such pulses.
bit 7 = 0 to disable

3)

conclusion of the timing
ing interval
interval sets the timer
er 1 Interrupt
Interrupt flag (bit 6 of the InIn­
The conclusion
terrupt Flag register).
terrupt

Table 11-7 describes
describes the addressing
addressing of the VIA.
VIA, Figure 11-10
11-10 describes
describes the Auxiliary
Auxiliary
Control register.
register, and Figure 12-3 describes
describes the Interrupt
Interrupt Flag register.
Control
Main Program:

HERE
HERE

LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
STA
LDA
LOA
STA
LDA
LOA
STA
CLI
CLI
JMP

#$FF
#$FF
;PUT
:PUT STACK AT END OF PAGE
PAGE 1
#00
VIAACR
#% 1
1000000
%11000000
VIAIFR
VIAIER
VIAIER
# $88
88
VIAT1L
VIAT1L
# $13
13
VIAT1CH
HERE
HERE

GENERATE ONE
:GENERATE
ONE PULSE
PULSE FROM
FROM TIMER 1

:CLEAR TIMER
TIMER 1 INTERRUPT
INTERRUPT
;ENABLE TIMER 1 INTERRUPT
INTERRUPT
PULSE LENGTH
5000 (1388 HEX)
;PULSE
LENGTH = 5000

;START TIMING INTERVAL
ENABLE CPU
CPU INTERRUPT
INTERRUPT
:ENABLE
DUMMY MAIN PROGRAM
:DUMMY
PROGRAM

Interrupt Service Routine:
Routine:
Interrupt

*=INTRP
PHA
LDA
#%1
1000000
LOA
%11000000
STA
VIAIFR
PLA
BRK
BRK

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
;CLEAR
:CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
;RESTORE
ACCUMULATOR FROM
:RESTOREACCUMULATOR
FROM STACK

change in the service
service routine
routine is the position
position of the Clock Interrupt
Interrupt flag in the
The only change
Interrupt Flag register.
Interrupt

12-26

bl
b)

Walt
ait for 10 Real-Time Clock Interrupts

Source Program:
Program:
Main
Main Program:
Program:

WTTEN
WTTEN

LOX
LDX
TXS
LOA
LDA
STA
STA
LOA
LDA
STA
STA
LOA
LDA
CLI
CMP
BNE
SEI
SEI
BRK
BRK

#$FF
#$FF
#00
VIAPCR
$40
#%10000010
#% 1
0000010
VIAIFR
VIAIER
#10
10

$40
$40
WTTEN

;PUT STACK AT END
END OF PAGE
PAGE 1

;MAKE ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
;CLEAR CLOCK
CLOCK COUNTER
COUNTER
;CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
;ENABLE CLOCK INTERRUPT
INTERRUPT FROM
FROM VIA
;NUMBER OF COUNTS== 10
;ENABLE CPU
CPU INTERRUPT
INTERRUPT
;HAVE TEN
TEN COUNTS ELAPSED?
ELAPSED?
;NO, WAIT
AIT
;YES,
CPU INTERRUPT
INTERRUPT
YES, DISABLE CPU

Interrupt
Routine:
Interrupt Service
Service Routine:
•=INTRP
*=INTRP
PHA
$40
INC
LDA
#% 1
0000010
%10000010
LOA
VIAIFR
STA
PLA
RTI
RTI

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
INCREMENT CLOCK COUNTER
;INCREMENT
COUNTER
;CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
;RESTORE ACCUMULATOR
FROM STACK
STACK
;REST0RE
ACCUMULATOR FROM

Clearly
Clearly we
we could
could generate
generate the pulses from the 6522
6522 timerer — for example, we could use
1). The only
timer
register== 1).
tim
er 1 in its continuous
continuous mode (bit 6 of the Auxiliary
Auxiliary Control
Control register
other
other change
change would
would be the bit
bit position
position of the Interrupt
Interrupt flag.

1212-27

O bject
je c t P ro gram:

Memory Address
Address
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Main Program:
Main
0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006)
0006}
00071
0008
0008
0009
0009
000A
OOOA
OOOB
000B
OOOC
000D)
000D}
000E)
OOOE
000F
OOOF
0010)
0010}
0011 f
0012
0013
0014
0015
0016
0016
0017
0018
0018
0019
001A
001A

oooi

oooc

A2
FF
9A
A9
00
8D

LDX
LOX

#$FF
#$FF

TXS
LDA
LOA

#00

STA

VIAPCR

STA

$40

LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR

STA

VIAIER

LDA
LOA

#10
10

CLI
CLI
CMP

$40

BNE
8NE

WTTEN

VIAPCR

85
40
A9
82
8D
VIAIFR
8D
VIAIER
A9
OA
OA
58
C5
40
DO
DO
FC
FC
78
00

WTTEN

SEI
SEI
BRK
BAK

Interrupt Service Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+3
INTRP+4
INTRP+5
INTRP+6)
INTRP+6}
INTRP+7)
INTRP+8
INTRP+9

48
E6
E6
40
A9
82
8D

PHA
INC
INC

$40

LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR
VIAIFR

VIAIFR
VIAIFR
68
40

1212-28

PLA
PLA
RTI
RTI

interrupt service routine
routine merely updates the counter
counter in memory location 0040. It is
This interrupt
transparent
transparent to the main program.
A more realistic real-time clock interrupt routine could
could main­
maintain real time in several memory locations.
example, the
locations. For example.
follow
ing routine
routine uses addresses 0040
0040 through
through 0043
0043 as follows:
follows:
following
0040 - hundredths
hundredths of seconds
0040
0041 - seconds
0042 - minutes
0042
0043 - hours
0043
We assume that the routine
routine is triggered
triggered by a 100 Hz clock.
Flowchart:
Start

Clear clock interrupt
Hundredths =
Hundredths + 1

Hundredths

0

=

Seconds
=
Seconds + 1

Seconds

0

Minutes
Minutes + 1

Minutes
0
Hours
Hours + 1

End

12-29

M A IN
TA IN IN G
INTAINING
REAL
REAL TIME

S o urce P ro gram:
0

ENDINT

*=INTRP
=INTRP
PHA
LDA
STA
INC
LDA
LOA
SEC
SEC
SBC
SBC
BNE
BNE
STA
INC
LDA
LOA
SBC
SBC
BNE
BNE
STA
INC
LDA
SBC
SBC
BNE
BNE
STA
INC
PLA
RTI
RTI

;SAVE
ACCUMULATOR IN STACK
:SAVE ACCUMULATOR
#%1
0000010
%10000010
VIAIFR
$40
$40

;CLEAR
:CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
;UPDATE
:UPDATE HUNDREDTHS OF SECONDS
SECONDS
;IS
:IS THERE
THERE A CARRY TO SECONDS?
SECONDS?

#1
00
100
ENDINT
$40
$41
$41
#60
60
ENDINT
$41
$42
$42
#60
60
ENDINT
$42
$43

:NO, DONE
DONE
YES, MAKE HUNDREDTHS
:YES,
HUNDREDTHS ZERO
ZERO
:UPDATE SECONDS
SECONDS
:IS THERE
THERE A CARRY
CARRY TO MINUTES?
NO. DONE
:NO,
DONE
YES, MAKE SECONDS
:YES,
SECONDS ZERO
ZERO
:UPDATE MINUTES
;IS THERE
THERE A CARRY
CARRY TO HOURS?
HOURS?
:NO, DONE
DONE
YES, MAKE MINUTES ZERO
;YES,
ZERO
:UPDATE HOURS
HOURS
RESTORE
ACCUMULATOR FROM
;RESTOREACCUMULATOR
FROM STACK

Now a wait
ait of 300 ms could be produced in the main program with the routine:

WAIT30
AIT30

LDA
LOA
CLC
ADC
CMP
BCC
BCC
SBC
SBC
CMP
BNE
BNE

$40

;GET
;GET CURRENT
CURRENT REAL
REAL TIME

#30
30
# 100
00
WAIT30
AIT30
# 100
00
$40
WAIT30
AIT30

iDESIRED
;DESIRED TIME IS 30 COUNTS LATER
LATER
;MOD
:MOD 100

;WAIT
AIT UNTIL DESIRED
DESIRED TIME

explicit SET
instructions except
except in the first
first operation
operation in
We do not need explicit
SET CARRY
CARRY (SEC)
(SEC) instructions
interrupt service
service routine.
routine. The other
other operations
operations in the interrupt
interrupt service
service routine
routine are
the interrupt
performed if the previous
previous subtraction
subtraction produced
produced a zero result
only performed
It (and hence also pro­
produced a Carry of 1 indicating
indicating no borrow). In the waitit program.
program, the subtraction
subtraction is only
duced
performed at all if the Carry is 1 (otherwise
(otherwise a branch
branch occurs).
performed
program could
could perform
perform other
other tasks and check the elapsed timee only oc­
Of course, the program
occasionally. How would
would you produce
produce a delay of seven seconds?
seconds? Of three minutes?
minutes?
casionally.
Sometimes
digits or as ASCII characters.
Sometimes you may want
want to keep tim e either
either as BCD digits
characters. How
would you revise the last program
program to handle
handle these alternatives?
alternatives?
would

1 2-30
30

When it is no longer needed.
needed, you can disable the clock
clock interrupt
interrupt
When
(or any other
other interrupt)
interrupt) in any of the following
following ways:

DISABLING
DISABLING
INTERRUPTS
INTERRUPTS

1) By
instruction
thedismain program. This dis­
By executing
executing an
an SEI instruction in the SEI
main
program. in
This
interrupt system.
system. An
An SEI
SEI instruction
instruction in
in the
the service
service routine
routine has
has no
no
ables the entire interrupt
effect, since RTI
restores the
the old
old II flag:
flag: anyway.
anyway, the
the 6502
6502 autom
atically disables
disables inin­
effect.
RTI restores
automatically
terrupts during
during the service routine.
terrupts
2) By
appropriate bit
bit in
in the
the Interrupt
Interrupt Enable
Enable register
register (see
(see Figure
Figure 12-2)
12-2)
By clearing
clearing the
the appropriate
either during
during the service routine
routine or during
during the main program. This disables only the
either
single interrupt
interrupt source from one VIA.
3)

By
By setting
setting the
the Interrupt
Interrupt Disable
Disable flag
flag in
in the
the Stack
Stack during
during the
the service
service routine.
routine. The
The
follow
ing program will
ill do the job (remember that
that the Interrupt
Interrupt Disable flag is bit 2
following
of the Status register and that the Status register is the top entry in the Stack -—
see Figure 12-1):
PLA
ORA
ORA
PHA

#%00000010
00000010

;GET
:GET STATUS
STATUS REGISTER
REGISTER
;SET
:SET INTERRUPT
INTERRUPTDISABLE
DISABLE FLAG
FLAG
;RETURN
:RETURN STATUS
STATUS REGISTER
REGISTERTO STACK
STACK

RTI
ill then cause a return to the main program with
ith the entire interrupt
interrupt system
RTI will
disabled.
Note, however,
re-enabling the interrupts
interrupts
however. that you must be very careful about not re-enabling
automatically.
atically, since the main program would
would be completely
completely unaware that interinter­
rupts were no longer allowed. In general, all interrupt
interrupt service routines should
re­
should reinterrupts before returning; any other policy means that
that the ser­
enable the interrupts
service routines are not transparent
transparent to the main program.
program.

12
12-31

A T e letyp
e w riter Interrupt
letypewriter
Purpose: The computer
computer waits
waits for data to be received
received from a teletypew
riter and stores
teletypewriter
memory location
location 0040.
the data in memory
a)
al

Using
5 0 ACIA
Using a 6 860

(7-bit characters
characters with
parity and twoo stop bits).
(7-bit
ith odd parity

ACIA
INTERRUPT
INTERRUPT
ROUTINE

Source Program:
Main Program:

HERE
HERE

LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
CLI
CLI
JMP

#$FF

;PUT
:PUT STACK AT END OF PAGE
PAGE 1

#%00000011
#%00000011
ACIACR
%11000101
#% 1
1000101
ACIACR

;MASTER
:MASTER RESET
RESET ACIA

HERE
HERE

;ENABLE ACIA INTERRUPT
INTERRUPT

CPU INTERRUPT
INTERRUPT
;ENABLE CPU
;DUMMY MAIN PROGRAM
:DUMMY
PROGRAM

Interrupt
Interrupt Service
Service Routine:
*=INTRP
PHA
LOA
ACIADR
LDA
ACIADR
STA
$40
$40
PLA
RTI
RTI

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
DATA FROM
:GET DATA
FROM ACIA
:SAVE DATA
DATA
:RESTOREACCUMULATOR
RESTORE
ACCUMULATOR FROM STACK

12-32
12

O bject
c t P ro gram:
m:

Instruction
Memory Address
Memory Contents
Instruction
(Hex)
____________(Hex)_______________ (Hex)
(Hex)____________________(Mnemonic)

Main Program:
0000
0001
0002
0003
0004
0005
00
061
0006}
0007)
0007
0008
0009
000A
OOOA
000Bl
OOOB}

A2
FF
FF
9A
A9
03
8D

oooct
oooc

ACIACR
ACIACR

000D
000E
OOOE
000F
OOOF
0010

58
4C
OE
OE
00

LDX

#$FF

TXS
TXS
LDA

# %00000011
00000011

STA

ACIACR
ACIACR

LDA

#% 1
1000101
%11000101

STA

ACIACR
ACIACR

ACIACR
ACIACR
A9
C5
8D

cu

HERE
HERE

CLI
JMP

HERE
HERE

PHA
PHA
LDA
LOA

ACIADR
ACIADR

STA

$40

Interrupt Service Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+1
INTRP+21
INTRP+2}
INTRP+3)
INTRP+4
INTRP+5
INTRP+6
INTRP+7

48
AD
ACIADR
ACIADR
85
40
68
40

PLA
RTI
RTI

Remember that
that the ACIA has
input, so a Master Reset
has no RESET
RESET input.
Reset (making Control
register bits 0
O and 1 both '1') is necessary
necessary before the ACIA is used.
used. The ACIA Control
configuration is:
register configuration
is:
receive interrupt
interrupt
= 1 to enable the receive
Bit 7 =
disable the
the transm
itter interrupt
interrupt andmake
high
Bit 6 = 1,
1, Bit 5 = 0 to disable
transmitter
make RTS
RTS high
(inactive)
Bit 4 = 0,
-bit data with
ith odd parity and two
0. Bit 3 = 0,
0. Bit 2 = 1 to select 7-bit
stop bits
16 clock
clock (1760
(1760 Hz)
Hz)
0. Bit 0
O = 1 for +-s- 16
Bit 1 = 0,
determine if a particular
particular ACIA is
is the
the source
source of
of an
an interrupt.
interrupt, the
To determine
the CPU
CPUmust
mustexamine
examine
the Interrupt
Interrupt Request bit. bit 7 of the Status register.
register. The program must examine the
Receive
Transmit Data Register
Receive Data Register Full bit (Status register bit 0) and the Transmit
Empty bit (Status register bit 1)
differentiate between receive and transm
1) to differentiate
transmitit interrupts.
Either reading the Receive
riting into the Transmit
Transmit Data register clears
Receive Data register or writing
the ACIA Interrupt
Interrupt Request
Request bit.

12-33
12-33

b)
bl

Using a 6522
6522 VIA
VIA
data tied to both
both data
date bit
hit 7 and
anH to
tn control
cnntmt line
linp 1 of
nf
(Received data
the VIA.)

START BIT
INTERRUPT

Source Program:
Main Program:
Program:
Main

HERE
HERE

LDX
TXS
LDA
STA
STA
LDA
STA
STA
CLI
JUMP

#$FF
#$FF
#00
VIAPCR
VIADDRA
VIADDRA
#% 1
0000010
10000010
VIAIFR
VIAIER
HERE
HERE

;PUT STACK AT END OF PAGE 1

;MAKE
MAKE ALL
ALL CONTROL LINES INPUTS

;CLEAR START BIT INTERRUPT FLAG
;ENABLE START BIT INTERRUPT
INTERRUPT FROM VIA
:ENABLE CPU INTERRUPT
INTERRUPT
;DUMMY
DUMMY MAIN
MAIN PROGRAM

Interrupt Service
Service Routine:
Routine:
Interrupt
•=INTRP
*=INTRP
PHA
LDA
STA
STA
JSR
LDA
STA
PLA
RTI
RTI

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
#%00000010
00000010
VIAIFR
VIAIER
TTYRCV
# %10000010
10000010
VIAIER

;CLEAR START BIT INTERRUPT
INTERRUPT FLAG
;DISABLE START BIT INTERRUPT
INTERRUPT
;FETCH
DATA FROM TTY
FETCH DATA
;RE-ENABLE START BIT INTERRUPT
INTERRUPT
;RESTORE ACCUMULATOR
FROM STACK
:RESTORE
ACCUMULATOR FROM

1212-34

O bjectt P ro gram:
m:

Memory
Address
Memory Address
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Main Program:
Program:
Main
0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006)
0006}
00071
0008
0008
0009)
0009}
000A)
000A
000BB
OOOC
oooc
000D
000D
000E
000F
0010
0010
0011)
0011}
0012)
0012
0013
0013
0014
0014
0015
0015
0016
0016

A2
FF
FF
9A
A9
00
8D

LDX

#$FF
#$FF

TXS
LDA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

LDA

#% 1
0000010
%10000010

STA

VIAIFR

STA

VIAIER

CLI
CLI
JMP

HERE
HERE

PHA
LDA

#%00000010
00000010

STA

VIAIFR

STA

VIAIER

JSR

TTYRCV

LDA

#% 1
0000010
10000010

STA

VIAIER

VIAPCR
8D
D
VIADDRA
VIADDRA

A9
82
8D
D
VIAIFR
8D
VIAIER
58
4C
14
00

HERE
HERE

Interrupt Service
Service Routine:
Interrupt
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+3
INTRP+3
INTRP+4)
INTRP+4}
INTRP+5)
INTRP+5
INTRP+6
INTRP+6
INTRP+7)
INTRP+7}
INTRP+8)
INTRP+8
INTRP+9
INTRP+10)
INTRP+10}
INTRP+11)
INTRP+l
INTRP+12
INTRP+12
INTRP+13
INTRP+13
INTRP+14
INTRP+14
INTRP+15)
INTRP+15}
INTRP+161
INTRP+16
INTRP+17
INTRP+17
INTRP+18
INTRP+18

48
A9
02
8D
D
VIAIFR
8D
D
VIAIER
20
TTYRCV
A9
82
8D
D
VIAIER
VIAIER
68
40

12-35

PLA
RTI
RTI

Subroutine
teletypewriter
chapter.
Subroutine TTYRCV is the teletypew
riter receive routine shown in the previous chapter.
The edge used to cause the interrupt
here. The transition from the
interrupt is very important
portant here.
normal '1'
'V (MARK)
(MARK) state to the 'O’ (SPACE)
(SPACE) state must cause the interrupt.
rru p t since this
transition
transition identifies
identifies the start of the transmission. No '0' to '1' transition
transition will occur until a
nonzero data bit
received.
bit is received.

·o·

·o·

·o·transi­
transiThe service routine
each '1'• to 'O'
routine must disable the VIA interrupt.
interrupt, since otherwise each
tion in the character
course. you must re-enable
re-enable the VIA in­
incharacter will
ill cause an interrupt.
interrupt. Of course,
terrupt
read.
terrupt after
after the entire character
character has been read.
Note how VIA interrupts
Enable register is
is
interrupts are enabled or disabled. Bit 7 of the Interrupt
Interrupt Enable
a "Set/C
"Set/Clear
0. subsequent T
lear Control"
Control" bit. If that
that bitit is 0,
'1' bits clear interrupt
interrupt enable bits
and hence disable the corresponding
1. subsequent ·1
corresponding interrupts:
interrupts; if that bit is 1,
'1'• bits set
interrupt
processor
interrupt enable bits and hence enable the corresponding
corresponding interrupts. The processor
cannot
Flag register,
register. so either an enabling or a
cannot actually
actually write
rite into bit 7 of the Interrupt
Interrupt Flag
disabling
interrupt flags. Remember the descriptions
descriptions of
disabling pattern
pattern can be used to clear the interrupt
the Interrupt
Flag register in Figures 12-2 and 12-3.
12-3.
Interrupt Enable register and Interrupt
Interrupt Flag

12-36

MORE GENERAL SERVICE ROUTINES
More general service routines that are part of a complete
interrupt-driven
handle the following tasks:
interrupt-driven system must handle
1)

Saving all registers thatt are used in the interrupt ser­
service routine in the Stack
proStack so that
that the interrupted pro­
resumed.
gram can be correctly resumed.

FOR
TASKS FOR
GENERAL SERVICE
SERVICE
GENERAL
ROUTINES

Remember that
Accumulator
and for
that the 6502 only has Push instructions
instructions for the Accum
ulator and
the Status (P)
(Pl register. Pushing the Status register is unnecessaryafter
afteran
aninterrupt
interrupt
since the interrupt
save all the
interrupt response does this automatically.
automatically. A routine to save
registers in the Stack would
(as shown earlier):
earlier):
would be (as
PHA
TXA
PHA
TYA
PHA

:SAVE
STACK
;SAVE ACCUMULATOR IN STACK
:SAVE
INDEX REGISTER
REGISTERX IN STACK
STACK
;SAVE INDEX
:SAVE
INDEX REGISTER
REGISTERY IN STACK
STACK
;SAVE INDEX

In some 6602
programs, certain memory locations on page
page zero are treated as
as
6502 programs,
extra
locatlons may have to be saved and
and restored during
during in­
inextra registers. Such locations
terrupt
save the contents
terrupt service routines. The procedure to save
contents of memory location
0040
be. for example:
0040 would
ould be,
LOA
LDA
PHA

$40

:SAVE MEMORY
MEMORY LOCATION
LOCATION 0040 IN
IN STACK
STACK
;SAVE

that are used
interrupt service routine must
Of course, only those registers that
used by the interrupt
be saved.
saved.

2)

Restoring all registers from the Stack after
after completing the interrupt service
service
that registers must be restored in the opposite order from that
routine. Remember that
in which
saved.
hich they were saved.

3)

Enabling and disabling interrupts appropriately. Remember that the CPU
CPU auto­
automatically
atically disables its interrupts
interrupts upon accepting
accepting one.
one.

The service routines should
should be transparent as far as the interrupt program
program is
is con­
concerned (i.e.,
(i.e., they should have no incidental
effects).
incidental effects).
that are used by an interrupt service routine
Any standard subroutines that
routine must be
be
reentrant. If some subroutines cannot be made reentrant, the interrupt service
service
routine m ust have separate versions to use.?
use.7

1212-37

PROBLEMS
1)

A Test
est Interrupt

Purpose: The computer
computer waits
waits for a VIA interrupt
interrupt to occur,
occur. then executes the endless
loop instruction:
instruction:
HERE
HERE

JMP

HERE
HERE

u ntil
til the next interrupt
interrupt occurs.

2)

A Keyboard Interrupt

Purpose: The computer
puter waits
ig it entry
entry from a keyboard and places the digits
digits
waits for a 4 -digit
0040 through
through 0043 (first one received in 0040). Each
into memory locations 0040
Each
digitit entry
entry causes an interrupt.
interrupt. The fourth
fourth entry
entry should also result in the disdis­
abling of the keyboard interrupt.
interrupt.
abling
Sample Problem:
Keyboard data =

04, 06, 01, 07

Result:
Result:

04
06
01
07

3)

(0040)
(0041)
(0042)
(0043)

=
=
=
=

A Printer Interrupt

Purpose: The computer
puter sends four
memory locations
locations 0040 to 0043
four characters from memory
ith 0040) to the printer. Each
character is requested by an interinter­
(starting with
Each character
rupt. The fourth
fourth transfer
transfer also disables the printer
printer interrupt.
interrupt.

4)

A Real-Time
eal-Tim e Clock Interrupt

Purpose: The computer
puter clears memory location 0040 initially
initially and then complements
complements
location 0040
0040 each time the real-time
real-time clock interrupt
interrupt occurs.
memory location
How would
would you change the program so that it complements
complements memory
memory loca­
location 0040
0040 after every ten interrupts?
interrupts? How would
would you change the program so
that it leaves memory location
location 0040
0040 at zero for ten clock periods,
q for
that
periods. FF-|
FF15.
continuously? You may want
ant to use a display
five clock periods,
periods. and so on continuously?
location 0040
0040 so that it will
ill be easier to see.
rather than memory location
see.

5)

A T e letyp
e w riter Interrupt
letypewriter

Purpose: The computer
computer receives TTY data from an interrupting
interrupting 6850 ACIA and stores
the characters in a buffer
buffer starting
starting in memory location 0040. The process
process
continues
puter receives a carriage return (0D-|g).
that
continues until
until the computer
(OD15). Assume that
the characters
characters are 7-bit
7-bit ASCII
ith odd parity. How would
would you change
change your
ASCII with
subroutine TTYRCV is available.
available, as in
program to use a·VIA? Assume that subroutine
the example. Include the carriage return as the final character
character in the buffer.

1 2-38
-3 8

REFERENCES
1.
1. A. Osborne. An Introduction
Introduction to Microcomputers:
Microcomputers: Volume
Volume 1 —
- Basic Concepts,
Concepts.
(Berkeley: OSBORNE/McGraw-Hill. 1977). pp.
pp. 5-14 to 5-34.
2. R.
Baldridge, "Interrupts
"Interrupts Add Power,
plexity to M icrocom
puter System
R. L.
L. Baldridge.
Power. Complexity
icrocomputer
Design", EDN,
August 5,
Design".
EON. August
5. 1977, pp. 67-73.
3. L L e v e
n th a l, 6 8
00 Ass
e m b ly L a n
guage
eventhal.
800
ssembly
anguage
OSBORNE/McGraw-Hill, 1979),
1979). pp. 12-5 to 12-25.

P ro g
ra m m in g .(B e
rk e le y :
rogramming
,(Berkeley:

4. MCS6500
MCS6500 M icrocom
puter Family Hardware Manual.
Manual, MOS Technology
Technology Inc.,.. pp.
icrocomputer
pp.
104-108.
5. J. Gieryic, "SYM-1 6522-Based Timer".
Timer", Micro.
Micro, April
April 1979,
1979. pp. 11:31
31 to 11:32.
32.
DeJong, "A Simple 24-Hour
24-Hour Clock for the AIM 65”
Micro, March 1979, pp.
6. M. L.
L. DeJong.
65",, Micro.
pp.
-10:5 to 10:7.
7. For further
further discussion
discussion and some real-life examples of designing
designing 65026502- and 6800based systems with
ith interrupts,
see the following:
interrupts. see
following:

6502
6502
T.
"Patching a Program into a ROM”
Electronics, September
September 1,
T. Travis,
Travis. "Patching
ROM"., Electronics.
1. 1976,
1976. pp. 98 10
101 .

G.
L. Zick and T.
"Remote Failure Analysis
Analysis of Micro-Based Instrum
entation",
G. L.
T. T.
T. Sheffer,
Sheffer. "Remote
Instrumentation".
Computer.
puter. September
September 1977,
1977. pp. 30-35.

6800
6800
S.
M6800-based GPIB
Interface", EDN,
September 20,
S. C.
C. Baunach,
Baunach. "Ann Example of an M6800-based
GPIB Interface".
EON, September
20.
1977, pp. 125-128.
L.
"Using a Microprocessor:
Microprocessor: a Real-Life Application.
Application. Part 2
L. E.
E. Cannon and P. S.
S. Kreager,
Kreager. "Using
- Software".
Software". Computer
Computer Design,
Design. October 1975. pp. 81-89.
D.
"Interfacing Data Converters and Microprocessors",
Microprocessors", Electronics,
D. Fullager et al.,.. "Interfacing
Electronics.
December 8,
December
8. 1976,
1976. pp. 81-89.
S.
ultiprocess Control Interface Makes Remote ix
P Command Possible".
Possible", EDN.
S. A. Hill,
Hill. "Multiprocess
1,tP
EON.
pp. 87-89.
-February 5, 1976, pp.
W. S.
Holderby, "Designing
"Designing a Microprocessor-based
Microprocessor-based Terminal
Terminal for Factory Data CollecCollec­
S. Holderby.
tion",
tion". Computer
Computer Design,
Design. March 1977, pp.
pp. 81-88.
A. Lange. "OPTACON Interface
Interface Permits the Blind to 'Read' Digital
Digital Instrum
ents". EDN,
Instruments",
EON,
February 5, 1976, pp. 84-86.
J. D.
"Using a Microprocessor:
Microprocessor: a Real-Life Application.
Application. Part 1 D. Logan and P.
P. S.
S. Kreager,
Kreager. "Using
Hardware”
Computer Design.
September 1975,
Hardware",, Computer
Design, September
1975. pp. 69-77.

12-39

Eidson. "Printer
A. Moore and M. Eidson,
rinter Control",
Control", Application
Application Note available from Motorola
Semiconductor
iconductor Products,
Products. Phoenix,
Phoenix. AZ.
C. Mulder
P. P.
P. Fasang,
Fasang. "A Microprocessor
M. C.
ulder and P.
Microprocessor Controlled
Controlled Substation
Substation Alarm LogLog­
Industrial Applications
Applications of Microprocessors,
ger", IECI
IECI '78 Proceedings - Industrial
Microprocessors. March
20-22.
20-22, 1978, pp. 2-6.
P. J. Zsombar-Murray
al.. "Microprocessor
Based Frequency Response
Response Analyzer".
P.
Zsombar-Murray et al„
icroprocessor Based
Analyzer",
IECI '78 Proceedings - Industrial
20-22.
IECI
Industrial Applications
Applications of Microprocessors.
Microprocessors, March 20-22,
1978, pp. 36-44.
The Proceedings of the IEEE's
Industrial Electronics and Control Instrumentation
Instrumentation
IEEE's Industrial
Group's Annual
Annual Meeting
eeting on "Industrial
"Industrial Applications
Applications of Microprocessors"
Microprocessors" contains
IEEEService
many interesting
interesting articles. Volumes (starting with
ith 1975) are available from IEEE
Center. CP Department.
Hoes Lane,
Lane, Piscataway.
Piscataway, NJ 08854.
Center,
Department, 445 Hoes

12-400

Chapter 13
Chapter
PROBLEM
PROBLEM DEFINITION AND
PROGRAM DESIGN
THE TASKS OF SOFTWARE DEVELOPMENT
chapters. we have concentrated
asIn the previous
previous chapters,
concentrated on the writing
riting of short programs in as­
sembly language. While
hile this is an important
portant topic.
topic, it is only a small part of software
development.
developm
ent Although
Although writing
ritin g assembly language programs is a major task for the
beginner, it soon becomes simple. By now,
now. you should be familiar
iliar with
ith standard
programming in assembly language on the 6502 microprocessor. The
methods for programming

next four chapters will
ill describe how to formulate
ulate tasks as programs and how to
next
working system.
combine short programs to form a working
Softw
are development
development consists of many stages. Figure
Software
13-1 is a flowchart
process. Its
13-1
chart of the software
software development
development process.
stages are:

STAGES OF
SOFTWARE
DEVELOPMENT
DEVELOPMENT

• Problem definition
definition
• Program design
• Coding
• Debugging
Debugging
• Testing
• Documentation
Documentation
• Maintenance
Maintenance and redesign

Each of these stages is important
Each
portant in the construction
construction of a working
working system. Note that
coding.
coding, the writing
ritin g of programs in a form that the computer
puter understands.
understands, is only one of
stages.
seven stages.

RELATIVE
In fact,
easiest stage to define and perper­
fact. coding is usually the easiest
IMPORTANCE
form. The rules for writing
riting computer
computer programs are easy to learn.
learn.
IMPORTANCE
They vary somewhat
somewhat from computer
computer to computer.
computer, but the basic
OF CODING
techniques remain the same.
trou­
techniques
same. Few software projects run into trouble because of coding;
coding; indeed,
coding is not the most time-consuming
time-consuming part of software
indeed. coding
development.
development. Experts estimate
estimate that a programmer
programmer can write
rite one to ten fully debugged
and documented
documented statements
statements per day. Clearly,
coding of one to ten statements
Clearly. the mere coding
less than 25% of
is hardly a full day's effort. On most software
software projects, coding
coding occupies less
the programmer's
programmer’s time.
Measuring progress in the other stages is difficult. You can say
Measuring
MEASURING
MEASURING
that half of the program has been written.
ritten, but you can hilrdly
hardly say
PROGRESS
PROGRESS
that half of the errors have been removed or half of the problem
IN STAGES
has been defined. Timetables
Timetables for such stages as program design,
design.
debugging, and testing
testing are d iffic
u lt to produce. Many days or weeks of effort
effort may result
debugging.
ifficult
progress. Furthermore,
Furthermore. an incomplete
in no clear progress.
incomplete job in one stage may result in trementremen­
dous problems later.
definition or program design can make
later. For example,
example. poor problem definition
debugging
debugging and testing
testing very difficult.
difficult. Time saved in one stage may be spent many times
over in later stages.
stages.

13-1
13

Start

Problem
Definition
Definition

Coding

Program
Program
Design

Debugging

Design
Evaluation
Evaluation

Testing

No

Yes

No

Documentation
Documentation

and
Maintenance and
redesign

C*)
End

Figure 13-1
13-1. Flowchart
Flowchart of
Software Development
Development
of Software

13
-2
13-2

DEFINITION
DEFINITION OF THE STAGES
Problem definition
PROBLEM
definition is the formulation of the task in terms of
PROBLEM
example.
DEFINITION
the requirements
requirements that
that it places on the computer. For example,
tool. run a series
series
what
hat is necessary to make a computer
computer control
control a tool,
of electrical
tests. or handle
communications
electrical tests,
handle comm
unications between a central
central controller
controller and a remote
instrument?
determine
rates of in­
ininstrument? Problem definition
definition requires that you determ
ine the forms and rates
puts and outputs.
needed. and the types of
outputs, the amount
amount and speed of processing that is needed,
possible errors and their
idea of building
their handling.
handling. Problem definition
definition takes a vague idea
building a
computer-controlled
tasks and requirements
computer-controlled system and defines the tasks
requirements for the computer.
PROGRAM
Program design is the outline of the computer program which
DESIGN
will
ill perform the tasks that
that have been defined. In the design
stage.
stage, the tasks are described
described in a way that can easily be concon­
verted into
program. Among the useful techniques in this stage are flowcharting,
into a program
structured
programming, and top-dow
top-downn design.
design.
structured programming, modular programming,

I

Coding is the writing
ritin g of the program in a form that
that the comcom•
puter
puter can either
either directly
directly understand or translate. The form may
be machine
language. or a high-level
machine language.
language, assembly language,
high-level language.

|iCODING
CODING |

I

I

Debugging, also called program
pro·
program verification.
verification, is making the pro| DEBUGGING |
gram do what
do. In this
h at the design specified that
that it would do.
stage.
traces. simulators.
analyzers. and
and in-cirstage, you use such tools as breakpoints.
breakpoints, traces,
simulators, logic analyzers,
cuit emulators.
emulators. The end of the debugging
debugging stage is
cuit
Is hard to define,
define. since you never know
when
error.
when you have found
found the last error.
Testing, also referred to as program validation.
validation, is ensuring that
|TESTING]
Testing.
!TESTING!
the program performs the overall system tasks correctly. The
designer uses simulators.
simulators, exercisers,
statistical techniques
techniques to measure
designer
exercisers. and various statistical
measure the
program's performance.
performance. This stage is like quality
quality control
control for hardware.
program's

!

Documentation
program in the |DOCUMENTATION]
•1D_O_C_U_M_E_N_T_A_T-10-N
..
Documentation is the description of the program
Docu­
proper form for users and maintenance personnel.
personnel. Documentation
entation also allows
allows the designer
designer to develop a program library so that subsequent
tasks will
ill be far simpler. Flowcharts.
Flowcharts, comments.
comments, memory maps,
maps. and library forms are
are
documentation.
some of the tools used in
In documentation.
MAINTENANCE
Maintenance and redesign are the servicing, improvement,
Maintenance
MAINTENANCE
extension of the program.
designer must be
AND
Clearly. the designer
and extension
program. Clearly,
REDESIGN
handle field
field problems
problems in computer-based
computer-based equipment.
equipment.
REDESIGN
ready to handle
diagnostic modes or programs and other maintenance
maintenance
Special diagnostic
Upgrading or extension of the program may be necessary
tools may be required. Upgrading
necessary to
requirements or handle new tasks.
meet new requirements
tasks.
The rest
rest of this chapter
chapter will
ill consider only the problem definition and program
program
Chapter 14 will
ill discuss debugging
debugging and testing.
testing, and Chapter 15
15 will dis­
disdesign stages. Chapter
documentation, extension.
extension, and redesign. We will
ill bring all the stages together in
cuss documentation.
simple systems examples in Chapter
Chapter 16.
some simple
16.

PROBLEM DEFINITIO
N
DEFINITION
Typical microprocessor
microprocessor tasks require a lot of definition.
definition. For example,
hat must a pro­
Typical
example. what
procontrol a scale,
gram do to control
scale. a cash register,
register. or a signal generator? Clearly,
Clearly. we have
have a
way to go just
just to define
define the tasks involved.
long way

13-3
13-3

DEFINING
DEFINING THE INPUTS
INPUTS
How do we start
Is with the inputs. We
start the definition?
definition? The obvious place to begin is
should
applicashould begin by listing all the inputs that
that the computer
computer may receive in this applica­
tion.
Examples of inputs
inputs are:
• Data blocks from transmission
transmission lines
• Status words
words from peripherals
• Data from A/0
A/D converters
converters
Then,
Then, wee may ask the following
ing questions about each input:

FACTORS
FACTORS
IN INPUT
INPUT
1) What
is
its
form:
i.e
..
what
signals
will
the
computer
actually
hat
form;
.,
at
ill
puter actually
receive?
2) When
Does
When is the input
input available
available and how does the processor know it is available? Does
the processor have to request the input
input with
ith a strobe signal?Does the input
input provide
its own clock?
3) How long is it available?
4) How often
often does it change.
change, and how does the processor know that it has changed?
5) Does the input
input consist
consist of a sequence or block of data? Is the order important?
portant?
hat should
should be done if the data contains
contains errors? These may include transmission
6) What
errors, incorrect
incorrect data,
sequencing errors,
errors.
data. sequencing
errors. extra data,
data. etc.
etc.
7) Is the input
input related to other
other inputs
inputs or outputs?
outputs?

DEFINING THE OUTPUTS
define is the output
The next step to define
output. We must list all the outputs that the computer
must produce. Examples of outputs
outputs include:
include;
must
transmission lines
• Data blocks to transmission
Control words
words to peripherals
peripherals
• Control
converters
• Data to D
0//A converters

ing questions about each output:
Then, wee may ask the following
1)

W
hat is
is its
its form;
form ; i.e
i.e.,
hat signals
signals must
must the
the com
puter produce?
produce?
What
.. w
what
computer

2)
When must
must itit be
be available.
available, and
and how
how does
does the
the peripheral
peripheral know
know itit is available?
21 When
How long
long must
must itit be
be available?
available?
3) How

4)
5)

How often
often must
must itit change.
change, and
and how
how does
does the
changed?
How
the peripheral
peripheral know
know that
that it has
has changed?
outputs?
Is there a sequence of outputs?

6)

What
hat should be done to avoid transmission
transmission errors or to sense
sense and recover from pe­
peripheral failures?
ripheral

7)

output related to other inputs
inputs and outputs?
How is the output

13-4
13-4

PROCESSING SECTION
Between the reading of input
input data and the sending of output
output results is the processing
section. Here wee must determine exactly
process the in­
inexactly how the computer must process
put
put data. The questions are:

FACTORS IN
What
hat is the basic procedure
procedure (algorithm) for transforming
transforming input
FACTORS
PROCESSING
data into
into output
output results?
PROCESSING
2) What
rates.
hat time
time constraints
constraints exist? These may include
include data rates,
delay times.
devices. etc.
etc.
times, the time constants
constants of input
input and output
output devices,
3) What
hat memory
memory constraints
constraints exist? Do we have limits
its on the amount
amount of program
memory
memory or data memory.
memory, or on the size of buffers?
4) What
are their requirements?
hat standard
standard programs
programs or tables must be used? What
hat are
5) What
hat special
special cases exist.
exist, and how should the program handle them?
6) How accurate
be?
accurate must
must the results be?
7) How should
as
should the program
program handle processing errors or special conditions
conditions such as
overflow.
overflow, underflow.
underflow, or loss of significance?
significance?
1)

ERROR HANDLING
ERROR
HANDLING
An important
handling of errors.
errors. Clearly,
Clearly. the
the
important factor
factor in many applications is the handling
designer
designer must
must make provisions
provisions for recovering
recovering from common errors and for diagnosing
diagnosing
malfunctions.
alfunctions Among the questions that
that the designer must ask at the definition
stage are:
ERROR
ERROR

1)

What
hat errors could occur?

2)

CONSIDERATIONS
CONSIDERATIONS
Which
hich errors are most likely? If a person operates the
system, human error is the most common. Following
Following
system.
unications or transmission errors are more common than
human errors,
errors. comm
communications
mechanical, electrical.
electrical, mathematical.
mathematical, or processor errors.
mechanical.
errors.

3)

Which
hich errors will
ill not be immediately
immediately obvious to the system? A special problem is
is
occurrence of errors that
that the system or operator may not recognize as incorrect.
the occurrence

4)

ith a minimum
inimum loss
How can the system recover from errors with
loss of time and data and
yet be aware that
that an error has occurred?
yet
Which
hich errors or malfunctions
alfunctions cause the same system behavior? How can these
these er­
eralfunctions be distinguished
distinguished for diagnostic
diagnostic purposes?
rors or malfunctions
Which
hich errors involve special system procedures? For example,
example. do parity errors
errors re­
require retransmission
retransmission of data?
quire

5)
6)

Another question
question is: How can the field technician
technician systematically
systematically find the source of
Another
malfunctions without
ith o u t being an expert? Built-in
Built-in test programs,
malfunctions
programs. special diagnostics,
diagnostics. or
or
signature analysis can help.^1
signature

13-5

H UMAN
M A N FACTORS
Many microprocessor-based
microprocessor-based systems involve
involve human
human interaction
interaction.
Many
Human factors
factors must be considered throughout
throughout the developdevelop­
ment process for such systems. Among the questions that
that the
ment
designer must ask are:

OPERATOR
INTERACTION
INTERACTION

What input
input procedures
procedures are
are most
most natural
natural for
for the
the human
human operator?
operator?
1) W
2)

Can the
the operator easily determine
determine how
how toto begin,
begin. continue
continue and
and end
end the
the input
Can
input
operations?
operations?

3)

How is the operator
operator informed
informed of procedural
procedural errors and equipment
equipment malfunctions?
malfunctions?

4)

W
What errors
errors is
is the
the operator
operator most
most likely
likely to
to make?
make?

How does
does the
the operator
operator know
know that
that data
data has
has been
been entered
enteredcorrectly?
correctly?
5) How
6)

Are displays
displays in
in aa form
form that
that the
the operator can
can easily
easily read
read and
and understand?
Are
understand?
71 Is
7)
Is the
the response
response of
of the
the system
system adequate
adequate for
for the
the operator?
operator?

8)

Is the system easy for the operator
operator to use?7

9)

Are there guiding
guiding features
features for an inexperienced
inexperienced operator?

10) Are
Are there
there shortcuts
shortcuts and
and reasonable
reasonable options
options for
for the
the experienced
experienced operator?
operator?
10)
11)
11) Can
Can the
the operator
operator always
always determine
determine or
or reset
reset the
the state
state of
of the
the system
system after
after interrup­
interrupdistractions?
tions or distractions?
Building a system for people to use is difficult.
difficult. The microprocessor
microprocessor can make the
Building
powerful, more flexible.
flexible, and more responsive. However.
However, the designer
designer still
system more powerful.
must add the human touches that can greatly
greatly increase the usefulness
usefulness and attractiveattractive­
ness of the system and the productivity
productivity of the human operator.22

13-6
13
-

EXAMPLES
Response
itch
Response to a S witch
Figure 13-2
Figure
13-2 shows a simple system in which the input is
single SPST switch
single LED
from a single
itch and the output is to a single
display. In response to a switch
processor
display.
itch closure, the processor
turns the display on for one second.
second. This system should be
easy to define.

DEFINING
SWITCH
ITCH AND
SYSTEM
LIGHT SYSTEM
SWITCH
ITCH AND
LIGHT INPUT

answer each of the questions
questions
Let us first examine the input and answer
previously
previously presented:
1)

·o· (switch
The input
input is a single bit. which
hich may be either
either 'O'
(switch closed) orr '1' (switch
open)
open).

2)

The input
input is always available
available and need not be requested.

3)

The input
input is available
available for at least several milliseconds
milliseconds after
after the closure.

4)

The input
input will
ill seldom change
change more than once every few seconds. The processor
has to handle only the bounce in the switch.
switch. The processor must monitor
monitor the
closed.
switch
itch to determine
determine when
when it is closed.

5)

There is no sequence of inputs.

6)

The obvious
obvious input
input errors are switch
switch failure.
failure, failure
failure in the input
input cIrcuItry.
circuitry, and the
operator
attempting
operator attem
pting to close the switch
switch again before a sufficient
sufficient amount
amount of time
has elapsed. We will
ill discuss the handling
handling of these errors later.
later.

7)

The input
input does not depend on any other inputs
inputs or outputs.
outputs.

The next
next requirement
requirement in defining the system is to examine the
output. The answers to our questions
questions are:

SWITCH
SWITCH
AND LIGHT
OUTPUTS

1) The output
·o·to turn the display
on.
1)
output is a single bit. which
which is '0'
display on,
'1' to turn it off.
2) There are no time constraints
constraints on the output.
output. The peripheral
peripheral does not need to be inin­
formed of the availability
availability of data.
3)

4)
5)

If the display
display is an LED,
available for only a few milliseconds
milliseconds at a
LED. the data need be available
pulse rate of about
about 100 times per second. The observer will
ill see a continuously
continuously lit
display.
The data must
must change
change (go off) after
after one second.

6)

There is no sequence of outputs.
The possible output
output errors are display
display failure
failure and failure
failure in the output
output circuitry.
circuitry.

7)

The output
output depends only on the switch
switch input
input and time.

The processing
ely simple. As soon
itch input becomes
processing section is extrem
extremely
soon as the switch
a logic '0',
second. No time or memo'O’, the CPU turns the light on (a logic '0')
'O') for one second.
memo­
ry constraints
constraints exist.

Let us now look at the possible
possible errors
errors and malfunctions. These
are:
• Another
Another switch
switch closure
closure before one second has elapsed

SWITCH AND
LIGHT ERROR
ERROR
HANDLING
HANDLING

• Switch
Switch failure
• Display failure
• Computer
puter failure
failure

Surely the first
igfirst error is the most likely. The simplest
simplest solution
solution is for the processor to ig­
nore switch
itch closures until
until one second has elapsed. This brief
brief unresponsive
unresponsive period will
ill
hardly be noticeable
noticeable to the human operator. Furthermore,
Furthermore, ignoring
ignoring the switch
switch during
during
this period means that
that no debouncing
debouncing circuitry
circuitry or software
software is necessary, since the
system will
ill not react to the bounce
bounce anyway.
1 3-7
7

Input

Port

+5V

CPU

Output

Port

·o·

The switch input
*1* if the switch
input is a '1'
switch is open,
open, 'O' if the
switch
switch is closed.
closed. The CPU
CPU applies
applies the output to the
cathode of the LED;
LED; a '0'
·o·lights
lights the display.
display.

Switch and Light
Light System
Figure 13-2. The Switch
Clearly, the last three failures
failures can produce
produce unpredictable
unpredictable results. The display
display may stay
on.
randomly. Some possible ways to isolate the failures
failures would
would
on, stay off, or change state randomly.
be:
• Lamp-test
Lamp-test hardware
hardware to check the display;
display; i.e.,
button that
that turns the light
light on in-­
i.e., a button
dependently of the processor
dependently
• A direct
direct connection
connection to the switch
switch to check its operation
operation
• A diagnostic
diagnostic program
program that
that exercises the input
input and output
output circuits
circuits
If both the display
display and switch
switch are working,
working, the computer
puter is at fault. A field technician
technician
with
ith proper equipment
equipment can determine
determine the cause of the failure.

1 3-8

A Sw itch-B
ased M emory
ory Loader
itch-Based
Loader
Figure 13-3
Figure
13-3 shows a system that allows the user to enter
enter
DEFINING A
data into any memory location in a microcomputer.
SWITCH-BASED
ITCH-BASED
microcomputer. One in­
inM EMORY
O RY LOADER
LOADER
put port, DPORT, reads data from eight toggle switches.
inforThe other input port, CPORT, is used to read control infor­
mation. There are three momentary switches:
itches: High Address, Low Address and
mation.
Data. The output is the value of the last completed entry from the data switches:
switches;
eight LEDs are used for the display.
display.
also. of course, require various resistors, buffers,
buffers. and drivers.
The system will
ill also,

We shall first examine the inputs.
inputs. The characteristics
switches are the same as
characteristics of the switches
however. here there is a distin
distinct
in the previous
previous example:
example; however,
ct sequence of inputs.
inputs, as
follows:
follows:
1)
1)

The operator
operator must set the data switches
switches according
according to the eight
eight most significant
significant
bits of an address,
address, then

2)

press the High Address button.
button. The high address bits will
ill appear on the lights, and
the program will
address.
ill interpret
interpret the data as the high byte of the address.
3) Then the operator must set the data switches
switches with
ith the value of the least significant
significant
byte of the address and
4) press the Low Address button. The low address bits will
ill appear on the lights, and
the program will
ill consider
consider the data to be the low byte of the address.
address.
5) Finally, the operator must set the desired data into the data switches
switches and
6) press the Data button.
button. The display
display will
ill now show the data, and the program stores
the data in memory at the previously
previously entered address.
address.
The operator may repeat the process to enter an entire program. Clearly, even in this
simplified
plified situation,
situation, we will
ill have many possible sequences to consider. How do we
cope with
ith erroneous sequences and make the system easy to use?7

Output is no problem.
problem. Afterr each input, the program
program sends
sends to the displays
displays the
active-low) of the input bits. The output
output data
complement (since
(since the displays
displays are active-low)
remains the same until
until the next input
input operation.
con­
The processing
processing section remains quite simple.
simple. There are no time or memory constraints. The program can debounce
debounce the switches
switches by waiting
aiting foraa few milliseconds.
milliseconds, and
provide complemented
complemented data to the displays.
must provide

errors are operator mistakes. These include
include:
The most likely errors
• Incorrect
Incorrect entries
• Incorrect
Incorrect order

M EMORY
ORY
LOADER
LOADER
ERROR
ERROR
HANDLING

• Incomplete
Incomplete entries; for example, forgetting
forgetting the data
The system must be able to handle these problems in a reasonable way, since they are
certain to occur
occur in actual
actual operation.
certain

effects of equipment failure. Just as before,
The designer must also consider the effects
before,
ifficulties are:
the possible difficulties
are:
• Switch
Switch failure
failure
• Display failure
• Computer
Computer failure

13-9
13

Input

Poet
DPORT

Data
Bus

J_
Input
CPU

J_

High Address

Low Address

Port

CPORT

J_

Data

+SV

Output
Port

Switch-Based Memory
Memory Loader
Figure 13-3. The Switch-Based

13-10

In this system,
attention to how these failures
failures affect
affect the
system. however,
however. we must pay more attention
system. A computer
puter failure
failure will
ill presumably
presumably cause very unusual
unusual behavior
behavior by the system,
system.
and will
ill be easy to detect. A display failure may not be immediately
mediately noticeable:
noticeable; here a
Lamp Test feature
feature will
ill allow
allow the operator
operator to check the operation. Note that we would
would
like to test each LED
hich output
output lines are
LED separately,
separately. in order to diagnose the case in which
shorted together.
together. In addition.
addition, the operator may not immediately
mediately detect
detect switch
switch failure;
failure:
however,
operator should soon notice it and establish which
which switch
itch is faulty
faulty by a
however. the operator
process of elimination.
elimination.
Let us look at some of the possible operator errors.
Typical errors
errors. Typical
will
ill be:
be:
• Erroneous data
• Wrong
rong order of entries or switches
switches

OPERATOR
ERROR
ERROR
CORRECTION
MEMORY
IN MEMORY
LOADER

• Trying
Trying to go on to the next entry w ith
o u t completing
pleting the current
current
ithout
one
The operator
operator will
ill presumably
presumably notice erroneous data as soon as it appears on the disdis­
plays.
a t is a viable recovery procedure for the operator? Some of the options
options are:
plays. What
1)
1)

The operator
operator must complete
complete the entry procedure;
procedure: i.e.,.. enter
enter Low Address and Data
procedure is wasteful
wasteful and
if the error occurs in the High Address. Clearly, this procedure
would only serve to annoy the operator.
would

2)

The operator
operator may restart the entry process by returning
returning to the high address entry
steps.
solution is useful if
steps. This solution
11the error was in the High Address,
Address. but forces the
operator to re-enter earlier data if the error was in the Low Address or Data stage.
operator
stage.

3)

The operator
operator may enter
enter any part of the sequence at any time simply
simply by setting
setting the
Data switches
switches with
ith the desired data and pressing the corresponding
corresponding button.
button. This
procedure allows the operator to make corrections
corrections at any point
point in the sequence.
procedure
sequence.

This type of procedure
procedure should always be preferred over one that does not allow immediimmedi­
ate error correction.
correction, has a variety
variety of concluding
concluding steps,
steps. or enters data into the system
w ith
o u t allowing
allowing the operator
operator a final check. Any added complication
plication in hardware or
ithout
software will
ill be justified
justified in increased operator efficiency.
efficiency. You should always prefer to
software
puter do the tedious work and recognize arbitrary
arbitrary sequences; it never
let the m icrocom
icrocomputer
gets tired and never forgets what
what was in the operating
operating manual.
A further
further helpful
helpful feature would
would be status lights
lights that would
would define the meaning of the
lights, marked "High
igh Address",
Address", "Low
o w Address".
Address", and "Data".
"Data",
display. Three status lights.
would let the operator know what
hat had been entered w ith
o u t having to remember which
which
would
ithout
button was pressed.
would have to monitor
onitor the sequence,
button
pressed. The processor would
sequence. but the added
complication
plication in software
would simplify
plify the operator's
operator's task.
task. Clearly.
Clearly, three separate sets
software would
sets
of displays plus the ability
ability to examine a memory location
location would
would be even more helpful
helpful to
the operator.

We should note that, although we have emphasized human interaction,
interaction, machine
We
interaction has many of the same characteristics.
characteristics. The microprocessor
or system interaction
should do the work. If complicating the microprocessor's task makes error recovrecov­
ill work
ork better
better
ery simple and the causes of failure obvious, the entire system will
and be easier
easier to maintain. Note that you should not waitit until
until after
after the software
software has
been completed
completed to consider
consider system use and maintenance:
maintenance: instead.
instead, you should include
these factors in the problem definition
definition stage.
stage.

13-11

A Verification
Verification Terminal
Figure 13-4
13-4 is a block diagram of a simple credit-verification
credit-verification
DEFINING A
terminal. One input port derives data from a keyboard (see
FICATION
VERI Fl
Figure 13-6);
13-5); the other input port accepts verification
verification data
TERMINAL
TERMINAL
from a transmission line. One output port sends data to a set of
displays (see Figure
13-6); another sends the credit
credit card number to the central
Figure 13-6);
whenever the terminal is ready to
computer. A third output port turns on one light whenever
accept an inquiry, and another light when the operator sends the information. The
"B usy"
s y " light turns off when
when the response
input and output
output of
response returns. Clearly, the input
data will
ill be more complex
complex than in
In the previous case,
although the processing is still
case. although
simple.
Additional displays may be useful to emphasize the meaning of the response.
ter­
Additional
response. Many terminals use a green light
light for "Yes",
"Yes", a red light
light for "No",
o", and a yellow
yellow light
light for "Consult
"Consult
Store Manager."
Manager." Note that
that these lights
lights will
ill still
still have to be clearly marked with
ith their
allow for a color-blind
color-blind operator.
meanings to allow

VERIFICATION
VERIFICATION
Let us first look at the keyboard input.
Input. This is.
is. of course,
course,
TERMINAL
different from the switch
switch input.
input, since the CPU
different
CPU must have some
TERMINAL
distinguishing new data. We will
ill assume that
that each key
way of distinguishing
INPUTS
closure
hexadecimal code (we can code
closure provides a unique
unique hexadecimal
code
each of the 12 keys into one digit) and a strobe. The program will
ill have to recognrecogn­
ize the strobe and fetch the hexadecimal number that
that identifies
identifies the key. There is a
time constraint.
constraint, since the program cannot miss any data or strobes. The constraint
constraint is
ill be at least several milliseconds
milliseconds apart.
not serious,
serious. since keyboard entries will
The transmission
transmission input similarly consists of a series of characters, each identified
by a strobe (perhaps
(perhaps from a UART). The program
program will
ill have to recognize each
strobe and fetch the character. The data being sent across the transmission lines
is usually organized into messages.
at is:
is:
messages. A possible message format
• Introductory
Introductory characters, or header
• Terminal
Terminal destination
destination address
• Coded yes or no
• Ending characters.
characters, or trailer
The terminal
terminal will
ill check the header,
destination address,
header. read the destination
address, and see if the
message is intended
intended for it. If the message
terminal, the terminal
terminal accepts the
message is for the terminal.
data. The address could be (and often is)
hard-wired into the terminal
terminal so that
that the terter­
is) hard-wired
minal receives only messages
intended for it. This approach simplifies
plifies the software
software at
messages intended
the cost of some flexibility.
flexibility.

VERIFICATION
The output is also more complex than in the earlier examples.
VERIFICATION
ultiplexed, the processor must not only
If the displays are multiplexed,
TERMINAL
TERMINAL
send the data to the display port but must also direct the data
OUTPUTS
to a particular display. We will
ill need either
either a separate control
control port
or a counter
counter and decoder
decoder to handle this. Note that hardware blanking
blanking controls
controls can
first digit
ig it in a m ulti-d
ig it number
number is never zero.
Soft­
blank leading zeros
zeros as long as the first
ulti-digit
zero. Software can also handle this task.
task. Time constraints
include the pulse length and frequency
constraints include
frequency
continuous display
display for the operator.
required to produce a continuous
The communications output will
ill consist of a series of characters with
ith a particular
ill also have to consider the time required between
between charac­
format. The program will
characters. A possible format
format for the output
output message is:
is:
• Header
• Terminal
Terminal address
• Credit card number
number

• Trailer
1313-12

Keyboard
tnput Port

Display

Display

Output Portis)

XMIT

CPU

Output Port

To Central Computer

RCV
Input Port

Status Light
Output Port

From Central Computer

.,_---t•

BUSY [>;splay

.,_---t•

READY Display

Verification Terminal
Terminal
Figure 13-4. Block Diagram of a Verification

The digit
digit keys allow digit
digit entries.
CLEAR
entire entry.
CLEAR deletes the entire
SEND transmits
transmits the entry to the central computer.
computer.

Verification Terminal
Terminal Keyboard
Figure 13-5. Verification

13-13
13-13

READY
READY

BUSY
BUSY

□
□

□
□

i ~ i O i— i 1— i i ~ i i ~ i i ~ i ' ~ i i ~ i
/_ / /_ / i_/ /____ / /_ / /_ / O i— i i ~ i i ~ l

The display consists of ten 7-segm
ent displays, which may be multiplexed, controlled by a shift
7-segment

register, or addressed separately. Two additional lights, READY and BUSY, are also present.
present.
register,

Figure 13-6. Verification
Verification Terminal
Terminal Display

A central communications computer
computer may poll the terminals, checking for data
ready to be sent.
as:
The processing
processing in this system involves many new tasks, such as:
• Identifying
Identifying the control
control keys by number
number and performing
performing the proper actions
actions
• Adding
Adding the header,
terminal address,
trailer to the outgoing
outgoing message
header, terminal
address, and trailer
message

message
• Recognizing the header and trailer
trailer in the returning
returning message
• Checking the incoming
incoming terminal
terminal address

arithmetic
Note that none of the tasks involve
involve any complex
complex arithm
etic or any
serious time or memory constraints.
constraints.

possible errors in this system is,
is, of course,
course,
The number of possible
much larger than in the earlier examples. Let us first consider
possible operator errors.
errors. These include:
the possible
include:

VERIFICATION
VERIFICATION
TERMINAL
TERMINAL
ERROR
ERROR
HANDLING
HANDLING

• Entering the credit
incorrectly
credit card number
number incorrectly
• Trying
Trying to send an incomplete
incomplete credit
credit card number
• Trying
Trying to send another
another number
number while
hile the central
central computer
puter is processing one
• Clearing non-existent
non-existent entries
Some of these errors can be easily handled by correctly
correctly structuring
structuring the program. For ex­
exhas
ample, the program should not accept
accept the Send key until
until the credit
credit card number
number has
been completely
completely entered, and it should ignore any additional
additional keyboard entries until
until the
response comes back from the central
central computer.
computer. Note that the operator
operator will
ill know that
on. The operator
the entry has not been sent, since the Busy light
light will
ill not go on.
operator will
ill also
know when the keyboard has been locked out (the program is ignoring
ignoring keyboard enen­
tries),
ill not appear on the display and the Ready
Ready light
light will
ill be off.
tries). since entries will

13-14
13
14

Incorrect entries
entries are an obvious
obvious problem.
problem. If the operator
operator recogrecog­
CORRECTING
Incorrect
KEYBOARD
nizes an error,
corrections. The
error. he can use the Clear key to make corrections.
ERRORS
operator would
ould probably
probably find it more convenient
convenient to have twoo Clear
ERRORS
operator
keys, one that
that cleared the most
most recent
recent key and one that
that cleared
the entire
entire entry. This would
would allow
allow both for the situation
situation in which
which the operator
operator recogrecog­
nizes the error immediately
situation in which
hich the operator
operator recognizes the
immediately and for the situation
procedure. The operator
operator should
should be able to correct
correct errors immediately
immediately
error late in the procedure.
and have to repeat
repeat as few keys as possible. The operator
operator will.
ill, however.
however, make a certain
certain
number of errors w ith
o u t recognizing
recognizing them. Most
Most credit
credit card numbers
numbers include
include a selfself­
number
ithout
checking digit;
digit; the terminal
terminal could
could check the number
number before perm
itting it
checking
permitting
1t to be sent to
the central
central computer.
computer. This step would
would save the central
central computer
puter from wasting
wasting precious
precious
processing time checking
checking the number.
processing
however, that
that the terminal
terminal have some way
way of inform
ing the operator
operator of
This requires,
requires. however.
informing
the error,
perhaps by flashing
flashing one of the displays
displays or by providing
providing some other
other special
special inin­
error. perhaps
dicator that
that the operator
operator is sure to notice.
dicator
Still another
another problem
problem is how the operator
operator knows
knows that
that an entry
entry has been lost or propro­
Still
cessed incorrectly.
incorrectly. Some terminals
terminals simply
simply unlock
unlock after
after a maximum
maximum time delay. The
operator notes that
that the Busy light
light has gone off w ith
o u t an answer
answer being received. The
operator
ithout
operator is then expected
expected to try the entry
entry again. After
fter one or two retries,
operator
operator
retries. the operator
report the failure
failure to supervisory
supervisory personnel.
should report

Many equipment
equipment failures are also possible. Besides the displays, keyboard, ancf
Many
and
processor,
exist the problems of communications errors or failures anc*
processor, there now exist
central computer
computer failures.
central
transmission will
ill probably
probably have to include
include error checking
checking and correcting
correcting propro­
The data transmission
cedures. Some possibilities
possibilities are:

CORRECTING
TRANSMISSION
TRANSMISSION
ERRORS
ERRORS

1)
1)

provides an error detection
detection facility
facility but
but no correction
correction
Parity provides
mechanism. The receiver
receiver will
ill need some way of requestrequest­
mechanism.
ing retransmission.
retransmission, and the sender will
ill have to save a copy
of the data until
until proper
proper reception
reception is acknowledged.
acknowledged. Parity
is,
however, very simple
simple to implement.
implement.
is. however.

2)

Short messages may use more elaborate
elaborate schemes. For example.
example, the yes/no
yes/no
Short
inal could be coded so as to provide
provide error detection
detection and corcor­
response to the terminal
rection capability.
capability.
rection
acknowledgement and a limited
limited number
number of retries could trigger
trigger an indicator
indicator
An acknowledgement
that would
would inform
inform the operator
operator of a communications
communications failure
failure (inability
(inability to-transfer
to-transfer a
that
o u t errors) or central
central com
puter failure
failure (no response at all to the
message w ith
ithout
computer
ith in a certain
certain period of time). Such a scheme.
scheme, along with
ith the Lamp
message within
Test,
ould allow
allow simple
simple failure
failure diagnosis.
Test. would

3)

A comm
unications or central
central computer
puter failure
failure indicator
indicator should
should also "unlock"
nlock” the terter­
communications
minal, i.e.,.. allow
allow it to accept
accept another
another entry. This is necessary if the terminal
terminal will
ill not acac­
minal.
cept entries
entries while
hile a verification
verification is in progress. The terminal
terminal may also unlock
unlock after
after acercer­
cept
tain maximum
aximum time delay. Certain
Certain entries
entries could
could be reserved for diagnostics:
diagnostics; 1e.
i.e., certain
certain
credit card numbers
numbers could
could be used to check the internal
internal operation
operation of the terminal
terminal and
credit
test the displays.

1 3-15
15

REVIEW OF PROBLEM DEFINITION
Problem definition
definition is as im
portant a part
part of softw
are development
development as it is of any
Problem
Important
software
other engineering
engineering task.
task. Note
Note that
that it does not
not require
require any programming
programming or
other
knowledge of
of the
the computer;
computer; rather,
rather, itit is based on an understanding
understanding of
of the
the system
system
knowledge
engineering judgment.
judgment. Microprocessors
Microprocessors can offer
offer fle x
ib ility that
that the
the
and sound engineering
flexibility
designer can use to provide
provide a range of
of features
features which
which were
were not
not prevlously
previously availaavaila­
designer
ble.
Problem definition
definition is independent
independent of any particular
particular computer,
computer, computer
computer language,
Problem
development system.
system. It should,
should, however,
however, provide
provide guidelines
guidelines as to what
h at type
type or
or development
computer the application
application willill require
require and what
h at kind
kind of hardhard­
speed of computer
ware/softw
are trade-offs
trade-offs the
the designer
designer can make. The problem
problem definition
definition stage is
ware/software
fact independent
independent of whether
hether or not a computer
computer is used at all, although
although a
in fact
knowledge of the capabilities
capabilities of the computer
computer can help the designer
designer in suggesting
suggesting
knowledge
possible implementations
implementations of procedures.
procedures.
possible

13-16
13-

PROGRAM DESIGN
Program
hich the problem definition is formulated as a propro­
Program design is the stage in which
gram.
gram. If the program is small and simple, this stage may involve little more than
the writingg of a one-page flowchart.
chart. If the program
program is larger or more complex, the
designer should consider more elaborate methods
We will
ill discuss
charting, modular programming,
We
discuss flowcharting,
programming, structured programming,
programming, and
top-down design.
ill try to indicate the reasoning behind these methods, and
top-down
design. We will
ill not,
however, advocate
advocate any particular
particular
their advantages and disadvantages. We will
not. however.
evidence that
that one method
method is always
always superior
superior to all others. You
method since there is no evidence
remember that
that the goal is to produce
produce a good working
orking system,
follow
should remember
system. not to follow
religiously the tenets
tenets of one methodology
methodology or another.
religiously
All the methodologies do,
obvious princi­
do. however,
however. have some obvious
principles in common.
principles that
that apply
common. Many of these are the same principles
to any kind of design.
design, such as:
1)
1)

Proceed in small steps. Do not try to do too much at one
time.

BASIC
PRINCIPLES
PRINCIPLES
OF PROGRAM
DESIGN

2) Divide
Divide large
large jobs
jobs into
into small,
small. logically
logically separate
separate tasks.
tasks. Make
Make the
the sub-tasks
sub-tasks as
as inde­
independent of one another
another as possible,
that they can be tested separately
separately and so
pendent
possible. so that
changes can be made in one w ith
o u t affecting
affecting the others.
that changes
ithout
3) Keep
Keep the
the flow
flow of
of control
control as
assimple
simple as
aspossible
possible so
soas
asto
to make
make itit easier
easier to
to find
find errors.
errors.
4) Use
Use pictorial
pictorial or
or graphic
graphic descriptions
descriptions as
as much
much as
as possible.
possible. They
They are
are easier
easier to
to
descriptions. This is
advantage of flowcharts.
flowcharts.
visualize than word descriptions.
Is the great advantage
5) Emphasize
plicity at
Emphasize clarity
clarity and
and sim
s1mplic1ty
at first.
first You
You can
can improve
improve performance
performance (if
(if neces­
necessary)
working.
sary) once the system is
Is working.
6) Proceed
Proceed in
in aa thorough
thorough and
and systematic
systematic manner.
manner. Use
Use checklists
checklists and
and standard
standard pro­
procedures.
7) Do
Do not
not tem
tempt fate.
fate. Either
Either do
do not
not use
use methods
methods that
that you
you are
are not
not sure
sure of,
of. or
or use
use them
them
very carefully.
carefully. Watch
atch for situations
situations that
that might
ight cause confusion.
confusion, and clarify
clarify them
as soon as possible.
8) Keep
Keep in
in mind
mind that
that the
the system
system must
must be
be debugged,
debugged. tested
tested and
and maintained.
maintained. Plan
Plan for
for
these later stages.
9) Use
inology and
Usesimple
simple and
and consistent
consistent term
terminology
and methods.
methods. Repetitiveness
Repetitiveness isis no
no fault
fault in
in
design, nor is complexity
plexity a virtue.
program design.
10) Have
Have your
your design
design completely
completely formulated
formulated before
before you
you start
start coding.
coding. Resist
Resist the
the
temptation to start writing
riting down
down instructions:
instructions: it makes no more sense than makmak­
temptation
ing parts lists or laying out circuit
circuit boards before you know exactly
exactly what
what will
ill be in
the system.
11) Be
Beparticularly
particularly careful
careful of
of factors
factors that
that may
may change.
change. Make
Make the
the implementation
implementation ofof
changes as simple
simple as possible.
likely changes
possible.

1 3-17
17

FLOW
CHARTING
FLOWCHARTING
Flowcharting is certainly
certainly the best-known
best-known of all program
program design
design methods.
methods. Programming
Programming
Flowcharting
textbooks describe
describe how programmers
programmers first
first write
write complete
complete flowcharts
flowcharts and then start
start
textbooks
writing
riting the actual
actual program.
program. In fact.
fact, few programmers
programmers have ever worked
worked this way.
way, and
flow charting has often
often been more of a joke or a nuisance
nuisance to programmers
programmers than a design
flowcharting
method. Wee will
ill try to describe
describe both
both the advantages
advantages and disadvantages
disadvantages of flowcharts.
flowcharts,
method.
show the place of this technique
technique in program
program design.
and show

ADVANTAGES OF
advantage of the flowchart
chart is that
that it is a pictorial
The basic advantage
ADVANTAGES
FLOWCHARTING
representation. People find
find such representations
much more
representation.
representations much
FLOWCHARTING
meaningful than written
ritten descriptions.
descriptions. The designer
designer can visualvisual­
meaningful
ize the whole
whole system and see the relationships
relationships of the various
various parts. Logical
Logical errors and
inconsistencies often stand out instead
instead of being
being hidden
hidden in a printed
printed page. Att its best.
best,
inconsistencies
the flowchart
cha rt is a picture of the entire system.
advantages of flowcharts
charts are:
Some of the more specific advantages
1)
1)

Standard symbols
symbols exist
exist (see
that flow
charting forms are widely
widely
Standard
(see Figure 13-7) so that
flowcharting
recognized.

2) Flowcharts
u t aa programming
Flowcharts can
can be
be understood
understood by
by someone
someone w ith
without
programming background.
background.
3) Flowcharts
Flowcharts can
can be
be used
used to
to divide
divide the
the entire
entire project
project into
into sub-tasks.
sub-tasks. The
The flowchart
flowchart
can then be examined
examined to measure overall progress.
4)

Flowcharts show the sequence
sequence of operations
operations and can therefore
therefore aid in locating
locating the
Flowcharts
source of errors.
5) Flowcharting
Flowcharting isis widely
widely used
used in
in other
other areas
areas besides
besides programming.
programming.
6) There
flowcharting, including
There are
are many
many tools
tools available
available to
to aid
aid in
in flowcharting.
including programmer's
programmer's
templates and automated
automated drawing
drawing packages.
templates

These advantages
advantages are all im p
orta n t There is no question
question that
portant.
flowcharting
charting will
ill continue
continue to be widely
widely used. But we should
should

note some of the disadvantages of flowcharting
charting as a pro­
program design method, e.g.:

DISADVANTAGES
DISADVANTAGES
OF
FLOWCHARTING
FLOWCHARTING

1)
ifficu lt to
1) Flowcharts
Flowcharts are
are ddifficult
to design,
design. draw,
draw. or
or change
change in
in all
all except
except the
the simplest
simplest situa­
situations.
2) There
There isis no
no easy
easy way
way to
to debug
debug or
or test
test aa flowchart.
flowchart.
3)
3) Flowcharts
Flowcharts tend
tend to
to become
become cluttered.
cluttered. Designers
Designers find
find itit d ifficu
difficultlt to
to balance
balance between
between
the amount
amount of detail needed to make the
chart useful and the amount
amount that
the flowchart
that
makes the flow
chart little
little better
better than a program
program listing.
flowchart
4) Flowcharts
Flowcharts show
show only
only the
the program
program organization.
organization. They
They do
do not
not show
show the
the organization
organization
of the data or the structure
structure of the in p u
t/o u tp u t modules.
ut/output
5)
ith hardware
ing problems
where
5) Flowcharts
Flowcharts do
do not
not help
help wwith
hardware or
or tim
timing
problems or give hints as to where
these problems
problems might
ight occur.
6)
6) Flowcharts
Flowcharts allow
allow for
for highly
highly unstructured
unstructured design.
design. Lines
Lines and
and arrows
arrows backtracking
backtracking
and looping
looping all over the
antithesis of good structured
structured design principrinci­
the chart
chart are the
the antithesis
ples.
ples.
Thus,
charting is
Thus. flowcharting
is a helpful technique that you should not try
try to
to extend
extend too
too far.
far.

Flowcharts are useful as program
program documentation,
documentation. since
since they have standard forms
forms
and are
however, flowcharts
flowcharts
tool. however,
are comprehensible to non-programmers.
non-programmers. As a design tool,
cannot provide
starting outline:
outline; the programmer cannot debug a
cannot
provide much more than
than aa starting
detailed flowchart
chart and the
flowchart is
ifficu lt to
the flowchart
is often
often more
more difficult
to design than
than the
the program
itself.

1313-188

^7
D
D

<>

CJ

Input/O
utput
Input/Output

operation
Processing operation
(Arithmetic, Logic, Data
(Arithmetic,
Movement)
Movement)

Decision Logic

Subroutine
Subroutine

0

Connector point
point
Connector

Connector arrows
Connector

c

)

Terminal point
point
Terminal
(Beginning or Ending)
(Beginning

Standard Flowchart
Flowchart Symbols
Symbols
Figure 13-7. Standard

1313-19

EXAMPLES
Response
Response to a Switch
This simple task, in w hich a single switch
itch turns on a light
for one second,
chart. In fact.
fact, such tasks are
second, is easy to flowchart.
typical examples
examples for flowcharting
charting books, although
although they form a
typical
structure here is so simple
small part of most systems. The data structure
that it can be safely ignored.
that

FLOWCHARTING
FLOWCHARTING
SWITCH AND
SWITCH
LIGHT SYSTEM

Figure
13-8 is the flowchart.
chart. There is little
little d ifficu
lty in deciding
deciding on the amount
amount of
ifficulty
Figure 13-8
chart gives a straightforward
straightforward picture
picture of the procedure, which
which
detail required. The flowchart
understand.
anyone could
Id understand.
Note that
that the most useful flowcharts
flowcharts may ignore program
program variables and ask questions
questions
directly. Of course, compromises
compromises are often necessary here.
Two versions of the
directly.
here. Two

flowchart
chart are sometimes helpful -— one general version in layman's language,
language,
which will
ill be useful to non-programmers,
non-programmers, and one programmer's version in terms
of the program variables, which will
ill be useful to other programmers.
programmers.

'"o_A.,..T
... -,------,
A third type of flowchart,
chart, a data flowchart,
chart, may also be
DATA
helpful. This flowchart
chart serves as a cross-reference
cross-reference for the other
FLOWCHARTS
flowcharts, since it shows how the program handles a particular
particular
flowcharts.
type of data. Ordinary
Ordinary flowcharts
flowcharts show how the program proceeds, handling
handling different
different
different points. Data flowcharts.
flowcharts, on the other hand, show how particuparticu­
types of data at different
lar types of data move through
through the system, passing from one part of the program to
flowcharts are very useful in debugging
debugging and maintenance.
maintenance, since errors
another. Such flowcharts
particular type of data being handled incorrectly.
incorrectly.
most often show up as a particular

1 3-20
20

Tum light on

Tum light off

End

Figure 13-8. Flowchart
Flowchart of One-Second Response
Switch
Response to a Switch

13-21

The Switch-Based
itch-B ased Memory
em ory Loader
Loader
considerably more complex
complex
This system (see
(see Figure 13-3) is considerably
previous example,
involves many more decisions.
than the previous
example·. and involves
cha rt (see Figure
rite
The flowchart
Figure 13-9) is more difficultlt to write
and is not as straightforward
straightforward as the previous example. In
example, we face the problem
problem that
that there is no way
way to
this example.
flowchart.
debug or test the flowchart.

FLOWCHARTING
THE
SWITCH-BASED
SWITCH-BASED
MEMORY LOADER
MEMORY
LOADER

chart in Figure 13-9 includes
includes the improvements
improvements we suggested as part of the
The flow
flowchart
definition. Clearly,
cha rt is beginning to get
get cluttered and lose
problem definition.
Clearly. this flowchart
lose its
ritte n description.
Adding other features
features that
that define
define the meanmean­
advantages over a written
description. Adding
ing of the entry with
ith status lights
lights and allow
allow the operator to check entries
entries after
after complecomple­
would make the flowchart
chart even more complex. Writing
ritin g the complete
complete flowchart
flowchart
tion would
quickly become a formidable
idable task.
However, once the program has
from scratch could quickly
task. However.
been written.
ritten, the flowchart
chart is useful as documentation.
documentation.

1313-22

Su1rt

High byte of

Low byte of

Address
Address==
Switches

Address =
Switches

*

♦

Lights
Lights = Switches

Lights
Lights = Switches

♦

*

Wait

Wait
ait

debounce
debounce

debounce
debounce

time

time
time

Data =- Switches

Lights = Switches
lights

♦
Store
Store Data
at Address
Address

Wait

debounce
time
No

No

WMt

dlbounce
time

Figure 13-9. Flowchart
Flowchart of Switch-Based
Switch-Based Memory
Memory Loader

1313-23

The
Credit-Verification
The C
redit-Verification Terminal
Terminal

«

In
In this
this application
application (see
(see Figures
Figures 13-4
13-4 through
through 13-6), the
flowchart
willill be
flow
chart w
be even
even more
more complex
complex than
than in
in the
the switch-based
switch-based
memory
memory loader
loader case.
case. Here.
Here, the
the best
best Idea
idea Is
is to flowchart
cha rt secsec­
tions
flowcharts
tions separately
separately so
so that
that the
the flow
charts remain manageable.
However.
However, the
the presence
presence of
of data
data structures
structures (as in the multi-digit
ulti-d ig it
display
display and
and the
the messages)
messages) will
ill make the gap between
between
flowchart
flow
chart and
and program
program much
much wider.
wider.

FLOWCHARTING
THE CREDIT
VERIFICATION
FLOWCHARTING
SECTIONS

Let
process
Let us
us look
look at
at some
some of
of the
the sections. Figure
Figure 13-10
13-10 shows the keyboard entry process
for
for the
the digit
digit keys.
keys. The program
program must
must fetch
fetch the data after
after each strobe and place the
digit
ard ig it into
into the
the display
display array
array if there
there is room for
for it. If there are already ten digits
digits in the ar­
ray.
ray, the
the program
program simply
simply ignores
ignores the entry.
The
willill have to handle
The actual
actual program
program w
handle the displays
displays at the same time. Note that either
software
reads a
software or
or hardware
hardware must
must de-activate
de-activate the keyboard strobe after
after the processor reads
digit.
digit.

Start

Clear Entry Array
Key Pointer = Stan
of Entry Array
Key Counter = 0

Key = Keyboard
Input Data
(Key Pointer) = Kev

Key Pointer =
Key Pointer + 1

Kev Counter =
Key Counter -+ 1

End

Figure 13-10. Flowchart
Flowchart of
of Keyboard
Keyboard Entry
Entry Process
Process

13-24
13-24

Start

Oear l:lisplayArray
Key Pointer= Start
of DisplayArray
Key Counter = 0

Kev = Keyboard
Input Data

Send

Figure 13-11. Flowchart
Flowchart of Keyboard Entry Process
Process with Send Key
Key

Figure
Figure 13-11 adds the Send key. This key,
key. of course,
course. is optional. The terminal
terminal could
just send the data as soon
complete number. However,
soon as
as the operator enters a complete
However. that
procedure would
would not give the operator a chance to check the entire entry.
entry. The
flow
chart with the
flowchart
the Send key
key is more
more complex because there are
are two alternatives.
1)
1) If the operator has
has not entered ten digits,
digits. the
the program must ignore the Send
Send key
key
and place any other key into
into the
the entry.
entry.
2)
2)

If the operator has
has entered ten
ten digits,
digits. the
the program must respond to the Send
Send key by
by
transferring control to
transferring
to the Send
Send routine,
routine. and
and ignore all
all other keys.
keys.

Note that the
chart has
ifficu lt to organize
the flow
flowchart
has become much more
more difficult
organize and
and to
to follow.
follow.
There is
is also
also no
no obvious way to check
check the
the flowchart.
flowchart.

13-25
13-

Stan

Key = Keyboard
Input Data

(Key PointM) = Kev
Kev Pointer

=

Kev Pointer + 1

Send

Figure 13-12. Flowchart
Flowchart of
Function Keys
of Keyboard Entry Process
Process w
with Function
Keys

Figure
chart of the keyboard entry
ith all the
Figure 13-12
13-12 shows the flowchart
entry process
process w
with
the func­
function
control is
ritten
In this
this example,
example. the
the flo
flow of
of control
is not
not simple. Clearly,
Clearly. some
some w
written
tion keys.
keys. In
description is
organization and
flowcharts requires
description
is necessary.
necessary. The organization
and layout of
of complex
complex flowcharts
requires
careful
chart one
careful planning. We
We have
have followed
followed the
the process
process of
of adding
adding features
features to
to the
the flow
flowchart
one
at
at aa time,
time. but
but this
this still
still results
results in
in aa large
large amount
amount of
of redrawing.
redrawing. Again
Again we
we should
should remem­
remember
throughout the
ber that
that throughout
the keyboard
keyboard entry
entry process,
process. the
the program
program must
must also
also refresh
refresh the
the dis­
displays
ultiplexed and
controlled by
plays ifif they
they are
are m
multiplexed
and not
not controlled
by shift
shift registers
registers or
or other
other hardware
hardware.

1313-26

Header flag = 0
Parity Error flag = 0
ress Match flag=O
AddreSsPointer= Sta
of terminal address
Address Counter "" O

Nmess =O

Panty Error

flag= 1

Measg (Nmeu) =

Charac1et
Nmess

=Nmns +

Heade<flag = 1

AddressCounter =
AddressCounter+ 1
Address Pomter =
Address Pointer + 1

Turn off Busy
light

Drsptayanswer

RTRAN

Figure
Figure 13-13.
13-13. Flowchart
Flowchart of
of Receive
Receive Routine
Routine

1313-27

Figure 13-13
13-13 is the flowchart
cha rt of a receive routine. We assume that the serial/parallel
serial/parallel
conversion
UART). The processor
processor
conversion and error checking
checking are done in hardware (e.g
(e.g.... by a UART).
must:
1)
2)

Look for the header (we assume that
that it is a single character).

3)
4)

Wait
a it for
for the trailer
trailer character.

5)

see if
Read the destination
destination address (we assume that it is three characters long) and see
the message is meant
the
meant for this terminal;
inal; i.e.,.. if the three characters agree with the
terminal
terminal address.
If the message is meant
meant for the terminal.
terminal, turn off the Busy lightt and go to Display
Answer
Answer routine.
In the event
errors. request retransmission
RTRANS routine.
event of any errors,
retransmission by going to RTRANS

This
is neither simple
This routine
routine involves
involves a large number
number of decisions.
decisions, and the flowchart
chart is
nor obvious.

Clearly, wee have come a long way
simple flowchart
(Figure 13-8) of the
ay from the simple
rt (Figure
be
first example. A complete set of flowcharts
charts for the transaction terminal would be
logic. and
a major task. It would
would consist
consist of several interrelated
interrelated charts with complex logic,
would
as difficult
would require
require a large amount
amount of effort. Such an effort
effort would
would be just
st as
ifficu lt as writrit­
ing a preliminary
compreliminary program, and not as useful.
useful, since you could not check it on the com­
puter.

1313-28

MODULAR PROGRAMMING
PROGRAMMING
MODULAR
Once programs become large and complex.
complex, flowcharting
charting is no longer a satisfactory
satisfactory
definition and the flowchart
chart can give you some idea
design tool. However,
However. the problem definition
as to how to divide
divide the program into reasonable sub-tasks. The division of the entire
program into sub-tasks
sub-tasks or modules is called "modular
odular programming."
programming." Clearly,
Clearly. most
of the programs we presented in earlier chapters
chapters would
would typically
typically be modules in a large
system program. The problems that
that the designer faces in modular programming are

how to divide the program into modules and how to put the modules together.

advantages of modular programming are obvious:
The advantages

ADVANTAGES
OF MODULAR
PROGRAMMING
PROGRAMMING

1)

A single module is easier to write.
write, debug.
debug, and test than an
entire program.

2)

AA module
module isis likely
likely to
to be
be useful
useful in
in many
many places
places and
and in
in other
other programs,
programs. particularly
particularly ifif
it is reasonably general and performs a common
common task.
task. You can build up a library of
standard modules.

3) M
odular programming
Modular
programming allows
allows the
the programmer
programmer to
to divide
divide tasks
tasksand
and use
use previously
previously
written
ritten programs.
4)

Changes
Changes can
can be
be incorporated
incorporated into
into one
one module
module rather
rather than
than into
into the
the entire
entire system.
system.

5) Errors
Errorscan
can often
often be
be isolated
isolated and
and then
then attributed
attributed to
to aa single
single module.
module.
6) M
odular programming
Modular
programming gives
gives an
an idea
idea of
of how
how much
much progress
progress has
has been
been made
made and
and
how much of the work is
1s left.

The idea of modular programming is such an obvious one
that its disadvantages
disadvantages are often ignored.
that
ignored. These include:
1) Fitting
Fitting the
the modules
modules together
together can
can be
be aa major
major problem,
problem. par­
particularly if different
different people write
write the modules.
ticularly

DISADVANTAGES
OF MODULAR
PROGRAMMING

2) Modules
Modules require
require very
very careful
careful documentation,
documentation, since
since they
they may
may affect
affect other
other parts
parts of
of
the program, such as data structures
structures used by all the modules.
3) Testing
ifficult, since
Testing and
and debugging
debugging modules
modules separately
separately isis ddifficult.
since other
other modules
modules may
may
module being debugged
debugged and still other
other modules may
produce the data used by the module
use the results. You may have to write
rite special programs
programs (called "drivers")
"drivers") just
just to
program­
produce sample data and test the programs. These drivers require extra programeffort that adds nothing
nothing to the system.
ming effort
system.
4) Programs
Programs may
may be
bevery
very d ifficu
difficult to
to modularize.
modularize. IfIfyou
you modularize
modularize the
the program
program poorly,
poorly.
integration will
ill be very difficult.
ifficult, since almost all errors and changes will
ill involve
integration
several modules.
5) MModular
odular programs
programs often
often require
require extra
extra time
time and
and memory,
memory. since
since the
the separate
separate
functions.
modules may repeat functions.
Therefore,
hile modular
modular programming
programming is certainly
certainly an improvement
provement over trying
trying to write
write
Therefore. while
the entire program from scratch, it does have some disadvantages
disadvantages as well.

Important considerations include restricting
restricting the amount
amount of information shared by
Important
modules, limiting design decisions that
that are subject
subject to change to a single module
module
and restricting
restricting the access of one module to another.3
another.^

1 3-29
29

An obvious problem is that
that there are no proven,
systematic
atic methods for modularizing programs.
programs. We
should
ing principles:4
should mention the following
1)
1)
2)

PRINCIPLES OF
MODULARIZATION
MODULARIZATION

Modules
Modules that
that reference common
common data should be parts of the same overall module.
which the first
first uses or depends on the second,
Two modules in which
second. but not the reverse,
reverse.
should be separate.
separate.

3)

A module that is used by more than one other
other module should be part of a different
different
overall module than the others.
others.

4)

which the first
first is used by many other
other modules and the second is
Two modules in which
used by only a few other
other modules should be separate.
separate.
frequencies of usage are significantly
significantly different
different should be part
Two modules whose frequencies
of different
different modules.
The structure
structure or organization
organization of related data should be hidden within
ith in a single
module.

5)
6)

If a program
that are
program is difficultlt to modularize, you may need to redefine the tasks that
involved. Too many special cases or too many variables that
that require special han­
handling are typical signs
signs of inadequate problem definition.

1 3-30
30

EXAMPLES
Response
itch
Response to a Switch
This simple program can be divided into two
o modules:
its for the switch
itch to be turned on and turns
Module 1 w aits
the light on in response.
response.

MODULARIZING
MODULARIZING
THE SWITCH
SWITCH
AND LIGHT
SYSTEM
SYSTEM

Module 2 provides the one-second delay.
Module
odule 1 is likely to be specific
specific to the system,
ill depend on how the switch
switch
system. since it
11will
and light
light are attached. Module
odule 2 will
ill be generally
generally useful,
useful. since many tasks require
delays. Clearly,
would be advantageous
advantageous to have a standard delay module that could
Clearly. it would
ill require careful documentation
documentation so
provide delays of varying lengths. The module will
ill know how to specify
specify the length of the delay,
that you will
delay. how to call the module,
module. and
what
hat registers and memory locations
locations the module affects.
A general version of Module 1 would
would be far less
would have to deal with
ith
less useful,
useful. since it would
different types and connections
connections of switches
switches and lights.
different
You would
would probably
probably find it simpler
simpler to write
rite a module for a particular
particular configuration
conf1gurat1on of
switches and lights
lights rather than try to use a standard routine. Note the difference
difference be­
switches
besituation and Module
odule 2.
tween this situation
2.

The Sw itch-B
ased M emory
ory Loader
itch-Based
Loader
switch-based memory loader is difficultlt to modularize,
The switch-based
since
since all the programming
programming tasks depend on the hardware
configuration and the tasks are so simple
that modules
simple that
hardly seem w orthw
hile. The flowchart
flowchart in Figure 13-9 sugsug­
orthwhile.
gests that one module might
ight be the one that waits for the
pushbuttons.
operator to press one of the three pushbuttons.

MODULARIZING
MODULARIZING
THE
SWITCH- BASED
SWITCHMEMORY LOADER
MEMORY
LOADER

Some other modules might
ight be:
• A delay module that provides the delay required to debounce
debounce the switches
switches
• A switch
switch and display module that reads the data from the switches
switches and sends it to
the displays
• A Lamp Test module
Highly system-dependent
system-dependent modules such as the last two are unlikely
unlikely to be generally
Highly
useful. This example is not one in which
hich modular
modular programming
programming offers great advantages.

1 3 -31

The Verification
Verification Terminal
The verification
hand. lends itself very
verification terminal, on the other
other hand,
well
well to modular
modular programming.
programming. The entire system can easily be
divided into three main modules:
,• Keyboard and display module
• Data transmission module

MODULARIZING
MODULARIZING
THE
VERIFICATION
VERIFICATION
TERMINAL
TERMINAL

• Data reception module
A general keyboard and display
display module could handle many keyboard- and displayas:
based systems. The sub-modules
sub-modules would
would perform such tasks as:
• Recognizing a new keyboard entry and fetching
fetching the data
• Clearing the array in response to a Clear key
• Entering digits
digits into storage
• Looking for the terminator
inator or Send key
• Displaying
Displaying the digits
digits

vary. the basic entry,
entry.
Although
lthough the key interpretations
interpretations and the number
number of digits
digits will
ill vary,
storage. and data display
processes will
data storage,
display processes
ill be the same for many programs. Such
function keys as Clear would
would also be standard. Clearly,
function
Clearly. the designer must consider

ill be useful in other applications, and pay careful attention
attention to
which modules will
those modules.
modules.
The data transmission
transmission module could also be divided
divided into such sub-modules
sub-modules as:
as:

1) Adding
Adding the
the header
header character.
character.
1)
2)
2)

Transm
itting characters
characters as the output
output line can handle them.
Transmitting

3)

Generating delay times between
between bits or characters.

4) Adding
Adding the
the trailer
trailer character.
character.
5)

transmission failures;
failures: i.e.,.. no acknowledgement
acknowledgement or inability
inability to
Checking for transmission
transmitit w ith
ithout
errors.
transm
o u t errors.

The data reception
reception module could include sub-modules
sub-modules which:
which:

1) Look
Look for
for the
the header
header character.
character.
1)
2) Check
inal address.
Check the
the message
message destination
destination address
address against
against the
the term
terminal
address

Store and
and interpret
interpret the
the message.
message.
3) Store
4) Look
Look for
for the
the trailer
trailer character.
character.

Generate bit
bit or
or character
character delays.
delays.
5) Generate
Note here how important
portant it is that each design decision (such as
INFORMATION
INFORMATION
rate. message format.
the bit rate,
format, or error-checking
error-checking procedure) be imim­
HIDING
plemented in only one module. A change in any of these decisions
plemented
PRINCIPLE
will
ill then require changes only to that single module. The other
modules should be written
ritten so that they are totally
totally unaware of the values chosen or the
methods used in the implementing
plementing module. An important concept here is the "inforr­

principle:•55 whereby
mation-hiding principle,"
whereby modules share only information that
that is abab­
solutely essential to getting the task done.
done. Other
Other information is hidden within
in a
single module.
module.
single

1313-32

Error
handling is a typical
typical context
context in which
which this principle
principle should be employed. When a
Error handling
module
module detects a lethal
lethal error, it should not try
try to
to recover;
recover: instead, it should inform the
calling module of the error status and allow that
that module
module to
to decide how to
to proceed.
proceed. The
reason
sufficient information
ation to
reason is that the lower level module often lacks
lacks sufficient
to establish
recovery procedures. For
For example,
example. suppose that
that the lower level module is one that ac­
accepts numeric
numeric input
input from a user.
numeric digits term
user. This module expects a string of numeric
termi-i­
nated by a carriage return. Entry of a non-numeric
non-numeric character
character causes the module toterter­
minate abnormally.
abnormally. Since the module does not know the context
context (i.e
(i.e.,.. is the numeric
string an operand,
cannot
operand. a line number,
number. an I/O
1/0 unit number,
number. or the length of a file?),
file?). it cannot
decide how to handle an error.
followed a single error recovery
error. If the
the module always followed
procedure,
generality and only be usable in those situations
situations where that
procedure. it would lose its generality
procedure was required.
procedure

13-33
13-33

REVIEW OF MODULAR PR O G RAMMING
ING
Modular programming can be very helpful if you abide by
Modular
ing rules:
the following
1)
1)

RULES FOR
MODULAR
MODULAR
PROGRAMMING
PROGRAMMING

Use modules of 20 to 50 lines. Shorter
Shorter modules
modules are
usually
hile longer modules are seldom general and may be difif­
usually a waste
waste of time,
time. while
ficu ltIt to integrate.
integrate,
ficu

Try to make modules reasonably general. Differentiate
Differentiate between
between common
common
asynchronous transmission
transmission formats.
formats, which
hich will
ill be the
features like ASCII code or asynchronous
same for many applications.
applications, and key identifications.
identifications, number
number of displays.
displays, or number
number
of characters
characters in a message,
hich are likely to be unique
unique to a particular
particular application.
application.
message. which
Make the changing
ajor changes like different
different
changing of the latter
latter parameters simple. Major
character codes should be handled by separate modules.
character
3) Take
e on
keyboardhandlers.
handlers,etc.
etc.
Take extra
extra tim
time
on modules
modules like
like delays,
delays. display
display handlers,
handlers. keyboard
that will
ill be useful in other projects or in many different
different places in the present
that
program.
program.
4) Try to keep modules as distinct
distinct and logically separate as possible.
possible. Restrict the
flow of information
ation between
between modules
modules and implement
implement each design decision
decision in a
flow
single module.
5) Do
riting the
the entire
entire task
task may
may be
be
Do not
not try
try to
to modularize
modularize simple
simple tasks
tasks where
where rew
rewriting
easier than assembling
assembling or
or modifying
modifying the
the module.
module
2)

1 3-34
34

STRUCTURED PROGRAMMING
PROGRAMMING
How
you
How do you keep
keep modules distinct
distinct and stop them from interacting? How do you
isolate
write
rite a program that
that has a clear sequence of operations so that you can isolate
and correct
procorrect errors? One answer
answer is to use the methods known as "structuredd pro­
gramming",
gram
m ing", whereby
whereby each part of the program consists of elements
elements from a limited
set
single entry and a single
single exit.
set of structures
structures and each structure has a single
Figure 13-14
flowchart
13-14 shows a flow
chart of an unstructured
unstructured program. If an error occurs in
B. we have five possible sources for that
each se­
seModule
odule B,
that error. Not only must we check each
quence. but
but we also have to make sure that any changes made to correct the error do
not affect
like
affect any of the other
other sequences. The usual result is that
that debugging
debugging becomes like
wrestling
control. there is
wrestling an octopus. Every time you think the situation
situation is under control,
another
another loose tentacle
tentacle somewhere.
The solution
solution is to establish
establish a clear sequence of operations so
that
that you can isolate errors. Such a sequence uses single-entry.
single-entry,
single-exit
modules. The basic modules that
single-exit modules
that are needed are:
1)

An ordinary sequence; i.e.. a linear structure
structure in which
which
statements
statements or structures
structures are executed consecutively.
consecutively. In
the sequence:

BASIC
OF
STRUCTURES OF
STRUCTURED
PROGRAMMING
PROGRAMMING

S1
51
S2
52
53
S3
puter executes
executes S11 first. S2 second,
the com
computer
second. and S3 third. S1,
S1, S2,
S2, and S3
S3 may be
be
single
single instructions
instructions or entire
entire programs.

2)

A conditional structure.
The common
S1 else S2," where C is a condition
S1 and S2
S2
common one is "1f
if C then S1
condition and S1
statements or sequences of statements. The computer
puter executes S1
are statements
S1 if C is true,
true.
structure. Note that the
and S2 if C is false.
false. Figure 13-15 shows the logic of this structure.
structure has a single entry and a single exit; there is no way to enter or leave
structure
leave S1
S1 or
other than through
through the structure.
S2 other

3)
3)

A loop structure.
common loop structure
structure is "while
h ile C do S," where C is a condition
condition and S is a
The common
statement or sequence of statements. The computer
computer checks C and executes S if C
statement
C
structure (see
is true. This structure
(see Figure 13-16) also has a single entry and a single exit.
exit.
that the com
puter will
ill not execute S at all if C is originally
originally false,
Note that
computer
false. since the
the
value of C is checked before S is executed.

In most structured
structured programming
programming languages.
languages, an alternative
alternative looping construct
construct is pro­
proconstruct is known
known as the do-until
do-until clause. Its basic structure
structure is
vided. This construct
is "do S until
unttl
C”
where C is a condition
condition and Sisis a statement
statement or sequence of statements. It is similar
C",, where
do-while construct
construct except
except that the test of the looping condition
condition C is
to the do-while
is performed at
the end of the loop. This has the effect
guaranteeing that the loop is always executed
effect of guaranteeing
illustrated by the flowchart
chart in Figure 13-17. The common indexat least once. This is illustrated
controlled or DO loop can be implemented
implemented as a special case
either of these two basic
controlled
case of either
looping constructs.
constructs.
looping

1313-35

C

B

Figure 13-14. Flowchart
Unstructured Program
Flowchart of an Unstructured

Start

51

52

End

Figure 13-15. Flowchart
Flowchart of the If-Then-Else Structure
Structure

13-36

Start

No

s
End

Figure 13-16. Flowchart
Flowchart of the Do-While
hile Structure
Structure

Start

s

End

Flowchart of the Do-Until
Do-Until Structure
Structure
Figure 13-17. Flowchart
4)

A case structure.
Although not a prim1t1ve
prim itive structure
structure like sequential.
sequential, if-then-else,
if-then-else. and do-while,
do-while, the
Although
case structure
structure is
commonly used that
that we include
include it here as an adIunct
adjunct to the
Is so commonly
structure descriptions.
descriptions. The case structure
structure is "case
"case I of SO,
1 ,. . Sn". where
where I
basic structure
SO, Sl..
I . . .Sn are statements
statements or sequences of statements
statements. If I is
is an index and SO,
SO, S1,
Is
statement SO
statement S1
equal to zero then statement
SO is
Is executed, if I is equal to 1 then statement
S1 is
executed, etc. Only
Only one of thenn statements
statements is
After its execution,
execution, control
control
executed.
Is executed. After
passes to the next sequential
sequential statement
statement follow
ing the case statement
statement group. If I is
following
Is
number of statements
statements in
in the case statement!.
statement), then none of
greater than n (i.e.,
(i.e., the number
the statements
statements in the case statement
statement is executed,
executed, and control
control is
directly to
Is passed directly
the next
next sequential
sequential statement
statement follow
ing the case statement
statement. This Is
is Illustrated
illustrated by
following
the flow
flowchart
chart in Figure 13-18.

1 3 -37
37

No

No

so

SI

S2

Sn

L-

______

.._

________________

...

.._

____

~

End

Figure 13-18. Flowchart of the Case Structure

ing features
features of structured programming:
Note the following
1)l

2)
3)

Only the three basic structures, and possibly a small
number of auxiliary structures, are permitted.
Structures may be nested to any level of complexity
plexity so that any structure
can,
can, in
in turn, contain any of the structures.
Each
Each structure has
has a single
single entry and a single
single exit.

Some examples of the conditional structure illustrated in
Figure
13-15 are:
Figure 13-15
1)
included:
1) S2 included:

EXAMPLES
OF
STRUCTURES

if X >
~ 0
0 then NPOS
NPOS = NPOS
NPOS ++ 11
else
NNEG ++ 1
else NNEG
NNEG == NNEG
Both S1
S1 and
and S2
S2 are single
single statements.
statements.
2)
2)

S2
omitted:
S2 omitted:
if X ^ 0
-foOthen Y == 1/X
1/X

Here
) is
Here no
no action is
is taken
taken if C
C (X
(X ^ 0
-foO)
is false.
false. S2
S2 and
and "else"
"'else" can
can be
be omitted
omitted in this case.
case.

1 3 -38
8

loop structure illustrated
Figure 13-16
Some examples of the loop
Illustrated in Figure
13-16 are:
1)
1)

N.
Form the sum of integers
integers from 1 to N.
1=0
=0
SUM =00
hile I<< N
do while
1 + 1
I1 ==I+
1
SUM== SUM++ I
end

computer executes the loop as long as I < N.
program within
ith in the "do"doThe computer
N. If N = 0, the program
all.
while"
hile" is not executed
executed at all21
2)

Count characters
characters in an array SENTENCE
until you find an ASCII period.
Count
SENTENCE until
NCHAR = 0
do while
hile SENTENCE
SENTENCE (NCHAR)
(NCHAR) ^-laPERIOD
PERIOD
NCHAR = NCHAR + 1
end

The computer
puter executes the loop as long as the character
is not an ASCII
character in SENTENCE
SENTENCE 1s
ASCII
period. The count
count is
character is a period.
1szero if the first character

The advantages of structured programming
programming are:
1)
1)

The sequence
sequence of operations
operations is simple
simple to trace. This allows
easily.
you to test and debug easily.

ADVANTAGES OF
ADVANTAGES
STRUCTURED
PROGRAMMING
PROGRAMMING

2) The
inology is
The number
number of
of structures
structures is
is limited
l1m1tedand
and the
the term
terminology
1s
standardized.
standardized.

The structures
structures can
can easily
easily be
be made
made into
into modules.
modules
3) The
4) Theoreticians
all
Theoret1c1anshave
have proved
proved that
that the
the given
given set
set of
of structures
structures is
is complete;
complete; that is,
is, all
programs can be written
ritten in terms of the three structures.
structures.
5)

structured version of a program is partly
partly self-docum
enting and fairly
fairly easy to
The structured
self-documenting
read.
read.
Structured programs
programs are
are easy
easy to
to describe
describe wwith
program outlines.
outlines.
6) Structured
ith program

Structured programming
programming has
has been
been shown
shown in
in practice
practice to
to increase
increase programmer
programmer pro­
pro7) Structured
ductivity.
ductivity.

Structured programming basically forces much more discipline on the programmer
than does modular programming.
atic and betterbetterprogramming. The result is more systematic
organized programs.
programs.
The disadvantages of structured programming
programming are:

DISADVANTAGES
DISADVANTAGES
OF

1) Only
Only aa few
few high-level
high-level languages
languages (e.g.,
(e.g.,PL/M,
PL/M, PASCAL)
PASCAL) wwill
1)
ill
STRUCTURED
directly accept
accept the structures.
structures. The programmer
programmer therefore
directly
PROGRAMMING
PROGRAMMING
has to go through
through an extra translation
translation stage to convert
convert the
structures
verstructures to assembly language code. The structured
structured ver­
sion of the program, however, is often useful as documentation.
documentation,
2)

Structured programs often execute more slowly
slowly and use more memory
memory than
Structured
unstructured
unstructured programs.

3)

Limiting
iting the structures
structures to the three basic forms makes some tasks very awkward
awkward to
completeness of the structures
structures only means that all programs
programs can be
perform. The completeness
implemented
implemented with
ith them; it does not mean that a given program can be impleimple­
efficiently or conveniently.
conveniently.
mented efficiently
The standard
standard structures
structures are often quite
quite confusing,
confusing, e.g.
e.g., nested "if-then-else"
"if-then-else" strucstruc­
tures may be very d iffic
ifficult
read. since there may be no clear indication
u lt to read,
indication of where
inner structures
"do-while"
read.
structures end. A series of nested "do-w
hile" loops can also be difficult
ifficu lt to read.

4)

13-39
13-39

5)

Structured programs
programs consider
consider only
only the sequence
sequence of program
program operations.
operations, not the
Structured
flow of data. Therefore.
Therefore, the structures
structures may handle
handle data awkwardly.
awkwardly.
flow

6)

programmers are accustomed
accustomed to structured
structured programming.
programming. Many
Many find
find the stanstan­
Few programmers
structures awkward
awkward and restrictive.
restrictive.
dard structures

We are neither
neither advocating
advocating nor discouraging the use of structured
structured programming. It
We
is one way
ay of system
atizing program design. In general, structured
structured programming
systematizing
is most useful in the following
ing situations:
• Larger programs.
programs, perhaps exceeding
exceeding 1000 instructions.
instructions.
• Applications
Applications in which
hich memory
memory usage is not critical.
critical.

WHEN TO USE
WHEN
STRUCTURED
STRUCTURED
PROGRAMMING
PROGRAMMING

Low-volume applications
applications where
where software
software development
development costs,
• Low-volume
costs.
particularly testing
testing and debugging.
debugging, are important
portant factors.
particularly
• Applications
Applications involving
involving string
string manipulation.
manipulation, process control.
control, or other
other algorithms
algorithms rara­
simple bit manipulations.
manipulations.
ther than simple

In the future, we expect
expect the cost of memory to decrease, the average size of
microprocessor programs to increase, and the cost of software
are development
development to inin­
crease. Therefore,
Therefore, methods like structured programming, which
hich decrease softsoft­
development costs for larger programs but use more memory, will
ill become
ware development
more valuable.
Just because structured
structured programming
programming concepts
concepts are usually
usually expressed in
high-level
Just
1n high-level
structured programming
programming is not applicable
applicable to assembly
languages does not mean that structured
language programming.
programming. To the contrary.
contrary, the assembly language programmer, with
ith
language
total freedom of expression that
that assembly level
level programming allows, needs
the total
the structuring concepts provided by structured programming. Creating modules
w ith single
single entry and e xitit points, using
using simple control structures and keeping the
complexity
plexity of each module minimal makes assembly language coding more effiffi­
cient.

1313-40

EXAMPLES
EXAMPLES
Response
Responseto
to aa S w
Switch
The
The structured
structured version
version of
of this
this example
example is:
11:
SWITCH
SWITCH== OFF
OFF
do
do w
while SWITCH
SWITCH == OFF
OFF
READ
READ SWITCH
SWITCH
end
end
LIGHT
LIGHT== ON
ON
DELAY
DELAY 1
LIGHT
LIGHT== OFF
OFF

STRUCTURED
STRUCTURED
PROGRAMMING
IN THE
THE
SWITCH AND
AND
LIGHT
LIGHT SYSTEM

ON
ON and OFF
OFF must
must have
have the
the proper definitions
defin1t1onsfor
for the
the switch and
and light- W
We assume
assume that
that
DELAY
DELAY is a module that
that provides a delay
delay given by its parameter in
In seconds.
seconds
A statement
statement in a structured
structured program may actually be
be a subroutine.
ine However,
However. in order to
conform to
structured programming.
programming, the subroutine
subroutine cannot have any exits
to the
the rules of structured
other than the one that returns control to the main program.
Since "d o -w
h ile ” checks the condition
condition before executing
executing the
-while"
the loop,
loop. we set the
the variable
SWITCH
SWITCH to OFF
OFF before starting.
starting. The structured
structured program is
Is straightforward,
straightforward. readable,
readable.
and easy
would probably require somewhat
somewhat more memo­
easy to check by hand.
hand. However,
However. it would
memory than an unstructured
unstructured program,
which would
would not have to initialize
SWITCH and could
program. which
1ni11ahze
combine the reading and checking
checking procedures.
combine

13-41
13-41

The Sw itch-B
ased M em
ory Loader
Loader
The
Switch-Based
emory
switch-based memory
memory loader is aa more complex
complex strucstruc­
The switch-based
tured programming problem. We
We may
may implement
implement the
tured
flowchart
chart of
of Figure 13-9
13-9 as follow
(a • indicates
indicates aa comcom­
followss (a
ment):
ment):

STRUCTURED
PROGRAMMING
PROGRAMMING
FOR THE
THE
SWITCH-BASED
SWITCH-BASED
MEMORY
MEMORY LOADER

INITIALIZE VARIABLES
VARIABLES
• INITIALIZE
HIADDRESS == 00
LOADDRESS = 00
DO-WHILE CONSTRUCT WITH
WITH NO CONDITION
CONDITION
• THIS PROGRAM USES A DO-WHILE
SIMPLY DO-FOREVER).
CONTINUALLY
• (CALLED SIMPLY
DO-FOREVER). THEREFORE,
THEREFORE. THE SYSTEM CONTINUALLY
CONTAINED IN THIS DO-WHILE
DO-WHILE LOOP.
• EXECUTES
EXECUTES THE PROGRAM CONTAINED
LOOP.
forever
do forever
BUTTON; PERFORM
• TEST FOR
FOR HIADDRESS BUTTON;
PERFORM THE REQUIRED
REQUIRED PROCESSING
PROCESSING
• IF IT IS ON.
if
HIADDRBUTTON = 1 then
1f HIADDRBUTTON
begin
HIADDRESS = SWITCHES
LIGHTS = SWITCHES
do
DELAY (DEBOUNCE
(DEBOUNCE TIME)
until HIADDRBUTTON
HIADDRBUTTON fo
?M1
until
end
• TEST
TEST FOR
FOR LOADDRESS BUTTON; PERFORM
PERFORM LOW ADDRESS PROCESSING
PROCESSING
• IF IT IS ON.
ON.
if11LOADDRBUTTON
LOADDRBUTTON = 1 then
then
begin
LOADDRESS = SWITCHES
LIGHTS = SWITCHES
do
DELAY (DEBOUNCE
(DEBOUNCE TIME)
until LOADDRBUTTON
LOADDRBUTTON ±
fo1
until
end
end

,

•• TEST
DATABUTTON, AND
TEST FOR
FOR DATABUTTON.
AND STORE
STORE DATA INTO
INTO MEMORY
•• IF
IF IT IS
IS ON.
ON.
if1fDATABUTTON
DATABUTTON == 11 then
thPn
begin
begin
DATA
DATA== SWITCHES
SWITCHE~
LIGHTS
LIGHTS == SWITCHES
SWITCHES
(HIADDRESS,
(HIADDRESS. LOADDRESS)
LOADDRESS) == DATA
DATA
do
do
DELAY
DELAY (DEBOUNCE
(DEBOUNCE TIME)
TIME)
uuntil DATABUTTON
DATABUTTON fo 1
end
end
end
end

1313-42

• THE
THE LAST END
END ABOVE TERMINATES
TERMINATES THE
THE
do forever LOOP
LOOP
Structured programs
programs are not easy to write, but they can give a great deal of insight
insight into
Structured
the overall program logic. You can check the logic of the structured
structured program by hand
before writing
ritin g any actual codecode.

13-43
13-43

The C
redit-Verification Term
inal
The
Credit-Verification
Terminal
Let us look at
at the keyboard
keyboard entry
entry for
for the
the transaction
transaction terminal.
Let
W
assume that
that the
the display
display array
array is
is ENTRY.
ENTRY, the
the keyboard
keyboard
Wee w
willill assume
strobe is
is KEYSTROBE,
and the
the keyboard
keyboard data
data is
is KEYIN.
KEYIN. The
The strucstruc­
strobe
KEYSTROBE. and

o u t the function
function keys
keys is:
tured program w ith
ithout
NKEYS == 110
0

STRUCTURED
PROGRAM FOR
PROGRAM
THE CREDITVERIFICATION
VERIFICATION
TERMINAL
TERMINAL
STRUCTURED
KEYBOARD
ROUTINE

•• CLEAR ENTRY TO START
do while
while NKEYS >
>0
do
NKEYS- 1
NKEYS = NKEYS
ENTRY(NKEYS) = 00
end
• FETCH
FETCH A COMPLETE ENTRY FROM KEYBOARD
do while
hile NKEYS <
< 10
ACTIVE then
if KEYSTROBE
KEYSTROBE = ACTIVE
begin
begin
KEYSTROBE
INACTIVE
KEYSTROBE = INACTIVE
ENTRY(NKEYS)
ENTRY(NKEYS) = KEYIN
+1
NKEYS = NKEYS +
end
end

Adding the SEND key means that the program
after it has
program must ignore extra digits after
a complete entry, and must ignore
ignore the SEND key until it has a complete entry. The
structured program is:
is:
NKEYS = 110
0
• CLEAR
CLEAR ENTRY
ENTRY TO START
do while
hile NKEYS >
>0
NKEYS
NKEYS- 1
NKEYS = NKEYS
ENTRY(NKEYS)
ENTRY(NKEYS) = 0
end
• WAIT
AIT FOR
FOR COMPLETE
COMPLETE ENTRY
ENTRY FOLLOWED BY
BY SEND
SEND KEY
KEY
do w
hile KEY
*S E N
D OR
SEND
OR NKEYS
NKEYS *#1 0
10
while
KEY #
ifif KEYSTROBE
KEYSTROBE == ACTIVE
ACTIVE then
begin
KEYSTROBE
KEYSTROBE == INACTIVE
KEY
KEY== KEYIN
KEYIN
if NKEYS
*S E N
D then
NKEYS *#1 0
10 AND
AND KEY
KEY #
SEND
then
begin
begin
ENTRY(NKEYS)
ENTRY(NKEYS) == KEY
KEY
NKEYS
NKEYS == NKEYS
NKEYS ++ 11
end
end
end
end
end
end

13-44
13-44

ing features
features of this
this structured
structured program.
Note the follow
following
1)

The second
second if-then
if-then is nested within
ith in the first
first one.
one, since
since keys are only
only entered
entered after
after a
strobe is recognized.
recognized. If the second if-then
if-then were
were on the same level as the first.
first, a
strobe
single
single key could
could fill
fill the entry.
entry, since its value
value would
would be entered
entered into
into the array during
during
each iteration
iteration of the do-while
do-while loop.

2)

KEY
not be defined
defined initially,
initially, since NKEYS
part of the clearing
clearing
KEY need not
NKEYS is set to zero as part
of the entry.

Adding the CLEAR key allowss the program to clear the entry
entry originally by simulatulat­
e, by setting
NKEYS to 10 and KEY to CLEAR before
ing the pressing of CLEAR; i.e.,
setting NKEYS
starting.
d1g1ts that
starting. The structured
structured program
program must
must also only
only clear
clear digits
that have previously
previously been
filled. The new
new structured
structured program is:
filled.
is:
• SIMULATE COMPLETE
COMPLETE CLEARING
CLEARING
NKEYS
0
NKEYS = 110
KEY
KEY== CLEAR
CLEAR
AIT FOR
• WAIT
FOR COMPLETE
COMPLETE ENTRY
ENTRY AND SEND
SEND KEY
KEY
do while
hile KEY
D OR NKEYS
10
KEY#*S E N
SEND
NKEYS *#1 0
• CLEAR
CLEAR WHOLE ENTRY
ENTRY IF CLEAR
CLEAR KEY
KEY STRUCK
STRUCK
if KEY
KEY = CLEAR
CLEAR then
begin
KEY
KEY== 0
do while
hile NKEYS
NKEYS >
>0
NKEYS
NKEYS = NKEYS
NKEYS - 1
ENTRY(NKEYS) = 0
ENTRY(NKEYS)
end
end
• GET
GET DIGIT
DIGIT IF ENTRY
ENTRY INCOMPLETE
INCOMPLETE
if KEYSTROBE
KEYSTROBE= INACTIVE then
begin
KEYSTROBE
= INACTIVE
KEYSTROBE=
KEY
KEY== KEYIN
KEYIN
if KEY
KEY <
< 10 AND NKEYS
NKEYS *# 10 then
begin
ENTRY(NKEYS) = KEY
KEY
ENTRY(NKEYS)
NKEYS = NKEYS
NKEYS ++ 1
NKEYS
end
end
end

that the
the program resets
resets KEY
KEY to
to zero after clearing the
the array, so
so that
that the
the operation
Is
Note that
operation is
not repeated.

13-45

We can sim ilarly build a structured program
program for the receive
routine. An initial
initial program
program could
could just
just look for the header
header and
trailer characters.
characters. We will
ill assume that
that RSTB
indicator that
that a
trailer
RSTB is the indicator
character is ready. The structured program
program is:
is:
character

STRUCTURED
RECEIVE
RECEIVE
ROUTINE

• CLEAR HEADER
HEADER FLAG TO START
HFLAG = 0
• WAIT
AIT FOR
FOR HEADER
HEADER AND TRAILER
TRAILER
hile HFLAG = 0 OR CHAR ^TRAILER
do while
ilcTRAILER
• GET
GET CHARACTER IF READY,
READY. LOOK FOR
FOR HEADER
HEADER

if RSTB
RSTB = ACTIVE then
begin
RSTB
RSTB = INACTIVE
CHAR== INPUT
then HFLAG = 1
if CHAR = HEADER
HEADER then
end

Now we can add the section that
that checks the message
Now
message address
address against the three
digits in TERMINAL
TERMINAL ADDRESS (TERMADDR). If any of the corresponding
corresponding digits
are not equal, the ADDRESS MATCH
MATCH flag (ADDRMATCH)
(ADDRMATCH) is set to 1.
• CLEAR HEADER
MATCH FLAG,
HEADER FLAG,
FLAG. ADDRESS MATCH
FLAG. ADDRESS COUNTER
COUNTER TO START
HFLAG = 0
ADDRMATCH = 0
ADDRMATCH
ADDRCTR = 0
AIT FOR
• WAIT
FOR HEADER,
HEADER. DESTINATION ADDRESS AND TRAILER
TRAILER
while HFLAG = 0 OR CHAR *i1cTRAILER
33
do while
TRAILER OR ADDRCTR *i1c

• GET
GET CHARACTER IF READY
if RSTB
RSTB = ACTIVE then
begin
RSTB
RSTB = INACTIVE
CHAR== INPUT
end
• CHECK
TERMINAL ADDRESS AND HEADER
CHECK FOR
FOR TERMINAL
HEADER
if HFLAG = 1 AND ADDRCTR *i1c
33 then
begin
ADDRMATCH = 1
ADDRMATCH
ADDRCTR+ 1
ADDRCTR = ADDRCTR
end
if CHAR = HEADER
HEADER then HFLAG = 1

end

13-46
13-46

program must
must now
now wait
ait for
for a header.
header, a three-digit
three-digit identification
identification code.
code, and a trailer.
The program
must be careful
careful of what
hat happens
happens during
during the iteration
iteration when
when the program
program finds
finds the
You must
header, and of what
hat happens
happens if an erroneous
erroneous identification
identification code
code character
character is the same
header.
trailer.
as the trailer.

further addition can store the message in MESSG. NMESS
NMESS is the number of
A further
characters in the message; if it is not zero at the end,
end. the program knows
knows that
that the
terminal has received
received a valid message. We have not
not tried
tried to minimize
minimize the logic
logic exex­
terminal
pressions in this program.
program.
pressions
• CLEAR FLAGS,
FLAGS. COUNTERS
COUNTERS TO START
HFLAG = 0
ADDRMATCH = 00
ADDRMATCH
ADDRCTR = 00
NMESS = 00
• WAIT
AIT FOR
FOR HEADER,
HEADER. DESTINATION ADDRESS AND TRAILER
TRAILER
hile HFLAG = 0 OR CHAR *,/,.TRAILER
33
do while
TRAILER or ADDRCTR *,/,.
• GET
GET CHARACTER IF READY

if RSTB
RSTB = ACTIVE then
begin
RSTB
RSTB = INACTIVE
CHAR== INPUT
end
• READ
READ MESSAGE IF DESTINATION ADDRESS== TERMINAL ADDRESS
ADDRESS
if HFLAG
HFLAG = 1 AND ADDRCTR = 3 then
if ADDRMATCH
ADDRMATCH = 0 and CHAR ^TRAILER
,/,.TRAILER then
begin
MESSG(NMESS)
MESSG(NMESS) = CHAR
NMESS = NMESS +
+1
end
• CHECK
CHECK FOR
FOR TERMINAL ADDRESS
ADDRESS
if HFLAG
33 then
HFLAG = 1 AND ADDRCTR *,/,.
then
if CHAR *,/,.TERMADDR(ADDRCTR)
TERMADDR(ADDRCTR) then
then
begin
ADDRMATCH = 1
ADDRMATCH
ADDRCTR
ADDRCTR = ADDRCTR ++ 1
end
• LOOK
LOOK FOR
FOR HEADER
HEADER
if CHAR = HEADER
HEADER then HFLAG
HFLAG == 1
end

113-47
3-47

identification code only if it found a header during
during a prepre­
The program checks for the identification
previously found a header and a
vious iteration. It accepts the message
message only if it has previously
complete, matching
matching destination
destination address.
address. The program must work properly during the
trailer and the last digit
ig it of the destination
destination adad­
iterations when it finds the header,
header. the trailer
dress.
ith the terminal
inal address or place the trailer
dress. It must not try to match the header with
ig it of the destination
destination address in the message.
or the final digit
message. You might try adding the
cha rt (Figure
13-13) to the structured program.
rest of the logic from the flowchart
(Figura 13-13)
program. Note
that the order of operations is often critical. You must be aura
sure thatt the program
program
that
does not complete one phase and start
start the next
next one during the same Iteration.
iteration.

13-48

STRUCTURED PR O G RA
M M ING
REVIEW OF STRUCTURED
RAMMING
Structured programming
programming brings
brings discipline
discipline to program
program design.
design. It forces
forces you
you to lim
Structured
limitit
the
the types
types of
of structures
structures you
you use and the
the sequence
sequence of
of operations.
operations. It provides
provides singlesingle­
entry, single-exit
single-exit structures,
structures, which
hich you can check
check for
for logical
logical accuracy.
accuracy. Structured
Structured
entry,
programming
programming often
often makes
makes the
the designer
designer aware
aware of
of inconsistencies
inconsistencies or possible
possible comcom­
binations of inputs.
inputs. Structured
Structured programming
programming is not
not a cure-all,
cure-all, but
but it does bring
bring
binations
some order
order into
into a process
process that
that can be chaotic.
chaotic. The structured
structured program
program should
should also
some
debugging, testing,
testing, and documentation.
documentation.
aid in debugging,
Structured programming
programming is not
not simple.
simple. The programmer
programmer must
must not
not only
only define
define the
the
Structured
problem
problem adequately,
adequately, but
but must
must also work
ork through
through the
the logic
logic carefully.
carefully. This is
tedious and difficu
but it results
results in a clearly
clearly written,
ritte n , working
orking program.
tedious
difficult,lt, but
program.
The particular structures we have presented are not ideal and
TERMINATORS
TERMINATORS
are often awkward.
awkward. In addition, it can be difficultlt to dis­
disFOR
tinguish where
where one structure ends and another begins, particpartic­
STRUCTURES
ularly if they
they are nested. Theorists may provide better
tte r strucstruc­
tures in the future, or designers may wish to add some of their own. Some kind of
necessary, since indenting
terminator
inator for each structure
structure seems necessary,
indenting does not always clarify
the situation.
situation. "End"
"End" is a logical terminator
inator for the "d o-w
h ile " loop. There is
o-while"
1sno obvious
terminator.
terminator, however, for the "'if-then-else"
"if-then-else" statement:
statement: some theorists have suggested
ndif"
backwards). but these are both awkward
"e n
d if" or " fi"i" ("if"
("if" backwards),
awkward and detract
detract from the
readability of the program.
readability

We suggest the following rules for applying
applying structured pro­
programming:
gramming:
1)
2)
2)

3)
3)
4)

5)
5)

6)

7)
7)

RULES FOR
FOR
RULES
STRUCTURED
PROGRAMMING
PROGRAMMING

Begin by writing a basic flowchart
chart to help define the
logic of the program.
Start
n tia l," "if-th e n
-e ls e ," and
h ile " constructs.
Start w
with the
the "se q u
"sequential,"
"if-then-else,"
and "d o -w
"do-while"
constructs. They
They
are known to be a complete
complete set.
i.e.,.. any program can be written
ritten in terms of these
set. ,e
these
structures.
Indent each level a few spaces
ill know
spaces from the previous level,
level. so that you will
which statements
statements belong where.
which
Use terminators
terminators for
for each
each structure;
structure; e.g.,
e.g.. "e n
··end"
for the
the "d o-w
··do-while"
and "e n
··endif"
or
Use
d " for
h
and
d if" or
"fi''
fi" for the "'if-then-else".
"if-then-else". The
The terminators
terminators plus
plus the
the indentation
indentation should
should make
make the
program reasonably clear.
clear.
Emphasize sim
simplicity
Emphasize
plicity and
and readability.
readability. Leave
Leave lots
lots of
of spaces.
spaces, use
use meaningful
meaningful
names, and make
names,
make expressions
expressions as clear
clear as
as possible.
possible. Do
Do not
not try
try to
to minimize
minimize the logic
logic
at the
the cost of clarity.
Comment the program
program in an
an organized manner.
manner.
Check the
the logic.
logic.Try
Try all
all the
the extreme
extreme cases
cases or
or special
special conditions
conditions and
and aa few
few sample
sample
Check
cases.
ill not plague you later.
cases. Any logical errors you find
find at this
this level will
later.

1313-49

TO P-DOWN
W N DESIGN
The remaining
remaining problem
problem is how
how to check
check and integrate
integrate modules
modules
The
BOTTOM-UP
BOTTOM-UP
structures. Certainly
Certainly wee want
a nt to divide
divide a large
large task
task into
into
DESIGN
or structures.
sub-tasks. But
But how
how do wee check
check the
the sub-tasks
sub-tasks in isolation
isolation and
sub-tasks.
put them
them together?
together? The standard
standard procedure,
procedure, called
called "b otto
m -up design,"
design," requires
requires
put
ottom-up
extra work
o rk in testing
testing and debugging
debugging and leaves
leaves the
the entire
entire integration
integration task
task to the
the
extra
hat wee need
need is a method
method that
that allows
allows testing
testing and debugging
debugging in the
the actual
actual
end. What
program environm
ent and modularizes
modularizes system
system integration.
integration.
program
environment
This method
method is "top
-do w n design."
design." Here wee start
start by writing
riting
This
"top-down
the overall
overall supervisor
supervisor program.
program. We
We replace
replace the
the undefined
undefined subsub­
the
programs by program
program "s tu
b s ," temporary
temporary programs
programs that
that may
programs
tubs,"
either record
record the
the entry,
entry, provide
provide the
the answer
answer to a selected
selected test
test
either
problem, or do nothing.
nothing. We then
then test
test the
the supervisor
supervisor program
program
problem,
that its logic
logic is correct.
correct.
to see that
We proceed
proceed by expanding
expanding the
the stubs.
stubs. Each stub
stub willill often
often concon­
We
tain sub-tasks,
sub-tasks, which
which we will
ill temporarily
temporarily represent
represent as stubs.
This process of expansion,
expansion, debugging, and testing
testing continues
continues
orking programs.
until all the stubs are replaced by working
programs. Note that
testing and integration
integration occur
occur at each level,
rather than all at the
testing
level. rather
end. No special driver
driver or data generation
generation programs
programs are necessary.
We get a clear idea of exactly
exactly where
where we are in
in the design. Toppati­
down design assumes modular programming, and is compatible with
ith structured
structured programming as well.

TOP-DOWN
TOP-DOWN
DESIGN
METHODS
METHODS
STUBS

EXPANDING
STUBS
ADVANTAGES
ADVANTAGES
OF
TOP-DOWN
DESIGN

disadvantages of top-dow
The disadvantages
top-downn design are:
DISADVANTAGES
DISADVANTAGES
OF
OF
TOP-DOWN
DESIGN

1)
1)

The overall design may not mesh well with
ith system hardhard­
ware.

2)
2)
3)
3)

It may not take good advantage
advantage of existing
existing software.
ifficu lt to write.
write, particularly
particularly if they must
Stubs may be difficult
correctly in several different
different places.
work correctly
places.

4)

Top-down design may not result in generally
generally useful modules.
Top-down

5)

Errors at the top level can have catastrophic
catastrophic effects,
bottom-up
effects. whereas errors in bottom-up
usually limited
limited to a particular
particular module
design are usually

In large programming
programming projects,
projects, top-down
top-down design
design has been shown
shown to greatly
greatly imim­
prove programmer
programmer productivity.
productivity. However,
However, almost
almost all of these
these projects
projects have used
prove
some bottom
-up design
design in cases where
where the top-dow
method would
would have
bottom-up
top-downn method
resulted in a large amount
amount of extra
extra work.
work.
resulted
Top-down design
design is a useful
useful tool
tool that
that should
should not
not be follow
ed to extremes.
extremes. It propro­
Top-down
followed
vides the same discipline
discipline for system
system testing
testing and integration
integration that
that structured
structured propro­
vides
gramming provides
provides for module
module design. The method,
method, however,
however, has more general
general
gramming
applicability, since it does not assume
assume the use of programmed
programmed logic.
logic. However,
However,
applicability,
top-down design
design may not result
result in the most
most efficient
efficient implementation.
implementation.
top-down

1313-50

EXAMPLES
Response to a S witch
itch
The first structured programming example actually demondemon­
was:
strates top-dow
top-downn design as well. The program
program was:

TOP-DOWN
TOP-DOWN
DESIGN
OF SWITCH
SWITCH
AND LIGHT
SYSTEM
SYSTEM

SWITCH== OFF
OFF
hile SWITCH = OFF
do while
OFF
READ
READ SWITCH
end
LIGHT
LIGHT== ON
DELAY 1
LIGHT
LIGHT== OFF
OFF

These statem
ents are really stubs, since none
none of them is fully defined. For exam­
examstatements
ple. what
hat does READ
switch were one bitit of input
input port SPORT,
READ SWITCH mean? If the switch
SPORT. it
really means:
means:
SWITCH = SPORT
SPORT AND SMASK
where SMASK has a ·1
'1'• bitit in the appropriate
appropriate position. The masking may. of course,
where
course. be
implemented with
ith a Bit Test instruction.
instruction.
implemented
Similarly, DELAY 1 actually
actually means (if the processor itself
itself provides
provides the delay):
Similarly,
REG
REG= COUNT
COUNT
do while
hile REG
REG * 0
f=.O
REG
REG== REG
REG - 1
end
COUNT
appropriate number
number to provide
provide a one-second
one-second delay. The expanded verver­
COUNT is the appropriate

sion of the program is:
is:
SWITCH== 00
do while
hile SWITCH = 0
SWITCH = SPORT
SPORT AND MASK
end
LIGHT
LIGHT== ON
REG
REG= COUNT
COUNT
REG *f=.0
do while
hile REG
REG
REG= REG
REG - 1
end
LIGHT
(LIGHT)
LIGHT== NOT (LIGHT)

•

explicit, and could
Certainly this program
program is more explicit,
could more easily be translated into
actual instructions or statements.
statements.

13-51

The Sw itch-Based
ased M emory
ory Loader
Loader
example is more complex
complex than the first
first example.
example, so we
This example
systematically. Here again,
structured pro­
must proceed systematically.
again. the structured
program contains stubs.
stubs.
For example.
example, if the HIGH
button is one bit of input
input
HIGH ADDRESS
ADDRESS button
port CPORT,
CPORT. "ifif HIADDRBUTTON = 1" really means:
1)
1)

Input from CPORT
Input
CPORT

2)

Complement
Complement
Logical AND with
ith HAMASK
Logical

3)

TOP-DOWN
TOP-DOWN
DESIGN OF
SWITCH-BASED
SWITCH-BASED
MEMORY
MEMORY
LOADER

where HAMASK has a T
appropriate bit position
position and 'Os'
Similarly
where
·1• in the appropriate
·os· elsewhere. Similarly
the condition
condition "ifif DATABUTTON = 1" really means:
1)
1)

2)
2)
3)

Input from CPORT
Input
CPORT
Complement
Complement
ith DAMASK
Logical AND with

So,
initial stubs could just
just assign values to the buttons.
buttons, e.g.,..
So. the initial
HIADDRBUTTON = 00
LOADDRBUTTON
LOADDRBUTTON = 00
DATABUTTON = 0
A run of the supervisor
supervisor program should show that it takes the implied
implied "else"
"else" path
through the "if-then-else"
"if-then-else" structures,
structures, and never reads the switches.
switches. Similarly.
Similarly, if the
through
stub were:
HIADDRBUTTON = 1
the supervisor
supervisor program
program should stay in
hile HIADDRBUTTON = 1".. loop waita it­
In the "do while
ing for the button
button to be released.
simple runs check the overall logic.
released. These simple

Now we can expand each stub and see if the expansion produces a reasonable
straightforward and
overall result. Note how debugging and testing proceed in a straightforward
modular manner. We expand the HIADDRBUTTON
HIADDRBUTTON = 1 stub to:
READ
READ CPORT
CPORT
HIADDRBUTTON = NOT (CPORT)
HIADDRBUTTf)N
(CPORT) AND HAMASK
The program should waitit for the HIGH
button to be closed. The program
HIGH ADDRESS
ADDRESS button
display the values of the switches
switches on the lights. This run checks for the
should then display
proper response to the HIGH
HIGH ADDRESS
ADDRESS button.
We then expand the LOW ADDRESS
button module
module to:
ADDRESS button
READ
READ CPORT
CPORT
LOADDRBUTTON = NOT (CPORT)
LOADDRBUTTON
(CPORT) AND LAMASK
With
ith the LOW ADDRESS
button in the closed position.
position, the program should display
display the
ADDRESS button
switches on the lights. This run checks for the proper
proper response to the LOW
values of the switches
ADDRESS
ADDRESS button.
Similarly, we can expand the DATA button
button module and check for the proper
proper response
Similarly.
to that
that button.
button. The entire program
program will
ill then have
nave been tested.

When ail
When
all the stubs have been expanded, the coding,
coding. debugging, and testing
stages will
ill all be complete. Of course, we must know exactly
exactly what
at results each
stub should
However, many logical errors will
ill become obvious at each
should produce.
produce. However,
level w ithout
o u t any further
further expansion.
level

13-52

The
Terminal
The Transaction
Transaction Term
inal
This
This example,
example, of course, will
ill have more levels of detail. We
cou
Id start
program (see
(see Figure 13-19 for
could
start with
ith the
the following
ing program
aa flowchart):
flowchart):
KEYBOARD
KEYBOARD
ACK =00
=0
do
do while
hile ACK =
TRANSMIT
TRANSMIT
RECEIVE
RECEIVE
end
DISPLAY

TOP-DOWN
TOP-DOWN
DESIGN OF
VERIFICATION
TERMINAL
TERMINAL

Here KEYBOARD, TRANSMIT,
RECEIVE, and DISPLAY are program
program stubs that will
TRANSMIT, RECEIVE,
ten-digit verified
be expanded later. KEYBOARD,
KEYBOARD, for example.
example, could simµly
simply place a ten-digit
number
number into
into the appropriate
appropriate buffer.

Start

Kevboard

ACK =O

No

Transmit
Rece,ve

End

Figure 13-19. Initial
Flowchart for
Transaction Terminal
ln1t1alFlowchart
for Transaction
Terminal

13-53

Start

VER =O

No

End
Complete= 0

Yes

KEVIN

Verify

KEYDS

Figure 13-20. Flowchart
Flowchart for Expanded KEYBOARD
KEYBOARD Routine

The next
next stage of expansion could
could produce
produce the following pro­
program for KEYBOARD (see Figure
13-20):
Figure 13-20):
VER
VER =00
do while
hile VER
VER = 0
COMPLETE
COMPLETE= 0
do w hile COMPLETE
= 00
COMPLETE=
KEYIN
KEYIN
KEYDS
KEYDS
end
VERIFY
VERIFY
end
end

EXPANDING
EXPANDING
THE
KEYBOARD
KEYBOARD
ROUTINE

Here
Here VER
VER = 0 means
means that an
an entry has
has not been
been verified; COMPLETE
COMPLETE= 0 means
means that
the entry is incomplete. KEYIN
KEYIN and KEYDS
KEYDS are
are the keyboard input and
and display routines
respectively. VERIFY
VERIFY checks
checks the
the entry. A stub
stub for
for KEYIN
KEYIN would simply place a random
entry (from
(from a random number table
table or
or generator)
generator! into the buffer and set
set COMPLETE
COMPLETEto
to
1..

We would continue by similarly expanding, debugging,
TRANSMIT,
debugging, and testing TRANSMIT,
RECEIVE,
RECEIVE, and DISPLAY. Note that you
you should
should expand each
each program
program by one
one level
so
so that you
you do
do not perform
perform the integration of an
an entire program
program at any one
one time.
You must use
use your judgment in
in defining
defining levels. Too small
small a step wastes
wastes time,
wh
while too large
large a step gets you
you back to
to the
the problems
problems of system integration that
top-down design
design is
is supposed
supposed to
to solve.
solve.
13-54

REVIEW OF TO P-DOWN
W N DESIGN
Top-down design
design brings
brings discipline
discipline to the
the testing
testing and integration
integration stages
stages of propro­
Top-down
design. It provides
provides a system
atic method
method for
for expanding
expanding a flow
chart or probprob­
gram design.
systematic
flowchart
definition to the
the level
level required
required to
to actually
actually write
rite a program.
program. Together
Together with
ith
lem definition
structured programming,
programming, it forms
forms a complete
complete set
set of
of design
design techniques.
techniques.
structured
Like structured
structured programming,
programming, top-dow
design is not
not simple.
simple. The designer
designer must
must
Like
top-downn design
defined the
the problem
problem carefully
carefully and must
must work
ork system
atically through
through each
have defined
systematically
level. Here again the
the methodology
methodology may seem
seem tedious,
tedious, but
but the
the payoff
payoff can be subsub­
level.
stantial if you follow
llo w the
the rules.
rules.
stantial
recommend the
the follow
ing approach
approach to top-down
top-down
We recommend
following
design:
design:
1)
2)

FORMAT
FORMAT FOR
TOP-DOWN
TOP-DOWN
DESIGN

Start
ith aa basic
chart.
Start w
with
basic flow
flowchart.
Make the
the stubs
stubs as complete
complete and as separate
separate as possipossi­
Make
ble.
3) Define
Define precisely
precisely all the
the possible
possible outcomes
outcomes from
from each stub
stub and select
select a test set
set.
carefully and
systematically.
4) Check
Check each
each level
level carefully
and systematically.
5)
structured programming.
Use the
the structures
structures from
from structured
programming.
&) Use
6) Expand
much 1n
in one
one step
step
Expand each
each stub
stub by
by one
one level.
level. Do
Do not
not try
try to
to do
do too
too much
7)
atch carefully
carefully for
structures.
71 W
Watch
for common
common tasks
tasks and
and data
data structures.
8)

9)

Test and debug
debug after
after each stub
stub expansion.
expansion. Do not try to do an entire level at a
Test
time.
Be aware
aware of what
hat the hardware
hardware can do. Do not
not hesitate
hesitate to stop
stop and do a little
little
bottom-up design
design where
where that
that seems
seems necessary.
necessary.
bottom-up

1313-55

REVIEW OF PROBLEM
PROBLEM DEFINITION AND PROGRAM DESIGN
should note
note that
that wee have
have spent
spent an entire
entire chapter
chapter w ith
o u t mentioning
mentioning any
You should
ithout
specific microprocessor
microprocessor or assembly
assembly language,
language, and w ith
o u t writing
ritin g a single
single line
line of
specific
ithout
actual code.
code. Hopefully,
Hopefully, though,
though, you
you now
now know
know a lott more
more about
about the
the examples
examples than
than
actual
would have
have if wee had just
st asked you
you to write
rite the
the programs
programs at the
the start.
start.
you would
Although wee often
often think
think of
of the
the writing
ritin g of
of computer
computer instructions
instructions as a key
key part
part of
Although
softw
are development,
development, it is actually
actually one of
of the
the easiest
easiest stages.
stages.
software
have written
ritte n a fe
programs, coding
coding willill become
become simple.
simple. You willill soon
Once you have
feww programs,
the instruction
instruction set,
set, recognize
recognize which
which instructions
instructions are really
really useful,
useful, and
learn the
remember
remember the
the common
common sequences
sequences that
that make up the
the largest
largest part
part of most
most propro­
grams. You willill than
then find
find that
that many
many of the
the other
other stages
stages of softw
are development
development
grams.
software
remain difficult
ifficu lt and have
have few
w clear
clear rules.
rules.
remain
have suggested
suggested here soma
some ways
ays to systematize
systematize the
the important
important early
early stages.
stages. In
We have
the
the problem
problem definition
definition stage,
stage, you must
must define
define all the
the characteristics
characteristics of the
system -— its inputs,
inputs, outputs,
outputs, processing.
processing, timee and memory
memory constraints,
constraints, and error
error
system
handling.
handling. You must
must particularly
particularly consider
consider how
how the system
system willill interact
interact with
ith the
larger system
system of which
which it is a part,
part, and whether
hether that
that larger
larger system
system includes
includes
larger
electrical
electrical equipment,
equipment, mechanical
mechanical equipment,
equipment, or a human operator.
operator. You must
must start
start
this stage
stage to make the system
system easy to use and maintain.
maintain.
at this
In the
the program
program design
design stage,
stage, several
several techniques
techniques can help you to system
atically
systematically
specify
specify and document
document the logic
logic of your
your program.
program. Modular
Modular programming
programming forces
forces you
to divide
divide the total
total program
program into
into small,
small, distinct
distinct modules.
modules. Structured
Structured programming
programming
provides a system
atic way
ay of defining
defining the logic
logic of those
those modules,
modules, w h
ile top-down
top-down
provides
systematic
hile
design
systematic
design is a system
atic method
method for integrating
integrating and testing
testing them.
them. Of course,
course, no one
can compel
compel you to follow
llo w all
alt of these
these techniques;
techniques; they
they are, in fact,
fact, guidelines
guidelines more
than anything
anything else. But they
they do provide
provide a unified
unified approach
approach to design,
design, and you
should consider
consider them
them a basis on which
which to develop
develop your
your own
own approach.
approach.
should

13-56
13-

REFERENCES
1.
1.

Ballard,
"Designing Fail-Safe Microprocessor
Microprocessor Systems."
Systems," Electronics.
Electronics, January
Ballard. D.
D. R.,.. "Designing
4,
4. 1979, pp. 139-143.
Signature Analysis,"
Analysis," Hewlett-Packard
Hewlett-Packard Application
Application Note
"A Designer's Guide to Signature
222, Hewlett-Packard.
Hewlett-Packard, Inc., Palo Alto. CA,
CA. 1977.
1977.
Donn. E.
fficient and Effective
Effective M icrocom
puter Testing Re­
E. S.
S. and M. D.
D. Lippman. "Efficient
icrocomputer
Requires CarefulI Preplanning."
Preplanning," EDN,
97-107 (includes self-test
EON. February 20,
20. 1979,
1979. pp. 97-107
examples for 6502).
-Gordon,
"Hexadecimal Signatures
Signatures Identify
Identify Troublespots
Troublespots in
Gordon. G.
G. and H.
H. Nadig,
Nadig. "Hexadecimal
Microprocessor Systems."
Systems," Electronics.
Electronics. March 3,
Microprocessor
3. 1977,
1977. pp. 89-96.
Neil,
"Designing a Serviceman's
Serviceman's Needs into MicroprocessorMicroprocessorNeil. M. and R.
R. Goodner,
Goodner. "Designing
Based
Systems," Electronics. March 1,
Based Systems."
1. 1979,
1979. pp. 122-128.
Schweber,
"Software Signature
Signature Analysis
Analysis Identifies
Identifies and Checks
Schweber. W. and L.
L. Pearce.
Pearce. "Software
PROMs,"
November 5,
PROMs." EDN.
EON. November
5. 1978,
1978. pp.
pp. 79-81.
Srini,
"Fault Diagnosis of Microprocessor
Microprocessor Systems," Computer.
Computer, January
January 1977,
Srini. V,
V. P.,.. "Fault
pp.
pp. 60-65.

2.

For a brief discussion of human factors considerations.
considerations, see G. Morns.
Morris, "Make
'Make Your
ent Design Emphasize
ants," EDN.
October 20.
Next Instrum
Instrument
Emphasize User Needs and Wants."
EON. October
1978. pp. 100-105.

3.

D.
modular pro­
D. L.
L. Parnas (see
(see the references below) has been a leader in the area of modular
programming.
gramming.

4.

Collected by B.
Collected
B. W. Unger (see
(see reference below).
below).

5.

Formulated by D.
Formulated
D. L.
L. Parnas.
Parnas.

The follow
ing references provide
provide additional
additional information
information on problem definition
definition and pro­
following
program design:
Chapin,
N., Flowcharts.
Flowcharts, Auerbach.
Auerbach, Princeton.
Princeton, N.
Chapin. N.
N. J.,.. 1971.
Dalton,
icrocom puter Software
Software like Other Systems -— Systematically."
Systematically,"
Dalton. W. F.,.. "Design
"Design Microcomputer
Electronics, January 19,
Electronics.
19. 1978,
1978. pp.
pp. 97-101.
Dijkstra,
Discipline of Programming.
Programming, Prentice-Hall.
Prentice-Hall, Englewood Cliffs.
Cliffs, N.
Dijkstra. E.
E. W., A Discipline
N. J.,..
1976.
1976.
Halstead,
Software Science. American
American Elsevier,
Halstead. M. H.,.. Elements of Software
Elsevier. New York,
York. 1977.
1977.
Hughes,
ichtom, A Structured
Structured Approach
Approach to Programming.
Programming. Prentice-Hall.
Hughes. J.
J. K.
K. and J. I.I. Michtom.
Cliffs, N.
Englewood Cliffs.
N. J. 1977.
Morgan, D.
Taylor, "A Survey of Methods
Methods for Achieving
Achieving Reliable Software,"
Software,"
Morgan.
D. E.
E. and D.
D. J. Taylor.
Computer. February 1977,
Computer.
1977. pp. 44-52.
Myers,
"The Need for Software
Software Engineering."
Engineering," Computer.
puter. February 1978. pp.
Myers. W.,.. "The
pp. 12-25.
Parnas,
Decomposing Systems into Modules:·
Modules." ComCom­
Parnas. D.
D. L.,
L.. "On the Criteria to be Used in Decomposing
munications of
1053-1058.
munications
Qfthe ACM
ACM., December 1972,
1972. pp. 1053-1058.
-Parnas,
Technique for the Specification
Specification of Software
Software Modules
Modules with
ith Examples,"
Parnas. D.
D. L."A Technique
Examples."
Communications of
330-336.
Communications
Qfthe ACM., May 1973,
1973. pp. 330-336.
Phister,
Technology and Economics.
Economics, Santa Monica Publishing
Publishing
Phister. M. Jr.,.. Data Processing Technology
Monica, CA,
Co.,.. Santa Monica.
CA. 1976.
Schneider, V.,.. "Prediction
"Prediction of Software
Software Effort and Project Duration
Duration -— Four New For­
Schneider.
Formulas," SJGPLAN
Notices. June 1978,
mulas."
SIGPLAN Notices.
1978. pp. 49-59.

1 3-57
57

Shneiderman, B.
"Experimental Investigations
Investigations of the Utility
tility of Detailed FlowFlow­
Shneiderman.
B. et al.,
al.. "Experimental
Programming,” Communications
373-381.
charts in Programming."
Communications~ of the ACM,
ACM. June 1977,
1977. pp.
pp. 373-381.
Tausworthe, R.
Development of Computer
Computer Software. Prentice-Hall.
Tausworthe.
R. C.,.. Standardized Development
Cliffs, N.
Englewood Cliffs.
N. J.,.. 1977.
Unger,
ming Languages for Computer
Computer System Simulation."
ulation," Simulation.
Simulation,
Unger. B.
B. W., "Program
"Programming
April 1978,
April
1978. pp. 101-110.
Wirth.
irth, N.,.. Algorithm
s + Data Structures
Prentice-Hall, Englewood Cliffs,
Algorithms+
Structures== Programs,
Programs. Prentice-Hall.
Cliffs.
N.
N. J.„ 1976"
1976.
Wirth.
irth, N.,.. Systematic
Prentice-Hall, Englewood Cliffs.
Cliffs,
Systematic Programming;
Programming; an Introduction,
Introduction. Prentice-Hall.
N. J „.. 1973.
Yourdon, E.
Techniques of Program Structure
Structure and Design,
Prentice-Hall, Englewood
Yourdon.
E. U.,.. Techniques
Design. Prentice-Hall.
Cliffs, N.
Cliffs.
N. J.. 1975.

13-58
13-58

Chapter 14
DEBUGGING AND TESTING
As we noted at the beginning
beginning of the previous chapter.
chapter, debugging
debugging and testing are
e-consuming stages of software
software development.
development. Even though such
among the most time-consuming

top-down design
methods as modular programming, structured programming, and top-down
can simplify programs and reduce the frequency
frequency of errors,
errors. debugging and testing
still are d ifficult
u lt because they are so poorly defined. The selection of an adequate set
of test data is seldom a clear or scientific
scientific process.
Finding errors sometimes seems like a
process. Finding
game of "pin
in the tail on the donkey."
donkey,” except
except that the donkey is moving and the pro­
programmer must position
position the tail by remote control. Surely,
frustrating as
grammer
Surely. few tasks are as frustrating
debugging programs.
debugging
This chapter
chapter will
ill firstt describe the tools available to aid in debugging. It will
ill then
discuss
discuss basic debugging procedures, describe the common types of errors,
errors. and
present some examples
examples of program debugging. The last sections will
ill describe
present
how to select
st data and test
st programs.
select test
programs.
We will
ill not do much more than describe the purposes of most of the debugging
debugging tools.
tools.
There is very little
little standardization
standardization in this area,
area. and not enough space to discuss all the
devices and programs that
that are currently
currently available. The examples should give you some
idea of the uses,
advantages, and lim
itations of particular
uses. advantages.
llm11at1ons
particular hardware or software
software aids.

SIMPLE
PLE DEBUGGING TOOLS
simplest debugging tools available are:
The simplest
• A single-step
single-step facility
facility
< A breakpoint
breakpoint facility
facility
• A Register
Register Dump program (or utility)
• A Memory
Memory Dump program
SINGLEsingle-step fa c
ility allowss you to execute
execute the program one
The single-step
cility
STEP
step at a time. Most 6502-based
6502-based microcomputers
icrocomputers have this
facility, since the circuitry
circuitry is fairly simple. Of course,
facility.
course. the only
things that
that you will
ill be able to see when
when the computer
computer executes
executes a single-step
single-step are
states of the output
output lines that
that you are monitoring. The most important
portant lines are:
the states
are:
• Data Bus
• Address Bus
■ Control
Control Ii
lines
nes
• SYNC
(synchronization) and READ/WRITE
SYNC (synchronization)
READ/WRITE

(either in hardware
hardware or in software).
software), you will
ill be able to
If you monitor these lines (either
addresses, instructions.
instructions, and data as the program executes.
executes.
see the progression of addresses.
You will
ill be able to tellll what
h at kind of operations the CPU is performing. This inforinfor­
ill inform
inform you of such errors as incorrect
incorrect Jumpp instructions.
instructions, omitted
omitted or incorincor­
mation will
operation codes,
incorrect data values.
rect addresses,
addresses. erroneous operation
codes. or incorrect
values. However,
However. you can­
cancontents of registers and flags w ith
o u t some additional
additional debugging
debugging facility
facility
not see
see the contents
ithout
or a special sequence of instructions.
instructions. Many of the operations
operations of the program cannot be
checked in real time.

1 4-1

LIMITATIONS
that a single-step
single-step mode cannot
cannot help you
LIMITATIONS
There are many errors that
to find. These include
OF SINGLEinclude timing
ing errors and errors in the interrupt
interrupt
STEP MODE
DMA systems. Furthermore.
Furthermore, the single-step
single-step mode is very
or OMA
slow, typically
typically executing
executing a program
program at less than one millionth
illionth
slow.
single-step through
through one second of real processor
of the speed of the processor itself. To single-step
time would
would take more than ten days. The single-step
single-step mode is useful only to check the
short instruction
instruction sequences.
logic of short
sequences.

I

I

ill automatautomat| bre
AKPOINTJ
A breakpoint is a place at which the program will
BREAKPOINT
ically halt or wait
a it so thatt the user can examine the current
status of the system. The program will
ill usually not start
start again until the operator rere­
quests a resumption of execution.
execution. Breakpoints
Breakpoints allow you to check or pass through
through an
entire section of a program. Thus,
Thus. to see if an initialization
initialization routine
routine is correct.
correct, you can
place a breakpoint
breakpoint at the end of it and run the program. You can then check memory
locations and registers to see if the entire section is correct. However,
However. note that
that if the
section is not correct.
you'lll still
breakcorrect, you’
still have to pin down
down the error, either
either with
ith earlier break­
points or with
ith a single-step
single-step mode.
points
mode.

Breakpoints complement
complement the single-step mode. You can use breakpoints either
either to
localize the error or to pass through sections that
that you know are correct. You can
cases. breakpoints
mode. In some cases,
then do the detailed
detailed debugging in the single-step mode.
breakpoints
put/output
do not affect
affect program timing;
ing; they can then be used to check in p u
t/o u tp u t and interinter­
rupts.
BRK AS A
Breakpoints often use part or all of the microprocessor
microprocessor interrupt
interrupt
BREAKPOINT
system.
microprocessors have a special Software
Software Interrupt
Interrupt
system. Some microprocessors
or Trap facility
facility that can act as a breakpoint. The 6502 BRK
BRK (Force
(Force
Break)
instruction can be used in this way. If you are not already using the maskable in­
Break) instruction
in(NM!) in your system,
system. you can use those
terrupt
(!RO) and the non-maskable interrupt
terrupt (IRQ)
interrupt (NMI)
externally controlled
controlled breakpoints. Table 14-1
vectors as
as externally
14-1 gives the address locations of
the 6502 interrupt
interrupt vectors. Chapter
Chapter 12 describes the vectors in more detail. The break­
breakpoint
conpoint routine can print
print register and memory contents, or just
just waitit (by executing
executing a con­
dition
prodition jump dependent
dependent on a switch
switch input) u ntil
til the user allows the computer
computer to pro­
ceed. But remember
BRK)use the Stack and Stack Pointer
ceed.
remember that the interrupts
interrupts (including
(including BRK)
to store the return address and the Status Register.
Register. Figure 14-1
14-1 shows a routine in
BRK results in an endless loop.
loop. The programmer
breakwhich
hich BRK
programmer would
would have to clear this break­
ith a RESET
interrupt signal.
point with
RESETor interrupt
signal.
14-1. 6502 Interrupt
Table 14-1.
Interrupt Vectors

Input

Vector Addresses (Hexadecimal)
Vector

n
m
NMI

FFFA, FFFB
FFFB
FFFA,
FFFC, FFFD
FFFD
FFFC,
FFFE,FFFF
FFFF
FFFE,

RESET
RESET
IRQ
!RO or BRK
BRK

•=BREAK
*=BREAK
JMP
BREAK
BREAK

;ADDRESS FOR
FOR BREAK
BREAK ROUTINE
ROUTINE
;ADDRESS
;WAIT IN PLACE
PLACE

BREAKwhen it finds
The interrupt
interrupt service routine must force a jump to address BREAK
the Break
differentiates between BRK
Break Command flag set (this
(this differentiates
BRK and
and an
an IRQ
!RO input).
Figure 14-1,
14-1. A
A Simple
Simple Breakpoint
Figure
Breakpoint Routine

14-2
14-2

The simplest
simplest method
method for
for inserting
inserting breakpoints
breakpoints is
is to
to replace
replace the
the first
first byte
byte of
of the
the instrucinstruc­
The
tion w
ith aa BRK
instruction or to
to replace the instruction
instruction w
ith aa JMP
JMP or JSR instruction.
instruction.
tion
with
BRK instruction
with
The BRK
instruction is preferable
preferable since
since only
only a single
single byte
byte must
must be replaced
replaced and the
The
BRK instruction
breakpoint w
not overrun
overrun the
the subsequent
subsequent instructions.
instructions.
breakpoint
willill not
Many monitors
onitors have
have facilities
facilities for
for inserting
inserting and
and removing
removing
Many
INSERTING
INSERTING
breakpoints im
plemented via some type
type of Jum
instruction.
BREAKPOINTS
BREAKPOINTS
breakpoints
implemented
Jumpp instruction
breakpoints do not
not affect
affect the tim
ing of the program
program until
until
Such breakpoints
timing
breakpoint is executed.
executed. However.
However, note that
that this procedure
procedure will
ill not
not work
work ifif part
part or all
the breakpoint
of the program
program is in ROM or PROM.
PROM. Other
Other monitors
onitors implement
im plement breakpoints
breakpoints by actually
actually
checking the address lines or the Program Counter
Counter in
in hardware
hardware or in software. This
checking
method allows
allows breakpoints
breakpoints on addresses in ROM or PROM,
but it may affect
affect the timing
ing
method
PROM. but
must be checked in software. A more powerfu
powerful fac,hty
cility would
would allow
allow the
if the address must
user to enter
enter an address to which
hich the processor would
would transfer
Another
•ransfer control. Another
possibility would
would be a return dependent
dependent on a sw,tch
switch:
possibility

•=BRKPT
*=BRKPT
BIT
VIAORA
VIAORA
BPL
BRKPT
BRKPT
RTI
RTI

:ADDRESS
.ADDRESS FOR
FOR BREAKPOINT
BREAKPOINT ROUTINE
ROUTINE
:W
AIT FOR
;WAIT
FORSWITCH
SWITCH TO
TO CLOSE
CLOSE

control lines could also be used. Remember that
that RTI
auto­
Of course,
course. other VIA data or control
RTI automatically
atically restores the Status register and re-enables the interrupt
interrupt. If the interrupt
interrupt comes
from a VIA control
routine would
control line,
line. the routine
would also have to clear the corresponding
corresponding bit in the
Interrupt Flag register.
Interrupt
register.

14-3
14-3

tility on a microcomputer
microcomputer is a program that
that
A Register Dump utility
REGISTER
REGISTER
contents of all the CPU registers. This
This inform
ation is
information
DUMPS
lists the contents
DUMPS
usually not
not directly
directly obtainable.
obtainable. The following
ing routine will
ill print
usually
contents of all the registers on the system printer, if we
we assume
assume that
that PRTHEX
PRTHEX
the contents
prints the contents
contents of the
the Accum
ulator as twoo hexadecimal
hexadecimal digits.
digits. Figure
Figure 14-2
14-2 is a
prints
Accumulator
flow
chart of the program
program and Figure
Figure 14-3 shows
shows a typical
typical result. Wee assume
assume that
that the
flowchart
routine is entered
entered with
ith a JUMP
JUMP TO SUBROUTINE instruction
instruction that
that stores
stores the old Program
Program
routine
Counter at the
the top
top of the Stack. An
An interrupt
interrupt or BRK instruction
instruction willill store
store both
both the ProPro­
Counter
gram Counter
Counter and the
the Status
Status register
register at the top
top of the Stack.
gram

ALREADY ON STACK)
; PLACE ALL CPU REGISTER
REGISTER CONTENTS IN STACK (PC
(PC ALREADY
PHP
PHA
TXA
TXA
PHA
TYA
PHA
TSX
TXA
CLC
ADC
PHA

;SAVE STATUS IF NECESSARY (NOT AFTER
AFTER IRO)
ACCUMULATOR
;SAVE CONTENTS OF ACCUMULATOR
;SAVE INDEX REGISTER
;SAVE
REGISTER X
;SAVE INDEX REGISTER
REGISTER Y
;SAVE ORIGINAL STACK POINTER
POINTER

#6

;OFFSET
;OFFSET BACK TO ORIGINAL VALUE

; PRINT CONTENTS OF REGISTERS
REGISTERS
; ORDER
ORDER IS S,
S, Y,
Y. X, A, P,
P. PC(LOW),
PC(LOW). PC(HIGH)
PC(HIGH)

PRNT1
PRNT1

LDY
LOY
LDA
LOA
JSR
INX
DEY
BNE

#7
#7
$0100,X
$0100.X
PRTHEX
PRTHEX

NUMBER OF
;NUMBER
OF BYTES
BYTES== 7
;GET A BYTE FROM
FROM STACK
;AND PRINT
PRINT IT

PRNT1
PRNT1

; RESTORE
RESTORE REGISTERS
REGISTERS FROM STACK
PLA
PLA
TAY
PLA
TAX
PLA
PLP
PLP
RTS
RTS

;PULL
;PULLAND
AND DISCARD
DISCARDSTACK
STACKPOINTER
POINTER
iRESTORE
;RESTOREINDEX
INDEXREGISTER
REGISTERYY
;RESTORE
;RESTOREINDEX
INDEXREGISTER
REGISTERXX
;RESTORE
;RESTORECONTENTS
CONTENTSOF
OFACCUMULATOR
ACCUMULATOR
;RESTORE
:RESTORESTATUS
STATUS REGISTER
REGISTERIFIFNECESSARY
NECESSARY
;RESTORE
;RESTOREPC
PCAND
AND SP
SP

14
14-4

'
Stan

Store all registers
in Stack
Count = 7 (number
of bytes in registers)

Base - 0100 16
Index = Stack

Pointer+

1

Print (Base+tndex)
as 2 hexadecimal
digits

Index = Index + 1
Count = Count - 1

Restore all registers
from Stack

End

Figure 14-2. Flowchart
Flowchart of Register Dump Program

(S)
(Y)
(X)
(A)
(P)
(PCL)
(PCH)

A6

05
08
3E
24
15

A2

Figure 14-3. Results of a Typical 6502 Register Dump

1 4-5

A Memory
Memory Dump is a program that
that lists the contents
contents of memomemo­
MEMORY
MEMORY
ry on an output
output device (such as a printer). This is a much
much more
DUMP
DUMP
efficient way
way to examine
examine data arrays or entire programs
programs than just
just
efficient
looking at single
However. very large memory
single locations. However,
memory dumps
dumps are not useful
useful (except
information
to supply
supply scrap paper) because of the sheer mass of inform
ation that they produce.
They may also take a long time to execute on a slow printer. Small dumps may,
however, provide the programmer with
ith a reasonable amount
amount of information that
that
however.
can be examined
examined as a unit. Relationships such
such as regular repetitions
repetitions of data patpat­
terns or offsets of entire arrays may become obvious.
obvious.
ifficult
A general dump
dump is often rather
rather d iffic
u lt to write. The programmer
programmer should be careful
careful of
ing situations:
situations:
the follow
following
1)
that an 8-bit
-b it counter
counter will
ill not
11 The size of the memory area exceeds 256 bytes,
bytes. so that
suffice.
2)

The ending
ending location
location is an address smaller
smaller than the starting
starting location. This can be
treated as an error,
ply cause no output.
output, since the user would
would seldom want
want to
error. or simply
print the entire memory contents
contents in an unusual order.
print
order.

Memory Dumpp depends on the speed of the output
output device,
Since the speed of the Memory
device. the
efficiency of the routine seldom matters. The following program will
ill ignore
efficiency
ignore cases
where the starting address is larger than the ending address,
ill handle
where
address, and will
handle
blocks of any length. We assume that the starting
starting address is in memory addresses
addresses
START
START+1 and the ending
ending address is in memory addresses
START and START+l
addresses LAST and
LAST+l.
START and START+l
zero. so
LAST+1. We have assumed that addresses START
START+1 are on page zero,
tht their contents
contents can be used indirectly.
indirectly.
: PRINT
PRINT CONTENTS
CONTENTS OF
OF SPECIFIED
SPECIFIEDMEMORY
MEMORY LOCATIONS
LOCATIONS
DUMP
DUMP
DBYTE
DBYTE

DONE
DONE

LDY
LDY
LDA
CMP
CMP
LDA
SBC
SBC
BCC
BCC
LDA
JSR
JSR
INC
INC
BNE
BNE
INC
INC
JMP
RTS
RTS

#0
:11=0
LAST
LAST
START
START
LAST+1
START+1
START+1
DONE
DONE
(START).Y
(START).Y
PRTHEX
PRTHEX
START
START
DBYTE
DBYTE
START+1
START+1
DBYTE
DBYTE

;KEEP
:KEEP OFFSET
OFFSETAT ZERO
ZERO ALWAYS
;ARE WE BEYOND
BEYOND FINAL ADDRESS?
ADDRESS?
:ARE

:YES.
:YES. DUMP
DUMP COMPLETED
COMPLETED
;NO. GET
GET CONTENTS
CONTENTS OF
OF NEXT
NEXT LOCATION
LOCATION
;NO.
:PRINT CONTENTS
CONTENTS AS 2 HEX
HEX DIGITS
DIGITS
;PRINT
INCREMENT
:INCREMENT MEMORY
MEMORY POINTER
POINTER

is no direct
to perform the
the 16-bit
this routine
There is
direct way to
16-bit comparison and increment
increment that this
requires.
requires.

Figure
Figure 14-4 shows the output from
from a dump
dump of memory locations
locations 1000 to 101F.
23 1F
6E
6E 42
47 36
34 ED
ED

60
38
38
23
BC
BC

54
17
17
81
81
AF
AF

37 28
59 44
El FF
FF
E1
FE
FE FF
FF

3E
3E
98
FF
FF
27

00
37
37
5A
SA
02

Figure 14-4.
14-4. Results
Results of
of aa Typical Memory
Memory Dump
Dump
Figure

14-6
14

This routine
routine correctly
correctly handles the case in which
hich the starting
starting and ending
ending locations
locations are
the same (try it!}.
it!). You will
ill have to interpret
interpret the results carefully
carefully if the dum
in­
dumpp area includes the Stack, since the dump
PRTHEX may also
dump subroutine
subroutine itself
itself uses the Stack. PRTHEX
change memory
memory and Stack locations.
change
dump, the data can be displayed
displayed in a number
number of different
different ways. Common
In a memory dump.
forms are ASCII characters
hexcharacters or pairs of hexadecimal
hexadecimal digits
digits for 8-bit
-b it values and four
four hex­
adecimal digits
digits for 16-bit
16-bit values. The format
at should be chosen based on the intended
adecimal
use of the dump. It is almost
almost always easier to interpret
interpret an object
object code dump
dump if
it is
dis­
1f It
Is dishexadecimal form rather
rather than ASCII form.
played in hexadecimal
common and useful dump
dump format
at is illustrated
illustrated here:
A common
here:

1000

54 68 65 20 64 75 6D 70

dump
The dump

Each line consists of three parts. The line starts with
ith the hexadecimal
hexadecimal address of the
first byte displayed
displayed on the line. Following
Following the address are eight
eight or sixteen bytes disdis­
first
hexadecimal form. Last is the ASCII
representation of the same eight
eight or six­
played in hexadecimal
ASCII representation
sixbytes. Try rewriting
teen bytes.
riting the memory dump program so that it will
ill print
print the address and
the ASCII
characters as well
well as the hexadecimal
hexadecimal form of the memory contents.
ASCII characters

14
14-7

MORE A D VANCED
NC ED DEBUGGING TOOLS
The more advanced debugging tools that
that are most w idely
e ly used are:
• Simulator programs
programs to check program
program logic
logic
• Logic
Logic analyzers to check signals and timing
variations of both these tools exist, and we shall discuss only the standard
Many variations
features.
res.

SOFTWARE
computerized equivalent
equivalent of the pencil-andpencil-andThe simulator is the computerized
SIMULATOR
computer. It is a computer program
that goes through the
SIMULATOR
paper computer.
program that
operating cycle of another computer, keeping track of the concon­
course. do this
tents of ail
all the registers, flags, and memory locations. We could, of course,
by hand,
but it would
would require a large amount
amount of effort
effort and close attention
attention to the exact
hand. but
effects of each instruction.
instruction. The simulator
ulator program
program riever
confused, forgets
forgets
effects
never gets tired or confused.
an instruction
instruction or register,
register. or runs out of paper.
paper.
Most simulators
simulators are large FORTRAN
Most
FORTRAN programs. They can be purchased or used on the
time-sharing services. The 6502
6502 simulator
ulator is available in several versions from different
different
time-sharing
sources.
rces.

Typical simulator features
features are:
1)

A breakpoint facility. Usually, breakpoints
breakpoints can be set after
after a particular
particular number
number of
executed, when
when a memory
memory location
location or one of a set of memory
cycles have been executed.
locations is referenced.
referenced, when
when the contents
contents of a location
location or one of a set of locations
locations
are altered, or on other
other conditions.
conditions.
2) Register
loca­
Register and
andmemory
memory dump
dumpfacilities
facilities that
that can
can display
display the
the values
valuesofofmemory
memory locations,
tions. registers,
registers. and I/O
1/0 ports.
3) AA trace
cility that
ill print
loca­
trace fa
facility
that wwill
print the
the contents
contents of
of particular
particular registers
registers or
or memory
memory locations whenever
whenever the program
program changes or uses them.
4) AA load
cility that
load fa
facility
that allows
allows you
you to
to set
set values
values initially
initially or
or change
change them
them during
during the
the
simulation.
simulation.
Some simulators
ulators can also simulate
simulate input/output.
input/output, interrupts.
interrupts, and even OMA
DMA.

The simulator has many advantages:
1)
1)

provide a complete
complete description
description of the status of the computer.
computer, since the
It can provide
simulator
ulator program
program is not restricted
restricted by pin limitations
itations or other
other characteristics
characteristics of the
underlying circuitry.
circuitry.
underlying

2)

provide breakpoints.
breakpoints, dumps.
dumps, traces, and other
other facilities.
facilities, w ith
o u t using any of
It can provide
ithout
the processor’
control system. These facilities
facilities will
ill therefore
therefore not
processor'ss memory space or control
interfere with
ith the user program.
interfere

3) Programs,
Programs. starting
starting points,
points. and
and other
other conditions
conditions are
are easy
easy to
to change.
change.
4) AAll
ll the
the facilities
facilities of
of aa large
large computer,
computer. including
including peripherals
peripherals and
and software,
software. are
are availa­
available to the microprocessor
microprocessor designer.

On the other hand, the simulator is limited by its software
are base and its separation
from the real microcomputer. The major limitations are:
1)
1)

The simulator
ulator cannot
cannot help with
ith timing
ing problems.
problems, since it operates far more slowly
slowly
than real time and does not model actual
actual hardware or interfaces.

2) The simulator
ulator cannot
lly model the input/output
p u t/o u tp u t section.
21
cannot fully
3) The
ulator is
The sim
simulator
is usually
usually quite
quite slow.
slow. Reproducing
Reproducing one
one second
second of
of actual
actual processor
processor
time may require hours of computer
puter time. Using the simulator
ulator can be quite
quite expen­
expensive.
sive.

1 4-8

The simulator
advansimulator represents the software
are side of debugging; it has the typical advan­
tages
approach. The simulator can
can pro­
protages and limitations
itations of a w holly
olly software-based
software-based approach.
vide insight into program logic and other software
are problems, but cannot help with
timing.
problems.
timing, 1/0.
I/O, and other
other hardware problems.
The logic or microprocessor analyzer
LOGIC
LOGIC
analyzer is the hardware solution
to debugging. Basically, the analyzer
ANALYZER
analyzer is the parallel digital verver­
oscilloscope. The analyzer displays informasion of the standard oscilloscope.
informa­
tion in binary,
CRT. and has
has a variety
binary, hexadecimal
hexadecimal or mnemonic
mnemonic form on a CRT,
variety of triggering
triggering
events.
disevents, thresholds.
thresholds, and inputs. Most
Most analyzers also have a memory so that they can dis­
play
busses.
play the past contents
contents of the busses.
The standard
event. such as the occurrence of a particustandard procedure
procedure is to set a triggering
triggering event,
particu­
lar address on the Address
Bus. For example,
example. one might
Address Bus or instruction
instruction on the Data Bus.
ight
trigger
icrocomputer
extrigger the analyzer if the m icrocom
puter tries to store data in a particular
particular address or ex­
ecute
ecute an input
input or output
output instruction.
instruction. One may then look at the sequence of events that
preceded the breakpoint
breakpoint. Common problems you can find in this way
include short
ay include
noise spikes (or glitches), incorrect signal sequences, overlapping wave-forms,
wave-forms,
and other
errors. Of course,
course, a software
could not be
be
other timing or signaling errors.
are simulator could
could conveniently
used to diagnose those errors any more than a logic analyzer could
be used to find errors in program logic.
logic.

Logic analyzers vary in many respects. Some of these are:

IMPORTANT
IMPORTANT
FEATURES
FEATURES
LOGIC
OF LOGIC
ANALYZERS

1)

Number
Number of input
input lines. Att least 24 are necessary to monitor
monitor
an 8-bit
are
-b it Data Bus and a 16-bit
16-bit Address Bus
Bus. Still
till more are
necessary for
Infor control
control signals.
signals, clocks, and other important
portant in­
puts.
ts.

2)
3)
4)
5)

Am
ount of memory. Each previous state that is saved
ill occupy several
Amount
saved will
several bytes.
bytes.

6)
7)
8)
9)
10)
11)
12)

processors.
Maximum
aximum frequency.
frequency. It must be several MHz to handle the fastest processors.
inimum
M inim
um signal
signal width
id th (important
(important for catching
catching glitches).
number of triggering
triggering events allowed. Important
portant features are pre- and
Type and number
post-trigger delays: these allow
allow the user to display
post-trigger
display events occurring
occurring before or
after the trigger
trigger event.
after
Methods
ethods of connecting
connecting to the microcomputer.
microcomputer. This may require a rather complex
interface.
Number of display
display channels.
Number
hexadecimal or mnemonic
mnemonic displays.
Binary, hexadecimal
Display formats.
Display
Signal hold time requirements.
Signal
capacitance.
Probe capacitance.
Single or dual thresholds.
Single

Allll of these factors
factors are important
portant In
in comparing
comparing different
different logic and microprocessor
analyzers, since these instruments
instruments are new and unstandardized.
unstandardized. A tremendous
tremendous variety
analyzers.
products is already available
available and this variety
variety will
ill become even greater in the future.
of products

Logic analyzers, of course,
course. are necessary only for systems with complex timing.
timing.
Simple applications with
ith low-speed
low-speed peripherals have few
w hardware problems that
ith a standard oscilloscope.
a designer cannot handle with
oscilloscope.

14
14-9

DEBUGGING WITH
IT H CHECKLISTS
designer cannot
cannot possibly
possibly check an entire program
program by hand:
hand; however.
however, there are
The designer
certain trouble
trouble spots that
that the designer
designer can easily check. You can use system
atic hand
certain
systematic
checking to find a large number of errors w ith
o u t resorting to any debugging tools.
ithout
tools.

where to place the effort. The answer
answer is on
WHAT
The question is where
WHAT TO
points that
that can be handled with
ith either
either a yes-no anwer
anwer or with
ith
INCLUDE IN
etic calculation. Do not try to do complex
complex
CHECKLIST
a simple arithmetic
arithmetic, follow
follow all the flags,
conceivable case.
it
arithmetic.
flags. or try every conceivable
case. Lim
L1m1t
your
your hand checking
checking to matters
matters that can be settled easily. Leave the complex
complex problems
to be solved with
ith the aid of debugging
debugging tools. But proceed systematically:
systematically; build your
checklist.
checklist, and make sure that the program performs the basic operations
operations correctly.
The firs t step is to compare the flowchart
cha rt or other program documentation with
ith
code. Make sure that everything
the actual code.
everything that appears in one also appears in the
other. A simple checklist
checklist will
ill do the job. It is easy to completely
completely omit
omit a branch or a pro­
processing section.
Next
ext concentrate on the program
program loops.
loops. Make sure that all registers and memory
locations used inside the loops are initialized
1nit1altzedcorrectly. This is a common source of er­
errors;
checklist will
ill suffice.
rors: once again,
again. a simple checklist

Now
branch. Select a sample case that should produce a
Now look at each conditional branch.
branch and one that should not;
not: try both of them. Is the branch correct
correct or reversed? If
the branch involves checking
checking whether
hether a number
number is above or below a threshold,
threshold. try the
equality
1sconsistent
equality case
case. Does the correct
correct branch occur? Make sure that your choice is
consistent
with
ith the problem definition.
defin1t1on
Look at the loops
iterations by hand,
loops as a whole. Try the first and last iterations
hand. these are often
cases What
1terat1onsis
1szero;
zero: i.e.,.. there
troublesome special cases.
a t happens if the number of iterations
has no elements? Does the program fall through
Prois no data or the table has
through correctly?
correctly? Pro­
grams often will
ill perform one iteration
iteration unnecessarily,
decrement councoun­
unnecessarily. or.
or. even worse,
worse. decrement
ters past zero before checking
checking them.
them.

assume (hopefully)
(hopefully) that
Check off everything
everything down to the last statement.
statement. Don't assume
the first error is the only one
ill allow you to get
one in the program.
program. Hand checking will
debugging runs,
runs, since
since you will
rid of many simple
simple
the maximum benefit
benefit from debugging
ill get rid
errors
errors ahead of time.
A quick review of the hand checking
checking questions:

HAND
CHECKING
QUESTIONS

1)
1)

Is every element of the
the program design in the
the program (and
(and
vice versa
documentation purposes)?
versa for documentation
purposes)?

2)
2)

and memory locations used
used inside loops initialized before they
Are all registers and
are
are used?
used?

3)
3)

Are all conditional
conditional branches logically correct?

4)
4)

Do all
all loops
loops start and end properly?

5)
5)

Are equality
equality cases
cases handled
handled correctly?

6)
6)

Are trivial
trivial cases
cases handled correctly?

1414-10

LOOKING
ERRORS
LOOKING FOR ERRORS
COMMON
Of course, despite all these precautions (or if you skip over
COMMON
ERRORS
ERRORS
some of them).
them), programs often still don't
don't work. The designer
is left
ft with
ith the problem of how to find the mistakes. The hand
checklist
checklist provides a starting place if you didn't
didn't use it earlier; some of the errors
that you may not have eliminated
eliminated are:
that
1)
initialize variables
variables such
such as
as counters,
counters, pointers,
pointers, sums,
sums, indexes,
indexes, etc.
etc.
1) Failure
Failure to
to initialize
registers. memory locations.
Do not assume that the registers,
locations, or flags necessarily contain
zero before they are used.
used.
Inverting the
2) Inverting
the logic
logic of
of aa conditional
conditional jump,
jump, such
such as
as using
using Branch
Branch on
on Carry
Carry Set
Set
when
when you mean
mean Branch
Branch on
on Carry
Carry Clear
Clear. Be
Be particularly
particularly careful
careful of
of the
the fact
fact that
that the
the
borrow
6502 (unlike most other microprocessors) uses the Carry as an inverted borrow
after a subtraction
subtraction or comparison. So the effects of a comparison
comparison or subtraction
subtraction are
alter
as follows
follows (A is the contents
contents of the Accum
ulator, M the contents
contents of the memory
Accumulator.
location):
Zero flag = 1 if A = M
11A £
I=M
M
Zero flag = 00 if
L M
1f A >
Carry flag = 1 if
Carry flag = 0 iiif A <
<M
easel So Branch on Carry
Note particularly
particularly that Carry== 1 if11A== M (the equa
equality case)
p if A ?
> Mand
and Branch on Carry Clear means jum
p if11A <
Set means jum
Jump
Jump
< M. If you
want
ant the equality
equality case on the other
other side,
either reversing the roles of A and Mor
or
side. try either
adding
M. For example,
example. if,I you want
Jump
L 10 use
adding 1 to M.
ant a jum
p if11A >
CMP
BCS
BCS

#100
ADDR

If,
ant a jum
p if A >
If. on the other hand,
hand. you want
Jump
> 10 use
CMP
BCS
BCS

#11
ADDR

3)

Updating counters, pointers, and indexes in the wrong place or not at all. Be
sure that there are no paths through
through a loop that either
either skip or repeat the updating
updating
instructions.
instructions.

4)

Failure totofall
fallthrough
throughcorrectly
correctlyinintrivial
trivia lcases
casessuch
suchas
as no
no data in
in aa buffer,
no
buffer. no
tests to beberun.
run,or no entries in a transaction. Do not assume
that such
assume that
such cases
cases will
never occur unless the program specifically
specifically eliminates
eliminates them.

Other problems to watch
atch for are:
Other
5)

6)

Reversing the order of operands.
instructions like TAX move the
operands. Remember that instructions
contents
contents of A to X. not the other way around.
Changing condition flags before you use them.
Almost
ost all instructions
instructions except stores and branches affect
affect the Sign and Zero flags.
Note especially
especially that PLP
PLP and RTI
RTI may change all the flags.
flags.

7)

Confusing the Index
Index registers and the indexed memory location.
Note that INX and INY increment
increment the Index registers while
hile INC ADDR.X and other
similar
similar instructions
instructions increment
increment the contents
contents of an indexed memory
memory location.

8)
B)

Confusing data and addresses.
Remember that LDA # $
4 0 loads A with
ith the number
number 4015.
40-)g. w hile
ile LDA $40 loads A
$40
with
ith the contents
contents of memory location
location 004015.
0040-]g. Be particularly
particularly careful when using
the pre-indexed
pre-indexed and post-indexed
post-indexed addressing modes in which
which a pair of addresses
on page zero contains
contains the actual or base address of the data.
data.

1 4 -11

9)

Accidentally
Accidentallyreinitializing
reinitializingaaregister
registerorormemory
memorylocation.
location.
Jumpp instructions
initial1zat1on stateMake sure that
that no Jum
instructions transfer
transfer control
control back to initialization
state­
ments.

10)

Confusing numbers and characters.
representations of digits
digits differ
differ from the
Remember that the ASCII and EBCDIC
EBCDIC representations
digits themselves. For example.
example, ASCII 7 is
iq , whereas hex 0715
07-|g is
digits
Is 3 7
715.
Is the ASCII
ASCII
BELL
BELL character.

11)
11)

Confusing binary and decimal
decimal numbers.
Remember that
that the BCD representation
representation of a number
number differs
differs from its binary
binary repre­
representation. For example. BCD
BCD 36.
36, when treated as a simple hexadecimal
hexadecimal constant.
constant,
is equivalent
equivalent to 54 decimal
decimal (try it).
itl.

12)
12)

13)
13)

Reversing the order in subtraction. Be careful also with
ith other
other operations (like
division) that
that do not commute. Remember that SBC,
SBC. CMP,
CMP. CPX,
CPX. and CPY
CPY all
subtract
subtract the contents
contents of the addressed memory location
location from the contents
contents of the
Accum
ulator or Index register
register.
Accumulator
Ignoring the effects
effects of subroutines and macros.
macros.
Don't
on't assume that calls to subroutines
subroutines or invocations
invocations of macros will
ill not change
flags. registers,
registers. or memory locations. Be sure of exactly
flags,
exactly what
hat effects subroutines
subroutines
have. Note that it11is
Is very important
or macros have.
portant to document
document these effects so that
the user can determine
determine them w ith
o u t going through
through the entire listing.
ithout

14)
14)

Using the Shift
hift instructions improperly.
ASL. LSR.
LSR. ROL,
ROL. and ROR.
ROR They are 1-bit
Remember the precise effects of ASL,
1-bit shifts
affect the Carry,
empty bit;
that affect
Carry. Sign,
Sign. and Zero flags.
flags. ASL and LSR
LSR both clear the empty
ROR and ROL
ROL are circular
register.
ROR
circular shifts that include
include the Carry in the circular
circular register.
Remember that the Carry,
instruc­
Carry. Sign,
Sign. and Zero flags are affected even if these instructions are applied to the data in a memory location.

15)
15)

Counting the length of an array incorrectly.
addresses
Remember that there are five (not four) memory locations included
included in addresses
0300 through
through 0304,
0304. inclusive.

16)
16)

Confusing
16-bit quantities.
Confusing 8- and 16-bit
long. The only 6502 register that
that can hold a com­
comAddresses are actually
actually 16 bits long.
plete address is
Is the Program Counter.

17)
17)

Forgetting that addresses or 16-bit
16-bit data occupy two memory locations.
locations.
Absolute
addresses occupy tw
two memory locations,
locations. as
as
Absolute direct
direct or absolute indexed addresses
do the
post-indexing or pre-in­
the addresses
addresses that are
are stored on page zero
zero for
for use in post-indexing
pre-inis
dexing. The Program Counter also occupies two memory locations when it is
stored in
post-indexed addressing
In the
the Stack.
Stack. Note that in
In the pre-indexed and post-indexed
modes. tw
two memory locations are
are used
used even
even though only one
one is
Is specified. The ad­
admodes,
dress
immediately follow
ing the
dress immediately
following
the one
one specified is
is also needed
needed to
to hold the
the indirect
address.
address.
JMP indirect
not work
work properly
properly if1f the
the indirect
crosses aa page
page
JMP
indirect will not
indirect address crosses
boundary. See
See the
the discussion of indirect
indirect addressing in Chapter 33 for
for a description
of this
this peculiarity.
peculiarity.

18)
18) Confusing
Confusing the Stack and the Stack Pointer.
Pointer.
The
instruction TXS
contents of the
The instruction
TXS affects the
the Stack Pointer,
Pointer. not
not the
the contents
the Stack.
Stack. PHA,
PHA,
PLA,
PLA. PHP,
PHP. and
and PLP
PLP transfer
transfer data to
to or
or from
from the
the Stack.
Stack. Remember that
that JSR.
JSR. RTS.
RTS.
RTI.and
and BRK
BAK also use
use the
the Stack.
Stack. Remember also
also that
that you
you must initialize
initialize the
the Stack
Stack
RTI,
Pointer before calling any subroutines
subroutines or allowing
allowing any interrupts.
interrupts. The
The 6502
6502 Stack
Stack
Is always
always on
on page one;
one; only
only the
the eight least
least significant
bits of
of the
the Stack
Stack address
address are
are
is
significant bits
actually in
in the
the Stack
Stack Pointer.
Pointer.

14-12
14-

19)
19)

Changing a register
register or memory location before using
using it.
Remember that LDA. STA,
STA. LDX,
LDX. STX,
STX. LDY,
LOY. STY,
STY. TAX. TXA,
TXA. etc. all change the
contents of the destination
destination (but not the source).
contents
source).

20) Forgetting
Forgetting to
to transfer
transfer control
controlpast
pastsections
sections of
ofthe
the program
programthat
that should
shouldnot
notbe
be

executed in particular situations.
executed
puter will
ill proceed sequentially
sequentially through
through the program
Remember that the computer
specifically ordered not to do so.
memory unless specifically
so.
21)

that the Carry is always
always included in addition and subtraction
Forgetting that
operations.
The 6502
6502 only has Add-with-Carry
Add-with-Carry and Subtract-w
ith Borrow instructions.
instructions, unlike
Subtract-with
many other
other processors which
hich have regular
regular Add and Subtract
Subtract instructions
instructions that do
include the Carry. The Carry must be explicitly
explicitly cleared before an addition
addition and
not include
set before a subtraction
subtraction if its
affect the operation. Note,
,ts value is
Is not to affect
Note. however,
however.
the comparison
comparison instructions
instructions (CMP,
include the Carry
Carry.
(CMP. CPX.
CPX. CPY)
CPY) do not include

22) Inverting
Inverting the
the significance
significance of
of the
the Carry
Carry ininsubtraction.
subtraction.
In subtraction
subtraction and comparison
comparison InstructIons.
instructions, the resulting
resulting Carry is
bor­
,s an inverted borrow
w -— that is,
Accordingly, the subtractsubtractis. the Carry is set if
11no borrow is required. Accordingly
with-Borrow
ith-Borrow instruction
instruction subtracts
subtracts the inverted Carry (1 —
Carry) along with
ith the
-Carry)
contents of the specified
specified memory location.
contents
23) Using
Usingthe
the decimal
decimal mode
mode improperly.
improperly.
When
hen the Decimal Mode flag is
etic results are decimal.
decimal, thus the
ts set. all arithm
artthmettc
flag must be explicitly
explicitly cleared after the decimal
decimal operations
operations are completed:
completed; otherother­
wise it will
ill change the results of operations
operations which
hich were not intended
intended to be
include a Set Decimal Mode instruction
instruction must also
decimal. Note that all paths that include
include a Clear Decimal Mode instruction:
instruction; be particularly
particularly careful of fall-through
fall-through
include
cases
cases and error exits.
24) Using
Using the
the Bit
Bit Test
Test instruction
instruction improperly.
improperly.
Note that
that the BitT e
instruction sets the sign and overflow
overflow flags according
according to bits
Test instruction
7 and 6 of the tested memory location,
o u t regard to the contents
contents of the AcAc­
location. w ith
ithout
cumulator. This instruction
instruction is convenient
convenient fortes-ting
testing status bits in 6520 PIAs and
cumulator.
for other
other bit checking
checking operations.
operations, but it requires careful documentation
documentation since its
unclear to a reader.
results are often unclear
reader.

Interrupt-driven programs
programs are particularly d ifficultlt to debug,
DEBUGGING
Interrupt-driven
since errors may occur randomly.
INTERRUPTIf. for example,
example. the program
randomly. If,
DRIVEN
enables the interrupts
interrupts a few instructions
instructions too early,
ill oc­
early. an error will
ocPROGRAMS
interrupt is received while
hile the program is executing
executing
cur only if an interrupt
those few instructions.
instructions In fact
ran­
fact you can usually assume that randomly occurring
system.2 Typical errors in interoccurring errors are caused by the interrupt system.2
rupt-driven programs
programs are;
are:
1)
1)

after accepting one and servicing it.
Forgetting to re-enable interrupts after
it.
The processor disables the interrupt
interrupt system automatically
atically on RESET
accept­
RESETor on accepting an interrupt.
interrupt. Be sure that no possible sequences fail to re-enable the interrupt
interrupt
system. Remember that,
addition to re-enabling
re-enabling interrupts.
interrupts, the program often
that. in addition
has to perform some action
action to cause the interrupting
interrupting signal to be reset.
reset. If this is not
done,
ill appear as if the interrupting
interrupting device is constantly
constantly requesting
requesting service.
done. it will
service.

2)

Using the Accumulator
Accumulator before saving it; i.e.,.. PHA must precede any operations
that change
change the Accumulator.
Accumulator.
that

3)

Forgetting to save and restore the Accumulator.

1 4 -13
3

4)
4)

Restoring
Restoring registers
registers in the wrong
wrong order.
IfIf the order
order in which
hich they were
were saved was:
PHA
TXA
TXA
PHA
TYA
PHA

:SAVE ACCUMULATOR
ACCUMULATOR CONTENTS
CONTENTS
;SAVE
:SAVE INDEX
INDEX REGISTER
REGISTERXX
;SAVE
:SAVE INDEX
INDEX REGISTER
REGISTERYY
;SAVE

the order
order of restoration
restoration should be:
PLA
TAY
PLA
TAX
PLA

:RESTOREINDEX
INDEX REGISTER
REGISTERYY
;RESTORE
:RESTOREINDEX
INDEX REGISTER
REGISTERXX
:RESTORE
:RESTOREACCUMULATOR
ACCUMULATOR CONTENTS
CONTENTS
: RESTORE

5)

as
Enabling interrupts
interrupts before establishing
establishing all the necessary conditions such as
priority.
etc.
priority, flags. PIA and VIA configurations.
configurations, pointers.
pointers, counters.
counters, etc.
A checklist
here.
checklist can aid here.

6))

Leaving results in registers and destroying them in the restoration process.
process.
As noted earlier,
earlier. registers should not be used to pass information
proation between the pro­
gram and the interrupt
interrupt service routines.

7/
7)

Forgetting that
that the interrupts
interrupts (including BRK)
Forgetting
BRKI leave the old Program
Program Counter
Status Register
Register in the Stack
Stack whether
whether you use them or not.
and Status
not.
re-initialize or update
update the Stack Pointer.
You may have to re-initialize

8)

Ignoring the possibility
the
possibility that
that the service routine may be entered with the
Decimal Mode
Mode flag set.
Decimal
You may have to include
CLO instruction
this possibility
include a CLD
instruction in the service routine if this
possibility
exists. Note that
that RTI
ill autom
atically restore the original
original state of the flag
RTI will
automatically
flag at the
the
end of the service routine.

9)

Not disabling the interrupt
interrupt during
ord transfers or instruction se­
Not
during m ulti-word
sequences.
Watch
atch particularly
particularly for situations
situations where the interrupt
interrupt service routine may
may use
use the
the
same memory locations that the program is
is using.
using.

Hopefully, these lists will
ill at least give you some ideas as to where to look
Hopefully,
look for er­
errors.
Unfortunately, even the most systematic
atic debugging can
rors. Unfortunately,
can sstill leave
leave some
some
when interrupts are involved.^
truly puzzling problems, particularly when
involved.3

1414-144

Start

Data = (0040)

Yes

Result = (SSEG
+ Data)

Result= 0

(0041 ) = Result

End

Flowchart of Decimal to Seven-Segment
Seven-Segment Conversion
Figure 14-5. Flowchart

Debugging Example 1:: Decimal to Seven-Segm
ent Conversion
Seven-Segment
The program converts
converts a decimal
decimal number in memory location
0040 to a seven-segment
seven-segment code in memory location 0041. It
0040
blanks the display
display if memory location
location 0040 does not contain
contain a
decimal number.
decimal

DEBUGGING
A CODE
CONVERSION
CONVERSION
PROGRAM

Initial Program (from flowchart
chart in Figure 14-5):
Initial

DONE
DONE
SSEG
SSEG

LDX
LOX
CPX
CPX
BCC
BCC
LDA
LOA
STX
BRK
BRK
.BYTE
.BYTE
BYTE
.BYTE

#$
40
$40
#99
DONE
DONE
(SSEG.X)
(SSEG.X)
$41

;GET
:GET DATA
:IS DATA GREATER
;IS
GREATERTHAN 9!r
;YES,
;YES. DONE
DONE
:GET
;GET ELEMENT
ELEMENT FROM
FROM TABLE
;SAVE
:SAVE SEVEN-SEGMENT
SEVEN-SEGMENTCODE
CODE

$3F,$06,$5B,$4F,$66
$3F.$06.$5B.$4F.$66
$6D,$7D,$07,$7D,$6F
$6D,$7D,$07,$7D.$6F

checklist procedure.
procedure, we were able to find
find the following
following errors:
Using the checklist
1)
1)
2)

that cleared Result had been omitted.
The block that
Conditional Branch was incorrect.
The Conditional

example, if the data is zero,
borrow is
< 9 and a borrow
For example.
zero. CPX #99 clears the Carry,
Carry. since 0
O<
utilizing the inverted
inverted condition
condition (i.e.,.. BCS DONE)
still did
required. However, the Jum
Jumpp utilizing
DONE) still
produce the correct
correct result. Now the program
program handles the equality
equality case incorrectly
incorrectly
not produce
since,
jump. The correct
correct version is:
since. if the data is 9,
9. CPX #99 sets the Carry and causes a jump.
CPX
BCS

#1
#10
DONE
DONE

;IS
;IS DATA
DATA AA DECIMAL
DECIMAL DIGIT?
DIGIT?
;NO.
:NO. KEEP
KEEPERROR
ERRORCODE
CODE
1 4 -15

Second Program:

DONE
DONE
SSEG
SSEG

;GET
:GET BLANK CODE
CODE FOR
FOR DISPLAY
DISPLAY
:GET
;GET DATA
:IS DATA A DECIMAL DIGIT?
DIGIT?
;NO. KEEP
KEEP ERROR
ERRORCODE
CODE
;GET
;GET ELEMENT
ELEMENT FROM
FROM TABLE
;SAVE SEVEN-SEGMENT
SEVEN-SEGMENT CODE
CODE OR
OR ERROR
: CODE
CODE

LDA
LOA
LDX
LOX
CPX
BCS
BCS
LDA
LOA
STX

#00
#$40
$40
#10
10
DONE
DONE
(SSEG.X)
(SSEG.X)
$41

BRK
BRK
.BYTE
.BYTE
.BYTE
.BYTE

$3F.$06,$5B.$4F.$66
$3F.$06.$5B.$4F.$66
$6D,$7D,$07,$7D,$6F
$6D.$7D.$07.$7D.$6F

successfully.
This version was hand checked successfully.
program was simple.
simple, the next stage was to single-step
single-step through
through it w
ith real
real
Since the program
with
data. The data selected for the trials was:
0
9
10
6B-|6
6815

(the smallest
smallest number)
number)
(the
(the
largest
number)
(the
largest
number)
(a boundary
boundary case)
(a
case)
(a randomly
randomly selected
selected case)
(a
case)

ith zero in location
location 0040.
0040. The first
The first trial was wwith
firsterror
errorwas
wasobvious
obvious—- LD X#$40
LDX#$40
loaded the number
number 40
40 into
into X. not the contents
contents of memory
The correct
correct
memory location
location 0040.
0040. The
instruction was LDX
immediate addressing). After
After this
instruction
LOX $40 (direct rather than immediate
correction
ith no apparent
until it tried to
correction was made,
made. the program moved along with
apparent errors until
execute the LDA
instruction.
execute
LOA (SSEG.X)
(SSEG.X) instruction.
The contents
contents of the Address Bus during
during the data fetch was 063F,
that was
063F. an address that
something had gone wrong.
not even being used. Clearly, something
It was now time for some more hand-checking.
hand-checking. Since we knew that
that BCS
BCSDONE
DONEwas corcor­
rect. the error was clearly in the LDA
instruction. A hand check showed:
LOA instruction.
LDA (SSEG.X)
contents of Index Register X to the page-zero address SSEG
LOA
(SSEG.X)adds the contents
SSEG and
uses the sum to fetch the address that
that contains
contains the actual
actual data. In the present
present case,
case.
contains zero,
indirect address is in memory
memory locations
locations SSEG
since Register X contains
zero. the indirect
SSEG and
SSEG+1
that is,
instruction is therefore
therefore getting
getting an address from a
SSEG+1 -— that
is. it is 063F. The instruction
that consists
consists of data. The correct
correct instruction
instruction is LDA
ant to get
table that
LOA SSEG.X
SSEG.X —
-wewe want
data from the table,
table. not the address of the data.
Even with
ith this correction.
correction, the program still
still produced
produced a result of zero,
zero. rather than the
expected 3F.
obviously in the last instruction
instruction -— it should be STA $41,
expected
3F. The error was obviously
$41.
portance of follow
ing through
through to the very end of the program.
program,
not STX $41. Note the importance
following
ittin g after
after what
hat might
ight seem to be the last error.
rather than q uitting
error.
The revised program
program now was:

Third Program:

DONE
DONE
SSEG
SSEG

LDA
LOA
LDX
LOX
CPX
CPX
BCS
BCS
LDA
LOA
STA

#0
$40
#100
DONE
DONE
SSEG.X
SSEG.X
$41

BRK
BRK
.BYTE
.BYTE
.BYTE
.BYTE

$3F.$06,$5B,$4F,$66
$3F,$06,$5B.$4F.$66
$6D,$7D,$07,$7D,$6F
$6D,$7D,$07.$7D.$6F

GET ERROR
;GET
ERRORCODE
CODE FOR
FOR DISPLAY
GET DATA
;GET
;IS DATA A DECIMAL DIGIT?
DIGIT?
:NO.
KEEP ERROR
ERROR.CODE
NO, KEEP
CODE
GET ELEMENT
:GET
ELEMENT FROM
FROM TABLE
:SAVE SEVEN-SEGMENT
SEVEN-SEGMENT CODE
CODE OR ER
ERROR
ROR CODE
CODE

1 4 -16
6

The results
results now
now were:
were:
The

Data
00
00
09
0A
OA
6B

Result
3F
3F
6F
6F
6F
6F

program was
was not
not clearing
clearing the result
result if the
the data was
was invalid.
invalid, i.e.,
greater than 9. The
The program
.. greater
program never
never stored the blank
blank code since the destination
destination address DONE was
program
misplaced
should have been attached
attached to the STA $41 instruction.
instruction. After
fter these corcor­
misplaced- — it should
rections were
were made.
made, the
the program
program produced
produced the correct
correct results
results for
for all the test cases.
rections
cases.
Since the
the program
program was simple.
simple, it could
could be tested for
for all the decimal
decimal digits.
digits. The results
Since
were:
Data
0
1
2
3
4
5
6
7
8
9

Result
3F
06
5B
4F
66
6D
7D
07
7D
6F

Note that
that the result
result for number
number 8 is
wrong -— itIt should be 7F.
everything else is
Is wrong
7F. Since everything
correct,
almost surely in
in the table. In fact,
entry 8 in the table had been
fact. entry
correct. the error is almost
miscopied.

The final program
program is:
is:
; DECIMAL TO SEVEN-SEGMENT
SEVEN-SEGMENT CONVERSION
CONVERSION
LDA
LDX
LDX
CPX
CPX
BCS
BCS
LDA
LDA

#0
$40
# 100
DONE
DONE
SSEG.X
SSEG.X

DONE
DONE

STA

$41
$41

SSEG
SSEG

BRK
BRK
.BYTE
.BYTE
.BYTE
.BYTE

$3F,$06,$5B,$4F,$66
$3F,$06,$5B,$4F.$66
$6D,
$7D,$07,$7F,$6F
$6D. $7D.$07.$7F,$6F

GET BLANK CODE
:GET
CODE FOR
FOR DISPLAY
DISPLAY
GET DATA
;GET
;IS DATA
DATA A DECIMAL DIGIT?
DIGIT?
:NO.
KEEPERROR
ERRORCODE
CODE
NO. KEEP
GET
:GET SEVEN-SEGMENT
SEVEN-SEGMENT CODE
CODE FROM
FROM
TABLE
TABLE
SAVE SEVEN-SEGMENT
:SAVE
SEVEN-SEGMENTCODE
CODE OR
OR
; ERROR
ERRORCODE
CODE

1414-17

encountered in this
this program
program are typical
typical of the ones that 6502
6502 assembly
The errors encountered
programmers should
should anticipate.
anticipate. They include:
include:
language programmers
1)
1) Failing
Failing to
to initialize
initialize registers
registers or
or memory
memory locations.
locations.
2) Inverting
Inverting the
the logic
logic on
on conditional
conditional branches.
branches.
3) Branching
hich the
Branching incorrectly
incorrectly in
in the
the case
case in
in wwhich
the operands
operands are
are equal.
equal.
4) Confusing
mediate and
Confusing im
immediate
and direct
direct addressing,
addressing. i.e..
i.e. data
data and
and addresses.
addresses.
5) Failing
Failing to
to keep
keep track
track of
of the
the current
current contents
contents of
of registers.
registers.
6) Branching
Branching to
to the
the wrong
wrong place
place so
so that
that one
one path
path through
through the
the program
program isis incorrect.
incorrect.
7) Copying
Copying lists
lists of
of numbers
numbers (or
(or instructions)
instructions) incorrectly.
incorrectly.
8)
B) Using
Using the
the indirect
indirect addressing
addressing modes
modes incorrectly.
incorrectly.
Note that straightforward
straightforward instructions
instructions (like AND.
AND, DEC.
simple addressing
DEC. INC)
INC) and simple
modes seldom cause any problems. Among
Among the particularly
particularly annoying
annoying errors that are
frequent in 6502 assembly language programming
programming are using the Carry improperly
properly after
frequent
subtraction or comparison
comparison (the Carry is set if no borrow is required)
required) and forgetting
forgetting to
subtraction
clear the Decimal Mode flag.

1414-18

Debugging
Debugging Example 2: Sort into Decreasing Order
The program sorts an array of unsigned
unsigned 8-bit
-b it binary numbers
numbers into
decreasing order.
order. The array begins in memory location
location 0041 and
its length is in memory location
location 0040.

DEBUGGING
DEBUGGING
A SORT
PROGRAM
PROGRAM

Initial
flowchart
14-6).
Initial Program (from flow
chart in Figure 14-6):

PASS
PASS

COUNT
COUNT

LDY
LOY
LDX
LOX
LDA
LOA
CMP
sec
BCC
STA
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
BRK
BRK

#00
$40
$41,X
$41,X
$42,X
$42,X
COUNT
COUNT
$42.X
$42,X

CLEAR INTERCHANGE
:CLEAR
INTERCHANGE FLAG
FLAG BEFORE
BEFOREPASS
PASS
GET LENGTH
:GET
LENGTH OF
OF ARRAY
NEXT PAIR
PAIR OF
OF ELEME
:IS NEXT
ELEMENTS IN ORDER?
ORDER?

:YES,
GE NECESSARY
YES, NO INTERCHA
INTERCHANGE
ECESSARY
:NO,
GE PAIR
PA1R
NO, INTERCHA
INTERCHANGE
,CHECK FOR
FOR COMPLETED
COMPLE-ED PASS
PASS
;CHECK

PASS
PASS
PASS
PASS

.WERE ALL ELEME
ORDER7
;WERE
ELEMENTS lIN ORDER?
;NO, MAKE ANOTHER
ANOTHER PASS
;NO.

The hand check shows that all the blocks in
chart have been implemented
implemented in
In the flowchart
In
init1al1zed The cond
t,onal branches
the program and that
that all the registers have been initialized.
conditional
must be examined carefully. The instruction
BCC COUNT must 'orce
1f the
instruction BCC
force a branch
branch if
value in A is greater than or equal to the next element
element in the array
array. Remember that we
are sorting
sorting elements into decreasing order and we are mov•ng
oving backward
backward through
through the
array in the usual 6502 manner. The equal
equality case must
ust not result in an interchange,
since such an interchange
interchange would
ould create an endless loop, with
ith the two equal elements
always being swapped.
Try an example:
(0041) = 30
(0042) = 37

37, The Carry is cleared since a borrow is
CMP $42,X
$42,X results in the calculation
calculation of 30 - 37.
required. This example should result in an interchange
interchange but
but does not.
BCS
ill provide the proper branch in this case.
BCS COUNT
COUNT will
case. If the two numbers are equal,
equal.
BCS COUNT
COUNT is again correct.
the comparison
comparison will
ill set the Carry and BCS

BNE PASS
PASS at the end of the program?7 If there are any elements
order.
How about BNE
elements out of order,
the interchange
interchange flag will
ill be one, so the branch is wrong.
wrong. It should be BEQ
SEO PASS.
PASS.
Now let's hand check the first
first iteration
iteration of the program. The initialization
initialization results in the
follow
ing values:
following

LENGTH (2)
(2)
X = LENGTH
y
= 0
Y =
The effects of the loop instructions
instructions are:
are:

COUNT
COUNT

LDA
LOA
CMP
BCS
BCS
STA
DEX
DEX
BNE
BNE

$41, X
$42, X
$42.
COUNT
COUNT
$42, X

:A== (0043)
;A
: (0043)-(0044)
(0044) = (0043)
: (0044)
:X = LENGTH
LENGTH -1 (1)
;X

PASS
PASS

The indexed addresses are clearly
clearly incorrect
incorrect since they are both beyond the end of the
array. We will
ill change them by subtracting
subtracting two from the addresses included
included in the
instructions. This offset
offset is a common
common problem in 6502 assembly language
indexed instructions.
programs, because arrays and tables have a zeroth element. Thus an array with
ith five
elements occupies memory addresses
addresses BASE
BASE through
through 8ASE+4,
BASE+4, not BASE+11 through
BASE+5. When
hen using indexed addressing on the 6502 microprocessor, be careful
careful that
your addresses are not in error at one end of the array or the other.
1 4-19
9

Start

Interchange Flag= 0
Index = Length of
Array
Base = Start of
Array

Interchange {Base+
Index) and (Base+
lndex-1 I
Interchange Flag = 1

Index = lndex - 1

End

Figure 14-6. Flowchart of Sort Program

1414-20

The initialization
initialization now
now results
results In
in the values:

X = LENGTH (2)
(2)
yY = 0
effects of the loop instructions
instructions are:
The effects

COUNT

LDA
CMP
BCS
STA
DEX
BNE
BNE

;A
:A== (0041)
:; (0041 )-(0042)

$3F,X
$3F.X
$40,X
$40,X
COUNT
$40, X

: (0042) = (0041)
1)
;X
:X = LENGTH
LENGTH - 1 (1)

PASS

that we have already
already checked
checked the Conditional
Conditional Branch
Branch InstructIons
instructions. Clearly the
Note that
logic is incorrect.
incorrect. If the first
first twoo elements
elements are out of order.
order, the results after
after the first
first
logic
iteration should
iteration
Id be:

(0041)
(0042)
X

OLD (0042)
OLD (0041)
LENGTH
LENGTH - 1

(0041)
(0042)
X

UNCHANGED
OLD (0041)
LENGTH
LENGTH - 1

Instead, they are:
Instead.

The interchange
interchange requires a bit more care and the use of the Stack:
PHA
LDA
STA
PLA
STA

$40,X
$40.X
$3F,X
$3F.X
$40,
$40.XX

An interchange
interchange always requires a temporary
temporary storage place in which
which one number
number can be
saved while
hile the other one is being transferred.
changes require a new copy of the program.
program, ,i.e..
All these changes
e

PASS
PASS

COUNT
COUNT

LDY
LDX
LDA
CMP
CMP
BCS
BCS
PHA
PHA
LDA
STA
PLA
STA
DEX
DEX
BNE
BNE
DEY
DEY
BEQ
SEO
BRK
BRK

:CLEAR
:CLEAR INTERCHANGE
INTERCHANGE FLAG
FLAG BEFORE
BEFOREPASS
PASS
:GET
:GET LENGTH
LENGTH OF
OF ARRAY
;IS
:IS NEXT
NEXT PAIR
PAIR OF
OF ELEMENTS
ELEMENTS IN ORDER?
ORDER?

#0
$40
$3F,X
$40,X
$40.X
COUNT
COUNT

:YES,
:YES. NO
NO INTERCHANGE
INTERCHANGE NECESSARY
NECESSARY
;NO.
.NO. INTERCHANGE
INTERCHANGE ELEMENTS
ELEMENTS USING
USING THE
THE STACK
STACK

$40.X
$40,X
$3F,X
$3F.X
$40,X
$40.X
;CHECK
:CHECK FOR
FOR COMPLETED
COMPLETED PASS
PASS
PASS
PASS
:WERE
;WERE ALL ELEMENTS
ELEMENTS IN ORDER?
ORDER?
;NO,
:NO, MAKE
MAKE ANOTHER
ANOTHER PASS
PASS

PASS
PASS

How about
about the
iteration? Let's say
the last
last iteration?
say that
that there
there are three
three elements:
(0040)
(0040)
(0041)
(0042)
(0043)
(0043)

=
=
=
=

03
03
02
04
06
06

(number of elements)
(number
elements)

1421
14-21

each time through.
through, the program
program decrements
decrements X by 1.
during the third
third iteration.
iteration,
cdch
1. So,
So. during
(X)
effects of the loop instructions
instructions are:
(X) = 1.
1. The effects
LDA
LOA
CMP

(A)== (0040)
(0040)
: :(A)
(0040) - - (0041)
(0041)
; ;(0040)

$3F.X
$40,X
$40.X

This is incorrect:
incorrect: the program has tried to move beyond the starting
starting address of the data.
The previous iteration
iteration should.
should, in fact.
fact, have been the last one,
number of pairs
one. since the number
is one less than the number
number of elements. The first
first element
element in the array has no prepre­
hich it can be compared. The correction
correction is to reduce the number
number of iteraitera­
decessor to which
accomplished by placing
placing DEX
after LDX
must also
tions by one: this can be accomplished
DEX after
LOX $40. We must
add 1 to all the addresses in the indexed instructions.
instructions.

hat happens
How about the triviall cases?7 What
happens if the array contains no elements at
all, or only one element? The answer
answer is that
that the program
ork correctly
program does not work
and may change
o u t any warning (try
change a whole block of data improperly and w ithout
it!). The corrections to handle
itl).
handle the triviall cases are simple but essential; the cost
is only a few
w bytes of memory to avoid problems that
that could be very difficult to
solve later.
The new program
program is:
is:

PASS
PASS

COUNT

DONE
DONE

LDY
LOY
LDX
LOX
CPX
CPX
BCC
BCC
DEX
DEX
LDA
LOA
CMP
BCS
BCS
PHA
LDA
LOA
STA
PLA
STA
DEX
DEX
BNE
BNE
DEY
DEY
BEQ
BEO
BRK
BRK

#0
#0
$40
#22
DONE
DONE

CLEAR INTERCHANGE
:CLEAR
INTERCHANGE FLAG
FLAG BEFORE
BEFOREPASS
PASS
GET LENGTH
LENGTH OF
OF ARRAY
:GET
DOES ARRAY HAVE 2 OR MORE
:DOES
MORE ELEMENTS?
ELEMENTS?
:NO. NO ACTION NECESSARY
NECESSARY
NUMBER OF PAIRS
;NUMBER
PAIRS== LENGTH
LENGTH - 1
:IS NEXT
NEXT PAIR
PAIR OF
OF ELEMENTS
ELEMENTS IN ORDER?
ORDER?

$40,X
$40.X
$4
1.X
41.X
COUNT
COUNT

;YES,
:YES. NO INTERCHANGE
INTERCHANGE NECESSARY
NECESSARY
:NO. INTERCHANGE
INTERCHANGE ELEMENTS
ELEMENTS USING
USING THE STACK
STACK

$4
1.X
41.X
$40,X
$40,X
$41,X
$41.X
:CHECK
:CHECK FOR
FOR COMPLETED
COMPLETED PASS
PASS
PASS
PASS
:WERE
:WERE ALL ELEMENTS
ELEMENTS IN ORDER?
ORDER?
;NO.
:NO. MAKE ANOTHER
ANOTHER PASS
PASS

PASS
PASS

program on the computer
computer or on the simulator.
simulator. A simple
simple set of
Now it's time to check the program
data is:
is:
(0040)
(0041)
(0042)

= 02
02
= 00
00
= 01
01

length
length of
of array
array
array
array to
to be
be sorted
sorted

consists of two elements
elements in the wrong
wrong order. The program should require two
This set consists
passes.
first pass should
should reorder the elements.
elements, producing:
producing:
passes. The first

(0041)
= 01
01
(0042) = = 00
00
Y = = 01
01

reordered
reordered array
array
Interchange
Interchange flag
flag

The second pass should find the elements
elements in the proper
proper (descending) order and propro­
duce:
Y

00
== 00

Interchange
Interchange flag
flag

1414-22

Is rather long
long for
for single
single stepping,
stepping. so
so we
we w
will use
use breakpoints
breakpoints instead.
instead. Each
Each
This program is
breakpoint
the com
computer
and print
print the
the contents
contents of
of all
all the
the registers.
registers. The
The break­
breakbreakpoint will halt the
puter and
points will come:
1)
1)

After
After DEX
DEX to
to check
check the initialization.
initialization.

2)
2)
3)
3)

After CMP
CMP $41,X
$41.X to
to check
check the
the comparison.
comparison.
After
After STA
STA $41.X
$41,X to
to check the interchange.

4)

After
After DEY
DEY to
to check
check the completion
completion of a pass through
through the array

the first
first breakpoint
breakpoint were:
were:
The contents
contents of the registers after the
Register
--x- X

Contents
Contents

Y

00
00

P (status)
(status)

25 (35
(35 if11you
you use
use BRK
BRKto
to create
create
the
the breakpoint since
since the
the Break
Break
Command flag
flag w
will be
be set)
set)

01
01

These are all correct.
correct, so the program is
performing the
correctly in
Is performing
the initialization
init1ahzat1on correctly
in this
this

case.
The results at the second breakpoint
breakpoint were:
Register

Content;
ents
00
01
01
00
A4 (B4
(84 if11you use
use BRK)
BRK)

A
X
y
Y
P (status)
(status)

00

These results are also correct.
third breakpoint
breakpoint were:
The results at the third

Register
A
X

Contents
00
01
00
26 (36 if1f you use BRK)
BRK)

yY
P (status)
(status)
Checking memory
memory showed:
showed:
Checking

(0041)
(0042)

01
00

The results
results at
at the fourth
fourth breakpoint
breakpoint were:
The

Register
A
A
X

yY
(status)
P (status)

Contents
Contents
00
00
FF
FF
A4 (84
(B4 if you use BRK)
BRK)

The Zero
Zero flag
flag (bit
(bit 11 of
of the Status
Status Register) Is
is incorrect.
incorrect, indicating
that no interchange
interchange
The
1nd1cating that
occurred. Register
Register Y
Y does
does not
not contain
contain the correct
correct value
value -— It
it should have been set to
occurred.
one after
after the
the interchange.
interchange. In
In fact.
fact, aa look
look at
at the
the program
program shows
shows that
that no instruction
instruction ever
one
changes Index
Index Register
Register Y
Y to
to mark
mark the
the interchange.
interchange. The correction
correction is to place the inin­
changes
struction LDY
LDY #1
#1 after
after BCS
BCS COUNT
COUNT.
struction

14
-23
14-23

Now the procedure
procedure is to load Index Register
Register Y with
ith the correct
correct value (zero),
(zerol. set the Zero
continue. The second iteration
iteration of the second breakpoint
breakpoint gives:
flag to 1,
1. and continue.
Register
A
X
Y
P (status)

Contents
Contents
02
02
00
00
00
00
BAK)
25 (35 if you use BRK)

Clearly the program
program has proceeded
proceeded incorrectly
incorrectly w ith
o u t reinitializing
reinitializing the registers
registers (par­
Clearly
ithout
(particularly Index Register X). The Conditional
Conditional Branch
Branch that
that depends
depends on the interchange
interchange
ticularly
should transfer
transfer control
control back to a point
point that
that reinitializes
reinitializes X; note that
that we do not need to
should
reinitialize Y (it will
ill be zero anyway
anyway -— why?)
why?) nor do we need to check the length
length of the
reinitialize
array again.
final version of the program
program is:
The final
is:
SORT
SORT

ITER
ITER
PASS
PASS

COUNT

DONE
DONE

LDY
LOY
LDX
LOX
CPX
CPX
BCC
BCC
LDX
LOX
DEX
DEX
LDA
LOA
CMP
BCS
BCS
LDY
LOY
PHA
LDA
LOA
STA
PLA
STA
DEX
DEX
BNE
BNE
DEY
DEY
BEQ
BEO
BRK
BAK

#00
$40
#22
DONE
DONE
$40

;CLEAR INTERCHANGE
INTERCHANGE FLAG TO START
;DOES
:DOES ARRAY HAVE 2 OR MORE
MORE ELEMENTS?
ELEMENTS?

$40,X
$40.X
$41,X
$41.X
COUNT
#1

;IS NEXT PAIR
PAIR OF ELEMENTS
ELEMENTS IN ORDER?
ORDER?

;NO.
:NO. NO ACTION NECESSARY
NECESSARY
:YES,
:YES. NUMBER
NUMBER OF PAIRS
PAIRS== LENGTH
LENGTH - 1

;YES,
;YES. NO INTERCHANGE
INTERCHANGE NECESSARY
NECESSARY
;NO. SET
SET INTERCHANGE
INTERCHANGE FLAG
INTERCHANGE
;INTERCHANGE ELEMENTS
ELEMENTS USING
USING THE STACK

41.X
$4
1.X
$40,
$40.XX
$41,X
$41.X
;CHECK
:CHECK FOR
FOR COMPLETED
COMPLETED PASS
PASS
PASS
ITER
ITER

;WERE
;WERE ALL ELEMENTS
ELEMENTS IN ORDER?
ORDER?
;NO,
;NO. MAKE ANOTHER
ANOTHER PASS
PASS

Clearly we cannot
cannot check
check all the possible
possible input
input values for this program.
program. Two
Two other
other simple
simple
Clearly
sets of data for debugging
debugging purposes
purposes are:
1)
1)

elements
Two equal elements
(0040)
(0041)
(0042)

2)

=
=
=

02
00
00

elements already in decreasing
decreasing order
Two elements

(0040)
(0041)
(0042)

=
=
=

1 4-24
24

02
01
00

INTRODUCTION TO TESTING
TESTING
INTRODUCTION
Program testing
testing is closely related to program debugging.
st cases will
ill be the same as the test
test
Surely some of the test
data used for debugging, such as:

USING TEST
CASES FROM
DEBUGGING

• Trivial
Trivial cases such as no data or a single element
element
Special cases that
that the program singles out for some reason
• Special
• Simple examples
examples that
that exercise
exercise particular parts of the program
In the case of the decimal to seven-segment
seven-segment conversion program, these cases
consists of:
cover all the possible situations. The test data consists
• The numbers
numbers 0 through
through 9
• The boundary
boundary case 10
• The random
random case 6B
The program
program does not distinguish
distinguish any other
other cases
cases- Here debugging and testing are

virtually the same.
virtually
In the sorting program, the problem is more difficult. The number
number of elements
elements could
range from 0 to 255.
255, and each of the elements
elements could
could lie anywhere
anywhere in that
that range. The
number of possible
possible cases is therefore
therefore enormous
enormous. Furthermore
Furthermore, the program
program is
number
moderately complex.
complex. How do we select
select test data that w ill give us a degree of conficonfi­
moderately
dence in that
that program?
program? Here testing requires some design decisions.
testing
dence
decisions. The testing
problem is particularly
particularly d iffic
u lt if
program depends
depends on sequences
sequences of real-time
real-time data.
problem
ifficult
1f the program
select the data.
data, generate
generate it.L and present
present IIit to the m icrocom
puter in a
How do we select
icrocomputer
realistic manner?
manner?
realistic
Most
ost of the tools mentioned
mentioned earlier
earlier for debugging are helpful
in testing also.
also. Logic or microprocessor analyzers can help
check the hardware;
hardware; simulators can help check the software.
software.
Other tools can also be of assistance, e.g.,
Other

TESTING
AIDS

I/O
that can simulate
simulate a variety
variety of devices
devices from a single
single input
input and a
1/0 simulations that
single output
output device.
single
2) In-circuit
the prototype
prototype to
to aa development
In-circuit emulators
emulators that
that allow
allow you
you to
to attach
attach the
development
control panel and test it.
system or control
3) ROM
ing ofof the particular
particular
ROM simulators
simulators that
that have
have the
the flexibility
flexibility of
ofaaRAM
RAMbut
butthe
thetim
timing
ROM or PROM that
that will
ill be used in the final
final system.
4) Real-time
Real-time operating systems
systems that
that can provide
provide inputs
inputs or interrupts
interrupts at specific
specific
perhaps randomly)
randomly) and mark the occurrence
occurrence of outputs.
outputs. Real-time
Real-time break­
times (or perhaps
br!Jakpoints and traces may also be included.
included.
points
1)

5)

Emulations (often on microprogrammable
microprogrammable computers)
computers) that
that may provide
provide real-time
real-time
execution speed and programmable
programmable I/O
1/0A
4
execution

6)

Interfaces that
that allow
allow another
another computer
computer to control
control the I/O
Interfaces
1/0 system and test the
microcom
puter program.
microcomputer

7) Testing
program for
for logical
logical errors.
errors.
Testing programs
programs that
that check
check each
each branch
branch in a program
8)

Test generation
generation programs that
that can generate
generate random
random data or other
other distributions.
distributions.
Test

testing theorems
theorems exist,
but they are usually
usually applicable
applicable only to very short
Formal testing
exist. but
programs.
rams.

You must be careful that
that the test
st equipment
equipment does not invalidate the test
test by
environment. Often,
Often, test
test equipment
equipment may buffer, latch, or condition
modifying the environment.
input and output
output signals.
signals. The actual system may not do this, and may therefore
differently.
behave quite differently.

1414-25

Furthermore, extra
extra softw
are in the
the te
st environment
environment may
may use some
some of
of the
the memomemo­
Furthermore,
software
test
space or part
part of
of the
the interrupt
interrupt system.
system. It may
may also provide
provide error
error recovery
recovery and
ry space
other features
features that
that willill not
not exist
xist in the
the final
final system.
system. A software
software test bed must be
other
just as realistic
realistic as a hardware
hardware test bed, since software
software failure
failure can be just
just as critical
critical as
just
hardware failure.
hardware
Emulations and simulations
simulations are, of course,
course, never
never precise.
precise. They
They are usually
usually adeade­
Emulations
quate for
for checking
checking logic,
logic, but
but can seldom
seldom help
help test
st the
the interface
interface or the
the timing.
timing. On
quate
the other
other hand,
hand, real-time
real-time test
st equipment
equipment does
does not
not provide
provide much
overview of
the
much of an overview
the program
program logic
logic and may affect
affect the
the interfacing
interfacing and timing.
timing.
the

14-26
14-

DATA
SELECTING TEST DATA
Very few
w real programs can be checked
checked for all cases. The designer
designer must
must choose a
Very
set that
that in some sense describes
describes the entire range of possibilities.
possibilities.
sample set
Testing should.
should, of course.
course, be part of the total
total development
development propro­
Testing
STRUCTURED
STRUCTURED
Top-down design
design and structured
structured programming
programming provide
provide for
cedure. Top-down
TESTING
TESTING
testing as part
part of the design.
design. This is
called structured
structured testing.5
testing.5
testing
1s called
Each module
module within
ith in a structured
structured program
program should
should be checked
checked separately. Testing,
Testing, as
well
e l as design, should be modular, structured,
structured, and top-down.
top-down.

But that
that leaves
leaves the question
question of selecting
selecting test
st data for a
that a
module. The designer must first list all special cases that
program recognizes. These may include:
include:
•

TESTING
TESTING
SPECIAL
CASES

Trivial
r1v1aI cases

■ Equality
Equality cases
• Special
Special situations
situations
include all of these.
The test data should include
these.

You must next
next identify
identify each class of data that
that statements
statements
within
in the program may distinguish. These may include
include:
•
•
•
•

Positive or negative
negative numbers
Positive
numbers
Numbers above or below
below a particular
particular threshold
threshold
Numbers

FORMING
FORMING
CLASSES
OF DATA
DATA

Data that
that does or does not include
include a particular
particular sequence
sequence or character
character
Data that
that is or is
present at a particular
particular time
1s not present
ume

If the modules
modules are short.
short, the total number
number of classes should still
still be small even though
though
each division
ultiplicative: ,e.
i.e., three two-w
ay divisions
d1v1s1onis
1s mult1pl1cat1ve,
two-way
d1vis1ons result in 2 x 22 x 2 = 8
classes of data.

You must now separate the classes according to whether
whether the
SELECTING
program produces a different
different result for each entry in the class
DATA FROM
class
DATA
(as in a table) or produces the same result for each entry (such
CLASSES
(such
as a warning that
that a parameter
parameter is above a threshold). In the dis­
discrete case,
include each element
element if the total number
number is small or sample if the
case. one may include
number is large. The sample should include
include all boundary
boundary cases and at least one case
number
case
randomly. Random number
number tables are available
available in
number
selected randomly.
1n books,
books. and random number
generators
generators are part of most computer
computer facilities.
facilities.
You must be careful of distinctions
example, an 8-bit
8-bit
distinctions that may not be obvious. For example,
microprocessor will regard an 8-bit
8-bit unsigned number greater
greater than 127 as nega­
negative. The programmer must consider this when using
using conditional branches that
depend on
watch for instructions that do
affect
on the Sign flag. You must also
also watch
do not affect
flags, overflow
overflow in
etic, and the distinctions between
between address-length
in signed arithmetic,
(16-bit) quantities
quantities and data-length
data-length (8-bit) quantities.
(16-bitl

1414-277

Testing Example 1: Sort Program
Program
The special cases here are obvious:
elements in the array
• No elements
element, magnitude
magnitude may be selected randomly
randomly
• One element.

TESTING
A SORT
PROGRAM

The other
other special case to be considered
considered is one in which
which elements
elements are equal.
ith signs and data length. Note that the array itself
There may be some problem here with
contain fewer
fewer than 256 elements. The use of the instruction
instruction LDY
must contain
LOY #1 rather than
INY to set the Interchange
Interchange flag means that there will
ill be no problems if the number
number of
elements or interchanges
interchanges exceeds 128. We could check the effects
effects of sign by picking
picking
elements
regular test cases with
ith numbers of elements between
between 128 and 255 and half
half the regular
agnitudes should be chosen randomly
randomly so as to avoid unun­
between 2 and 127. All magnitudes
conscious bias as much as possible.
conscious
possible.

Testing Example 2: Self-Checking Numbers (see
(see Chapter 8)
r8)__________

-----

...

Here we will
ill presume that a prior validity
validity check has ensured that
TESTING AN
the number
number has the right
right length and consists of valid digits.
d1g1ts Since
ARITHMETIC
ARITHMETIC
the program makes no other
other distinctions.
distinctions, test data should be
PROGRAM
PROGRAM
number table or random numnum­
selected randomly. Here a random number
ber generator
generator will
ill prove ideal: the range of the random numbers is
,s 0
O to 9.
9.

1414-28

TESTING PRECAUTIONS
The designer can simplify the testing
testing stage by designing pro·
pro­
grams sensibly. You should use the follow
ing rules:
following

RULES
RULES FOR
FOR
TESTING

1)
inate trivial
trivial cases
out
1) Try to eliminate
cases as
as early as possible w ith
ithout
introducing unnecessary
unnecessary distinctions.
introducing
dist1nct1ons.
2)
2)

Minimize
inimize the number
number of special cases.
additional testing
cases. Each
Each special case means additional
testing
and debugging
debugging time.

3)
3) Consider
Consider performing
performing validity
validity or
or error
error checks
checks on
on the
the data
data prior
prior to
to processing.
processing.
4)

Be
Be careful
careful of
of inadvertent
inadvertent and
and unnecessary
unnecessary distinctions,
distinctions. particularly
particularly in
in handling
handling
signed numbers
numbers or using operations
operations that
that refer to signed numbers.

5)
5) Check
Check boundary
boundary cases
cases by
by hand.
hand. These
These are
are often
often aa source
source of
of errors.
errors Be
Be sure
sure that
that the
the
problem definition
definition specifies
specifies what
hat is to happen in these cases
cases.
problem
6)
6)

Make the program
program as general as reasonably
reasonably possible. Each
Each distinction
d1st1nct1onand separate
routine increases the required
required testing.
routine

7)
7)

program and design the modules
modules so that
that the testing
testing can proceed in
Divide the program
steps in conjunction
conjunction with
ith the other stages of software
software development.6
development®

CONCLUSIONS
Debugging and testing
testing are the stepchildren
stepchildren of the software
are development
development process.
process.
Most
ost projects leave far too little time for them and most textbooks
textbooks neglect
neglect them.
that these stages are the most expensive
expensive
But designers and managers often find that
and time-consuming.
time-consuming. Progress may be very d ifficult
u lt to measure or produce.
produce.
testing microprocessor software
are is particularly
particularly difficult
ifficu lt because
Debugging and testing
powerful hardware
hardware and softw
are tools
tools that
that can be used on larger
larger computers
computers
the powerful
software
seldom available
available for
for microcomputers.
microcomputers.
are seldom
designer should
should plan debugging
debugging and testing
testing carefully.
carefully. We recommend
recommend the
The designer
follow
ing procedure:
procedure:
following
1) Try
rite programs
Try to
to write
programs that
that can
can easily
easily be debugged
debugged and
and tested.
tested. Modular
Modular pro­
pro·
gramming, structured
structured programming,
programming, and top-dow
design are useful
useful techni·
techni­
gramming,
top-downn design
ques.
2) Prepare
debugging and
testing plan
Prepare aa debugging
and testing
plan as
as part
part of
of the
the program
program design.
design. Decide
Decide
early what
hat data
data you must
must generate
generate and what
hat equipment
equipment you willill need.
early
3) Debug
Debug and
and te
test each
each module
module as
as part
part of
of the
the top-dow
top-downn design
design process.
process.
4) Debug
Debug each
each module's
module's logic
logic systematically.
systematically. Use
Use checklists,
checklists, breakpoints,
breakpoints, and
and
the single-step
single-step mode.
mode. If the
the program
program logic
logic is complex,
complex, consider
consider using
using the
the so
ft­
the
soft·
ware simulator.
simulator.
ware
module's tim
ing system
atically ifif this
problem. An
5) Check
Check each
each module's
timing
systematically
this is
is aa problem.
An
oscilloscope can solve
solve many
many problems
problems if you
you plan
plan the
the test
st properly.
properly. If the
the
oscilloscope
tim
ing is complex,
complex, consider
consider using
using a logic
logic or microprocessor
microprocessor analyzer.
analyzer.
timing
representative sample.
atch for
6) Be
Be sure
sure that
that the
the te
test data
data is
is aa representative
sample. W
Watch
for any
any classes
classes of
of
data that
that the
the program
program may
may distinguish.
distinguish. Include
Include all
all special
special and trivial
trivia l cases.
data
differently or
7) IfIf the
the program
program handles
handles each
each element
element differently
or the
the number
number of
of cases
cases isis
large, select
select the
the test
te st data
data randomly.?
randomly.7
large,
8) Record
documentation. IfIf problems
8)
Record all
all te
test results
results as
as part
part of
of the
the documentation.
problems occur,
occur, you
you
willill not
not have
have to
to repeat
repeat test
st cases
cases that
that have
have already
already been
been checked.
checked.

14
-29
4-29

REFERENCES
1.

For more inform
ation about
about logic analyzers,
information
analyzers. see:
see:
N. Andreiev.
Andreiev, "Special
"Special Report: Troubleshooting
Troubleshooting Instruments."
Instruments," EDN
EDN. October 5,
5.
1978, pp.
89-99
pp, 89-99
R.
Down, "Understanding
"Understanding Logic Analyzers,"
Analyzers," Computer
Computer Design June 1977, pp.
R. L.
L. Down.
188-191.
R.
. Gasperini, "A Guide to Digital
Digital Troubleshooting
Troubleshooting Aids,"
Aids," Instruments
Instruments and Control
Systems. February 1978, pp. 39-42.
R.
"Troubleshooting Microprocessors
Microprocessors with
ith a Logic Analyzer
Analyzer System,"
System."
R. Lorentzen. "Troubleshooting
Computer Design. March 1979,
160-164 (includes a 6502-based
6502-based example).
Computer
1979. pp. 160-164
M. Marshall.
Marshall, "What
hat to Look for in Logic Timing
Timing Analyzers," Electronics.
Electronics. March 29,
29.
1979, p.
p, 109-114.
K.
hat Do Logic Analyzers Do?".
Digital Design,
September 1977,
K. Pines,
Pines. "What
Do?", Digital
Design. September
1977. pp. 5572.
I Spector. "Logic
Spector,Analysis
"Logic by
Analysis
by Telephone,"
EDN.
pp. 139-142.
Telephone,"
EDN, March
20.March
1979.20,
pp.1979,
139-142.

2.

W. J. Weller. Assembly Level Programming
Programming for Small Computers, Lexington
Lexington Books.
Books,
Lexington, MA,
Lexington.
MA. 1975,
1975. Chapter 23.

3.
3.

R.
"Interrupts Add Power,
Complexity to M icrocom
puter System
L. Baldridge, "Interrupts
Power. Complexity
icrocomputer
R. L.
Design," EDN.
August 5,
EDN. August
5. 1977,
1977. pp. 67-73.

4.
4.

H.
. Burris,
"Time-Scaled Emulations of the 8080 Microprocessor,"
Microprocessor," Proceedings of
Bums. "Time-Scaled
H. R.
the 1977 National Computer
Computer Conference, pp. 937-946.

5.
5.

D.
"Structured Testing,"
Testing." Datamation,
Datamation, July 1977,
D. A.
A. Walsh,
Walsh. "Structured
1977. pp. 111-118.
P.
Top-Down Testing,"
Testing," Datamation.
Datamation, October
P. F.
F. Barbuto Jr.
Jr. and J.
J. Geller,
Geller. "Tools for Top-Down
1978, pp. 178-182.

6.
6.

R.
ints on Test Data
R. A. DeMillo et al„
al., "Hints
Data Selection: Help for the Practicing Pro­
Programmer," Computer.
Computer. April 1978, pp. 34-41
grammer,"
W. F.
puter Software,"
Software," Electronics. January 19,
F. Dalton,
Dalton. "Design M icrocom
icrocomputer
19, 1978,
1978. pp.
pp.
97-101.

7.
Distribution Sampling for Computer Simulation.
Simulation, Lexington
Lexington Books,
7. T.
T. G. Lewis,
Lewis. Distribution
Books,
Lexington, MA,
Lexington.
MA. 1975.
1975.
R.
Microprocessors," Simulation.
ulation.
R.A.
A. Mueller et al„.. "A Random
Random Number Generator for Microprocessors,"
April 1977,
1977. pp.
pp. 123-127.

1414-30

Chapter 15
DOCUMENTATION AND REDESIGN
DOCUMENTATION
REDESIGN
The working
software
Adeworking program
program is not
not the only requirement
requirement of softw
are development.
development. Ade­
quate
software
Not only
quate documentation
documentation is also an important
portant part of a softw
are product.
product. Not
documentation help the designer
designer in the testing
testing and debugging
debugging stages, it is
does documentation
is
also
poorly documented
also eHential
essential for
for later
later use and extension
extension of the program. A poorly
documented
program willill be difficult
ifficu lt to maintain,
maintain, use, or extend.
extend.
program
Occasionally, a program
program uses too much memory
memory or executes
executes too slowly.
slowly. The
Occasionally,
designer must
must then
then improve
improve it. This stage is called redesign,
redesign, and requires that
that you
designer
concentrate on the parts of the program
program that can yield the most improvement.
improvement.

SELF-DOCUMENTING
SELF-D O C
U M ENTIN G PROGRAMS
Although no program
ever completely self-documentent­
program is ever
ing, some of the rules that
that we mentioned
mentioned earlier can help
help.
These include:

RULES
RULES FOR
FOR
SELF-DOCUMENTING
PROGRAMS
PROGRAMS

structure with
ith as few transfers of control
• Clear,
Clear, simple structure
(jumps) as possible
meaningful names and labels
• Use of meaningful
,• Use of names for I/O
1/0 devices, parameters,
parameters. numerical factors,
factors. etc.
etc.
plicity rather than on minor
inor savings in memory usage,
,• Emphasis on simplicity
usage. execution
time, or typing
typing
time.
example, the follow
ing program sends a string of characters to a teletypewriter:
teletypewriter:
For example.
following

w

LDX
LOX
LDA
LOA
STA
JSR
DEX
DEX
BNE
BRK
BRK

$40
$0FFF,X
$0FFF.X
$A000
$AOOO
XXX

w

o u t comments
comments we can improve the program.
program, as follows:
Even w ith
ithout
MESSG
MESSG
COUNT
COUNT
TTYVIA
TTYVIA
OUTCH
OUTCH

=$1000
=$1000
=$40
=$40
=$A000
=$AOOO
COUNT
LDX
COUNT
LOX
LDA
MESSG-1.X
MESSG-1.X
LOA
STA
TTYVIA
TTYVIA
STA
BITDLY
JSR
JSR
DEX
OUTCH
BNE
OUTCH
BNE
BRK
BRK

Surely this
this program
program is easier to understand
understand than the earlier version. Even
out
Surely
Even w ith
ithout
further documentation.
documentation, you could
could probably
probably guess at the function
function of the program and
further
the meanings
meanings of most
most of the
the variables. Other
Other documentation techniques cannot
the
substitute for
for self-documentation.
self-documentation.
substitute

15
15-1

S ome fu rther n otes on c h o o
s in g n a mes:
s:
osing

CHOOSING
USEFUL
NAMES

1)
1)

Use the obvious name when
when it is available, like TTY or CRT
CRT
for output
output devices, START or RESET
RESETfor addresses,
addresses, DELAY or
SORT
subroutines, COUNT or LENGTH
SORT for subroutines.
LENGTH for data.

2)

Avoid acronyms like S168A
S16BA for SORT
.§.ORT 16;BIT
!.§.-~IT ARRAY.
6,RRAY. These seldom mean
anything to anybody.
anything
Use full words or close to full
full words
words when
when possible,
possible. like DONE,
DONE. PRINT,
PRINT, SEND,
SEND, etc.
Keep the names as distinct as possible.

3)
4)

1 5-2

COMMENTS
COMMENTS
However,
The most obvious form of additional documentation is the comment. However,
few
w programs (even
(even those used as examples
examples in books)
effective comments.
books) have effective
ing guidelines for good comments.
You should consider the following
1)

Don't
on't repeat
repeat the meaning of the instruction code. Rather,
Rather.
explain the purpose of the instruction
instruction in the program. ComCom­
explain
ments like
DEX
;X=X-1
;X=X-1

COMMENTING
COMMENTING
GUIDELINES

nothing to documentation.
documentation. Rather,
add nothing
Rather. use
DEX
;LINENUMBER=LINE
NUMBER=LINENUMBER-1
NUMBER-1
;LINE
that you
youknow
know w
hatthe
theoperation
operationcodes
codesmean and
mean
and else
anyone
Remember that
what
anyone
can
look them up in the
themanual.
manual The
Theimportant
importantpoint
pointisisto explain
to what
explain w
h atthe
task
program is performing.
performing.
2)

Make
possible. Do not use abbreviations
abbreviations or acronyms
Make the comments as clear as possible.
unless they are well-known
well-known (like ASCII,
num­
ASCII, VIA, or UART)
UART) or standard (like no for number,
millisecond, etc.).
comments like
ber. ms for millisecond.
etc.I. Avoid comments
DEX
DEX

;LN=LN-1
;LN=LN-1
or
;DEC
;DEC LN
LN BY
BY 11

DEX
DEX

The extra typing
typing simply
ply is not all that expens,ve
expensive.
3)

Comment every important or obscure
particularly careful to mark
Comment
obscure point. Be particularly
mark
functions, such as
operations that may not have obvious functions.
AND #%00100000
00100000 ;TURN
TURN TAPE
TAPE READER
READERBIT OFF
OFF
or
LDA GCODL.X
;CONVERT
GCODL.X
;CONVERT TO GRAY
GRAY CODE
CODE USING
USING TABLE
TABLE
Clearly,
Clearly. I/O
1/0 operations often require extensive comments. If you're not exactly
sure
hat an instruction
instruction does,
clarifying
sure of what
does. or if you have to think about it,
it. add a clarifying
comment. The comment
comment will
ill save
ill be helpful in documentadocumenta­
save you time later and will
tion.

4)
4)

Don't
on't comment the obvious.
ent on each line simply
ply makes
ifficu lt to
obvious. A comment
makes it difficult
find the important
portant points. Standard sequences like
'
DEX
DEX
BNE
BNE

SEARCH
SEARCH

need
something special. One comment
ent will
need not be marked unless you're doing something
often suffice for several lines,
lines. as
as in
LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR

A
A
A
A

;GET
;GET MOST
MOST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT

LDA
LDX
LDX
STA
STA
STX
STX

$40
$41
$41
$41
$41
$40

;EXCHANGE
;EXCHANGE MOST
MOST SIGNIFICANT,
SIGNIFICANT. LEAST
LEAST
; SIGNIFICANT
SIGNIFICANT BYTES
BYTES

5)

Place
Place comments on
on the lines
lines to which they refer or at the
the start of a sequence.
quence.

6)
6)

Keep your comments up-to-date. IfIf you
you change the
the program,
program. change the
the com­
comments.
ments.

1 5 -3

elsecan

task the

7)

Use standard forms and terms in commenting.
commenting. Don't
on't worry
worry about repetitiveness.
Varied names for the same things
things are confusing.
confusing, even if the variations
variations are just
COUNT
COUNT and COUNTER,
COUNTER. START
START and BEGIN,
BEGIN. DISPLAY and LEDS,
LEDS. or PANEL
PANEL and
SWITCHES.
SWITCHES.
There's no real gain in not being consistent. The variations
variations may seem obvious to
now. but may not be clear later;
later: others will
you now,
ill get confused
confused from the very beginbegin­
ning.

8)
B)

Make comments mingled with
ith instructions brief. Leave a complete
complete explanation
explanation
Make
to header comments
comments and other
other documentation.
documentation. Otherwise.
Otherwise, the program gets lost
in the comments
comments and you may have a hard time even finding
finding it.

9)

Keep improving your comments. If you come to one that
that you cannot
cannot read or unun­
derstand.
derstand, take the time to change it. If you find that
that the listing
listing is getting
getting crowded.
crowded,
lines. The comments
add some blank lines.
comments w on't
n 't improve themselves:
themselves; in fact.
fact, they will
ill
just
just become worse as you leave the task behind and forget
forget exactly
exactly what
hat you did.

10)
10)

Before every
every major section, subsection, or subroutine, insert a number of
comments describing the functions of the code thatt follows. Care should be
taken to describe all inputs.
inputs, outputs.
outputs, and side effects.
effects, as well
well as the algorithm
algorithm
employed.

11)

It is good practice
practice when modifying working programs to use comments to inin­
made.
dicate the date, author, and type of modification made.

Remember, comments are important. Good ones will
ill save you time and effort. Put
some work into comments and try to make them as effective
ffective as possible.
possible.

15-4
15-4

Commenting
Commenting Example 1:: Multiple-Precision
Addition
Addition

CO M M E
N TIN G
MENTING
EXAMPLES
EXAMPLES

program is:
The basic program

ADDWD
ADDWD

LDX
CLC
LDA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BAK

$40
$40,X
$40.X
$50,X
$50.X
$40,X
$40.X
ADDWD
ADDWD

First,
ent the important
portant points. These are tVP•ca
typicaliv ~ a
initializations,
fetches,
First. comm
comment
za ions. data fetches.
and processing
processing operations.
operations. Don't
Don't bother
bother with
ith standard
standard seouences
seauences ,
like updating
updating poinpoin­
ters and counters. Remember that
that names are clearer
dearer than
numbers,
a r,u
bers. so use them freely.
The new version of the program
program is:
Is·
MULTIPLE-PRECISION ADDITION
:MULTIPLE-PRECISION

BINARY ADD~
ADDITION
0,
:THIS PROGRAM
PROGRAM PERFORMS
PERFORMS MULTI-BYTE
Tl-BYTE Bl
INPUTS:
0040 (HEX)
LENGTH OF NUMBERS
INPUTS: LOCATION 0040
(HEX)== E
UMBERS (IN BYTES)
BYTES)
LOCATIONS 0041 THROUGH
0050 (HEX)
THROUGH 0050
(HEX) = FIRST
FIRST NUMBER
NUMBER STARTING
STARTING
WITH MSB'S
LOCATIONS 0051 THROUGH
0060 (HEX)=
(HEX) = SECOND
NUMBER STARTING
STARTING
THROUGH 0060
SECOND NUMBER
WITH MSB'S
OUTPUTS:
0050 (HEX)
OUTPUTS: LOCATIONS 0041 THROUGH
THROUGH 0050
(HEX)== SUM STARTING
STARTING WITH
MSB'S
LENGTH
LENGTH
NUMB1
NUMB1
NUMB2

ADDWD
ADDWD

=$40
$40
=$41
=$51
LDX
CLC
CLC
LDA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BAK

LENGTH
LENGTH

;COUNT
:COUNT = LENGTH
LENGTH OF NUMBERS
NUMBERS (IN BYTES)
BYTES)

NUMB1-1.X
NUMB1-1.X
NUMB2-1.X
NUMB2-1.X
NUMB1-1.X
NUMB1-1.X

;GET
;GET BYTE
BYTE FROM
FROM STRING
STRING 1
;ADD BYTE FROM
FROM STRING
STRING 2
;STORE
:STORE RESULT
RESULT IN STRING
STRING 1

ADDWD
ADDWD

:CONTINUE
BYTES ADDED
:CONTINUE UNTIL ALL BYTES

15-5

Second,
instructions that might
ight not
Second. look
look for any instructions
not have
have obvious
functions and mark them. Here,
functions
Here. the purpose of CLC
CLC is
is to
to clear the
the
Carry the first tim
time through.
through.

QUESTIONS
FOR
FOR
COMMENTING
COMMENTING

Third,
whether the comments
comments tell you what
hat you would need
Third. ask
ask yourself whether
need to know if you
you
wanted to use
use the program,
program. e.g.:
e.g.:
1)
alternative entry points?
1) Where is the program entered? Are there alternative
2)
2)

Whatt parameters are
hat form must they
are necessary?
necessary? How and in what
they be supplied?

3)
3)

What
hat operations does the program perform?

4)

From
From where does it get the data?

5)
5)

Where does it store the results?

6)
6)

What
hat special cases
cases does it consider?

7)

What
hat does the program do about errors?
errors?

8)

How does it exit?

Some of the questions
questions may not be relevant to a particular
particular program and some of the
answers may be obvious. Make sure that you w
o n 'thave to sit
sit down and
won't
and dissect the
the
program to figure out what
hat the answers are.
are. Rememberthat
that too
too much
muchexplanation
explanation isis
just dead wood that you will
ill have to clear out of the way. Is there anything
anything that you
just
subtract from this listing? If so,
would
Id add to or subtract
so. go ahead -— you are the one who has
has to
feel that the comm
enting is adequate and reasonable.
commenting
reasonable.
MULTIPLE-PRECISION
:MULTIPLE-PRECISIONADDITION

:THIS PROGRAM
PROGRAM PERFORMS
PERFORMSMULTI-BYTE
Tl-BYTE BINARY
BINARY ADDITION
INPUTS:
0040 (HEX)
INPUTS: LOCATION
LOCATION 0040
(HEX) = LENGTH
LENGTH OF NUMBERS
NUMBERS (IN
(IN BYTES)
BYTES)
LOCATIONS
0050 (HEX)
LOCATIONS 0041 THROUGH
THROUGH 0050
(HEX) = FIRST
FIRST NUMBER
NUMBER STARTING
STARTING
WITH MSB'S
LOCATIONS
0060 (HEX)
LOCATIONS 0051 THROUGH
THROUGH 0060
(HEX)= SECOND
SECOND NUMBER
NUMBER STARTING
STARTING
WITH MSB'S
OUTPUTS:
0050 (HEX)
OUTPUTS: LOCATIONS
LOCATIONS 0041 THROUGH
THROUGH 0050
(HEX)= SUM STARTING
STARTING WITH
MSB'S
LENGTH
LENGTH
NUMB1
NUMB1
NUMB2

ADDWD
ADDWD

=$40
$40
=$41
=$51
LDX
LOX
CLC
LDA
LOA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BRK

NUMB1-1.X
NUMB1-1,X
NUMB2-1.X
NUMB2-1.X
NUMB1-1.X
NUMB1-1.X

LENGTH OF NUMBERS
:LENGTH
NUMBERS (IN BYTES)
BYTES)
:MSB'S OF 1ST NUMBER
NUMBER AND RESULT
RESULT
:MSB'S OF SECOND
SECOND NUMBER
NUMBER
COUNT
:COUNT== LENGTH
LENGTH OF NUMBERS
NUMBERS (IN BYTES)
BYTES)
CLEAR CARRY
:CLEAR
CARRY TO START
START
GET BYTE FROM
;GET
FROM STRING
STRING 1
:ADD BYTE FROM
FROM STRING
STRING 2
STORE RESULT
:STORE
RESULT IN STRING
STRING 1

ADDWD
ADDWD

CONTINUE UNTIL ALL BYTES
;CONTINUE
BYTES ADDED

LENGTH
LENGTH

15-6
15-6

Commenting Exam
ple 2: T eletyp
e w riter Output
Commenting
Example
eletypewriter
The basic program is:

TBIT

LDA
LDA
ASL
LDX
STA
JSR
ROR
ROA
SEC
SEC
DEX
BNE
BRK
BAK

$60
$60
A
#11
#11
$A000
$AOOO
BITDLY
A

TBIT

Commenting the important
portant points and adding names g•ves
gives:
Commenting
:TELETYPEWRITER OUTPUT PROGRAM
LOCATION 0060
0060 (HEX)
;THIS PROGRAM PRINTS THE CONTENTS OF MEMORY LOCATION
(HEX) TO THE
TELETYPEWRITER
TELETYPEWRITER
INPUTS: CHARACTER TO BE TRANSMITTED
TRANSMITTED IN MEMORY
0060
ORY LOCATION 0060
OUTPUTS: NONE
NBITS
TDATA
TDATA

=11
=11
==$60
$60

TTYVIA
TTYVIA

=$A
000
=$A000
LDA
ASL
LDX
STA
STA
JSR
ROR
ROA
SEC
SEC
DEX
DEX
BNE
BNE
BRK
BAK

TBIT

TDATA
TOATA
AA
#NBITS
#NBITS
TTYVIA
TTYVIA
BITDLY
BITDLY
AA

TBIT
TBIT

NUMBER OF BITS PER
PER CHARACTER
ADDRESS OF CHARACTER TO BE
BE
TRANSMITTED
TRANSMITTED
TELETYPEWRITER OUTPUT DATA
DATA PORT
:TELETYPEWRITER
PORT
GET DATA
DATA
;GET
:SHIFT LEFT
LEFT AND FORM START BIT
COUNT
:COUNT== NUMBER OF BITS IN CHARACTER
:SEND NEXT BIT TO TELETYPEWRITER
TELETYPEWRITER
W
AIT 1 BIT TIME
:WAIT
GET NEXT BIT
:GET
;SET CARRY
CARRY TO FORM
FORM STOP
STOP BITS
BITS
;COUNT
:COUNT BITS
BITS

15
15-7

could change
change this program
program so that
that it would
would transfer
transfer a whole
whole string
Note how easily we could
starting at the address in page-zero locations
locations DPTR
ending
of data, starting
DPTR and DPTR
DPTR + 1 and ending
with
ith an "03"
3 ” character
character (ASCII
Furthermore, let us make the terminal
terminal a 30
(ASCII ETX),
ETX). Furthermore.
character per second device
device with
ith one stop bit (we will
ill have to change
change subroutine
subroutine
character
making the changes
changes before looking
looking at the listing.
listing.
BITDLY). Try making
STRING OUTPUT PROGRAM
;STRING
PROGRAM

;THIS PROGRAM
PROGRAM TRANSMITS A STRING
STRING OF CHARACTERS
CHARACTERS TO A 30 CPS
CPS TERMINAL.
TRANSMISSION CEASES
CEASES WHEN AN ASCII ETX
ETX (03 HEX)
HEX) IS ENCOUNTERED
ENCOUNTERED
INPUTS:
0060 AND 0061 (HEX)
INPUTS: LOCATIONS 0060
(HEX) CONTAIN ADDRESS
ADDRESS OF
OF
STRING
STRING TO BE TRANSMITTED
OUTPUTS: NONE
NONE
DPTR
DPTR
ENDCH
ENOCH
NBITS
TRMVIA
TRMVIA
TCHAR

TBIT

DONE
DONE

=$60
$60
=$03
=$03
=10
10
=$A000
=$AOOO
LDY
LDA
CMP
BEQ
BEG
ASL
LDX
STA
JSR
ROR
ROR
SEC
SEC
DEX
DEX
BNE
BNE
INY
JMP
BRK
BRK

#00
(DPTR).Y
(DPTR).Y
#ENDCH
#ENOCH
DONE
DONE
A
#NBITS
#NBITS
TRMVIA
TRMVIA
BITDLY
A

TBIT

POINTER TO OUTPUT DATA
DATA BUFFER
;POINTER
BUFFER
:ENDING CHARACTER
CHARACTER = ASCII ETX
ETX
;NUMBER OF BITS
BITS PER
PER CHARACTER
CHARACTER
DATA PORT
;TERMINAL OUTPUT DATA
PORT
:POINT TO START OF OUTPUT DATA BUFFER
BUFFER
GET A CHARACTER
;GET
CHARACTER FROM BUFFER
BUFFER
;IS IT ENDING
ENDING CHARACTER?
CHARACTER?
;YES,
DONE
YES, DONE
NO, SHIFT
;NO.
SHIFT LEFT
LEFT AND FORM
FORM START BIT
COUNT
;COUNT== NUMBER OF BITS PER
PER CHARACTER
CHARACTER
:SEND NEXT BIT TO TERMINAL
W
AIT 1 BIT TIME
;WAIT
GET NEXT BIT
:GET
;SET CARRY TO FORM STOP
STOP BIT
BIT
;COUNT
:COUNT BITS
BITS
;PROCEED
:PROCEED TO NEXT CHARACTER
CHARACTER

TCHAR

Good comments
comments can make it easy for you to change
change a program
program to meet new requirerequire­
ments. For example.
example, try changing
changing the last program
program so that
that it:
• Starts each message with
ith ASCII STX (0215)
(02-]g) followed
followed by a three-digit
three-digit identification
identification
memory locations
locations IDCODE through
through IDCODE+2
code stored in memory
• Adds
Adds no start
start or stop bits
• Waits
aits 1 ms between
between bits
• Transmits
Transmits 40 characters,
characters, starting
starting with
ith the one located at the address in DPTR
DPTR and
DPTR+1
ith twoo consecutive
consecutive ASCII ETXs (03-)
6)
• Ends each message with
(0315)

1 5-8

FLOWCHARTS
FLOWCHARTS AS
AS D O C U M EN
DOCUMENTATION
W
We have
have already
already described
described the
the use
use of
of flowcharts
flowcharts as
as aa design
design tool
tool
in
documentation, partic­
in Chapter
Chapter 13.
13. Flowcharts
Flowcharts are
are also
also useful
useful in
in documentation.
particularly if:
if:
ularly

HINTS
HINTS FOR
FOR
USING
USING
FLOWCHARTS
FLOWCHARTS

They are
are not
not so
so detailed
detailed as
as to
to be
be unreadable
unreadable
•• They
•• Their
Their decision
decision points
points are
are clearly
clearly explained
explained and
and marked
marked

They include
include all
all branches
branches
• They
•• They
They correspond
correspond to
to the
the actual
actual program
program listings
listings
Flowcharts
Flowcharts are
are helpful ifif they
they give you
you an
an overall
overall picture
picture of
of the
the program.
program. They
They are
are not
not
helpful
ifficu lt to
helpful ifif they
they are
are just as
as difficult
to read
read as
as an
an ordinary listing.
listing.

STRUCTURED
TIO N
STRUCTURED PROGRAMS
PROGRAMS AS D O C U MENTATION
A structured
structured program can serve as
documentation for an assembly language program
as documentation
if:
if:
• You describe the purpose of each section in the comments
comments
• You make it clear which
hich statements
statements are
conditional or loop structure
structure
are included in each conditional
by using indentation
indentation and ending markers
markers
• You make the total structure
structure as simple as possible
• You use a consistent,
consistent. well-defined
well-defined language
The structured
structured program can help you to check the logic or improve it. Furthermore.
Furthermore,
since the structured
structured program is machine-independent.
machine-independent, it can also aid you in implementimplement­
ing the same task on another
another computer.

15-9
15-9

MEMORY
MEMORYMAPS
A memory map is simply a list of all the memory assignments in
In a program.
program. The
map allows you to determine the amount of memory needed, the locations of data
or subroutines, and the parts of memory not allocated. The map is a handy reference
finding storage locations
locations and entry points
points and for dividing
dividing memory
memory between
for finding
different routines
routines or programmers. The map will
ill also give you easy access to data and
different
subroutines
subroutines if you need them in later extensions
extensions or in maintenance.
maintenance. Sometimes
Sometimes a
graphical map is more helpful
helpful than a listing.
graphical
A typical map would be:

TYPICAL

MEMORY
MAP
Program Memory
Memory

Address

Routine

Purpose

E000-E1FF
E000-E1
FF
E200-E240
E241-E250
E251-E270
E271-E3F9
E271-E3F9
E3FA-E3FF
E3FA-E3FF

INTRPT
INTRPT
BRKPT
BRKPT
DELAY
DELAY
DSPLY
DSPLY
MAIN

Interrupt
Interrupt Service Routine for Keyboard
Service Routine for Break Instruction
Instruction
Delay Program
Display Control Program
Main Program
Interrupt
Reset Vectors
Interrupt and Reset
Data Memory

0000
0001-0002
0001-0002
0003-0041
0003-0041
0042-0051
0042-0051
0051-006F
0051-006F
0100-01FF
FF

NKEYS
NKEYS
KPTR
KPTR
KBFR
KBFR
DBFR
DBFR
TEMP
TEMP
STACK
STACK

Number
Keys
Number of Keys
Keyboard Buffer Pointer
Keyboard Buffer
Display Buffer
Temporary Storage
RAM Stack

Remember that the 6502 RAM Stack is always on page
page 1 of memory.
memory.

15-10
15-

PARAMETER AND DEFINITION LISTS
LISTS
Parameter
Parameter and
and definition
definition lists
lists at the
the start
start of
of the
the program
program and
and each
each subroutine
subroutine
make
ing rules
make understanding
understanding and
and changing
changingthe
the program
programfar simpler.
simpler. The
The follow
following
rules can
can
help:
help:
1)
1
)

2)

Separate RAM
RAM locations,
locations, I/O
1/0 units,
units, parameters,
parameters, defini­
definiSeparate
tions, and
and memory
memory system
system constants.
constants.
tions,
Arrange
ith aa descripdescrip­
Arrange lists
lists alphabetically when possible,
possible, with

RULES
RULES FOR
FOR
DEFINITION
LISTS
LISTS

tion of
of each
each entry.
entry.
tion
3)

Qive
Give each
each parameter that m
might change
change a name
name and
and include
include it in
in the
the lists.
lists. Such
Such
parameters may include
include tim
ing constants.
constants, inputs
inputs or
corresponding to
partic­
parameters
timing
or codes
codes corresponding
to particular keys
functions, control
control or
patterns, starting
starting or ending
ending characters,
keys or
or functions.
or masking
masking patterns.
characters.
thresholds.
etc.
thresholds, etc.

4)

Make the memory system constants into
constants will
into a separate
separate list.
list. These constants
include Reset and interrupt
interrupt service addresses, the starting
starting address of the
include
the program,
program.
areas. etc.
RAM areas. Stack areas,

5)
5)

Give each port used
though devices
devices may share
used by an I/O
1/0 device a name,
name, even though
ports in the current
current system. The separation
separation will
ill make expansion
expansion or reconfiguration
reconfiguration
much
much simpler.
simpler.

A typical list of definitions will be:

TYPICAL
DEFINITION
LIST

:MEMORY SYSTEM CONSTANTS
INTRP
INTRP
RAMST
RESET
RESET
STPTR
STPTR

=$E200
=$E200
=$E300
=$E300
=$01FF
=$01
FF

INTERRUPT ENTRY
,INTERRUPT
ENTRY POINT
DATA STORAGE
.START OF DATA
STORAGE AREA
RESET ADDRESS
:RESET
ADDRESS
;TOP ADDRESS IN RAM STACK (ON PAGE 1)
1)

=$AOOO
=$A000
=$A001
=$A001
=$AOOO
=$A000
=$ABDO
=$A 800

:OUTPUT VIA FOR
FOR DISPLAYS
;INPUT VIA FOR
FOR KEYBOARD
VIA FOR
:OUTPUT VIA
FOR KEYBOARD
DATA PORT
;TTY DATA
PORT

=$0

; I/O
1/0 UNITS
DSPLY
KBDIN
KBDOT
TTYVIA
TTYVIA

: RAM LOCATIONS

NKEYS
KPTR
KPTR
KBFR
KBFR
DBFR
TEMP
TEMP

·=RAMST
•=RAMST
·=·+1
"=
*+ 1
·=·+2
*=
*+ 2
'='+$40
*= *+
$40
'='+$10
*= *+
$10
·=·+$14
*= *+
$14

;NUMBER OF KEYS
:NUMBER
KEYBOARD BUFFER
:KEYBOARD
BUFFER POINTER
POINTER
KEYBOARD INPUT BUFFER
;KEYBOARD
BUFFER
:DISPLAY DATA
DATA BUFFER
;DISPLAY
BUFFER
TEMPORARY STORAGE
;TEMPORARY

:PARAMETERS
BOUNCE
GOKEY
GOKEY
MSCNT
MSCNT
OPEN
OPEN
TPULS
TPULS

=2
=2
=10
=10
=$C7
=$C7
=$0F
=$OF
=11

DEBOUNCING TIME
TIME IN MS
MS
,DEBOUNCING
IDENTIFICATION OF
OF 'GO'
'GO' KEY
:IDENTIFICATION
COUNT FOR
FOR 11 MS
MS DELAY
DELAY
;COUNT
PATTERN FOR
FOR OPEN
OPEN KEYS
;PATTERN
PULSE LENGTH
LENGTH FOR DISPLAYS
DISPLAYS IN
IN MS
MS
;PULSE

15
-1 1
15-11

DEFINITIONS
DEFINITIONS
ALLHI
ALLHI
STCON
STCON

=$FF
=$FF
=$80
= 80

;ALL
;ALL ONES
ONESPATTERN
PATTERN
iPATTERN
;PATTERNFOR
FORSTART
STARTCONVERSION
CONVERSIONPULSE
PULSE

Of
alphabetical order,
Of course,
course. the
the RAM
RAM entries
entries w
will usually
usually not
not be
be in
in alphabetical
order. since
since the
the designer
designer
must
minimize the
must order
order these
these so
so as
as to
to minimize
the number
number of
of address
address changes
changes required
required in
in the
the pro­
program.
gram.

15
-1 2
15-12

LIBRARYROUTINES
ROUTINES
LIBRARY
Standard
Standarddocumentation
documentationofofsubroutines
subroutineswill
w illallow
allowyou
youtotobuild
buildup
upa alibrary
libraryofof
useful
usefulprograms.
programs.The
Theidea
ideaIsistotomake
makethese
theseprograms
programseasily
easilyaccessible.
accessible.AAstandard
standardforfor­
mat
what
matwill
w illallow
allowyou
youororanyone
anyoneelse
elsetotosee
seeatata aglance
glance w
hatthe
theprogram
programdoes
does.The
Thebest
best
procedure
procedureisistotomake
makeup
upaastandard
standardform
formand
anduse
useItitconslS'fently.
consistently.Save
Savethese
theseprograms
programs
inina awell-organized
well-organizedmanner
manner(for
(forexample,
example,according
accordingtotoprocessor.
processor,language.
language,and
andtype
typeofof
without
program).
program),and
andyou
youwill
w illsoon
soonhave
haveaauseful
usefulset
set.But
Butremember
rememberthat,
that, w
ith o u torganizaorganiza­
tion
difficult
rewrittionand
andproper
properdocumentation,
documentation,using
usingthe
thelibrary
librarymay
maybe
bemore
more d
iffic u ltthen
than re
w rit­
ing
ingthe
theprogram
programfrom
fromscratch.
scratch.Debugging
Debuggingaasystem
system requires
requiresaaprecise
preciseunderstanding
understanding
theeffects
effectsofofeach
eachsubroutine.
subroutine.
ofofallallthe
Amongthe
the inform
ation that
thatyou
youwill
w ill need
needInin the
thestandard
standard form
form ,s:
is:
Among
information
Purposeofof the
the program
program
• •Purpose
Processor used
used
, •Processor

STANDARD
STANDARD
PROGRAM
PROGRAM
LIBRARY
LIBRARY
FORMS
FORMS

Language used
used
••Language
Parameters required
required and
and how
how they
they are
are passed
passed to
to the
the subroutine
subroutine
•• Parameters
Results produced
produced and
and how
how they
they are
are passed
passed to
to the
the main
main program
program
•• Results
Number of
of bytes
bytes of
of memory
memory used
used
•• Number
•• Number
Number of
of clock
clock cycles
cycles required
required. This
This number
number may
may be
be an
an average
average o·
or aa ryp,cal
typical figure.
figure,
or
timee w
or itit may
may vary
vary widely
widely. Actual
Actual execution
execution tim
will, of
of course
course, ceoer,d
depend on
on the processor
clock rate
rate and
and the
the memory
memory cycle
cycle 11me
time
clock
• Registers affected
affected
,Registers
Flags affected
affected
••Flags
•A typIca
typical example
example
,A
Error handling
handling
•• Error
•Special
,Spec1a cases
cases
••Documented
Documented program
listing
program 11s1
ng
IfIf the
complex, the
the program
program is
1s complex
the standard
standard library
library form
form should
should also
also include
nclude aa general
general
flow
chart or
structured
flowchart
or aa s
ructured program.
program. As
As we
we have
have mentioned
mentioned before,
before aa library
library program
program isis
most
performs aa single
single distinct
d1st1nc function
function in
1naa reasonably
reasonably general
general
most likely
t,kely to
to be
be useful
useful if,f itit performs
manner.
manner

1 5 -1
3
15-13

j

LIBRARY EXAMPLES
EXAMPLES
LIBRARY
Library Exam
Example
Sum of
of Data
Data
Library
ple 1:: Sum
Purpose:
Purpose: The
The program
program SUM8
SUMS computes
computes the
the sum
sum of
of aa set
set of
of 8 -b
8-bit unsigned
unsigned binary
binary num­
numbers.
bers.
Language: 6502
6502 Assembler.
Assembler.
Language:

Initial Conditions: Address
Address one
one less
less than
than the
the starting
starting address
address of
of the
the set
set of
of numbers
numbers in
in
memory
memory locations
locations 0040
0040 and
and 0041,
0041, length
length of
of set
set in
in Index
Index Register
Register Y.
Y.
Final Conditions: Sum in
in Accumulator.
Accumulator.
Final
Requirements:

Memory
Memory
Time
Registers
Registers
RAM
RAM
All flags affected.

- 99 bytes.
bytes.
- 7 +12n
1 2n clock cycles,
cycles. where nn is
is the
the length of the
the set
set ofof·
numbers.
numbers. May be
be longer if page
page boundaries are
are crossed.
crossed.
A.Y
locations 0040 and
and 0041.
0041.

(all data in hexadecimal)
hexadecimal)
Typical Case: (all
Start:
(0040 and 0041) = 004F
Y = 03
(0050) = 27
(0050)
(0051) = 3E
(0051)
(0052) = 26
(0052)
End:
End:
BB
A = 8B
Error Handling: Program ignores all carries.
carries. Carry bit reflects only the last operation.
Initial contents
contents of Index register Y must be 1 or more.
Initial
more. Decimal Mode
flag should be cleared.
cleared.
Listing:

:SUM OF 8-BIT
S-BIT DATA
SUMS
SUM8
ADDS
ADD8

LDA
LOA
CLC
CLC
ADC
DEY
DEY
BNE
BNE
RTS
RTS

#00

($40).Y
($40),Y

:SUM =ZERO
=ZERO
;CLEAR
:CLEAR CARRY
CARRY EACH
EACH TIME
:SUM== SUM++ DATA ENTRY
ENTRY

ADDS
ADD8

15
-1 4
15-14

Library Example 2: D ecimal-to-Seven
al-to-Seven Segment Conversion
Conversion
Purpose: The program
program SEVEN converts
converts a decimal
decimal number
number to a seven-segment
seven-segment display
display
Purpo•e:
code.
Language:
6502 Assembler.
Assembler.
Lenguege: 6502
Initial Condition•:
Conditions: Data in Index Register
Register X.
lnltlel
Final condition•:
conditions: Seven-segment
Seven-segment code in Accumulator
Accumulator.
Requirements:
Requirement•:
Memory
Memory

-

Time
Time

-

Registers
Allll flags affected
affected.

-

19 bytes,
including the seven-segment
seven-segment code table (10
bytes. including
entries).
16 clock
clock cycles
cycles if the data is
,s valid. 13 if it is not.
longer if
boundaries are crossed.
May be longer
1f page boundaries
A. X

Input data in
Register X is
unchanged.
Input
In Index Register
Is unchanged

Typical Case: (data in
hexadecimal)
In hexadecimal)
Start:
X =

05

A =

6D

End:

Error
Program returns
returns zero in the
ulator if1f the data is
decimal
Error Handling: Program
he Accum
Accumulator
Is not a decimal
digit.
digit.
Listing:
;DECIMAL
.DECIMAL TO SEVEN-SEGMENT
SEVEN-SEGMENT CONVERSION
VERSION
;GET
:GET ERROR
ERRORCODE
CODE TO BLANK DISPLAY
DISPLAY
;IS
:IS DATA A DECIMAL DIGIT?
DIGIT?
;NO.
NO. KEEP
KEEP ERROR
ERRORCODE
CODE
;:YES.
YES, GET
GET SEVEN-SEGMENT
SEVEN-SEGMENT CODE
CODE FROM
FROM
;: TABLE
TABLE

SEVEN
SEVEN

LDA
CPX
CPX
BCS
BCS
LDA

#0
# 10
DONE
DONE
SSEG.X
SSEG.X

DONE
DONE
SSEG
SSEG

RTS
RTS
. BYTE
BYTE
. BYTE
BYTE

$3F,$06,$5B,$4F,$66
$3F.$06.$5B.$4F.$66
$6D,$7D,$07,$7F,$6F
$6D.$7D.$07.$7F.$6F

1515-15

Library Example 3: Decimal Sum
program DECSUM
ulti-word decimal
decimal numbers.
Purpose: The program
DECSUM adds twoo multi-word

Language: 6502
6502 Assembler.
Initial Conditions: Address
Address of MSBs of one number
number in memory
memory locations
locations 0040
0040 and
Initial
0041, address of MSBs of other
other number
number in memory locations
locations 0042
0041.
Length of numbers
numbers (in bytes) in Index Register Y. NumNum­
and 0043. Length
bers arranged starting
starting with
ith most significant
significant digits.
Final Conditions: Sum replaces number
ith starting
starting address in memory locations
number with
0040 and 0041.
0040
Requirements:
Requirements:
Memory
Memory
Time
Registers
RAM
All flags affected
affected

- 14
14bytes.
bytes.
- 11
11++22n
22n clock
clock cycles,
cycles.where
where nnisisthe
the number
number of
of
bytes. May be longer if page boundaries
boundaries are crossed.
crossed.
- A, y
Y
- memory
memory locations
locations 0040
0040 through
through 0043.
0043.
- Carry
Mode
Carry shows
shows ifif sum
sum produced
produced aa carry.
carry. Decimal
Decimal Mode
flag is
Is cleared.
cleared.

Typical Case: (all
(all data in hexadecimal)
Start:
(0040 and 0041) =
(0042 and 0043) =
(Y)
(Y) =

0060
0050
02

(0060) =
(0061)
(0061) =

55
34

(0050)
(0050) =
(0051)
(0051) =

15
88
BB

(0060)
(0060) =
(0061) =
Carry =

71
71
22
0

End:
End:

Error
validity of decimal inputs. The contents
contents of
Error Handling: Program does not check the validity
Index Register Y must be 1 or more.
more.
Listing:
;MULTI-DIGIT DECIMAL
DECIMAL (BCD)
(BCD) ADDITION
ADDITION
DECSUM
DECSUM
DECADD
DECADD

SED
SED
CLC
CLC
DEY
DEY
LDA
LDA
ADC
ADC
STA
STA
TYA
TYA
BNE
BNE
CLD
CLD
RTS
ATS

:MAKE
:MAKE ALL ARITHMETIC
ARITHMETIC DECIMAL
DECIMAL
:CLEAR
,CLEAR CARRY
CARRY TO
TO START
START
($40),Y
($40).Y
($42).Y
($42).Y
($40).
($40).Y

;GET
:GET 2 DECIMAL
DECIMAL DIGITS
DIGITS FROM
FROM STRING
STRING 1
;ADD
:ADD PAIR
PAIR OF
OF DIGITS
DIGITS FROM
FROM STRING
STRING 2
:STORE
;STORE RESULT
RESULT IN
IN STRING
STRING 1

DECADD
DECADD
;RETURN
;RETURNTO
TO BINARY
BINARY ARITHEMETIC
ARITHEMETIC MODE
MODE

1515-16

TOTAL D O C U M ENTATION
TA TIO N
Complete documentation
documentation of microprocessor software will
ill in­
include all or most of the elements that
that we have
have mentioned. So.
So.

DOCUMENTATION
DOCUMENTATION
PACKAGE
PACKAGE

the total documentation package
package may involve:
• General flowcharts
• A writtenn description
description of the program
program
• A list of all parameters and definitions
• A memory map
map
• A documented listing of the program
program
• A description
description of the testt plan
plan and test results
results
The documentation may also
also include:
include:
• Programmers'
Programmers' flowcharts
• Data flowcharts
• Structured programs
programs
The documentation procedures
procedures outlined above are the minimal acceptable set of
documents for non-production
non-production software. Production
Production software demands
demands even
greater documentation efforts. The following
following documents
documents should also be produced:
• Program Logic Manual
• User's Guide
• Maintenance
aintenance Manual
The program
program logic manual expands on the writtenn explanation produced
produced with the
ritten for a technically
technically competent
competent individual
individual who
who may not
software. It should be written
possess the detailed knowledge
knowledge assumed 1n
in the written
ritten explanation
possess
explanation in the software.
algorithms
The program logic manual should explain the system's design goals,
goals. the algorithms
used,
hat tradeoffs
tradeoffs were necessary.
used. and what
necessary.
hat data structures
structures were employed and how they
It should then explain in great detail what
are manipulated.
manipulated. It should provide a step-by-step
step-by-step guide to the operations
operations of the pro­
program. Finally,
contain any special tables or graphs that help explain the propro­
Finally. it should contain
gram. Code conversion
conversion charts.
charts, state diagrams.
diagrams, translation
translation matrices.
matrices, and flowcharts
flowcharts
should be included.

The User's guide
guide is probably the most important and most overlooked piece of
atter how well
e l a system is designed,
documentation. No matter
designed, it is useless if no one
can take advantage of its features. The User's guide should introduce
introduce the system to
sophisticated and unsophisticated.
unsophisticated. It should
should then provide
provide detailed
detailed explanaexplana­
all users,
users. sophisticated
features and their
their use.
Frequent examples will
ill help to clarify
clarify the points
points
tions of system features
use. Frequent
in the text. Step-by-step
Step-by-step directions
directions should be provided (and tested!).
testedl). Programmers with
ith
detailed knowledge
knowledge of a system often take shortcuts
shortcuts that
that the general reader cannot
cannot
detailed
follow. Further
Further discussion
discussion of the writing
ritin g of User's guides is beyond the scope of this
follow.
book. However.
However, remember
remember that
that you can never spend too much effort
effort in preparing
preparing a
guide, since it will
ill be the most frequently
frequently referenced system document.
document.
User's guide.
The maintenance manual is designed for the programmer who has to modify the
should outline
outline step-by-step
step-by-step procedures
procedures for those reconfigurations
reconfigurations designed
system. It should
into the system. In addition.
addition, it should describe
describe any provisions
provisions built
u ilt into
into the program
program for
into
future expansion.
future
taken lightly or postponed until the end of the softft­
Documentation should not be taken
ware development. Proper documentation, combined with
ith proper programming
ware
programming
practices, is not only an im portant part of the final product but can also make
development simpler, faster, and more productive. The designer should make concon­
development
sistent and thorough documentation part of every
every stage of software
are development.
sistent
15
15-177

REDESIGN
Sometimes the designer
designer may have to squeeze the last microsecond of speed or
Sometimes
the last byte of extra memory
program. As larger single-chip
memory out of a program.
single-chip memories
memories have
available, the memory
memory problem
problem has become less serious. The time
time problem,
problem, of
become available.
course. is serious only if the application
course,
application is time-critical:
e-critical; in many applications
applications the
microprocessor spends most of its timee waiting
aiting for external
external devices.
devices, and program
program speed
microprocessor
is
major factor.
1s not a major
Squeezing the last bit of performance out of a program is
Squeezing
seldom as important
portant as some writers
rite rs would
would have you believe.
believe.
In the firstt place, the practice is expensive
expensive for the follow
ing
following
reasons:
reasons:
1)
1)
2)

COST OF
REDESIGN

It requires extra programmer
programmer time, which
which is often the single
single largest cost in software
software
development.
development.
It sacrifices
sacrifices structure
structure and simplicity
plicity with
ith a resulting
resulting increase in debugging
debugging and
testing time.
testing

3)

The programs
programs require extra documentation.
documentation.

4)

The resulting
resulting programs
programs will
ill be difficult
ifficu lt to extend, maintain.
maintain, or re-use.
re-use.

In the second place, the lower
lower per-unit
per-unit cost and higher performance may not really
be important. Will
ill the lower cost and higher
higher performance
performance really sell more units? Or
would
would you do better
better with
ith more user-oriented
user-oriented features? The only applications that
would seem to justify
stify the extra effort
effort and time are very high-volume,
high-volume, low-cost
low-cost
and low-performance
low-performance applications where the cost of an extra memory chip will
ill far
outweigh
outweigh the cost of the extra software
are development.
development. For other applications,
applications, you
will
ill find that
that you are playing
playing an expensive
expensive game for no reason.
reason.
However, if you must redesign a program,
ing
However.
program, the following
MAJOR
MAJOR OR
hints will
ill help.
determine how much more
help. First, determine
more perfor­
perforMINOR
MINOR
mance or how much less memory usage
usage is necessary. If
REORGANIZATION
REORGANIZATION
the required improvement
improvement is 26¾
25% or less,
less, you may be
able to achieve it by reorganizing the program.
25%, you have
program. If it is more than 26%,
made a basic design error; you will
ill need to consider drastic changes in hardware
or software.
software. We will
ill deal first with
ith reorganization
reorganization and later with
ith drastic changes.
Note particularly
particularly that saving memory can be critical
critical if1fit allows a program to fit into the
limited amount
amount of ROM
one-chip or two-chip
o-chip microcomicrocom­
limited
ROM and RAM available in a simple one-chip
puter. The hardware
for small systems can thus be substantially
reduced. if their
hardware cost for
substantially reduced,
their
requirements
to the
the memory size
size and I/O
1/0 limitations
particular
requirements can be limited
ited to
itations of that particular
one-chip or two-chip
o-chip system.
one-chip

15-188
15-

REORGANIZING TO USE
USE LESS
LESS M EMORY
The following procedures
procedures will reduce
reduce memory usage
usage for 6502
assembly language
language programs:
programs:

SAVING
MEMORY
MEMORY

1) Replace
Replace repetitious
repetitious in-line
In-line code
code w
with subroutines.
subroutines. Be
Be
1)
sure,
sure, however, that
that the Call
Call and Return
Return instructions
instructions do not offset most of the
the gain.
gain.
Note that this
replacement usually results in
this replacement
In slower programs because
because of the time
spent in transferring
transferring control
control back and forth.
2)

Place
Place the
the most
most frequently
frequently used
used data
data on
on page
page zero
zero and
and access
access itit w
with oneonebyte addresses.
ant to place a few I/O
there.
1/0 addresses
addresses there
addresses. You may even want

3)
atically updated
Use the
the Stack
Stack when
when possible.
possible.The
The Stack
Stack Pointer
Pointer isIs autom
automatically
updated after
after
3) Use
each use so that no explicit
explicit updating
updating instructions
instructions are necessary.
necessary. Remember,
Remember.
however,
however. that the 6502 Stack can never be longer than one page.
page.
4) Eliminate
Eliminate Jump
Jump instructions.
instructions. Try
Try to
to reorganize
reorganize the
the program
program instead.
instead.
5)
5)

8-bit quantities.
Take advantage of addresses that you can manipulate as 8-bit
addresses that are multiples
example.
These include
include page zero and addresses
ultiples of 10015
1 6- For example,
you might
ight try to place all ROM
6-byte section of memory,
ROM tables in one 100 115-byte
memory. and
all RAM variables into another lO O
ig-byte section.
10015-byte

6)

Organize data
data and
and tables
tables so that so
can them
address
them w
ith o u t worrying
Organize
youthat
can you
address
without
worrying
about address calculation carries
o u t any
This w
willill
carriesororw ith
without
anyactual
actual indexing.
indexing.This
again allow you to manipulate
manipulate 16-bn
16-bit addresses
-b it quantities.
quantities.
addresses as 8-b,t

7)
7)

Use the Bit Test
Test or Shift instructions to operate on bit positions at either
either end
of a word.

8
B) Use
Use leftover
leftover results
results from
from previous
previous sections
sections of
of the
the program.
program.
9) Take
Take advantage
advantage of
of such
suchinstructions
instructions as
as ASL,
ASL, DEC,
DEC, INC,
INC, LSR,
LSR, ROL,
ROL,and
and ROR,
ROR,

o u t using registers.
which operate directly on memory locations w ithout
10)
10)

Use INC
INC or
or DEC
DEC to
to set
set or
or reset flag
reset
Use
bits.flag bits.

11)
11)

Use relative
relative jumps
jumps rather
rather than jumps
thanwith
jumps
w ithaddressing.
direct addressing.
Use
direct

12)
12)

Use BRK,
BRK, RTS, and RTI to perform jumps and reach subroutines, if they are
not already being used.
instructions can act as one-byte
one-byte CALL instructions
instructions
used. These instructions
if the required data and addresses are already in the Stack.
Stack.

13)

Watch
atch for special short forms of instructions such as the Accum
ulator shifts
shifts
Accumulator
(ASL A,
A. LSR
LSR A,
A. ROL
AOL A, and ROR
ROA A) and BIT.
BIT.

14)

rather than tables to calculate
calculate arithm
etic or logical
logical expressions
Use algorithms rather
arithmetic
perform code conversions. Note that this replacement
replacement may result in slower
and to perform
programs.

15)

Reduce the size of mathematical
mathematical tables by interpolating
interpolating between
between entries. Here
again, we are saving memory
memory at the cost of execution
execution time.
again.

16)

advantage of the CPX and CPY instructions to perform comparisons
Take advantage
comparisons
w ith
o u t involving the Accumulator.
ithout

that reduce memory usage also
SAVING
Although some of the methods that
SAVING
time, you can generally
generally save an appreciable amount of
save time,
EXECUTION
concentrating on frequently
frequently executed
executed loops.
TIME
time only by concentrating
loops. Even
TIME
completely elim
inating an instruction
instruction that
that is executed
executed only once
completely
eliminating
microseconds. But
But a savings
savings in a loop that
that is executed
executed frefre­
can save at most a few microseconds.
quently will
ill be multiplied
ultiplied many
many times
times over.
quently

15
-1 9
15-19

So,
So. if you must reduce execution time, proceed as follows:

1)
1) Determine
Determine how
how frequently
frequently each
each program
programloop
loopisisexecuted.
executed. You
You can
can do
do this
this by
by
hand or by using the software
software simulator
ulator or another
another testing
testing method.
2) Examine
Examine the
the loops
loops in
in the
the order
order determined
determined by
by their
their frequency
frequency of
of execution,
execution,
starting with
ith the most frequent. Continue
Continue through
through the list until
until you achieve the re­
starting
required reduction.
3) First,
First, see
see ifif there
there are
are any
any operations
operationsthat
that can
can be
be moved
moved outside
outside the
the loop,
loop,i.e..
i.e .
repetitive calculations,
calculations, data that
that can be stored in a register or on the Stack, data or
repetitive
addresses that
that can be stored on page zero,
that can be
zero. special cases
cases or errors that
ill require extra initialization
initialization and memory
handled elsewhere,
elsewhere. etc. Note that this will
ill save time.
but will
4) Try
Try to
to eliminate
eliminate Jump
Jump statements.
statements. These
These are
are very
very time-consuming.
time-consuming.
5) Replace
ith in-line
ill save
Replacesubroutines
subroutineswwith
in-linecode.
code.This
This wwill
saveat
at least
leastaaCall
Call and
and aaReturn
Return
instruction.
instruction.

6) Use
Use page
page zero
zero for
for temporary
temporary data
data storage.
storage.
7) Use
Use any
any of
of the
the hints
hints mentioned
mentioned in
insaving
saving memory
memory that
that also
alsodecrease
decrease execu­
execution time. These include
include the use of 8-bit
-b it addresses,
addresses. BRK,
BRK. RTI,
RTI. special short forms
of instructions.
instructions, etc.
etc.
8) Do
Do not
not even
even look
look at
at instructions
instructions that
that are
are executed
executed only
only once.
once. Any
Any changes
changes
instructions only invite
invite errors for no appreciable
appreciable gain.
that you make in such instructions
9) Avoid
Avoid indexed
indexed and
and indirect
indirect addressing
addressingwhenever
whenever possible
possible because
because they
they take
take
extra lime
time.

10)
Usetables
tables rather
ratherthan
thanalgorithms;
algorithms;make
makethe
the tables
tables handle
handle as
asmuch
much of
of the
the tasks
tasks
10) Use
as possible even if
1f many entries must be repeated.
repeated.

15-200
15

M AJOR
R REORGANIZATIONS
If you need more than a 26%
25% increase in speed or decrease in memory usage,
usage, do
not try reorganizing the code. Your chances of getting that
that much of an improveimprove­
ment are small unless you call in an outside expert.
expert. You are generally better
better off
ment
making a major change.
change.
The most obvious change is a better
better algorithm. Particularly
Particularly if11
BETTER
BETTER
you are doing sorts,
athematical calculations.
calculations, you
sorts. searches,
searches. or mathematical
ALGORITHMS
ALGORITHMS
may be able to find a faster or shorter method in the iltera
literature.
ure
algorithms are available in some journals
journals and from
Libraries of algorithms
'rorn professional groups. See,
See.
for example,
example. the references at the end of this chapter.
software. Couo
Counters,
shift registers,
More hardware can replace some of the software.
ers. shift
registers.
arithm
etic units.
units, hardware multipliers.
multipliers, and other fast aod-c;rs
add-ons ::a
can save both time and
arithmetic
memory. Calculators.
Calculators, UARTs,
add-ons may save
UARTs. keyboards,
keyboards. encoders,
encoders. and other
e· slower
01,e add-ons
though they operate slowly. Compatible
Compatible oaral
parallel and
septal interfaces.
interfaces, and
memory even though
ano se•,a
specially designed for use with
ith the 6502
6502 or 6800. ma'
may save tim
other devices specially
t,me by tak­
taking some of the burden off the CPU.
CPU.
ell:
Other changes may help as well:

OTHER
MAJOR
CHANGES

1)
1)

A CPU with
ith a longer word will
ill be faster
faster if11the data ,s
is :ng
eng
ill use less total memory
16-b’t- :·;r
pro­
enough. Such a CPU
CPU will
memor,, • 6-t
cessors,
fficiently ~3
than 8-o
8-bit•
cessors. for example,
example. use memory more e14c
processors,
their ns ruct
instructions
one word
long.
processors. since more of their
O"S are
a<e ore
Nora ·Iong

2)
2)

Versions
Versions of
of the
the CPU
CPU may
may exist
exist that
that operate
operate at
at higher
higher clock
clock rates.
rates. But
But remem­
remember that you will
ill need !as
faster riernor,
memory and 1
I/O
ill have to adjust any
0 ports,
ports. and you will
delay loops.

3) Two
Two CPUs
CPUs may
may be
be able
able to
to do
do the
the job
job in
in parallel
parallel or
or separately
separately ifif you
you can
can divide
divide
the job and solve the comm
unications problem.
communIcatIons
4)

AA specially
specially microprogrammed
microprogrammed processor
processormay
may be
be able
able to
to execute
execute the
the same
same pro­
program much
much faster. The cost,
ill be much higher
higher even if you use an offcost. however,
however. will
the-shelf
emulation.
he-she'f emulation

5)

You can make tradeoffs
tradeoffs between
between time and memory. Lookup tables and function
function
ROMs
algorithms, but will
ill occupy
occupy more memory.
ROMs w ill be faster than algorithms.

------

This kind of problem, in which a large improvement
improvement is necesneces­
DECIDING
sary, usually results from lack of adequate planning
MAJOR
ON A MAJOR
planning in the
definition and design stages. In the problem definition stage
CHANGE
CHANGE
you should
determine which processor and methods will
ill be
should determine
ill be high.
adequate to handle
handle the problem. If you misjudge, the cost later will
high. A
cheap solution may result in an unwarranted
unwarranted expenditure
expenditure of expensive
expensive developdevelop­
ment time. Do not try to just get by; the best solution is usually to do the proper
design and chalk a failure up to experience. If you have followed
ed such methods as
flowcharting,
charting, modular programming,
top-down design,
programming, structured programming,
programming, top-down
design,
proper documentation,
documentation, you
you willill be able to salvage
salvage a lott of your
your effort
effort even
even if
and proper
have to make
make a major
major change.
you have

15-21

REFERENCES
REFERENCES
1.

Collected Algorithm
from ACM. ACM.
ACM, Inc.,
0. Box 12105.
12105, Church
Church Street
Street StaSta­
Collected
Algorithmss from
.. P. 0.
tion, New
New York
York 10249.
tion.

2. T.
atic Computation
Computation of
2.
T. C.
C. Chen,
Chen. "A utom
"Automatic
of Exponentials,
Exponentials. Logarithms,
Logarithms. Ratios,
Ratios. and
and
Roots," IBM Journal
Journal of Research
Development, Volume
Volume 18.
18, pp.
Square Roots."
Research and Development.
380-388, July.
July, 1972.
197Z
380-388.
3. H.
putation, Wiley-lnterscience,
H. Schmid,
Schmid. Decimal
Decimal Com
Computation.
Wiley-lnterscience. New
New York,
York. 1974.
1974.
rt of
4. D.
D. E.
E. Knuth,
Knuth. The
The AArt
of Computer
Computer Programming.
Programming. Volume
Volume 1:
1: Fundamental
Fundamental
Algorithms. Addison-Wesley.
Addison-Wesley, Reading. Mass.,
Algorithms.
.. 1967.
rt of
5. D.
D. E.
E. Knuth,
Knuth. The
The AArt
of Computer
Computer Programming,
Programming. Volume
Volume 2:
2: Seminumerical
Seminumerical
Algorithms. Addison-Wesley.
Addison-Wesley, Reading.
Reading, Mass.,
Algorithms.
.. 1969.
rt of
6. D.
D. E.
E. Knuth,
Knuth. The
The AArt
of Computer
Computer Programming,
Programming. Volum
Volume 3:
3: Sorting
Sorting and
and Search­
SearchAddison-Wesley, Reading,
ing. Addison-Wesley.
Reading. Mass.,.. 1973.
7. B.
ethods, W
iley, New
B. Carnahan
Carnahan et
et al..
al.. Applied
Applied Numerical
Numerical M
Methods.
Wiley.
New York,
York. 1969.
1969.
8. A.
A. M.
M. Despain,
Despain. "Fourier
"Fourier Transform
Transform Computers
Computers Using
Using CORDIC
CORDIC Iterations,"
Iterations." IEEE
IEEE
Transactions on Computers.
Computers, October
October 1974,
993-1001.
Transactions
1974. pp. 993-1001.
9. Y.
atical Functions.
Y. L.
L. Luke,
Luke. Algorithm
Algorithmss for
for the
the Computation
Computation of
of M athem
Mathematical
Functions. Academic
Academic
Press,
Press. New York,
York. 1977.
10.
etic, W
iley, New
10. K.K.Hwang,
Hwang. Computer
Computer Arithm
Arithmetic.
Wiley.
New York,
York. 1978.
1978.
11.
etic operations
11. New
New methods
methods for
for performing
performing arithm
arithmetic
operations on
on computers
computers are
are often
often dis­
discussed in the triennial
triennial Symposium on Computer
Computer Arithm
etic. The Proceedings
Arithmetic.
ith 1969) are available from the IEEE
Computer Society,
(starting with
IEEEComputer
Society. 5855 Naples
Plaza,
Plaza. Long Beach,
Beach. CA 90803.
12.
puter Number
12. A.
A. D.
D. Edgar,
Edgar. and
and S.
S. C.
C. Lee,
Lee. "FOCUS
"FOCUS M icrocom
Microcomputer
Number System,"
System," ComCommunications of the ACM. March 1979,
munications
1979. pp. 166-177.
--

15-22
1522

Chapter 16
SAMPLE PROJECTS
PROJECTS
PROJECT
1 : A Digital Stopwatch
PROJECT #1:
STOPWATCH
Purpose:
project is a digital
stopwatch. The operator
operator enters
Purpose: This project
STOPWATCH
d1g1tal stopwatch.
INPUT
two digits
digits (minutes and tenths
tenths of minutes) from a
PROCEDURE
calculator-like keyboard and then presses
PROCEDURE
calculator-like
presses the GO
GO key.
key.
The system counts
counts down
down the
remaining time on two
the remaining
seven-segment LED
Chapter 11
description of unencoded
seven-segment
LED displays (see
(see Chapter
11 for a description
nencoded
keyboards and LED
LED displays).
Hardware: The project
project uses one input
input port and one output
output port (one 6522 Versatile
Versatile In­
Hardware:
Interface Adapter
Adapter or VIA),
seven-segment displays, a 12-key keyboard,
in­
VIA). two seven-segment
keyboard. a 7404 inverter,
either a 7400 NAND
depending on the polarity
polarity of
verter. and either
NANO gate or a 7408 AND gate,
gate. depending
o:
the seven-segment
seven-segment displays. The displays may require drivers.
drivers, inverters.
inverters, and resistors,
resistors.
depending on their
their polarity
polarity and configuration.
configuration.
depending
The hardware
hardware is organized as shown in Figure 16-1,
utput lines 0,
16-1. Output
0. 1,
1. and 2 are used to
scan the keyboard. Input
Input lines 0,
determine whether
whether any keys
0. 1.,22., and 3 are used to determine
have been pressed.
utput lines 0,
digits to the sevenpressed. Output
0. 1,
1. 2, and 3 are used to send BCD digits
segment decoder/drivers.
decoder/drivers. Output
utput line 4 is used to activate
activate the LED
displays (if line 4 is
segment
LED displays
'1', the displays
displays are lit). Output
utput line 5 is used to select the left or right
right display.
display, output
output
T.
'V if the left display
display is being used,
right display
display is
line 5 is T
used. '0'
·o·if the right
Is being used. Thus,
Thus.
the common
common line on the left display
display should be active
active if
V. while
while
11line 4 is
,s ‘ 1’ and line
hne 5 is
Is 1'
common line on the right
right display
display should be active
active if
the common
1f line
Ine 4 is
Is '1'
1· and line 5 is
Is 'O'.
·o·.
Output
utput line 6 controls
controls the right
right hand decimal
decimal point
point on the left display. It may be driven
with
ith an inverter
inverter or simply
simply left on.

Keyboard Connections: The keyboard is
calculator keyboard available
available for
Is a simple
simple calculator
50<( from a local source. It consists
consists of 12 unencoded
unencoded key-switches
key-switches arranged in four rows
50¢
columns each. Since the wiring
iring of the keyboard does not coincide
coincide with
ith the obob­
of three columns
served rows and columns.
columns, the program
program uses a table to identify
identify the keys. Tables 16-1
16-1
and 16-2 contain
contain the input
input and output
output connections
connections for the keyboard. The decimal
decimal point
point
present for operator
operator convenience
convenience and for future
future expansion:
expansion; the current
current program
program
key is present
actually use-the key.
does not actually
actual application.
application, the keyboard
keyboard would
would require pullup
pullup resistors to ensure that
that the
In an actual
inputs would
would actually
actually be read as logic
logic Ts
'1's when
when the keys were
were not being pressed. It
inputs
would also require
require current-lim
iting resistors or open-collector
open-collector drivers
drivers on the output
output port
would
current-lim1tIng
damaging the VIA drivers
drivers In
in the case where
where two outputs
outputs were driving
driving against
against
to avoid damaging
could occur
occur if twoo keys in
in the same row were
were pressed at the same time.
time,
each other. This could
thus connecting
connecting two
two different
different column
column outputs.
outputs.
thus

1 6-1

PB7 -(not
PB5

used)

OutputPB5
Port PB4
(VIA PB3
Port s1P8 2
PB1
PBo

''

u

"

Coc, C2
PA3
Input PA
2
Port
(VIA PAi
Port Al
PAo

-

-

R3

--

R2

K■vboard

R1

If

I

tt

• t

Co D1 D2 D3

' ,' "

Do D1 D2 D3

DP
Display
and
Driver

Oioplay
and
Driver

(left)

(right)

Common

Common

'I

•

Ro

~

ITn

1/0 Configuration
Figure 16-1. I/O
Configuration for a Digital
Digital Stopwatch
Stopwatch

Keyboard
Table 16-1. Input Connections
Connections for Stopwatch
Stopwatch Keyboard
Input
Input Bit

Keys Connected
Keys

0
1
2
3

·3·_ '5'.
·5·, '8'
·a·
•3',
·2·. '6',
'6', ’9'
·9·
■2',
·o·.T.
'7'’
’O’,
'1', 7
'GO'
4'. '.', 'GO'

16-2. Output
Keyboard
Table 16-2.
utput Connections
Connections for Stopwatch
Stopwatch Keyboard
Output
utput Bit

Keys Connected
Keys

0
1
2

·o·.'2',
·2·. '3',
·3·, '4'
·4·
'O',
'1'., '8',
'8'. '9',
'9'. 'GO'
'GO'
T
'5', '6'.
'6', 7'7',\ '.'
'.'
'5'.

16-2
16

G e neral P ro gram F lo w
c h a r t:
lowchart:
Start

Initialization

ldent,fv
l<eyclosure

Save key value

Count time on LEDs

End

Display Connections: The displays are
are standard seven-segment displays with their
their
own integral decoders.
decoders. Clearly,
Clearly. undecoded seven-segment
seven-segment displays would be cheaper
but would require some
additional software (the
some additional
(the seven-segment conversion routine
shown in Chapter 7).
7). Data
Data is
is entered into the
the display as
as a single binary coded decimal
digit; the
digit
the digits are
are represented as
as shown in Figure 11
11-22. The decimal point is
is a single
LED
LED that
that is
is turned on
on when the decimal point input is a logic '1'.
'1'. You can find more
more in­
information
formation about
about displays in References
References 12
12 and
and 13
13 at the
the end
end of this chapter.
chapter.

16
16-3

P ro gram D e s c r
ip tio n :
cription:

program is modular
odular and uses several subroutines.
subroutines. The emphasis
emphasis is on clarity
clarity and
The program
generality rather
rather than
than efficiency;
efficiency: obviously.
obviously, the program
program does not utilize
utilize the full
full
generality
capabilities of the 6502
6502 processor. Each section
section of the listing
listing will
ill now
now be described
described in
capabilities
detail.

1)

Introductory
Introductory Comments
The introductory
introductory comments
comments fully
lly describe
describe the program;
program; these comments
comments are a
that other
other users can easily apply, extend,
extend, and understand
understand the propro­
reference so that
gram. Standard
Standard formats, indentations,
indentations, and spacings
spacings increase the readability
readability of the
program.

2)

Definitions
Variable Definitions
Allll variable
variable definitions
definitions are placed at the start
start of the program
program so that
that they can easily
be checked
checked and changed. Each variable
variable is placed in a list alphabetically
alphabetically with
ith other
comments describe
describe the meaning
meaning of each variable. The
variables of the same type; comments
categories are:
categories
a)
a)

Memory system constants
constants that may vary from system to system depending
depending on
Memory
memory space allocated
allocated to different
different programs
programs or types of memories
the memory

b)
b)

Temporary storage (RAM)
Temporary
(RAM) used for variables

c)

I/O
1/0 (VIA)
(VIA) addresses

d)

Definitions
Definitions

The memory
memory system constants
constants are placed in the definitions
definitions so that
that the user may
temporary storage,
o u t making any
relocate the program, temporary
storage. and memory stack w ith
ithout
constants can be changed
changed to accommodate
accommodate other
other changes. The memory constants
coincide with
ith a particular
particular system's allocation
allocation of ROM
ad­
programs or to coincide
ROM and RAM addresses.
dresses.
Temporary storage is allocated
allocated by advancing
advancing the location
location counter
counter as shown in
Temporary
— (Equate)
pseudo-operation names the temporary
temporary storage
Chapter 3.
3. An =
(Equate) pseudo-operation
locations. An ORG
pseudo-operation places the temporary
temporary storage
ORG (origin) pseudo-operation
locations in a particular
particular part of memory. No values are placed in these locations
locations so
so
that the program could eventually
eventually be placed in ROM
ROM or PROM
PROM and the system
could be operated from power-on
power-on reset without
ithout reloading.
Each
occupied by a VIA is named so that the addresses can
Each memory address occupied
easily be changed to handle varied configurations.
configurations. The naming also serves
serves to
clearly distinguish
distinguish control
control registers from data registers.
The definitions
definitions clarify
clarify the meaning of certain constants
constants and allow parameters to
be changed easily.
definition is given in the form
easily. Each
Each definition
form (binary, hex,
hex, octal, ASCII,
ASCII, or
decimal) in which
which its meaning is the clearest. Parameters (such as debounce
debounce time)
time)
are
are placed here so that they can be varied with system needs.
needs.
3)
3)

Initialization
Initialization
Memory locations FFFC
FFFC and FFFD
FFFD (the 6502 RESET
RESETlocations) contain the
the starting
starting
address of the
anywhere in
the main program.
program. The main program can thus
thus be placed anywhere
memory and reached via a "RESET"
"RESET" signal.
signal.
The initialization
initialization consists of three steps:
steps:
a)
starting value in the Stack
a) Place
Place aa starting
Stack Pointer
Pointer. The Stack is used only
only to store
store
subroutine return addresses.
subroutine
addresses. Note that
that the Stack Pointer
Pointer is
is only 8 bits
bits long
since the 6502 Stack is
is always
always on page
page one of
of memory.
b)
Configure the
b) Configure
the VIA.
VIA.
c)
c)

Start the number of
of digitit keys
keys pressed
pressed at
at zero.
zero.

16-4
16-4

4)
4)

Look
Look for Key Closure
Closure
Flowchart:
Start

Ground all keyboard
columns

End

Key closures are identified
identified by grounding
grounding all the keyboard columns
columns and
ano then
:'1en
checking for grounded
grounded rows (i.e.,.. colum
n-to-row switch
switch closures
closures). Note
checking
column-to-row
o·e •that
a; thee
program does not assume that the unused input
input bits are all n,g
high: nstead,
eao. ithee bits
ith a log,ca
logical AND
nstruction
'!) ns•·uc
o
attached to the keyboard are isolated with
5)

Debounce Key
The program debounces the key closure
software
aiting for two millise·
illise­
c,osure Iin so'
Nare by wa111ng
conds. This is usually
usually long enough fa
for a clean contact
contact to be made.
Subroutine
made. Subroutine
DELAY
counts with
ith Index Reg,s
Register X 'or
for one millisecond.
number of milliilli­
DELAY counts
m1llisecond. The number
seconds is in Index Register Y. DELAY would
would have to be adjusted if a slower
slower clock
or slower memories were being used. You could make the change simply
simply by
redefining the constant
constant MSCNT
MSCNT.
redefining

1 6-5

6)

Identify Key Closure
Identify
Closure

Flowchart:

(

Start

)

~ZET

KeyTable Index = -1
KeyTable
Keyboard Output =
fe
16 = 1 1 1 1
110 2
FE15
111102

Yes

Key Table Index =
Key
Key Table Index +
+
NROWS
NROWS
Shift Keyboard
Shift
Output left 1 bit

Key Table Index =
=
Key Table Index +
+1
Shift
hift keyboard input

Key T a b l e ^ ^ ^
■ ^ ^ In d e x = K L A S T ^ ^
T lY e s

^LY es

Key ID== (KTAB +
+

Key ID
10 = Error
Error code

Key Table Index)

C

End

particular key closed is identified
identified by grounding
grounding single
single columns
columns and observing
observing
The particular
whether a closure is found.
found. Once a
closure is found
found (so the key column
column is deterdeter­
whether
q closure
mined), the key row can be determined
determined by shifting
shifting the input
input until
until a grounded
grounded bit
mined).
is found.
found.
output patterns
patterns required
required to ground
ground single
single keyboard
keyboard columns
columns are obtained
obtained by
The output
shifting the original
original pattern
pattern left one bit
bit after
after each column
column is examined.
examined. The highhigh­
shifting
est numbered
numbered key in the keyboard
keyboard is used as a marker
marker to indicate
indicate that
that all the colcol­
grounded w ith
o u t a closure
closure being found. When
hen this value is
umns have been grounded
ithout
reached,
ulator to indicate
reached. the error code FF
FF is placed in the Accum
Accumulator
indicate to the main
program that
that the closure
closure could
could not be identified
identified (ie
(i.e.,.. the key closure
closure ended or a
program
hardware error occurred).
occurred).
hardware
identifications are in table KTAB in memory. The
KEY
The key identifications
keys in the first
first column
column (attached
(attached to the least significant
significant outoutTABLE
followed by those in the second column.
column, etc.
put bit) are followed
Within
ithin a column.
column, the key in the row attached
attached to the least significant
significant input
input bit is
first, etc. Thus, each time a column
column is scanned w ith
o u t finding
finding a closure.
closure, the numnum­
first.
ithout
column (NROWS)
must be added to the key table index in order to
ber of keys in a column
(NROWS) must
column. The key table index is also incremented
incremented before each bit
move to the next column
in the row inputs
inputs is examined;
examined; this process stops when
when a zero input
input is found.
found. Note
in
that the key table index is initialized
initialized to -1,
always incremented
incremented once in
that
-1. since it is always
the search forr the proper
proper row.
If we cannot
cannot identify
identify the key closure.
closure, we simply
simply ignore it and look for another
another
closure.
1 6-6

■

7)

Act
ct on Key
Key Identification
Identification
If the program
easel. it looks only for the GO
GO
program has enough digits
digits (two in this simple case),
key and ignores all other
keys. If it finds a digitit key,
key, it saves
saves the value in the key ar­
arother keys.
ray, increments
pressed, and increments
increments the number
number of digit
ig it keys pressed,
increments the key array
pointer.
If the entry
end so
so
entry is not complete,
complete, the program must waitit for the key closure to end
that
that the system will
ill not read the same closure again. The user must waitit between
key closures (i.e..., release one key before pressing another
proanother one).
one). Note that the pro­
gram will
other. depending
on
ill identify
identify double
double key closures as one key or the other,
depending on
which
hich closure the identification
identification routine
routine finds first. An improved version of this
program
program would
would display
display digits
digits as they were entered and would
would allow the user to
omitit a leading or trailing
trailing zero.
"7", "GO” too get a count
count of sevenzero, (i.e.,
(i.e., key in",", "7",
tenths
tenths of a minute).

8))

Set
Set Up Display Output
Output
The digits
b,1 4 set
se· s:i
·~a- the output
Is sent
digits are placed in memory locauons
locations w,ithh bit
so that
output is
to the displays. Sits
',car• d'.l;;
Bits 5 and 6 are set for the most s,gr
significant
ig it, to direct
direct the outout­
put
n; _=I)
put to the left display
display and to light
light the dee.ma
decimal oo
point
LED

9)

Pulse the LED Displays
Each display
display is turned
turned on for two milliseconds
milliseconds. -h
Thiss process
repeated
orocess is
•s reoea
ed 1500
times in order
-,.,e o ...
sss are fre­
freorder to get a total
total delay of 0.1 minutes, or 6 seconcs
seconds The
pulses
quent
LED displays
o s
quent enough
enough so that
that the LED
displays appear to be lit c:i~- contmuously

1 6 -7
16-7

10)
10)

Decrement Display Count
Decrement
Flowchart:
Start

Right Display = Right
Display - 1

No

End

left Display =
Left Display - 1

Vas

Right Display

End of timer

=9

program

End

The value of the less significant
significant digitit is reduced by one.
affects bit 4
one. If this affects
(LEDON
(LEDON-— used to turn the displays on),
on). the digitit has become negative. A borrow
obtained from the more significant
significant digit.
digit. If the borrow
borrow from the more
must then be obtained
significant digitit affects bit 4,
count has gone past zero and the countdown
countdown is
4. the count
significant
significant digit
ig it to 9
finished. Otherwise, the program sets the value of the less
less significant
and continues.
Note that comments
comments describe both sections of the program and individual
individual statements.
The comments
comments explain what
hat the program is doing, not what
what specific
specific instruction
instruction codes
do. Spacing and indentation
indentation have been used to improve readability.
readability.

1 6-8
8

NAME: STOPWATCH
STOPWATCH
;PROGRAM NAME:
PROGRAM:4/28/79
:DATE OF PROGRAM:4/28/79
:PROGRAMMER: LANCE A. LEVENTHAL
:PROGRAM REQUIREMENTS:
REQUIREMENTS: DD(221) BYTES
BYTES
;RAM REQUIREMENTS:
REQUIREMENTS: 5 BYTES
BYTES
I/O REQUIREMENTS:
6522 VIA)
:1/0
REQUIREMENTS: 1 INPUT PORT.
PORT, 1 OUTPUT PORT (1 6522

STOPWATCH THAT ACCEPTS INPUTS FROM A
:THIS PROGRAM IS A DIGITAL STOPWATCH
CALCULATOR-LIKE KEYBOARD AND THEN PROVIDES
COUNTDOWN
CALCULATOR-LIKE
PROVIDES A COUNTDOWN
TENTHS
; ON TWO 7-SEGMENT LED DISPLAYS IN MINUTES ANDTE
; OF MINUTES

:KEYBOARD

;A 12-KEY KEYBOARD IS ASSUMED
THREE COLUMN
COLUMN CONNECTIONS ARE OUTPUTS FROM
THE PROCESSOR
;THREE
FROM -rlE
PROCESSOR
THAT A COLUMN OF KEYS
; SO THAT
KEYS CAN BE GROUNDED
FOUR ROW CONNECTIONS ARE INPUTS TO THE PROCESSOR
;FOUR
PROCESSOR SO -THAT
; COMPLETED CIRCUITS CAN BE IDENTIFIED
IDENTIFIED
WAITING FOR
MILLISECONDS
__
SEC::: JS
:THE KEYBOARD IS DEBOUNCED BY WAITING
FOR TWO
; AFTER
AFTER A KEY CLOSURE
CLOSURE IS RECOGNIZED
RECOGNIZED
--=,--~JO
'E
:A NEW KEY CLOSURE
CLOSURE IS IDENTIFIED
IDENTIFIED BY WAITING
- G -~:.
FOR THE
OLD ONE
; TO END SINCE NO STROBE
STROBE IS USED
BiTS 0
;THE KEYBOARD COLUMNS
S ARE CONNECTED
,t:.:--=D X
-o) B-s
PORT
; TO 2 OF THE VIA B POW
ARE CONNECTED
tCEiJ TO BITS 0
;THE KEYBOARD ROWS A;,il:
; TO 3 OF THE VIA
~ POQVIA A
PORT
; DISPLAYS
TWO 7-SEGMENT LED DISPLAYS ARE USED WITH SEPARATE DECODERS
;TWO
DECODERS
7448 DEPENDING
; (7447 OR 7448
DEPENDING ON THE TYPE OF DISPLAY)
DATA INPUTS ARE CONNECTED
TO 3
:THE DECODER
DECODER DATA
CONNECTED TO BITS 0
OTO
; OF THE VIA B PORT
PORT
ACTIVATE THE LED
;BIT 4 OF THE VIA B PORT
PORT IS USED TO ACTIVATE
DATA TO LEDS)
; DISPLAYS (BIT 4 IS 1 TO SEND
SEND DATA
LEDS)
:BIT 5 OF THE VIA B PORT
PORT IS USED
USED TO SELECT
SELECT WHICH
; LED IS BEING
BEING USED
USED (BIT 5 IS 1 IF THE LEADING DISPLAY
; IS BEING
BEING USED,
USED, 0 IF THE TRAILING DISPLAY IS BEING
BEING USED)
USED)
;BIT 6 OF THE VIA B PORT
PORT IS USED TO LIGHT THE DECIMAL
; POINT LED ON THE LEADING DISPLAY (BIT 6 IS 1 IF
; THE DISPLAY IS TO BE LIT)
LIT)

;METHOD
STEP 1 - INITIALIZATION
INITIALIZATION
;STEP
: THE MEMORY STACK POINTER
POINTER (USED
(USED FOR
FOR SUBROUTINE
SUBROUTINE RETURN
RETURN
; ADDRESSES)
ADDRESSES) IS INITIALIZED. THE NUMBER OF DIGIT KEYS
KEYS PRESSED
PRESSED IS SET
SET
; TO ZERO
ZERO
STEP 2 - LOOK FOR
:STEP
FOR KEY CLOSURE
CLOSURE
COLUMNS ARE GROUNDED AND THE KEYBOARD ROWS
ALL KEYBOARD COLUMNS
ARE EXAMINED
EXAMINED UNTIL A CLOSED CIRCUIT IS FOUND

16-9

;STEP 3 - DEBOUNCE KEY CLOSURE
CLOSURE
; A WAIT
KEY BOUNCE
AIT OF 2 MS IS INTRODUCED TO ELIMINATE KEY
;STEP
CLOSURES
STEP 4 - IDENTIFY KEY CLOSURES
; THE
SINGLE KEYBOARD
KEYBOARD
THE KEY CLOSURE IS IDENTIFIED BY GROUNDING SINGLE
COLUMNS
KEY
COLUMNS AND
AND DETERMINING THE ROW AND COLUMN OF THE KEY
CLOSURE. A TABLE IS USED TO ENCODE
ENCODE THE KEYS
KEYS ACCORDING TO THEIR
THEIR
CLOSURE.
; ROW AND
AND COLUMN
COLUMN NUMBER
; IN THE KEY TABLE, THE DIGITS ARE IDENTIFIED
THEIR VALUES,
IDENTIFIED BY THEIR
: THE DECIMAL
KEY IS NO.
NO. 11
11
DECIMAL POINT KEY IS NO. 10, THE "GO"
"GO" KEY
;STEP 5 - SAVE KEY CLOSURE
CLOSURE
DIGIT KEY CLOSURES
CLOSURES ARE SAVED IN THE DIGIT KEY
KEY ARRAY UNTIL
TWO
BEEN IDENTIFIED.
IDENTIFIED. DECIMAL
POINTS. FURTHER
FURTHER DIGITS,
DIGITS.
TWO DIGITS HAVE
HAVE BEEN
DECIMAL POINTS,
AND
CLOSURES OF THE "GO"
BEFORE TWO
BEEN
AND CLOSURES
"GO" KEY BEFORE
TWO DIGITS HAVE BEEN
IGNORED
IDENTIFIED ARE IGNORED
BEEN FOUND,
FOUND. THE "GO"
KEY IS USED TO
AFTER TWO
TWO DIGITS HAVE BEEN
"GO" KEY
START THE COUNTDOWN
PROCESS
COUNTDOWN PROCESS
;STEP
LEDS
STEP 6 - COUNT DOWN
DOWN TIMER INTERVAL ON LEDS
A COUNTDOWN
PERFORMED ON THE LEDS
LEDS WITH THE LEADING DIGIT
DIGIT
COUNTDOWN IS PERFORMED
REPRESENTINGTHE REMAINING NUMBER OF MINUTES AND THE TRAILING
REPRESENTING
; DIGIT REPRESENTING
REPRESENTINGTHE REMAINING NUMBER OF TENTHS OF
OF MINUTES

:STOPWATCH
;STOPWATCH VARIABLE
VARIABLE DEFINITIONS
;MEMORY SYSTEM CONSTANTS
CONSTANTS
:MEMORY

=$0400
BEGIN
=$0400
STKBGN =$FF
=$FF
TEMP
=0
=0

;STARTING
FOR PROGRAM
;STARTING ADDRESS FOR
;STARTING STACK ADDRESS ON PAGE 1
;STARTING
;STARTING
FOR RAM STORAGE
STORAGE
;STARTING ADDRESS FOR

;RAM TEMPORARY STORAGE
;RAM
STORAGE

DCTR
KEYNO

*=TEMP
*=TEMP
*=
*+ 2
•=•+2
•=•+2
'=
'+ 2

NKEYS

•=•+1
*=
*+1

: 16-BIT COUNTER
COUNTER FOR
FOR TIMING LOOP
LOOP
:DIGIT KEY
KEY ARRAY -— HOLDS IDENTIFICA­
IDENTIFICA1E BEEN
BEEN
: TIONS OF DIGIT KEYS
KEYS THAT HA' 'E
; PRESSED
PRESSED
;NUMBER OF DIGIT KEYS
KEYS PRESSED
PRESSED

I/O UNITS AND
AND VIA
VIA ADDRESSES
;1/0
ADDRESSES
VIAORB =$A000
VIAORB
=$AOOO
VIAORA =$A001
=$A001
VIAORA
VIADDRB =$A002
=$A002
VIADDRB
VIADDRA =$A003
=$A003
VIADDRA
VIAPCR =$A00C
VIAPCR
=$AOOC

;OUTPUT PORT
PORT FOR
FOR KEYBOARD AND DISPLAY
;INPUT PORT
PORT FOR
FOR KEYBOARD
DATA DIRECTION
;DATA
DIRECTION REGISTER
REGISTERFOR
FOR PORT
PORT B
DATA DIRECTION
;DATA
DIRECTION REGISTER
REGISTER FOR
FOR PORT
PORT A
VIA PERIPHERAL
;VIA
PERIPHERAL CONTROL REGISTER
REGISTER

DEFINITIONS
;DEFINITIONS

DECPT
ECODE
ECODE

=%
01000000
=%01000000
=$FF
=$FF

GOKEY
KLAST
KLAST

=11
=11

DECIMAL POINT LED
;CODE TO LIGHT DECIMAL
LED
ERROR CODE IF ID ROUTINE
;ERROR
ROUTINE DOES
DOES NOT FIND
FIND
; KEY
KEY
"GO” KEY
;IDENTIFICATION NUMBER FOR
FOR "GO"
KEY
;HIGHEST NUMBERED KEY
KEY

1 6-10
-1 0

LEDON
LEDON
LEDSL
LEDSL
MSCNT
MSCNT
MXKEY
MXKEY

=%
00010000
=%00010000
=%
00100000
=%00100000
=$C7
=$C7
==2

NROWS ==4
4
NROWS
OPEN
=%
00001111
OPEN
=%00001111
TPULS
2
TPULS ==2
TW
AIT ==2
2
TWAIT

;CODE
;CODETO SEND
SEND OUTPUT
OUTPUTTO LEDS
LEDS
;CODE
;CODETO SELECT
SELECTLEADING
LEADINGDISPLAY
DISPLAY
;COUNT
:COUNT NEEDED
NEEDEDTO
TO GIVE
GIVE 1 MS
MS DELAY
DELAY TIME
TIME
;MAXIMUM
:MAXIMUM NUMBER
NUMBEROF
OF DIGIT
DIGIT KEY
KEY
USED
:; CLOSURES
CLOSURESUSED
;NUMBER
;NUMBEROF
OF ROWS
ROWS IN KEYBOARD
KEYBOARD
;INPUT
:INPUT FROM
FROMKEYBOARD
KEYBOARDIF
IF NO
NO KEY
KEY CLOSED
CLOSED
;NUMBER
:NUMBEROF
OF MS
MS BETWEEN
BETWEENDIGIT
DIGIT DISPLAYS
DISPLAYS
;NUMBER
;NUMBEROF
OF MS
MS TO
TO DEBOUNCE
DEBOUNCEKEYS
KEYS

*=$FFFC
•=$FFFC
RESET
STOPWATCH PROGRAM
;RESETADDRESS
ADDRESSTO REACH
REACHSTOPWA
PROGRAM
.WORD
.WORD

BEGIN
BEGI

;VECTOR
.VECTORTO START
START OF STOPWATCH
STOPWATCH
.; PROGRAM
PROGRAM

INITIALIZATION
;INITIALIZATION OF STOPWATCH
STOPWATCH PROGRAM
PROGRAM
"=BEGIN
•=BEGIN
LDA
#
LOA
#00
STA
VIADDRA
STA
VIADDRA
STA
VIAPCR
STA
VIAPCR
LDA
#$FF
LOA
#$FF
STA
VIADDRB
VIADDRB
STA
LDX
#STKBGN
LOX
#STKBGN
TXS
TXS

;MAKE
;MAKE PORT
PORTA LINES
LINES INPUTS
INPUTS
;MAKE ALL CONTROL
CONTROLLINES
LINES INPUTS
INPUTS
;MAKE

:MAKE PORT
PORTB LINES
LINESOUTPUTS
OUTPUTS
;MAKE
INITIALIZE
;INITIALIZESTACK
STACK POINTER
POINTER

;INITIALIZE
COUNTER
;INITIALIZEDIGIT
DIGIT KEY
KEY COU
TEA
INITL
INITL

LDA
LOA
STA
STA

#0
#0
NKEYS
NKEYS

: U
BEROF
Of DIGIT
IG KEYS
EYS== ZERO
ZERO
;NUMBER

;SCAN
KEY c_os
CLOSURE
:SCAN KEYBOARD
KEYBOARDLOOKING
LOOKINGFOR
FOR KE
RE
SRCHK
SRCHK JSR
JSR

SCANC
SCANC

;WAIT
.WAI FOR
F09 KEY
KEYCLOSURE
CLOSURE

;W
AIT FOR
:WAIT
FORKEY
KEYTO
TO BE
BEDEBOUNCED
DEBOUNCED
LDY
LOY
JSR
JSR

#T
W A IT
#TWAIT
DELAY
DELAY

;GET
TIME
:GETDEBOUNCE
DEBOUNCE
TIMEIN
INMS
MS
;W
AIT FOR
:WAIT
FORKEY
KEYTO
TOSTOP
STOPBOUNCING
BOUNCING

IDENTIFY
IDENTIFYWHICH
WHICH KEY
KEYWAS
WAS PRESSED
PRESSED
JSR
JSR
CMP
CMP
BEQ
BEO

IDKEY
IDKEY
#ECODE
#ECODE
SRCHK
SRCHK

IDENTIFY
;IDENTIFYKEY
KEYCLOSURE
CLOSURE
;WAS
IDENTIFIED?
;WASKEY
KEYCLOSURE
CLOSURE
IDENTIFIED?
; NO.
AIT FOR
:NO.W
WAIT
FORNEXT
NEXTCLOSURE
CLOSURE

16-11
16-11

TIMING IF "GO"
"GO’' KEY PRESSED
START TIMING
PRESSED AND ENOUGH DIGITS ENTERED
ENTERED
LDX

NKEYS

CPX
BNE
CMP
BEQ
BEO
BNE

#MXKEY
#MXKEY
ENTDG
ENTDG
#GOKEY
#GOKEY
STTIM
SHIM
WAITK
WAITK

MAXIMUM NUMBER OF DIGIT KEYS
;HAS MAXIMUM
KEYS
; BEEN
BEEN ENTERED?
ENTERED?
NO, GO ENTER
;NO.
ENTER DIGIT KEY
;YES, IS KEY "GO"?
"GO"?
YES, START TIMING
;YES,
;NO, IGNORE
IGNORE KEY

DECIMAL POINT OR "GO"
"GO" KEY
ENTER DIGIT KEY
;ENTER
KEY INTO ARRAY, IGNORE
IGNORE DECIMAL
ENTDG

CMP
BCS
INC

#10
10
WAITK
WAITK
NKEYS
NKEYS

STA

KEYNO.X
KEYNO,X

;IS KEY A DIGIT?
;NO, IGNORE
IGNORE IT
;YES, INCREMENT NUMBER OF DIGIT KEYS
KEYS
; ENTERED
ENTERED
;SAVE DIGIT KEY IN ARRAY

;W
AIT FOR
:WAIT
FOR CURRENT
CURRENT KEY CLOSURE TO END
WAITK
WAITK

JSR
BEQ
BEO

SCANO
SRCHK
SRCHK

;WAIT
FOR ALL KEYS TO BE RELEASED
RELEASED
W
AIT FOR
ALWAYS
;LOOK FOR
FOR NEXT CLOSURE (SCANO ALWAYS
; SETS
SETS Z)
Z)

;PROCESS
;PROCESS DIGITS FOR
FOR DISPLAY
STTIM
SHIM

LDA
ORA

KEYNO
#DECPT
#DECPT

ORA
ORA
STA
LDA
ORA
STA

#LEDON
#LEDON
#LEDSL
#LEDSL
KEYNO
KEYNO+1
#LEDON
#LEDON
KEYNO+1
KEYNO+l

;GET LEADING DIGITS
DECIMAL POINT FOR
;TURN ON DECIMAL
FOR LEADING
; DIGIT
;SET OUTPUT TO LEDS
LEDS
DISPLAY
; SELECT
SELECT LEADING DISPLAY
;GET TRAILING DIGIT
;SET OUTPUT TO LEDS

;PULSE
;PULSE THE LED DISPLAYS
LEDLP
TLOOP
DSPLY

LDA
STA
LDA
STA
LDA
STA
LDY
JSR
LDA
STA
LDY
JSR
DEC
DEC
BNE
DEC
DEC
BNE

#66
DCTR+1
DCTR+l
#2
50
250
DCTR
DCTR
KEYNO
VIAORB
#TPULS
#TPULS
DELAY
KEYNO+1
KEYNO+l
VIAORB
#TPULS
#TPULS
DELAY
DCTR
DCTR
DSPLY
DCTR+1
DCTR+l
TLOOP

1500 PULSES
;SET COUNTERS
COUNTERS FOR
FOR 1500
PULSES

;SEND LEADING DIGIT TO LED 1
DELAY BETWEEN DIGITS
;DELAY
;SEND TRAILING DIGIT TO LED 2
DELAY BETWEEN DIGITS
:DELAY

1 6-12

DECREMENT
DECREMENT COUNT
COUNT ON
ON LED
LED DISPLAYS
DISPLAYS
LDA
LOA
DEC
DEC
BIT
BIT
BNE
BNE
DEC
DEC
BIT
BIT
BEQ
BEG
LDA
LOA
ORA
ORA
STA
STA
BNE
BNE

#LEDON
#LEDON
KEYNO+1
KEYNO+l
KEYNO+l
KEYNO+1
LEDLP
LEDLP
KEYNO
KEYNO
KEYNO
KEYNO
INITL
INITL
##9
9
#LEDON
#LEDON
KEYNO+1
KEYNO+l
LEDLP
LEDLP

;GET
FOR CARRIES
CARRIES
;GET BIT PATTERN TO LOOK FOR
COU
DOWN TRAILING
TRAILING DIGIT
DIGIT
;COUNTT DOWN
IS TRAILi
DIGITPAST
PASTZERO?
ZERO?
;IS
TRAILINGGDIGIT
.NO, DISPLAY
DISPLAY NEW
EWTIME
TIME
;NO,
.
YES.COUNT
COUNT DOW
LEADINGDIGIT
DIGIT
;YES.
DOWN LEADING
,ISLEADING
LEADING DIGIT
DIGITPAST
PASTZERO?
ZERO?
;IS
;YES.WWAIT
FORNEXT
EXTTIMING
TIMINGTASK
TASK
;YES.
AIT FOR
;
NO.MAKE
MAKE TRAILi
DIGIT99
;NO.
TRAILINGGDIGIT
;SETOUTPUT
OUTPUTTO
TOLEDS
-EDS
;SET
RETUR TO
TO PU
SI GDISPLAYS
DISPLAYS
:RETURN
PULSING

SUBROUTINE SCANC SCANS
WAITING
;SUBROUTINE
s THE KEYBOARD • A
- G FOR
=onA KEY CLOSURE
CLOSURE
ALL KEYBOARD INPUTS ARE GROUNDED
; ALL
OED
SCANC
SCANC

KEYCLS

LDA
LOA
STA
STA
LDA
LOA
AND
AND
CMP
BEQ
BEG
RTS
RTS

##0
0
VIAORB
VIAORB
VIAORA
VIAORA
#OPEN
#OPEN
#OPEN
#OPEN
KEYCLS
KEYCLS

GROU DALL
ALL KEYBOARD
KEYBOARD COLUM
;GROUND
COLUMNS

s

DA-A
;GET
;GETKEYBOARD
KEYBOARDROW
FIO DATA
0
;IGNORE
UNUSED
.IG
ORE U
USEDINPUTS
o
GROU
OED?
ARE A
;ARE
ANY'YINPUTS
GROUNDED?
;NO.0.W AIT

.-.

-s

-s

SUBROUTINE
WAITS
NUMBER
;SUBROUTINE DELAY WAI
S FOR
FOR THE
E U
BER OF MS SPECIFIED
SPECIFIED
; IN INDEX REGISTER
REGISTERY BY COUNTING
-, G WITH INDEX REGISTER
REGISTERX
DELAY
DELAY
WTLP
WTLP

LDX
LOX
DEX
DEX
BNE
DEY
DEY
BNE
BNE
RTS
RTS

#M
SCNTT
#MSC

;COUNT FOR
FOR11 MS
MS DELAY
DELAY
;COUNT
;W
AIT 11 MS
;WAIT
MS

WTLP
WTLP
;COUNT
:COUNT MS
MS
DELAY
DELAY

SUBROUTINE
:SUBROUTINE IDKEY
IDKEY DETERMINES
DETERMINES THE
THE ROW AND COLUMN NUMBER
NUMBER OF
OF
; THE KEY
KEY CLOSURE
CLOSURE AND IDENTIFIES
IDENTIFIES THE
THE KEY
KEY FROM
FROM A
A TABLE
TABLE
IDKEY
IDKEY

FCOL
FCOL

LDA
LOA
STA
STA
LDX
LOX
LDA
LOA
AND
AND
CMP
CMP
BNE
BNE
ROL
ROL
TXA
TXA
ADC
ADC
TAX
TAX
CMP
CMP
BNE
BNE
LDA
LOA
RTS
RTS

#% 1
1111110
#%11111110
VIAORB
VIAORB
#$FF
#$FF
VIAORA
VIAORA
#OPEN
#OPEN
#OPEN
#OPEN
FROW
FROW
VIAORB
VIAORB

;GET
;GETPATTERN
PATTERNTO
TOGROUND
GROUNDCOLUMN
COLUMNZERO
ZERO
;GROUND
:GROUNDCOLUMN
COLUMN ZERO
ZERO
;KEY
= -1-1
;KEYTABLE
TABLEINDEX
INDEX=
;FETCH
:FETCHKEYBOARD
KEYBOARDROW
ROWDATA
DATA
:IGNORE
.IGNOREUNUSED
UNUSEDINPUTS
INPUTS
;ARE
,AREANY
ANYINPUTS
INPUTSGROUNDED?
GROUNDED?
;YES.
DETERMINE EWHICH
,YES. DETERMI
WHICHONE
ONE
;NO.
,NO.GROUND
GROUNDNEXT
NEXTCOLUMN
COLUMN
;MOVE
,MOVEKEY
KEYTABLE
TABLEINDEX
INDEXTO
TO NEXT
NEXT COLUMN
COLUMN

#NROWS-1
#NROWS-1
#KLAST
#KLAST
FCOL
FCOL
#ECODE
#ECODE

;HAVE
HAVE ALL
ALL COLUMNS
COLUMNS BEEN
BEEN EXAMINED?
EXAMINED?
;NO,
NO.EXAMINE
EXAMINENEXT
NEXTCOLUMN
COLUMN
;YES.
WITH
CODE
YES.RETURN
RETURN
WITHERROR
ERROR
CODEININA A

1616-13

:DETERMINE ROW NUMBER OF CLOSURE
CLOSURE
FROW

INX
LSR

AA

BCS

FROW
FROW

;INCREMENT KEY TABLE INDEX
:SHIFT INPUTS LOOKING FOR
FOR GROUNDED
GROUNDED
: ROW

:IDENTIFY KEY FROM TABLE
LDA
RTS
RTS

KTAB,X
KTAB.X

:GET KEY
KEY NUMBER FROM TABLE
;GET

:KEYBOARD TABLE
COLUMNS ARE PRIMARY INDEX. ROWS SECONDARY INDEX.
.COLUMNS
ATTACHED TO OUTPUT BIT 0
ARE FOLLOWED
:THE KEYS
KEYS IN THE COLUMN ATTACHED
OARE
BY THOSE IN THE COLUMN
COLUMN ATTACHED
ATTACHED TO OUTPUT BIT 1 ETC.
WITHIN
ETC. WITHIN
COLUMN. THE KEY
ATTACHED TO INPUT BIT 0
; A COLUMN.
KEY ATTACHED
O IS FIRST.
FIRST, FOLLOWED
, BY THE ONE ATTACHED
ETC.
ATTACHED TO INPUT BIT 1. ETC.

:THE DIGIT KEYS
KEYS ARE 0
O TO 9. THE DECIMAL
10. AND "GO"
11
DECIMAL POINT IS 10,
"GO" IS 11
KTAB

BYTE

3,2,0,4,8,9,1,11,5,6,7,10
3.2.0.4.8,9,
11,5.6,7.10

:SUBROUTINE SCANO WAITS
FOR ALL KEYS
KEYS TO BE
BE RELEASED
RELEASED SO THAT THE
WAITS FOR
: NEXT CLOSURE
CLOSURE CAN BE FOUND
LDA
STA
KEYOPN LDA
AND
CMP
BNE
BNE
RTS
RTS
.END
END

SCANO

#0
VIAORB
VIAORA
#OPEN
#OPEN
KEYOPN
KEYOPN

;GROUND
:GROUND ALL KEYBOARD COLUMNS
;GET
:GET KEYBOARD
KEYBOARD ROW INPUTS
:IGNORE UNUSED INPUTS
INPUTS
;IGNORE
:ARE ANY KEYS
KEYS BEING
BEING PRESSED?
PRESSED?
;ARE
:YES. WAIT
RELEASED
;YES.
AIT UNTIL ALL RELEASED

16-14
16-

PROJECT
2 : A Digital Thermometer
PROJECT #2:
Purpose:
project is a digital
digital thermometer
thermometer which
which shows the temperature
temperature in
Purpose: This project
seven-segment displays.
degrees Celsius on twoo seven-segment
Hardware: The project
project uses one input
input port and one output
output port,
seven-segment
Hardware:
port. two seven-segment
displays, a 74LS04 inverter, a 74LS00
depending on
74LSOONAND
NANO gate or a 74LS08
74LSOB AND gate depending
the polarity
polarity of the displays, an Analog Devices AD7570J
AD7570J 8-bit
8-bit monolithic
onolithic A/D concon­
verter,
comparator, and various peripheral
peripheral drivers,
verter. an LM311 comparator,
drivers. resistors, and capacitors
as required by the displays and the converter. (See
(See Chapter 11
11 and Reference 1 at the
end of this chapter
chapter for discussions
discussions of A/D
/D converters.)
Figure 16-2 shows the organization
organization of the hardware. Control
Control line CB2 from the VIA is
used to send a Start Conversion signal to the A/D converter. Input
Input lines 0
through 7 are
O through
attached directly
directly to the eight
eight digital
digital data lines from the converter. Output
utput lines 0
attached
through 3 are used to send BCD digits
seven-segment decoder/drivers.
decoder/drivers. Output
Output
through
d1g1tsto the seven-segment
line 4 activates
activates the displays and output
output line 5 selects the left or right
right display
display (line 5 is '1'’
for the left display). Control
Control line
determine when the conversion
conversion is comcom­
hne CA1 is
1sused to determine
plete (BUSY
(BUSY becomes one).
one).

THERMOMETER
The analog part of the hardware
hardware is shown in Figure 16-3. The
THERMOMETER
ANALOG
therm
istor simply
simply provides a resistance that depends on tem-­
thermistor
perature. Figure 16-4 is a plot of the resistance and Figure 16-5
HARDWARE
shows the range of current
current values over which
which the resistance is
conversion to degrees Celsius in the program is performed
performed with
ith a calibracalibra­
constant. The conversion
potentiometers can be adjusted to scale the data properly. A clock
tion table. The two potentiometers
converter is generated from an RC
for the A/D converter
RC network, as shown in Figure 16-3.
16-3. The
values are R7=33
R7=33 kO
f l and Cl
C1 =1000
=1000 pF,
frequency is about 75 kHz A t
pF, so that the clock frequency
frequency, the maximum
maximum conversion time for eight
eight bits is about 50 microseconds.
this frequency.
When
hen BUSY
Interrupt Flag
-b it version
BUSY goes high, it sets bit 1 of the VIA Interrupt
Flag register. The 8-b,
vers,on
of the converter
converter requires the follow
ing special connections
connections. The eigh
eight data
nes are
following
da-a ' "es
DB2 through
through DB9 (DB
(DB11 is always high during
during conversion
conversion and 080
DBO low• The Sr:ir:
Short Cycle
8-bit input
input (pin 26-SC8)
-b 't conversion
performed. In the
8-bit
26-SCB) is tied low so that only an 8-b:
C" is oe-'o
20-HBEN)I and
Low 3.
Byte
Enable (pin
1-LBEN)
:;; ':~a::
o" 2 BE were
present case,
case, High Byte Enable (pin 20-HBE
ano -c.''
both tied high so that the data outpu
outputss were
;,e•e always
~.a enabled
e~ac ea

-,.=

The AID
A/D converter
converter uses Ithes c::ess
successive
approximation
.e a:::::r:,x
~a· en method
rnethod to perform a conversion.
The ADCss data reg,s
register is ccnne~ieo
connected to
of an internal
internal D
/A converter
converter whose
:o: thee inputs
nou·s o'
0/A
output (available at OUT1
and OlJ
OUT2)
is compared
output
ou-, a'>O
-2 ts
:omoared to the analog input. When a conver­
conversion is initiated
initiated, the ADC og
logic sets Ithe data reg,ster
register to all zeroes
ith the exception
exception of
zeroes with
the most significant
input is less than the
lv1SB which
1ch is set to one. If the analog input
s1gn1f1cantb,it (MSB),
resulting internally
internally generated analog value,
otherwise it
resulting
value. then the MSB is reset to zero;
zero: otherwise
remains a one. The next most significant
is then set to one and the process repeated
s,gmftcant bit 1s
until all eight
eight bits have been ·tested in
After the eighth
eighth cycle, the value in the
until
,n this way. After
which most closely corresponds to the analog input.
register is the value which
This method is fast,
input be stable during
during the conversion
fast. but it requires that the input
process.
changing or noisy inputs
inputs would
would require additional
additional signal conditioning.
conditioning.
process. Rapidly changing
The references at the end of this chapter
chapter describe more accurate
accurate methods
methods for handling
analog I/O.
1/0.

16-15

pb7
PB7
..,__ (not used)
pb6
PB5
-.-(not
used)

PB,
Output
utput PB5

Port
(VIA
IVIA

PB4
PB3

Bl PB2
Port B)
PH,
PB1
f

CB2

PB0
PBo

I
'
pa7
PA7
PA5
PA,
Input PA5
PA,
Port PA4
PA3
(VIA
IVIA p a
Port Al) PA2
PA1
PA,
CA1

PAfi

'
Analog
Analog In putt-

-

Start
eon-slon

.
'

I I•

•

Display

Display
and

Converter

Driver

(left)

Driver
!right)

Common

Common

BUSY

I a

:--n-

_Yn
-

Figure 16-2.
Configuration for a Digital
Digital Thermometer
Thermometer
16-2. I/O
1/0 Configuration

1616-166

I

Do D1 D2 D3

and

-

I

Do D1 D2 D3

A/D

-

-

,.

R6
R6
550
0 kkO
n
OFFSET
OFFSETADJ
ADJ
- W ♦r
— "O ++ 1
155 VV
.-1l55 VV O '
00----•'W/"'\
t,•.•---<O

+15V

+5 V

RS

2 M!l

VREF
-10 V

1

22

R3
200 n

Vee

vDD

our,

VREF

R2
5k0

4
RI
1\0

+5 V
5

OUT2
R7
33 kO
24

CLOCK

+15 V
AD7570J
AID
Converter

Cl
IOOOpF
Ar

T'

Thermistor

8

R4

3
1 kO

SYNC

ANALOG
INPUT

DBS
D87

Gain Adjus,

RS
68 k!I

+ 5V

-

DBS
20

A
21

From VlA C82 outout
To VlA CAI
+5 V

nput

25
25
27
26

(not used)

SRO

D89

A

-15 V

COMP

HBEN

DBS

L8EN

DB<!

9

(not used)

10

PA7

11

PAS

12

PAS

13

PA4

14

PA3

"-

15

'6

S"llT

D!!J

~

08'2

BSEN

D81

SC8

DBO

AGND

To VIA
Par. A

OA

•7
PAO

8
19

(not used)

!not used)

DGND

6

23

-

~A

D

Note: If positive
positive VREF
pgp is
used, the ANALOG INPUT range is 0
to -Vpgp,
Note·
1sused.
Oto
.VREF· and the
COMPARATOR'S (-)
should be connected
connected to
to OUT11 (pin 4)
7 5 70
1-1inputt should
41 o
off the A D
D75
COMPARATOR's
R
isto r The analog in
er ,s
is:
RTj is the th e rm
rmistor
mput from the voltage d ivid
iv1oer

Rab
R

x 15 V
Volt
o lt

Ra++ Rr
R8
RT
= 688 k
f l , the input is:
Since Rp
RF""'
kO.
r

K

1.02 MOf l
________________
-----Volt
Rr + 68 kO

V/ftW

R
has a m inim
um value
value o
H (T
see Figure
Figure 1 6
-4 ) so
so fu
scale is 10
10 Volt.
olt.
Rrj has
minimum
off 3
344 k
kO
IT== 50°C
SO'C, sae
16-4}
fulll scale

Figure 16-3.
16-3. Digital
Digital Thermometer
Thermometer Analog
Analog Hardware
Hardware
Figure

16-17
16-17

1000000 ---------------------------.

100 000

-------..........
-o......
"CX.

T (°C)
l"Cl

R(Ohml
(Ohm)

0

365
365 000

25

100
100 000
000

50

34 000

100
100

6 000

........
........

........

............

10 000

L..-----------1...----------~
0
25
25

J
50

Temperature (°C)
Temperature
('Cl

Figure 16-4,
Thermistor Characteristics
Characteristics
16-4. Thermistor
(Fenwal GA51J1 Bead)
Bead)
(Fenwal

100

r--------------------------,
The curve is linear(i.e.. the resistanceis
independentof current)for currentsless
than 0.1 milliampere.

10

0.01

0.1
I (milliampere)
(milliampere)

Figure 16-5. Typical E-l
Thermistor (25°C)
E-I Curve for Thermistor
(25°C)

16-18

1,0

G e n e r a l Program
P ro g ra m Flowchart:
F lo w c h a r t:
General
Start

ln1t1ahzat10n

Send Start
Converst0n Stgnal
to A •D converter

Read data from
A/O converter

Convert data to
degrees Cetsius

Display

temperature

on

LEDs for Saxseconos

116-19
6 -1 9

P ro gram D e s c ription:

1) Initialization
Initialization
1)
Memory locations
FFFC and FFFD
FFFD (the 6502 Reset
Reset locations) contain
locations FFFC
contain the starting
starting
address of the program. The initialization
initialization configures
configures the VIA and places a value in
the Stack Pointer. The Stack is used only to store subroutine
subroutine return addresses.
addresses.
11 contains
VIAs.
Remember that
that Chapter 11
contains numerous
numerous examples of how to configure
configure VIAs.
2)

Send Start
Start Conversion Signal to A'D Converter
Converter
The CPU
CPU pulses the Start Conversion line by first placing
placing a one and then a zero on
output line CB2.
input from the converter
converter requires a starting
starting pulse.
output
CB2. Each
Each input

3)

Wait
ait for Conversion to be Completed.
·o·to '1'1transition
BUSY line sets bit 1 of the VIA Interrupt
Register.
A ’O’
transition on the BUSY
Interrupt Flag Register.
Actually.
Actually, the converter
converter only requires a maximum
aximum of 50 microseconds
microseconds for an 8-bit
8-bit
conversion.
conversion, so a short delay would
would also be adequate. Note that
that reading the
converter
Flag Register so that the next
converter data clears bit 1 of the VIA Interrupt
Interrupt Flag
operation can proceed correctly.
correctly.

4)

Read Data from A'D Converter
Converter
Reading the data involves a single input
input operation.
operation. We should note that the Analog
Devices AD7570J
AD7570J has an enable input
input and tristate
tristate outputs.
outputs, so that it could be tied
directly
Bus. The 7570 converter
is. of course,
course.
directly to the Microprocessor
Microprocessor Data Bus.
converter is,
underutilized in this particular
particular application.
application, particularly
particularly since we are interfacing
interfacing it to
underutilized
the 6502 processor through
through a VIA. A simpler
simpler 8-bit
8-bit converter
converter such as the National
5357 described in Chapter 11 would
would do the job at lower cost.

16-20

5) Convert
Convert Data
Data to
to Degrees
Degrees Celsius
Celsius
5)

Flowchart:
Flowchart:
Start
Stan

T
Value= Dato
received from
A/0 converter
Index= -1

Index = lnde><• I

USING A
The conversIor
conversion uses
table: that
contains
ses a ;;:;
•a· - _
:a ns the
the largest in­
inCALIBRATION
put value corresoc~o
correspondingg to: aa ;given
= temperature.
:emperature. The
The pro­
proTABLE
TABLE
gram searches
es the
·•e table,
ao e ookingg for
for a value greater
greater than
than
or equal to thee a
valuee received
ea from
'•om the
the converter.
converter. The
The first
first
such value it: 'finds
temperature; that
cs corresponds to
to the
the required
required temperature;
that is,
is, ifif the
the tenth
tenth
entry
value
entry iss thee 'first
s a
ue larger than
than or
or equal
equal to
to the data,
data. the temperature is
is ten
ten
degrees.
i s search
sea•c method
method is
Is inefficient
inefficient but
but adequate for
for the present
present applica­
applicadegrees This
tion.
tIon.
The
The conversion
conversionssubroutine
broutine returns
returns aa binary
binary value
value w
which is
is then
then converted
converted to
to BCD
BCD
by
repeatedly s D
subtracting
by repeated,
ractmg ten
ten and
and counting
counting operations
operations until
unul the
the remainder
remainder
becomes
becomes negative
nega e The
he final
tonal ten
ten is
is then
then added
added back
back to
to produce
produce the
the least
least signifi­
significant
it
cant d ig
d1g1t
The
obtained
The table
table could
could be
be obta
ned by
by calibration
calibration or
or by
by aa mathematical
mathematical approximation.
approximation.
The
The calibration
calibration method
metnod is
1ssimple,
simple. since
since the
the thermometer
thermometer must
must be
be calibrated
calibrated any­
anyway.
way. The
The table
table occupies
occup,es one
one memory
memory location
location for
for each
each temperature
temperature value
value to
to be
be
displayed.11 Reference
displayed.
Reference 22 describes
describes aa method
method that
that uses
uses far
far less
less memory.
memory. To
To cali­
calibrate
brate the
the thermometer,
thermometer. you
you must
must first
first adjust
adjust the
the potentiometers
potentiometers to
to produce
produce the
the
proper
proper overall
overall range
range and
and then
then determine
determine the
the converter
converter output
output values
values correspond­
corresponding
ing to
to specific
specific temperatures.
temperatures

1 6 -2
1
16-21

6) Prepare
Prepare Data
Data for
for Display
Display
6)

Flowchart:
Flowchart:
Sten

Get least significant
digotset
output to LEDs

Get most

s,gn;tant digit

Set output to LEDs

..

....

(

End

For the least significant
significant digit.
digit, we simply
simply set the bit that turns
on the displays. The result is saved in page zero address
LSTEMP.
LSTEMP.

BLANKING
A LEADING
ZERO
ZERO

leadThe only difference
difference for the most significant
significant digit
ig it is that a lead­
displays show "blank
"blank 7" rather
rather than "07"
7 " for 7°C).
ing zero is blanked (i.e.,.. the displays
7°C). This
simply involves
involves not setting
setting the bit that turns on the displays
displays if
simply
1f the dig
digitit is zero.
zero. The
result is saved in page zero address MSTEMP.
MSTEMP.

16
-2 2
16-22

7)
7)

Temperature for Six
Six Seconds
Seconds
Display Temperature
Flowchart:
Flowchart:

Count =TSAM!'

Send most
sognlant dlg,t

tolelt-

W.t 2 ms

~·
Send-

10"!1"'-

W•t 2 ms

Count = Count - l

End

Each
Each display
display is
is pulsed
pulsed often enough
enough so
so that
that itit appears
appears to
to be
be lit
lit continuously.
continuously. IfIf
TPULS
TPULS were
were made
made longer
longer (say
(say 50
50 ms),
msl. the
the displays
displays would
would appear
appear to
to flash
flash on
on and
and
off.
off.
The
The program
program uses
uses aa 16-bit
16-bit counter
counter in
in tw
two page-zero
page-zero memory
memory locations
locations to
to count
count the
the
time
time between
between temperature
temperature samples.
samples.

1616-23

PROGRAM NAME: THERMOMETER
THERMOMETER
PROGRAM
DATE OF PROGRAM: 5 /1
/7 9
/1/79
;PROGRAMMER: LANCE A. LEVENTHAL
;PROGRAM MEMORY REQUIREMENTS
BYTES
REQUIREMENTS: 173 BYTES
;RAM REQUIREMENTS:
REQUIREMENTS: 5 BYTES
BYTES
;1/0
REQUIREMENTS: 1 INPUT PORT.
PORT. 1 OUTPUT PORT
PORT (1 6522
I/O REQUIREMENTS:
6522 VIA)
;THIS PROGRAM
PROGRAM IS A DIGITAL THERMOMETER
THERMOMETER THAT
THAT ACCEPTS INPUTS FROM
. AN AID
CONVERTER ATTACHED
THERMISTOR. CONVERTS THE INPUT
A/D CONVERTER
ATTACHED TO A THERMISTOR.
; TO DEGREES
DEGREES CELSIUS.
CELSIUS. AND DISPLAYS THE RESULTS
RESULTS ON TWO
; SEVEN-SEGMENT
SEVEN-SEGMENT LED DISPLAYS
A
/D CONVERTER
;A/D
CONVERTER
A/D CONVERTER
ANALOG DEVICES
7570J MONOLITHIC
MONOLITHIC CONVERTER
:THE A/D
CONVERTER IS AN ANALOG
DEVICES 7570J
CONVERTER
; WHICH
PRODUCES AN 8-BIT OUTPUT
WHICH PRODUCES
;THE CONVERSION PROCESS
PROCESS IS STARTED BY A PULSE
PULSE ON THE START
; CONVERSION
CONVERSION LINE (CONTROL
(CONTROL LINE 2 ON VIA PORT
PORT B)
B)
;THE CONVERSION IS COMPLETED IN 50 MICROSECONDS AND
AND THE
; DIGITAL DATA
DATA IS LATCHED

;DISPLAYS
:TWO SEVEN-SEGMENT LED DISPLAYS ARE USED
USED WITH SEPARATE DECODERS
DECODERS
: (7447 OR 7448
G ON THE TYPE OF DISPLAY)
7448 DEPENDING
:THE DECODER
DECODER DATA
CONNECTED TO BITS 0
OTO
DATA INPUTS ARE CONNECTED
TO 3 OF
; VIA PORT
PORT B
:BIT 4 OF VIA PORT
PORT BIS
USED TO ACTIVATE
IS USED
ACTIVATE THE LED DISPLAYS
; (BIT 4
4 IS 1 TO SEND DATA
LEDS)
DATA TO LEDS)
;BIT 5 OF VIA PORT
PORT B IS USED TO SELECT
SELECT WHICH
BEING
WHICH LED IS BEING
: USED
USED (BIT 5 IS 1 IF THE LEADING DISPLAY IS BEING
BEING USED,
USED.
; 0 IF THE TRAILING DISPLAY IS BEING
BEING USED)
USED)
;METHOD
;STEP
STEP 1 - INITIALIZATION
INITIALIZATION
; THE MEMORY STACK (USED
(USED FOR
FOR SUBROUTINE
SUBROUTINE RETURN
RETURN ADDRESSES)
ADDRESSES) IS
; INITIALIZED
;STEP
PULSE START CONVERSION LINE
STEP 2 - PULSE
; THE A/D CONVERTER'S
CONVERTER'S START CONVERSION
CONVERSION LINE (CONTROL LINE 2 OF VIA
; PORT
PORT B)
Bl IS PULSED
PULSED
:STEP
FOR AID
SETTLE
STEP 3 - WAIT
AIT FOR
A/D OUTPUT TO SETTLE
CONVERTER IS ATTACHED
THE BUSY LINE FROM THE CONVERTER
ATTACHED TO CONTROL
, ; LINE 1 ON PORT
PORT A OF THE VIA. WHEN BUSY GOES
GOES HIGH TO SIGNAL
; CONVERSION
CONVERSION COMPLETED,
COMPLETED. IT SETS
SETS BIT 1 OF THE VIA INTERRUPT
INTERRUPT
; FLAG REGISTER
REGISTER
STEP 4 - READ
/D VALUE.
VALUE, CONVERT TO DEGREES
:STEP
READ A/D
DEGREES CELSIUS
CELSIUS
A TABLE IS USED FOR
CONTAINS THE MAXIMUM
MAXIMUM
FOR CONVERSION,
CONVERSION. IT CONTAINS
FOR EACH TEMPERATURE
TEMPERATURE READING
READING
INPUT VALUE FOR
s-EP
TEMPERATURE ON LEDS
LEDS
STEP 5 - DISPLAY TEMPERATURE
-THE TEMPERATURE
TEMPERATURE IS DISPLAYED ON THE LEDS
LEDS FOR
FOR SIX SECONDS
SECONDS
3:~0RE
CONVERSION IS PERFORMED
PERFORMED
BEFORE ANOTHER CONVERSION

16-24
16-24

THERMOMETER VARIABLE
VARIABLE DEFI
DEFINITIONS
:THERMOMETER
ITIO

MEMORY SYSTEM CONSTANTS
:MEMORY

.STARTING ADDRESS "OR
FOR PROGRAM
0 ESS ON PAGE 1
STARTING STACK AJD
ADDRESS
.START!
,START!
ORAGE
STARTING ADDRESS ::oq
FOR RAMSSTORAGE

BEGIN
=$0400
BEGIN
=$0400
STKBGN =$FF
=$FF
TEMP
=00
I/O UNITS AND
AND VIA
VIA ADDRESSES
1/0
ADDRESSES

rOUTPUT p o = " D'SPuAYS
==-=:>
SiPUT f>0«'r R W CONVERTER
-pi "OR
PORT B
DAr A DIRECTION REGISTER
FOR PORT
G
STER FOR
FOR PORT
PORT A
.DATA DIRECTION
REGISTER
NTROL REGISTER
REGISTER
:VIA PERIPHERAL CONTROL
.;VIA INTERRUPT FLAG REGISTER
REGISTER

VIAORB =$A000
=$AOOO
=$A001
VIAORA =$A001
=$A002
VIADDRB =$A002
VIADDRA =$A
003
VIADDRA
=$A003
VIAPCR =$AOOC
=SAOOC
VIAIFR
=$A00D
=-~
RAM TEMPORARY
RAM
PQRARY STORAGE
STORAGE

DCTRC
DCTRC
INPUT

•=TEMP
·=TEMP
*=
*+ 2
•=•+2
•=
*+ 1
'='+1

:DISPLAY PULSE
PULSE COUNTER
COUNTER
TEMPORARY STORAGE
:TEMPORARY
STORAGE FOR
FOR CONVERTER
CONVERTER
: INPUT
INPUT
;LEAST SIGNIFICANT DIGIT OF
: TEMPERATURE
TEMPERATURE
.MOST SIGNIFICANT DIGIT OF
OF
; TEMPERATURE
TEMPERATURE

LSTEMP
*+ 1
LSTEMP ‘ =
•=•+1
MSTEMP •=•+1
*+ 1

DEFINITIONS
DEFINITIONS
BUSYF
BUSYF

=%00000010
=%00000010

LEDON
LEDON
LEDSL
LEDSL
MSCNT
TSAMPH

= %00010000
00010000
=%00100000
00100000
=$C7
=6
=6

PATTERN FOR EXA'J'
EXAMINING
L G BUSY
BUSY
.PATTER,
STA-us
STATUS
CODE -o
TO SE
SEND OUTPUT
.CODE
OUTPUT TO LEDS
LEDS
CODE
CODE TO
TO SELECT
SE~ECT LEADING
LEADING DISPLAY
;COUNT NEEDED
EEDEDTO GIVE
GIVE 1 MS DELAY
DELAY
;TSAMPH X TSAMPL
SAMPL IS
IS THE
THE NUMBER
NUMBER OF
OF
;TIMES
THE DISPLAYS ARE
ARE PULSED
PULSED IN
IN A
TIMES THE
TEMPERATURE
TEMPERATURE SAMPLING
SAMPLING PERIOD.
PERIOD.
HE LENGTH
LENGTH OF
OF A
A SAMPLING
SAMPLING PERIOD
PERIOD
THE
IS
2*TPULS*TSAMPH*TSAMPL
IS THUS
HUS 2·TPULS.TSAMPWTSAMPL
MILLISECONDS THE
THE FACTOFf
FACTOR' OF
OF 2'TPULS
2•TPULS
MILLISECONDS
IS
IS INTRODUCED
INTRODUCED BY
BY THE
THE FACT
FACT THAT
THAT
EACH
EACH OF
OF 22 DISPLAYS
DISPLAYS IS
IS PULSED
PULSED FOR
FOR
TPULS
TPULS MS
MS
.DISPLAY PULSE
PULSE LENGTH
LENGTH IN
IN MS
MS

TSAMPL
50
TSAMPL = 2
=250

TPULS
TPULS

==2

•=$FFFC
'=$FFFC
RESET
RESETADDRESS
ADDRESS TO
TO REACH
REACH THERMOMETER
THERMOMETER PROGRAM
PROGRAM
WORD
WORD

BEGIN
BEGIN

116-25
6 -2 5

INITIALIZATION OF
INITIALIZATION
OF THERMOMETER
THERMOMETER PROGRAM
PROGRAM

*=BEGIN
LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA

#STKBGN
#STKBGN

INITIALIZE
;INITIALIZE STACK
STACK POINTER
POINTER

##0
0
VIADDRA
VIADDRA
#$FF
#$FF
VIADDRB
VIADDRB
##%11000001
% 1 1000001

;MAKE
;MAKE PORT
PORTAA LINES
LINESINPUTS
INPUTS

STA
LDA
LOA
STA

VIAPCR
VIAPCR
#BUSYF
#BUSYF
VIAIFR
VIAIFR

;MAKE
;MAKE PORT
PORTBBLINES
LINESOUTPUTS
OUTPUTS
START
;STARTCONVERSION
CONVERSIONLOW.
LOW. BUSY
BUSY
; ACTIVE LOW-TO-HIGH
LOW-TO-HIGH
;CONFIGURE
;CONFIGUREVIA
VIA PERIPHERAL
PERIPHERALCONTROL
CONTROL
;CLEAR
;CLEARBUSY
BUSYFLAG
FLAGINITIALLY
INITIALLY

;PULSE
;PULSE START CONVERSION
CONVERSION LINE
LINE
START

LOA
LDA
STA
LOA
LDA
STA

#% 1
#%11100001
VIAPCR.
VIAPCR'
#% 1
#%11000001
VIAPCR
VIAPCR

;SEND
SENDSTART
STARTCONVERSION
CONVERSIONHIGH
HIGH
;SEND
.SENDSTART
STARTCONVERSION
CONVERSIONLOW
LOW

:W
AIT FOR
;WAIT
FOR BUSY TO GO HIGH AND READ
READ DATA

WTBSY

LDA
LOA
BIT
BEG
BEQ
LOA
LDA

#BUSYF
#BUSYF
VIAIFR
VIAIFR
WTBSY
WTBSY
VIAORA
VIAORA

;HAS
:HAS CONVERSION
CONVERSIONBEEN
BEENCOMPLETED?
COMPLETED?
;NO,
AIT
;NO.WWAIT
;YES.
:YES.READ
READDATA
DATA FROM
FROMCONVERTER
CONVERTER

;CONVERT DATA
DATA TO TEMPERATURE
TEMPERATURE IN DECIMAL
JSR

CONVR
CONVR

JSR
JSR

BINBCD
BINBCD

;CONVERT
:CONVERTDATA
DATA TO
TOTEMPERATURE
TEMPERATURE
; IN BINARY
;CONVERT
:CONVERTBINARY
BINARYTO
TOBCD
BCD

;CONFIGURE
;CONFIGURE DIGITS
DIGITS FOR
FOR DISPLAY
ORA
STA
TXA
BEG
BEQ
ORA
ORA
STA
SVMSD STA

#LEDON
#LEDON
LSTEMP
LSTEMP
SVMSD
SVMSD
#LEDON
#LEDON
#LEDSL
#LEDSL
MSTEMP
MSTEMP

;SET
;SETOUTPUT
OUTPUTTO
TOLEDS
LEDS(LSD
(LSDININA)A)
;SAVE
;SAVELEAST
LEASTSIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
;GET
;GET MOST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
;LEAVE
:LEAVEDISPLAY
DISPLAY OFF
OFFIFIFMSD
MSDISISZERO
ZERO
;SET
:SETOUTPUT
OUTPUTTO
TOLEDS
LEDS
;SELECT
;SELECTLEADING
LEADINGDISPLAY
DISPLAY
SA
VE MOST
:SAVE
MOSTSIGNIFICANT
SIGNIFICANT DIGIT
DIGIT

iPULSE
;PULSE THE
THE LED
LED DISPLAYS

PULSE
PULSE
-LOOP
TLOOP

LOA
LDA
STA
LOA
LDA
STA

#TSAMPH
#TSAMPH
DCTR+1
DCTR+1
#TSAMPL
#TSAMPL
DCTR
DCTR

; 16-BIT
;16-BIT COUNTER
COUNTERFOR
FORDISPLAY
DISPLAY PULSES
PULSES

1 6 - 26
6

DSPLY
DSPLY

LDA
LDA
STA
STA
LDY
LDY
JSR
JSR
LDA
LDA
STA
STA
LDY
LDY
JSR
JSR
DEC
DEC
BNE
BNE
DEC
DEC
BNE
BNE
BEQ
BEQ

MSTEMP
MSTEMP
VIAORB
VIAORB
#TPULS
#TPULS
DELAY
DELAY
LSTEMP
LSTEMP
VIAORB
VIAORB
#TPULS
#TPULS
DELAY
DELAY
DCTR
DCTR
DSPLY
DSPLY
DCTR+1
DCTR+1
TLOOP
TLOOP
START
START

;OUTPUT
.OUTPUTTO
TOLEADING
LEADINGDISPLAY
DISPLAY
;DELAY
:DELAYDISPLAY
DISPLAYPULSE
PULSELENGTH
LENGTH
iOUTPUT
TRAILINGGDISPLAY
:OUTPU TO0 "RAIL!
DISPLAY
:DELAY
:DELAYDISPLAY
DISPLAYPULSE
PULSELENGTH
LENGTH

:HAS
REACHED
:HAS COUNT
COUNT REAC
EDZERO?
ZERO?
: 0. KEEP
KEEPPULSING
PULS! G DISPLAYS
;NO.
DISPLAYS
.
YESGO
GO SAMP
;YES.
SAMPLE E -E
TEMPERATURE
PE>!A UREAGAIN
AGAIN

:SUBROUTINE DELAY
DELAY WAITS
WAITS FOR
FOR THE
THE U
BE? OF
OF MSS SPECIFIED
SPECIFIED IIN
■SUBROUTINE
NUMBER
INDEX REGISTER
REGISTERY
Y BY
BY COUNTING
Tl G WITH INDEX
DEX REGISTER
REGISTERX
;: INDEX
DELAY
WTLP
WTLP

LDX
LDX
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
RTS
RTS

#MSCNT
#MSCNT

;COUNT
.COUNT FOR
FOR 1MS
MSDELAY
DELAY
;WAIT 11 MS
MS
;W

WTLP
WTLP
COU
MS
;COUNT,- MS

DELAY
DELAY

:SUBROUTINE
VR CONVERTS
VER-5
:,
- :::,
I A /D
.:...'DCONVERTER
CONVERTER TO
TO
SUBROUTINE CONVR
INPUT
FROM
DEGREESCELSIUS
CELSIUS 8
G A -TABLEAB_E INPUT
PUT DATA IS IN
DEGREES
BY S
USING
; THE
THE ACCUMULATOR
O AND
D THE
-..,E RES
,SAA BINARY NUMBER
NUMBER IN
RESULT IS
: THE ACCUMULATOR
A oq
:REGISTERSUSED: A.X
REGISTERS
:MEMORY LOCATION USED:
USED· INPUT
CONVR

CHVAL

STA
LDX
INX
LDA
CMP
BCC
TXA
TXA
RTS

INPUT
#$FF
#$FF
DEGTB.X
INPUT
CHVAL
CHVAL

:SAVE INPUT READING
READING
:START TABLE INDEX AT -1
:INCREMENT TABLE INDEX
:GET ENTRY
ENTRY FROM TABLE
IS A/D
A/D INPUT BELOW ENTRY?
ENTRY?
;IS
NO, KEEP
:NO.
KEEP LOOKING
YES, RETURN
WITH TIN
IN ACCUMULATOR
ACCUMULATOR
:YES.
RETURN WITH

:TABLE DEGTB WAS
WAS FOUND BY
BY CALIBRATION.
DEGTB CONTAINS
CONTAINS THE LARGEST INPUT
INPUT VALUE
VALUE WHICH
WHICH CORRESPONDS
:DEGTB
CORRESPONDS
TO A
TEMPERATURE READING (I.E.
FIRST ENTRY
A PARTICULAR
PARTICULAR TEMPERATURE
(I.E.. THE FIRST
IS
LARGEST
IS DECIMAL
DECIMAL 58
58 SO
SO AN INPUT VALUE
VALUE OF 58
58 IS
IS THE
THE LARGEST
: VALUE
TEMPERATURE READING -— VALUES
VALUE GIVING A ZERO
ZERO TEMPERATURE
VALUES
: BELOW
BELOW ZERO
ZERO ARE
ARE NOT
NOT ALLOWED
ALLOWED
DEGTB

.BYTE
BYTE
.BYTE
BYTE
.BYTE
BYTE
.BYTE
BYTE
.BYTE
BYTE
.BYTE
BYTE
.BYTE
.BYTE

58.61.63.66,69.71,74,77,80,84
58.61.63.66,69.
71. 74. 77.80.84
87,90,93,97,101,104,108
87.90.93.97.
101.104. OB
112,116,120.124,128.132,136
1 12. 1 16.120.124.
128.132. 36
141.145.149.154.158.163,167
141.145.149.154.158.163,
172,177.181,186.191.195.200
172.177.181.186.191.
195.200
204,209,214.218,223,227,232
204.209.214.218,223.227
.232
236.241.245.249.253,255
236.241.245.249.253.255

16-27
16-27

SUBROUTINE
;SUBROUTINE BINBCD
BINBCD CONVERTS
CONVERTS AA BINARY
BINARY NUMBER
NUMBER LESS
LESSTHAN
THAN 100
100 INTO
INTO
, TWO
TWO BCD
BCD DIGITS.
DIGITS. THE
THE INPUT
INPUT DATA
DATA IS
IS IN
IN THE
THE ACCUMULATOR
ACCUMULATOR AND
AND THE
THE
; RESULT
RESULTIS
IS IN
IN INDEX
INDEX REGISTER
REGISTERXX (MOST
(MOST SIGNIFICANT
SIGNIFICANT DIGIT)
DIGIT) AND
AND THE
THE
; ACCUMULATOR
ACCUMULATOR (LEAST
(LEAST SIGNIFICANT
SIGNIFICANT DIGIT)
DIGIT)

;REGISTERSUSED:
USED: A.X
A,X
REGISTERS
BINBCD
BINBCD

LOX
LDX
SEC
SEC
SUBTEN INX
INX
SUBTEN
SBC
SBC
BCS
BCS
ADC
ADC
RTS
RTS
.END
.END

#$FF
#$FF

#10
#10
SUBTEN
SUBTEN
#10
#10

TENS
-1
;TENS COUNT
COUNT ==-1
SET
;SET CARRY
CARRY INITIALLY
INITIALLY
INCREMENT
;INCREMENT TENS
TENS COUNT
COUNT
CAN TEN
;CAN
TEN STILL
STILL BE
BE SUBTRACTED?
SUBTRACTED?
YES.
;YES. CONTINUE
CONTINUE
NO.
;NO. ADD
ADD BACK
BACK LAST
LAST TEN
TEN

16
-2 8
16-28

REFERENCES
REFERENCES
1. E.
E. R.
R. Hnatek.
Hnatek, AA User's
User's Handbook
Handbook of
of D,
D /A
and A/0
A /D Converters.
Converters. Wiley,
W iley. New
New York.
York,
1.
A and
1976
1976
2. T.
T. A.
A. Seim,
Seim, "Num
erical Interpolation
Interpolation for
for Microprocessor-Based
Microprocessor-Based Systems."
Systems," ComCom2.
"Numerical
puter Design,
Design, February
February 1978.
1978, pp.
pp. 111-116
111-116,
puter
-3. D.
D. H.
H. Sheingold.
Sheingold, ed
ed..
Analog-Digital Conversion
Conversion Notes
Notes, Ana
Analog
Devices, Inc
Inc.. PP. 0.
0.
3.
.. Analog-D1g1tal
og Devices.
Box 796.
796, Norwood.
Norwood, MA.
MA. 02062,
02062, 1977
1977
Box
4.
4.

D. P.
P. Burton.
Burton, and
and A
A. L.
L. Dexter,
Dexter, Microprocessor
Microprocessor S s
Systems
Handbook. Analog
Analog
0.
;:"'ls Handbook.
Devices. Inc
Inc.,
P O.
0. Box
Box 796.
796. Norwood.
Norwood. M
1977
02062 ·::
Ti
Devices.
.. P.
MAA 02062

5.
5.

B. Peatman.
Peatman, Microcomputer-b
Microcomputer-based Design. McGraw-*JJ. 8.

New York. 1977

6. F.
F. Molinari.
Molinari. et
et al,
al., "Shopping
"Shopping for
for the Right Analog 1 0 Board
6.
October 11,
11, 1978,
1978, pp
pp. 238-243
238-243
October

Electronic Design.

Auslander, D M
irect D g
Digital
Control: Prac·
Practice and Algorithm s
Auslander,
M. et aal.. "Direc
·a OProcess
xess Centro
for Microprocessor
Microprocessor Apphcat1ons,"
Applications, Proceedings
Proceedings of
of the
the IEEE.
IEEE. :::.,
February 1978. pp
for
199-208
199-208
c· ·977
8
J. Bibbero,
Microprocessors In
in Instruments
Instruments an
and C
Con
tro l W iley. New York.
1977
R. J.
81bbero, Microprocessors
~··:
8.. R.

7.
7.

9
9.

A Mrozowski.
Mrozowski. "Analog
"Analog Ou
O utput
Chips
Shrink
A-D Conversion Software,
A
ou· C
os S-•
Electronics.
June 23
23. 1977
1977. pp
130-133
Electronics, June
or, • 3
10.
10. P.
P. R. Rony et al.. ' M ic rocc o m
r-:cp jte ' ".er'a: ng Sample
Samp,e and Hold Devices." Computer Design.
December
1977. pp 106-108
puter
Design. Dece
oer 97,
11.
11.

P H. Garrett. Analog Systems for Microprocessors
inicomputers. Reston
croprocessors and Minicomputers,
Reston
Publishing Co
Reston. V A 1978
Publishing
Co.. Re

12.
12.

The Optoelectronics
Optoelectronics Data Book.
Inc.,.. P.
Book. Texas
Texas Instruments. Inc
P. 0.
O. Box
Box 5012. Dallas.
Dallas,
TX..
TX. 1978
1978

13.
Optoelectronic Designer's
Inc.,•• 1820
13. The Optoelectronic
Des1gner"sCatalog. Hewlett-Packard.
Hewlett-Packard. Inc
1820 Embarcadero
Embarcadero
Road,
Road, Palo
Palo Alto,
Alto. CA
CA 94303,
94303. 1978.
1978.

16-29
16-29

Index
A ccum
u la t o r , U sing the. 4-2
umulator.
A CIA I n t e rrupt
p t R o utine. 1 2-32
A CIA In te r rupts. 6 850., 1 2-9
-9
A CIA R e g isters
rs

Credit Verification. Flow
charting the. 1 3-24
l=Jowcharting
Credit Verification Term inal. Structured
Program for the. 1 3 -4 4
Cross-Assembler. 2 -1 6

6 551., 1 1 -118
6 850, 1 1 -1
11
-111
A /D C o n verter In terface. 1 1 -98
A d dress F ield.
, N u mbers a nd C h a r acters. 3-111 11
A d d r essing M o des., 3 -111
1
P o s t-Indexed (In direct). 5 -20
P re -ln
d e x e d (In direct). 5 -22
-Indexed
A d d resses., S to ring., 3-7
A lg ebraic
ic N o tation. 1-8

D / A Converter Interface

11-93
Data. Forming C'asses of. 14-27
Data Flowcharts- '3 - 2 0
Debouncing ~ Sc^tw a'e 11-47
w ith Cross-C oup^o >iAN D Gates. 1 1 -5 0
Debugging. 13-3
Using Test Cases from. 14-25
Deciding o n a M ajo r C h a n g e . 15-21

A lg o rithms.
ith m s . B e
-2 1•
Setter. 1 5-2

D e c im a l D a ta o r A d d re s s e s . 2 -1 0

A r it hmetic a nd L o g
ic a l E.Kores5;
Expressions.
g1ca
.......
5 2,--1 1

D e c im a l M o d e . 8 -5

_ im it aait io n
ions
8-6
L
s. 8-

Arithmetic P ro g
Program
-es·
a~
..4 .!-La
A r it h
ra m . T e
s tin gg a
n. 1
28
A r it h
m e t ic with
it h T a
b le s . 4
- 1• 55
ithmetic
-aces
,:_

D e cimal N u m bers. D o ubling a nd Halving. 8-21•

A SCII
II C h a r acters
rs . 2-1111

D e cimal R o u nding., 8 -22

A SCII.
II. H and lin
g D ata in
Ing
In. 6-1
6-1

D e fining N a m
e s , 2-6
mes.

A s s embler. 1-5
-5

D e f in
itio n L ist. R ules
le s for. 15-1
15-11
finition

A r it h
m e t i c E x p re ssions.
io n s , 3 -111
1
ithmetic

T y pical. 1 5-11
-1 1

C h o osing an.
, 1-6

D e f in
itio n s , P la c ement of. 2-7
1nit1ons.

O n e -p
a s s , 2 -16
e-pass.

D e lim
ite r s . 2-2
l1m1ters.

T w o -pass., 2 -16

D ivision A lg o r
ith m . 8 -12
rithm.

A s s embly L a n g u
e , A p p lic
t io n s for.
r, 1 -10
uage.
hcauons

D o c u m entation.
a t io n , 1 3-3

A s s embly L a n guage F ields.
s , 2-1
2-1

D o c u mentation
n t a t io n P a c k
a g e , 1 5-17
7
ackage.

A s s embly L a n guage P ro gram.
. 1-4

D o c u menting
t in g S tatus and C o ntrol T ra n sfers.
.

B inary a nd B CD.
D , A c c uracy
a c y in. 8 -6

D o uble B u ffering., 1 2 -19

B inary., D e cimal A c c uracy
a c y in., 8-3
B inary I n s t r uctions.
n s , 1-1
1-1
B inary R o u nding. 8 -21
1
Bit T est In s t r uction.
t io n , 1 1 -79
B o o tstrap L o ader.
r, 2 -17
B o tto
Bottom-Upp D e s
Design. 1 3
13-50
B re a kpoint.
t, 1 4-2
In s erting. 1 4-3
BRK
RK I n s t r uction.
t io n . 1 2-4
As a B re a kpoint.
t, 1 4-2
C a libration
n T a ble., U sing a,
-2 1
a. 1 6-21
C h e cklist. Whatt to In clude in. 1 4-110
0
C ode
e C o n version P ro gram. D e b ugging a. 1 4-15
C o ding., 1 3-3
R e lative I m p o rtance
n c e of. 13-1
13-1

1 1- 80

8 - B it S u m m a tio n., 5 -4
E rro
rs . C o mmon., 14-11
4-11
rrors.
C o n s id e
-5
Considerations. 1 3
13-5
E x ample F ormat. 4-1
4-1
E x a mples
s . G u id elines for. 4-1
4-1
E x te
nces. 2
External R e fe re
References
2-8
F lo w c h a r tss. H in ts f o r U s in g . 1 5 -9
F lo wcharting
c h a r tin g . A d v a n tages
g e s o f. 1 3 - 1 8B
D is a d v antages ol,
f, 1 3-18
S ec
Sections. 1 3
13-24
F ormat. 2-2
FO R T
R A N . 1-7
ORTRAN.
1-7
G e neral
ra l S e rvice R o utines. T a s
k s for. 1 2-37
sks
E L 6 Hand
a n d A s s embly. 1-5
-5

C o m bining
g C o ntrol I n f o r mation
io n , 1 1 -7
9
-79

H and C h e cking Q u e stions. 14-110
0

C o m menting
tin g E x a mples.
s . 1 5-5

H a s hing,. 9-4

G u id elines., 1 5-3

H e x a decimal L o a
d e r. 1-3
ader.

Q u e stions for.
r, 1 5-6

H ig h
-11
High-Level L a n g
Language. 11-11

T e c h niques., 2 -15

A p p lic
a t io n s for,
r. 1-11
plications
1-11

C o m m on-Anode
n o d e or C o m m o n-Cathode D is plays,

A d v a ntages of. 1-9
-9

1 1-65

D is a d v antages of. 1-9

C o mpiler.
r, 1-7
-7

In e f f ic
ie n c y of. 1-8
lneff1c1ency

O p t imizing.
iz in g , 1-8

M a chine I n d e p endence of. 1-7

Co
f, 1
Cost oof.
1-8

O v e rh
e a d for., 1-9
rhead

C o mputer P ro gram. 1-2

P o r tability
b ilit y of. 1-7
-7

C o n ditional
n a l B ra n c
h e s . L ong, 5 -11
1
ches.

S y ntax of. 1-8
-8

C o ntrol a nd S tatus I n f o r mation.
t io n , 1 1 -78

U nsu
it a b ilit y of.
f, 1 -10
uitability

xxi
xxi

Index (Continued)
(Continued)
I n f o rmation
m a t io n H iding
in g P r in c iple.
le . 1 3 -3 2
In p u t, F a c to rs in., 1 3 -4
In p utt S y s te m s., C h a racteristics
a c t e r is t ic s of.
f, 12-1
12-1
I n s truction
r u c t io n E x e c u tion.
n , S ta tu s C h a n g e s with,
it h ,
3 -18
In s t ructions.
u c t io n s . D e fining
in in g a S e q u e n c e o f. 2 -1 3
In t e rrupt-Driven
r u p t- D r iv e n P ro g ra m s., D e b u gging.
g in g , 1 4 -1 3
In t errupt
r r u p t H a ndling
lin g by M o nitors.
it o r s , 1 2-15
In t errupt
r r u p t In puts,. 1 2-3
In terrupt,
r r u p t, N o n -Maskable.
M a s k a b le , 1 2 -2., 1 2 -4
In t errupt
r r u p t R e s ponse., 1 2-3
In t errupt
r r u p t R e tu rn A d d re s s., C h a n ging
in g th e . 1 2 - 1 8
In t errupt
r r u p t S y s te m., S p e c ia l F e a tu re s of.
f, 1 2 -3
In te r rupts.
p ts , D is abling.
lin g , 12-31
2-31
D is a d vantages
ta g e s of 1 2-2
E m ptying
ty in g a B uffer
ffe r with.
it h . 1 2 -2 2
E n a b lin g a n d D is a bling.
lin g . 1 2 -2
on P a r tic
u la r M ic r o c o
m p u te r s . 1 2-15
ticular
rocomputers.
R e a s o n in g B e h in d., 12-1
12-1
6 5 30
0 a n d 6 5 3 2 M ultifunction
lt if u n c t io n D e v ic e., 1 2 -9
V e c tored. 1 2-12
I/O
1/0 D e v ic e T a b le . 1 1 - 1 2 3
I/O
o n iz in g w ith.
h , 1 1-78
1/0 D e vices. S y n c h r
hronizing
J ump a nd B ranch T e r m in
o lo g y . 9 -17
inology,

M emory
m o r y L o a d e r E rro r H a n dling.
lin g , 1 3 -9
O p erator
to r Error C o r r ection
c tio n in., 1 3-11
M em
o r y M ap, T y pical.
ic a l, 1 5 -10
mory
M eta-Assembler.
ta - A s s e m b le r , 2 -1 6
M ic roassembler.
o a s s e m b le r , 2 -1 6
M nem
o n ic s , P ro blem w ith.
h , 1-4
emonics,
M o dular
u la r P ro gramming.
r a m m in g . A d v antages
n ta g e s of.
f, 1 3 -2 9
D is a d vantages
n ta g e s of.
f, 1 3 -29
R ules for.
r, 1 3 -34
M o d u la
r iz a t io n , P r in ciples
ip le s of.
f, 1 3 -30
ularization.
M u lt ip
lic a t io n A lg o
r it h m , 8-7
ltiplication
orithm.
N a mes. C h oice of. 2-6., 1 5-2
N a mes., Use
se of. 2 -6
N o n - Decimal
c im a l N u mber
b e r S y s tems. 2 -10
N o tation.
tio n , D iffe r
e n c e s in., 3-5
rences
O bject
c t P ro gram., 1-2., 1-5
O ctal or H e x a decimal.
c im a l, 1-3
O n e-Pass A s s e
m b le r , 2 -16
embler.
O p e ra to r I n t e r a c tio n., 1 3 -6
O rigin P s e u d o -O
p e r a tio n , S et.
t, 3 - 110
0
o-Operation.
P a ssing P a ra meters., 10-1
0-1
PIA In te r r
u p ts . 6 520. 1 2-5
rrupts.
P olling,. 1 2-2
In te r rupts.
p ts , 1 2-11
-1 1

Key C lo sure. W a it
in g f or a. 1 1 V\a1t1ng
1-84

In te r rupts.
p ts . D is a d vantages
ta g e s of.
f, 1 2-11
-1 1

Key T a ble. 1 6-6
K e y board E rrors. C o rrecting.
c tin g . 1 3-15

P o r ta
b ilit y , 1-6
tability.

K e y board I n t e r
r u p t. 12-116
6
errupt,

P riority.
rity . 1 2-2

K e y board R o utine. E x p anding
in g the. 1 3 -54

P ro blem D e f in
itio n , 1 3-3
inition.

K e y board S can., 1 1-81
1

P ro c essing., F a ctors in., 1 3-5
P ro gram D e sign., 1 3-3

L abel F ield. 2-2

B asic P r in ciples
ip le s of. 1 3-17

L a b eling., R ules of. 2-4

P ro g r a
m in g G u id elines.
lin e s . 4-2
amming

L a bels. C h o osing., 2-3

P s e u d o -O
p e r a tio n s , 2-4
-Operations.

L a bels in J ump
p In s t r u
c t io n s , 2-2
uctions.

BYTE
. . DBY
T E , . T EXT
T .... W ORD. 3 -109
BYTE.
YTE.

L a n guage L e vels., A p p lic
a t io n A reas for,
r. 1-10
lication
F uture T rends in., 1-11
1-11

R AM. A llo c
a t in g . 2-7
cating.
I n itia liz
in g . 2-8
ln111ailzing,

L e ading Z ero,. B la nking
in g a,
a. 1 6-22
LED
D C o ntrol. 11-61
1-61

R eal
al T ime. M a in t
a in in g . 1 2-29
intaining.

L ink E ditor. 2 -17

R e al-Time C lock. 1 2 -23

L inking
in g L o aders. 2 -17

F re q uency
y of. 1 2 -23

L o c ation
n C o unter . 2-7

P r iority
r it y of.
f, 1 2-23
S y n c h ro
n iz a t io n with.
it h . 1 2-23
hronization

L ogic A n alyzer. 1 4-9
Im p o
r ta n t F e atures of. 1 4-9
ortant
L o gicall D e vices., 1 1 -123

R e d esign. C ost of.
f, 1 5 -18
R e e ntrant S u b r o
u tin e . 1 0-2
broutine.
R e gister D u mps, 1 4-4

M a chine
in e L a n guage,. A p p lic
a t io n s for. 1-110
plications
P ro gram., 1-2

R e lo cating
tin g L o ader. 2 -17

M acro A s s embler.
b le r, 2 -16

R e lo cation C o n stant,
t, 2-3

M a cros. A d v a n
ta g e s of.
f, 2 -14
ntages
D is a d v
a n ta g e s of.
f, 2 -14
vantages
M a in te
n a n c e a nd R e d esign., 1 3-3
intenance
M atrix
tr
K e y board., 1 1-81
1
M eas
u rin g P ro gress in S tages., 13-1
Veasuring
13-1
Me
m o r y D ump., 1 4-6
'.'emory
M em
o r y . S a ving. 1 5-19
'/e,..,orv
U s in~g P age Z ero of. 4-3

R e lo cation. 1 0-2
R e sident A s s embler.
b le r, 2 -16
R e o r g anization.
a tio n , M ajorr or M inor., 1 5-18
R o llover.
r, 1 1 -90
S a ving M e mory,
y , 1 5 -19
S a ving E x e cution
n T ime. 1 5-19
S e a rching
in g M e thods.
s , 9-6
S e lecting
c t in g D ata f r om C la sses.
e s , 1 4 -27

xxii
xxii

Index (Continued)
(Continued)
Self-Checking
Numbers. 8 -1
8-17
S e lf- C h
e c k in g N u m
Self-Documenting
or. 115-1
S e lf- D o c u m e n tin g Programs.
P
, Rules
R
fo
-1
Separating
Status
Information.
S
S
In r m a t io n , 11-79
1
Simple
Sorting
Algorithm.
9-12
S im
le S o r
tin g A lg o
r it h m , 9 -1
Single-Step., 14-1
14-1
S in g le
Limitations
of.
14-2
L
it a t io n s o f, 1
Software
a r e Simulator.
la to r , 14-8
6520 P
PIA I n t e r r
Interrupts.
12-5
65
u p ts , 1 2
6522 V
VIA In te r r
Interrupts,
12-6
65
u p ts . 1 2
Enabling a n
and D is a
Disabling., 1 2
12-6
Ena
6551 A C
ACIA C o n f ig
Configuration.
Example oo!f. 1 1 - 1 1 8
65
u r a tio n , E x a
6551 A C
ACIA R e g is
Registers., 1 1 11-118
65
6800
/6 5 0 2 A d d re
s s in g M o
n.
Mode C o m
Cor,,pa,r is o
sec
6800/6502
Addressing
3-105
3 -1
In s tr
u c t io n C o m parison. 3- 1 0
Instruction
;066
Reg
Register C o m panion. 3 - 105
S im
ila r it y . 3 - 1
Similarity.
3-105
S ta
5
Status C o m parison, 3-1 0
105
68
u r a tio n , E x ample of.
f, 1 1 - 1
15
68500 A CIA C o n f ig
nfiguration,
;-115
68
11
68500 A C
CIA R e g isters., 1 1 -111
68
11
68500 A CIA., S p ecial F e atures of. 1 1 -1
1-111
6 850 A CIA In te r rupts.
ts , 1 2-9
Sort P ro gram. D e b u
g g in g a. 1 4
ebugging
~- 1• 9:i
T e sting a. 1 4 -28
S or
tin g M e thods. Oth er. 9-1·:5
orting
S o urce P ro gram. 1
-5
'-5
S o ftw
a r e D e v e lo
p m e n t. S ta
g
oftware
velcpr,,er.·
:a;;es
:o f. -1 3-1•
S ta ndard In terfaces . 1 1 - 1 2
,-4
S ta ndard P ro gram L ib r a
r y Fer
o m s . •1 5-1• 3
,brarv
Start B
it In t errupt
r u p t. 1 2
-3 4
81t
'2-34
S to p
w a tc h I n putt P ro c edure. 16-1
6-1
Stopwatch
S tr u c
tu re d K e y b
o a rd R o utine. 1 3 -44
board
Structured
S tr u c
t u r e d P ro g r a
m in g , A d v a n
es o
f, 1 3
Structured
Programming.
Advantages
of.
13-39
B asic S tr u c
u r e s o f. 1 3 -35
ctures
D is a d vantages of. 1 3-39
Ru
Rules fo
for., 1 3 13-49
Wh
e n to Use.
se. 1 3-40
hen
S tr u c
t u r e d R e ceive R o utine., 1 3 -46
Structured
S tr u c
tu re d T e s
Structured
Testing., 1 4
14-27
S tr u c
tu r e s , E x a m
f, 1 3 Structures.
Examples oof.
13-38
Ru
Rules fo
for., 1 3
13-49
S tubs., 1 3-50
E xpa
Expanding, 1 3
13-50
Subr
o u t in e I n s t r u
c t io n s . 10-11
Subroutine
Instructions.
Subr
o u tin e L ib r
Subroutine
Library., 10-1
10-1
S u b ro
u tin e s , D o c u m
e n t in g , 1 0
Subroutines.
Documenting.
10-2

S,,
;en
and'..L ig h t EErrorr H a n d
Handling., 13-7
13-7
S
w it c
h an
IYtC
ar.::_;
""OLt.13-7
Sw
it c h a n d
L ig h...t In p u t,
13-7

·c•

Swit c h aa.,o
Ou:oJtS
13-7
S
n d L_iggrt
ht O
tp u ts . 13-7
Sw
it c h a n
te m . D e fin
Sw,tch
and L ig
Lightt S y s
Svs:er,,
Defining. 13-7
13-7

Flowcharting.
F lo w c h
r tin g . 13-r
13-20
M odu
iz in g th
e . 13-31
Modularizing
tt'=
3-3

Structured P
Frc;-a-:he
13~,
o g r a m m in--g;
g inr, th
e . 13-41

Top-Down D!)=5
Tope s ig; n o f. 13-51

·=-.

:>e'·

S w itc h
B
d •
M e m o r y L o a d e r. D e fin in";!g a.
,tch-Sasec
a 13-9
13-9
F lo w c h a r tin g th e . ' 3 -2 2
M o d u la r iz in g t h e . '3 - 3 *
S tr u c t u r e d

(ram i— c so r. 1 3 - 4 2

T o p - D o w n D essgr* c C 1 3 - 5 2
S w it c h S o u r c e , 1 1 - 4 7
S y m b o l T a b ie . 2 - 6
T e r m inr,a
a t oors
r s f o..,.-5~
r S tr...
u.....
c tu
e s . T3-43
~ ..r:'?.Si
~-T e s tin g . 1 3
1-3
A id s . 14-25
R u le s fo r . 1 4 -2 9
S p e c ia l C a s e s

1 4 -2 7

5- 115
T h e r r o o r n e fe r A n a 'o g H a r d w a rea. 1 6
5
13-50
T o p - D o w n D e s ig n . A d v a n ta g e s o f. 1 3
-5 0
O s a d v a n t a g e s o f. 1 3 - 5 0
Fo
rm a t• foor
r . 113 -55
P.,""'a
M e th
'e·~ods. 1 3 13-50
T ra n s m
is io n E rro
rs , C o r r ecting. 1 3
-1 5
-,ansm1ss1on
rrors.
13-15
TTL
T L E ncoder.
c o d e r. U s in g a.
-5 6
a. 1 1-56
T TY
Y In te rfa c e,. 1 1 - 1 0 3
T TY
Y R eceive
c e iv e Mode,
o d e , 111-103
1 -1 0 3
T TY.
Y . S ta n d a rd . 1 1 - 1 0 3
TTY
T Y T r a n s m it M o d e . 1 1 - 108
08
T w o -P a ss
s A s s e m b le r, 2 -16
6
UA
R T , 1 1 -110
ART,
V a r iables., L ocal or G lobal. 2 -14
V e c t o r ing,
g , 1 2 -2
V e r if
ic a t io n T e r minal.
l, D e fining a,
-1 2
ification
a. 1 3
13-12
Error
r H a n dling, 1 3 -14
In puts, 13-112
2
M odu
la r iz in g the,. 1 3-32
2
ularizing
O
u tp u ts , 113-12
3 -1 2
Outputs.
Topf, 1 3
3
Top-Down D e s
Design oof.
13-53
V
IA In
te r r u p ts , 6
5 2 2 , 112-6
2 -6
VIA
Interrupts.
6522.
Ena
lin g 6 5 2
-6
Enabling a n
and D is a
D,sabhng
6522., 1 2
12-6
F illin g aa B
u ffe r , 112-19
2 -1 9
Filling
Buffer,

xxiii

About the Author
Lance A. Leventhal is a partner in Emulative Systems Company, a San
Diego-based
consulting firm specializing in microprocessors and
Dif!!go-based consulting
microprogramming. He serves
for
microprogramming.
serves as Technical Editor of the Society for
Simulation and as a Contributing
Contributing Editor for Digital Design.
Computer Simulation
Design.
He
microprocessors for
for the IEEE,
He is a national lecturer on microprocessors
IEEE,the author of
forty articles on microprocessors, and a regular
five books and over forty
contributor to such publications
publications as Simulation,
Simulation, Digital Design,
contributor
Design, and
Kilobaud.
---Kilobaud.
Dr. Leventhal's previous experience includes affiliations
affiliations with
with Linkabit
Intelcom Rad
Corporation, lntelcom
Rad Tech, Naval
Naval Electronics Laboratory Center
Center
and Harry Diamond Laboratories. He received a B A degree from
Washington University in St. Louis, Missouri, and
Washington
ano M.S. and Ph.D.
Ph.D.
degrees from the University of California at San
mem­
San Diego.
ego He is a member of SCS,
SCS, ACM,
ACM, and IEEE.
IEEE.

OSBORNE/McGraw-Hill
E/McGraw-Hill GENERAL BOOKS
BOOKS
Introduction to Microcomputers
Microcomputers series
An Introduction
by Adam Osborne
Volume 0
Beginner's Book
Volume
O -— The Beginner's
Volume 1 -— Basic Concepts
Concepts
Volume
Volume 2 -— Some Real Microproceasors
Microprocessors (197b
Volume
(1971Sed.)
Volume 3 -— Some Real Support
Support Devices
Devices (1978
(1978 ed.)
Volume
ed.)
Volume 2 1978-1979
1978-1979 Update Series
Volume
Volume 3 1978-1979
1978-1979 Update Seriu
Series
Volume
8089 I/O
Processor Handbook
Handbook
The 8089
1/0 Processor
by Adam Osborne
The 8086
8086 Book
Book
by R.
Rector and G Alexy
R. Rector
8080 Programming
Programming for Logic Duign
Design
8080
by Adam Osborne
6800 Programming
Programming for Logic Design
6800
by Adam
Adam Osborne
Programming for
for Logic Design
Z80 Programming
Design
by Adam Osborne
8080A/8085 Assembly Language
8080A/8086
Language Programming
Programming
Leventhal
by L. Leventhal
6800 Assembly
Assembly Language Programming
Programming
6800
Leventhal
by L. Leventhal
Z8000 Assembly
Assembly Language Programming
Programming
Z8000
Leventhal et al.
by L. Leventhal
al.
ild: The Next
Next Industrial
Industrial Revolution
Revolution
Running Wild:
by Adam Osborne
PET-CBM Personal Computer
Computer Guide
Janice Enger
by Carroll Donahue and Janice
PET
488 Bus
PET and the IEEE
IEEE 488
Bus (GPIB)
(GPIB)
by E.
Jensen
E. Fisher and C.
C. W. Jensen

OSBORNE/McGraw-Hill SOFTWARE
OSBORNE/McGraw-Hill
Practical Basic Programs
Practical
by L. Poole et al.
Some Common BASIC Programs
Borchers
by L. Poole and M. Borchers
Common BASIC Programs PET Cassette
Cassette
Some Common
Some Common BASIC Programs PET Disk
TRS-80 Cassette
Cassette
Some Common BASIC Programs TRS-80
Payroll with
ith Cost
Cost Accounting
Accounting - CBASIC
Payroll
by Lon Poole et al.
Accounts Payable and Accounts
Accounts Receivable
Receivable - CBASIC
Accounts
by Lon Poole et al.
General Ledger
Ledger - CBASIC
General
by Lon Poole et al.

Some Common Basic Programs -— PET/CBM
edited by Lon Poole et al.
edited

