OSBORNE/McGRAW-HILL

02 ASSEMBLY LANGUAGE PROGRAMMING
LANCE A. LEVENTHAL
■ ■■

■

■

■

\ m

#
T ■

■

a

■

■
■

■

--

BURKE~
DAVIDLL BURKE
DAVID
Bitting St
1129 N Bitting
1129
Wichita KS
17203
KS 67203

---------

6502
nsscmsLV
rgc
LAnGUAGE
ASSEfflBLYi r h g u
pROGRAmmmGG
PROGRAmmm

6502
6502
RSSCfllflLV
LAnGUAGE
ASSEfflBLY LRRGURGC

pROGRnmminG
PAOGAAfflffllnG

Lance fl.
Leventhcil
A. Leventhal

OSBORNE/McGraw-Hill
OSBORNE/McGraw-Hill
Berkeley, California
California
Berkeley,

Published
Published by
OSBORNE/McGraw-Hill
OSBORNE/McGraw-Hill
630
630 Bancroft
Bancroft Way
Way
Berkeley,
Berkeley, California
California 94710
94710
U.S.A.
For information on translations
For
translations and book distributors outside of
ORNE/McGraw-Hill
the U.S.A., please write
rite O S B O R N E
/M cG raw -H ill at the above
address.
address.
6502
RAMMING
65
0 2 A S S EMBLY
L Y L A N GUAGE P R O G R
A M M IN G
Copyright
Inc. All rights reserved. Printed in the
Copyright ©
® 1979
1979 by McGraw-Hill,
McGraw-Hill, Inc.
United States of America. No part of this publication
publication may be reproduced,
stored in a retrieval system, or transmitted
transmitted in any form or by any means,
means,
electronic, mechanical, photocopying,
photocopying, recording or otherwise
otherwise without
ithout the
prior written
written permission of the publishers, with
ith the exception that
that the propro­
gram listings may be entered, stored, and executed in a computer
computer system, but
they may not be reproduced forr publication.

DODO 8 7 6 5 4 3
6 7 8 9 0 DODO
ISBN 0 -9 3 1 9
-931988-27-6
ISBN
8 -2 7 -6
Cover design by K.L.T.
K.L.T. van Genderen.
Genderen.

ACKNOWLEDGMENTS
ACKNOWLEDGMENTS
following
The author
author would
would like to acknowledge
acknowledge the follow
ing people: Mr. Curt InIn­
graham and Ms. Janice Enger of OSBORNE/McGraw-Hill,
OSBORNE/McGraw-Hill, who made many
corrections,
corrections, improvements,
improvements, and suggestions;
suggestions; Mr. Gary Hankins, Mr. Michael
Lehman, Mr.
Mr. Winthrop
inthrop Saville, and Mr. Stanley St. John of Sorrento Valley
Associates,
Associates, who provided
provided assistance and examples;
examples; Mr. Leo Scanlon of
Rockwell
Rockwell International,
International, who
who provided constant
constant encouragement
encouragement and reference
materials; Mr. Charles Peddle of Commodore
Commodore International,
International, who
who provided
materials;
some reference material;
material; Ms. Marielle
Marielle Carter of Sorrento
Sorrento Valley Associates,
Associates,
who typed some of the material;
material; Mr. Stanley Rogers of the Society
Society forr ComCom­
puter Simulation,
Simulation, who has continually
continually encouraged clear and concise technitechni­
cal writing;
ritin g ; and his wife
ife Donna, forr her patience and understanding
understanding
throughout
throughout the writing
riting of this book.
Others who provided assistance and suggestions
suggestions were Mr. Colin Walsh,
Walsh, Mr.
Favreau, Mr. Richard Deisher, Mr. Karl Amatneek,
Romeo Favreau,
Amatneek, Mr. Robert Stow,
Stow,
and Mr. Irv Stafford.
Stafford. Other students
students and colleagues also helped to keep the
author on the right
right track.
The author, of course, bears responsibility
responsibility forr any remaining
remaining errors, misconmiscon­
ceptions,
ceptions, and misinterpretations.
misinterpretations.
A special note of acknowledgment
acknowledgment should go to the magazine MICRO, which
which
is entirely
entirely dedicated
dedicated to 6502-based
6502-based personal computers.
computers. Besides numerous
articles,
MICRO also contains
articles, MICRO
contains resource and reference lists related to the
6502.
MICRO is published
6502. MICRO
published monthly
monthly by Dr. Robert Tripp,
Tripp, The Computerist
Computerist
Inc., P.O.
Chelmsford, MA 01824.
01824.
P.O.. Box 3, South Chelmsford,
dedicated on behalf
behalf of Amanda Catherine (Elizabeth Bramble) to
This book is dedicated
Greenlee, Max and Peggy Leventhal,
some very special people -— Catherine Greenlee,
Rosen, and Julius
Ross.
Al and Rose Rosen,
Julius and Jeanette Ross.

The author
Karl Amatneek,
Evans, and particularly
author would
would like to thank Karl
Amatneek, Mel Evans,
particularly
Philip Hooper forr their lists of corrections
corrections to earlier printings
printings of this book.

Contents
Page

Chapter
Chapter
1

Introduction to Assembly
Assembly Language Programming
Programming
Introduction
How This Book Has Been Printed
Meaning of Instructions
Instructions
The Meaning
puter Program
A Computer
The Programming
Programming Problem
Hexadecimal
Using Octal or Hexadecimal
Instruction Code Mnemonics
Mnemonics
Instruction
The Assembler
Assembler Program
Additional
Additional Features of Assemblers
Assemblers
Disadvantages of Assembly
Assembly Language
Disadvantages
High-Level
High-Level Languages
Advantages of High-Level
High-Level Languages
Advantages
Disadvantages of High-Level
High-Level Languages
Disadvantages
High-Level Languages for Microprocessors
Microprocessors
High-Level
Use?
Which
hich Level Should You Use?
How About
About the Future?
Book?
Why
hy This Book?
References

1-11-1
1-11-1
1-11-1
1-21-2
1-21-2
1-31-3
1-41-4
1-51-5
1-61-6
1-61-6
1-71-7
1-71-7
1-81-8
1-91-9
1-10
1-10
1-11
1-11
1-12
1-12
1-13
1-13

2

Assemblers
Assemblers
Features of Assemblers
Assembler Instructions
Instructions
Assembler
Labels
Assembler Operation
Operation Codes (Mnemonics)
Assembler
Pseudo-Operations
Pseudo-Operations
The Data Pseudo-Operation
Pseudo-Operation
The Equate (or Define) Pseudo-Operation
Pseudo-Operation
The Origin
Origin Pseudo-Operation
Pseudo-Operation
The Reserve
Pseudo-Operation
Reserve Pseudo-Operation
Linking
Pseudo-Operations
Linking Pseudo-Operations
Housekeeping Pseudo-Operations
Labels with
ith Pseudo-Operations
Operation Field
Field
Addresses and the Operation
Conditional Assembly
Assembly
Conditional
Macros
Comments
Comments
Assemblers
Types of Assemblers
Errors
Errors
Loaders
References

2-12-1
2-12-1
2-12-1
2-22-2
2-42-4
2-42-4
2-52-5
2-62-6
2-72-7
2-72-7
2-8
2-8
2-9
2-9
2-9
2-9
2-10
2-10
2-12
2-12
2-13
2-13
2-15
2-15
2-16
2-16
2-17
2-17
2-17
2-17
2-18
2-18

vii
vii

Contents (Continued)
Chapter
3

Page
Page
The 6502 Assembly
Assembly Language Instruction
Instruction Set
CPU Registers and Status Flags
Flags
CPU
Memory Addressing
Addressing Modes
6502 Memory
Memory
Memory -— Immediate
Immediate
Memory
Memory -— Direct
Direct
Implied
Implied or Inherent
Inherent Addressing
Addressing
Accumulator
Accum
ulator Addressing
Addressing
Pre-Indexed
Pre-lndexed Indirect
Indirect Addressing
Addressing
Post-Indexed Indirect
Indirect Addressing
Addressing
Indexed Addressing
Addressing
Indirect
Indirect Addressing
Addressing
Relative Addressing
Addressing
6502
6502 Instruction
Instruction Set
Abbreviations
Abbreviations
Instruction
Instruction Mnemonics
Mnemonics
Instruction
Instruction Object
Object Codes
Instruction
Instruction Execution Times
Status
Carry, to Accu
mu lat
ADC -— Add Memory, with
ith Carry,
Accum
lator
-AND
Accumulator
AND —
AND Memory
Memory with
ith Accum
ulator
Accumulator
ASL -— Shift
Shift Accum
ulator or Memory Byte Left
BCC
(C = 0)
BCC -— Branch if Carry Clear (C
BCS -— Branch if Carry Set (C =1)
BCS
BEG -— Branch if Equal to Zero (Z = 1)
1)
BEQ
BIT -— Bit Test
1)
BMI -— Branch if Minus
inus (S = 1)
BNE -— Branch if Not Equal to Zero (Z = 0)
BNE
BPL -— Branch if Plus (S = 0)
BPL
BRK -— Force Break (Trap or Software
BRK
Software Interrupt)
Interrupt)
BVC -— Branch if Overflow
Overflow Clear (V = 0)
1)
BVS -— Branch if Overflow
Overflow Set (V = 1)
CLC
LC -— Clear Carry
CLO -— Clear Decimal Mode
CLD
CLI -— Clear Interrupt
(Enable Interrupts)
CLI
Interrupt Mask (Enable
Interrupts)
CLV
L V -— Clear Overflow
Overflow
Accumulator
CMP -— Compare Memory
Memory with
ith Accum
ulator
CPX -— Compare Index Register with
ith Memory
Memory
CPY -— Compare Index Register Y with
CPY
ith Memory
Memory
DEC -— Decrement
1)
DEC
Decrement Memory
Memory (by 1)
DEX -— Decrement
DEX
Decrement Index
Index Register
Register XX (by
(by 1)
1)
DEY -— Decrement
DEY
Decrement Index
Index Register
Register YY (by
(by 1)
1)
EOR-— Exclusive-OR Accum
Accumulator
EOR
ulator with
ith Memory
-Increment
1)
INC —
Increment Memory
Memory (by 1)
INX -— Increment
1)
INX
Increment Index Register X (by 1)
1)
INY
Y -— Increment
Increment Index Register Y (by 1)
Jumpp via Absolute
JMP -— Jum
Absolute or Indirect
Indirect Addressing
Addressing
-Jump
JSR —
Jum p to Subroutine
Subroutine
LOA -— Load Accum
Accumulator
LDA
ulator from Memory
Memory
LDX
Register XX from
from Memory
Memory
LOX -— Load Index Register
LDY
Register YY from
from Memory
Memory
LOY -— Load Index Register
LSR -— Logical
ccumulator
LSR
Logical Shift
Shift Right of A ccum
ulator or Memory

viii
viii

3-1
3-1
3-3
3-3
3-5
3-5
3-6
3-6
3-7
3-7
3-8
3-8
3-8
3-8
3-9
3-9
3-10
3-10
3-11
3-11
3-13
3-13
3-14
3-14
3-15
3-15
3-15
3-15
3-17
3-17
3-17
3-17
3-17
3-17
3-17
3-17
3-38
3-38
3-40
3-40
3-41
3-41
3-43
3-43
3-44
3-44
3-44
3-44
3-45
3-45
3-47
3-47
3-47
3-47
3-48
3-48
3-49
3-49
3-51
3-51
3-51
3-51
3-52
3-52
3-53
3-53
3-54
3-54
3-55
3-55
3-56
3-56
3-58
3-58
3-59
3-59
3-60
3-60
3-61
3-61
3-62
3-62
3-63
3-63
3-65
3-65
3-67
3-67
3-68
3-68
3-69
3-69
3-70
3-70
3-71
3-71
3-72
3-72
3-74
3-74
3-76
3-76

Contents (Continued)
Page
Page

Chapter
Chapter
3 (Cont.)
(Cont.I

NOP
NOP -— No Operation
Accumulator
OR Memory with Accum
ORA
Logically OR
ulator
ORA -— Logically
Accumulator
PHA -— Push
ulator onto Stack
Push Accum
(P) onto Stack
PHP
PHP -— Push Status Register (P)
PLA -— Pull Contents of Accum
ulator from Stack
Accumulator
(P) from Stack
PLP
PLP -— Pull Contents of Status Register (P)
ROL
ulator or Memory Left through
through Carry
Accumulator
AOL -— Rotate Accum
Carry
ROR
ulator or Memory Right,
through Carry
Right. through
Accumulator
ROA-— Rotate Accum
RTI
Interrupt
RTI -— Return from Interrupt
RTS
Subroutine
ATS -— Return from Subroutine
SBC
Subtract Memory from Accum
ulator with Borrow
Accumulator
SBC -— Subtract
SEC
SEC-— Set Carry
SED
SEO-— Set Decimal Mode
Interrupts)
(DisableInterrupts)
SEI
Interrupt Mask (Disable
SEI -— Set Interrupt
lator in Memory
STA -— Store Accumu la
STX
STX -— Store Index Register X in Memory
STY
STY -— Store Index Register Y in Memory
TAX -— Move from Accum
ulator to Index Register X
Accumulator
TAY-Move
— Move from Accum
ulator to Index Register Y
Accumulator
TSX -— Move from Stack Pointer to Index Register X
TXA -— Move from Index Register X to Accum
ulator
Accumulator
TXS -— Move from Index Register
Register X to Stack Pointer
TYA -— Move from Index Register Y to A ccum
ulator
ccumulator
6800/6502 C om
patibility
ompatibility
6B00/6502
MOS Technology
Technology 6502 Assembler Conventions
Conventions
Structure
Assembler Field Structure
Labels
Pseudo-Operations
Examples
Examples
Labels
ith Pseudo-Operations
Labels with
Addresses
Features
Other Assembler Features

ix

3-7B
3-78
3-79
3-79
3-B1
3-81
3-B2
3-82
3-B3
3-83
3-B4
3-84
3-B5
3-85
3-B7
3-87
3-B9
3-89
3-90
3-90
3-91
3-91
3-93
3-93
3-94
3-94
3-95
3-95
3-96
3-96
3-97
3-97
3-9B
3-98
3-99
3-99
3-100
3-100
3-101
3-101
3-102
3-102
3-103
3-103
3-104
3-104
3-105
3-105
3-109
3-109
3-109
3-109
3-109
3-109
3-109
3-109
3-110
3-110
3-110
3-110
3-111
3-111
3-111
3-111
3-112
3-112

Contents
Contents (Continued)
Chapter
Chapter

Page
Page

4

Simple
Programs
Simple
Programs
General Format of Examples
Guidelines for Solving Problems
Program Examples
8-Bitit Data Transfer
8-Bitit Addition
ddition
Shift
Shift Left One Bit
Mask Off Most Significant
Significant Four Bits
Clear a Memory
Memory Location
Word Disassembly
Find Larger of Two Numbers
16-Bit Addition
ddition
Table of Squares
Ones Complement
Complement
Problems
16-Bit Data Transfer
8-Bitit Subtraction
Subtraction
Shift
Shift Left Two Bits
Mask Off Least Significant
Significant Four Bits
Set a Memory
Memory Location to All Ones
Word Assembly
Find Smaller of Two Numbers
24-Bit
24-Bit Addition
ddition
Sum of Squares
Twos Complement
Complement

4-1
4-1
4-1
4-1
4-2
4-2
4-4
4-4
4-4
4-4
4-5
4-5
4-6
4-6
4-7
4-7
4-8
4-8
4-9
4-9
4-10
4-10
4-12
4-12
4-13
4-13
4-16
4-16
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-17
4-18
4-18
4-18
4-18
4-18
4-18
4-19
4-19

6
5

Loops
Simple Program Loops
Examples
Sum of Data
16-Bit
16-Bit Sum of Data
Number of Negative Elements
Maximum
aximum Value
Justify a Binary Fraction
Justify
Post-Indexed (Indirect)
Ondirectl Addressing
Pre-Indexed (Indirect) Addressing
Pre-lndexed
Problems
Checksum of Data
Sum of 16-Bit Data
Number
Zero. Positive,
Positive. and Negative Numbers
Number of Zero,
inimum
Find M inim
um
Count 1 Bits

5-1
5-1
5-4
5-4
5-4
5-4
5-9
5-9
5-12
5-12
5-14
5-14
5-17
5-17
5-20
5-20
5-22
5-22
5-23
5-23
5-23
5-23
5-23
5-23
5-24
5-24
5-24
5-24
5-24
5-24

x
X

Contents (Continued)
Page

Chapter
Chapter

8
6

Character-Coded
Character-Coded Data
Examples
Length
Length of a String of Characters
Find First Non-Blank Character
Character
Replace Leading Zeros with
ith Blanks
Add Even Parity to ASCII Characters
Pattern Match
Match
Problems
Length
Length of a Teletypewriter
Teletypewriter Message
Find Last Non-Blank Character
Character
Truncate
Truncate Decimal String to Integer Form
Check Even Parity in ASCII Characters
String Comparison

6-16-1
6-36-3
6-36-3
6-76-7
6-10
6-10
6-13
6-13
6-17
6-17
6-20
6-20
6-20
6-20
6-20
6-20
6-21
6-21
6-21
6-21
6-22
6-22

7

Code Conversion
Examples
Hex to ASCII
Decimal to Seven-Segment
Seven-Segment
ASCII to Decimal
BCD to Binary
Convert
ASCII String
Convert Binary Number
Number to ASCII
Problems
ASCII to Hex
Seven-Segment
Seven-Segment to Decimal
Decimal to ASCII
Binary to BCD
BCD
ASCII String
String to Binary Number
Number
References

7-17-1
7-27-2
7-27-2
7-4
7-4
7-77-7
7-97-9
7-11
7-11
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-13
7-14
7-14
7-15
7-15

8

A rithm
etic Problems
rithmetic
Examples
Multiple-Precision
ultiple-Precision Binary Addition
Addition
Decimal
Decimal Addition
Addition
8-Bitit Binary Multiplication
ultiplication
8-Bitit Binary Division
Self-Checking Numbers Double Add Double Mod 10
Self-Checking
Problems
Multiple-Precision Binary Subtraction
Subtraction
Multiple-Precision
Subtraction
Decimal Subtraction
8-Bitit by 16-Bit
16-Bit Binary Multiplication
ultiplication
Division
Signed Binary Division
Self-Checking
1, 3, 7 Mod 10
Self-Checking Numbers Aligned
Aligned 1,
References

8-18-1
8-2
8-2
8-2
8-2
8-4
8-4
8-7
8-7
8-12
8-12
8-17
8-17
8-23
8-23
8-23
8-23
8-23
8-23
8-24
8-24
8-24
8-24
8-25
8-25
8-26
8-26

xi
xi

(Continued}
Contents
Contents (Continued)
Chapter

Page

9

Tables and Lists
Examples
Examples
Add Entry to List
Check an Ordered List
Remove
Remove Element from Queue
8-Bit Sort
Using an Ordered Jump Table
Problems
Remove
Remove an Entry From a List
Add an Entry to an Ordered List
Oueue
Add an Element to a Queue
16-Bit Sort
Key
Using a Jump Table with
ith a Key
References
References

9-1
9-1
9-2
9-2
9-5
9-8
9-12
9-16
9-18
9-18
9-19
9-19
9-20
9-20
9-21
9-21

10

Subroutines
Subroutine Documentation
Documentation
Subroutine
Examples
Examples
ASCII
Hex
Hex to ASCII
Length of a String of Characters
Maximum
aximum Value
Pattern Match
Multiple-Precision Addition
Addition
Multiple-Precision
Problems
Hex
ASCII
ASCII to Hex
Message
Length of a Teletypewriter
Teletypewriter Message
M inim
um Value
inimum
String Comparison
Decimal Subtraction
Subtraction
References
References

10-1
10-1
10-2
10-3
10-4
10-7
10-11
10-11
10-15
10-21
10-21
10-25
10-25
10-25
10-25
10-26
10-27
10-28

xii
xii

Contents (Continued)
Page
Pago

Chapter
Chapter
11
11

Input/O
utput
Input/Output
Timing
ing Intervals (Delays)
(Delays)
Delay Routines
Delay Program
utput Chips
Input/Output
6502 Input/O
The 6520 Peripheral Interface Adapter
Adapter
PIA
PIA Control Register
Configuring the PIA
Configuring
Examples
Configuration
Examples of PIA Configuration
Using the PIA to Transfer Data
(VIA)
The 6522 Versatile Interface Adapter
Adapter (VIA)
Configuring
Configuring the VIA
CA2 Input
Input
CA2 Output
utput
Examples of VIA Configuration
Configuration
Using the VIA to Transfer Data
VIA Interrupt
Interrupt Flag
Flag Register
VIA Timers
Operation of 6522 VIA Timer 2
Operation of 6522 VIA Timer 1
The 6530 and 6532 Multifunction
ultifunction Support Devices
Examples
A Pushbutton
Pushbutton Switch
Switch
A Toggle
Toggle Switch
Switch
A Single LED
LED
LED Display
Seven-Segment LED
Problems
An On-Off Pushbutton
Pushbutton
Debouncing a Switch
Switch in Software
Debouncing
Switch
Control for a Rotary Switch
Record
Switch Positions on Lights
Record Switch
Count on a Seven-Segment Display
More Complex I/O
1/0 Devices
Examples
An Unencoded Keyboard
An Encoded Keyboard
A Digital-to-Analog
Digital-to-Analog Converter
Analog-to-Digital Converter
Analog-to-Digital
Teletypewriter (TTY)
(TTY)
A Teletypewriter
The 6850 Asynchronous
Asynchronous Communications
Communications Interface
Adapter (ACIA)
(ACIA)
Adapter
The 6551 Asynchronous
Asynchronous Communications
Communications Interface
Adapter (ACIA)
(ACIA)
Adapter
Logical and Physical Devices
Standard Interfaces
Problems
Separating Closures from an Unencoded Keyboard
Read
Encoded Keyboard
Read a Sentence from an Encoded
plitude Square Wave Generator
A Variable Amplitude
Averaging Analog Readings
Readings
Averaging
A 30 Character-per-Second
Character-per-Second Terminal
References
References

xlii
xiii

11-1
11-1
11-8
11-8
11-9
11-9
11-10
11-10
11-12
11-12
11-13
11-13
11-15
11-15
11-18
11-18
11-19
11-19
11-21
11-21
11-23
11-23
11-27
11-27
11-31
11-31
11-31
11
-31
11-32
11
-32
11-34
11-34
11-35
11-35
11-36
11-36
11-37
11-37
11-38
11-38
11-39
11-39
11-43
11-43
11-43
11-43
11-50
11-50
111-61
-61
11-65
11-65
11-76
11-76
11-76
11-76
11-76
11-76
111-76
-76
11-77
11-77
11-77
11-77
11-78
11-78
11-81
11-81
11-81
11-81
11-90
11-90
11-93
11-93
11-98
11-98
11-103
11-103
11-111
11-111
11-118
11-118
11-123
11-123
11-124
11-124
11-125
11-125
11-125
11-125
11-125
11-125
11-126
11-126
11-126
11-126
11-126
11-126
11-127
11-127

Contents (Continued)
Chapter
Chapter

12

Page
Page

Interrupts
Interrupts
6502 Interrupt
Interrupt System
6520
6520 PIA Interrupts
Interrupts
6522 VIA Interrupts
Interrupts
6530 and 6532
6532 Multifunction
ultifunction Device Interrupts
Interrupts
ACIA Interrupts
Interrupts
6502 Polling Interrupt
Interrupt Systems
6502 Vectored
Vectored Interrupt
Interrupt Systems
Examples
A Startup
Startup Interrupt
Interrupt
A Keyboard Interrupt
Interrupt
A Printer
Printer Interrupt
Interrupt
A Real-Time Clock Interrupt
Interrupt
A Teletypewriter
Teletypewriter Interrupt
Interrupt
More General Service Routines
Problems
A Test Interrupt
Interrupt
A Keyboard Interrupt
Interrupt
A Printer Interrupt
Interrupt
A Real-Time Clock Interrupt
Interrupt
A Teletypewriter
Teletypewriter Interrupt
Interrupt
References

xiv

12-1
12-1
12-3
12-3
12-5
12-5
12-6
12-6
12-9
12-9
12-9
12-9
12-11
12-11
12-12
12-12
12-13
12-13
12-13
12-13
12-16
12-16
12-20
12-20
12-23
12-23
12-32
12-32
12-37
12-37
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-38
12-39
12-39

Contents (Continued)
Page
Page

Chapter
Chapter
13

Problem Definition
Definition and Program Design
The Tasks of Software Development
Development
Definition of the Stages
Definition
Problem Definition
Definition
Defining the Inputs
Defining
Defining the Outputs
Outputs
Defining
Processing
Processing Section
Error Handling
Human Factors
Examples
Response
Switch
Response to a Switch
A Switch-Based Memory Loader
A Verification
Verification Terminal
Review of Problem Definition
Definition
Program Design
Flowcharting
Flowcharting
Examples
Response
Switch
Response to a Switch
The Switch-Based
Switch-Based Memory Loader
The Credit-Verificati
Credit-Verification
on Terminal
Modular
odular Programming
Programming
Examples
Response
Switch
Response to a Switch
The Switch-Based
Switch-Based Memory Loader
The Verification
Verification Terminal
Review of Modular
Modular Programming
Programming
Structured Programming
Structured
Examples
Response
Switch
Response to a Switch
The Switch-Based Memory Loader
The Credit-Verificati
Credit-Verification
on Terminal
Review of Structured
Structured Programming
Programming
Top-Down Design
Top-Down
Examples
Response
Switch
Response to a Switch
The Switch-Based
Switch-Based Memory Loader
The Transaction Terminal
Review of Top-Down Design
Review of Problem Definition
Definition and Program Design
References
References

xv
xv

13-1
13-1
13-1
13-1
13-3
13-3
13-3
13-3
13-4
13-4
13-5
13-5
13-5
13-5
13-6
13-6
13-7
13-7
13-7
13-7
13-9
13-9
13-12
13-12
13-16
13-16
13-17
13-17
13-18
13-18
13-20
13-20
13-20
13-20
13-22
13-22
13-24
13-24
13-29
13-29
13-31
13-31
13-31
13-31
13-31
13-31
13-32
13-32
13-34
13-34
13-35
13-35
13-41
13-41
13-41
13-41
13-42
13-42
13-44
13-49
13-50
13-51
13-51
13-51
13-51
13-52
13-53
13-55
13-56
13-57

Contents (Continued)
Chapter
14

Debugging
Debugging and Testing
Simple Debugging
Debugging Tools
Tools
More Advanced Debugging
Debugging Tools
Debugging With
Debugging
ith Checklists
Errors
Looking for Errors
Debugging
1: Decimal to Seven-Segment
Debugging Example 1:
Conversion
Debugging Example 2: Sort into Decreasing Order
Debugging
Introduction
Introduction to Testing
Selecting Test Data
Testing Example 1: Sort Program
Testing Example 2: Self-Checking Numbers
Testing Precautions
Conclusions
References
References

Page
14-1
14-1
14-1
14-1
14-8
14-8
14-10
14-10
14-11
14-11

14-15
14-15
14-19
14-19
14-25
14-25
14-27
14-27
14-28
14-28
14-28
14-28
14-29
14-29
14-29
14-29
14-30
14-30

15

Documentation
Redesign
Documentation and Redesign
Self-Documenting
Self-Documenting Programs
Comments
Commenting
Example 1:
1: Multiple-Precision
Commenting Example
Multiple-Precision Addition
ddition
Commenting
Commenting Example 2: Teletypewriter
Teletypewriter Output
utput
Flowcharts as
as Documentation
Documentation
Structured
as Documentation
Structured Programs as
Documentation
Memory Maps
Parameter and Definition
Definition Lists
Library Routines
Examples
Library Examples
1: Sum of Data
Library Example 1:
Example 2: Decimal to Seven-Segment Conversion
Library Example
Library Example 3: Decimal Sum
Total Documentation
Documentation
Redesign
Redesign
Less Memory
Reorganizing to Use Less
Major Reorganizations
References
References

15-1
15-1
15-1
15-1
15-3
15-3
15-5
15-5
15-7
15-7
15-9
15-9
15-9
15-9
15-10
15-10
15-11
15-11
15-13
15-13
15-14
15-14
15-14
15-14
15-15
15-16
15-16
15-17
15-17
15-18
15-18
15-19
15-19
15-21
15-21
15-22
15-22

16

Sample Projects
Project #1:: A Digital Stopwatch
Stopwatch
Project #2:: A Digital
Digital Thermometer
Thermometer
References
References

16-1
16-1
16-1
16-1
16-15
16-15
16-29
16-29

xvi
xvi

Figures
Page

Figure
5-1
5-2

Flowchart
Flowchart of a Program Loop
Allowss Zero Iterations
A Program Loop that Allow

5-2
5-3

11-1
11-1
11-2
11-3
11-4
11-5
11-6
11-7
11-8
11-9
11-10
11-11
11-11
11-12
11-13
11-14
11-15
11-16
11-17
11-18
11-19
11-20
11-21
11-21
11-22
11-23
11-24
11-25
11-26
11-27
11-28
11-29
11-30

11-3
11-3
11-4
11-4
11-6
11-7
11-14
11-24
11-26
11-26
11-30
11-40
11-42
11-43
11-50
11-50
11-55
11-56
11-62
11-66
11-67
11-68
11-75
11-82
11-82
11-83
11-90
11-94
11-95

11-32
11-33
11-34
11-35
11-36
11-37
11-38
11-39
11-40

An Output
utput Demultiplexer
ultiplexer Controlled by a Counter
An Output
utput Demultiplexer
ultiplexer Controlled by a Port
An Input
Input Multiplexer
ultiplexer Controlled by a Counter
An Input Multiplexer
ultiplexer Controlled by a Port
An Input
Input Handshake
An Output
utput Handshake
Block Diagram of the 6520 Peripheral Interface Adapter
Adapter
Block Diagram of the 6522 Versatile Interface Adapter
Adapter
6522 VIA Peripheral Control Register Bit Assignments
Assignments
6522 VIA Auxiliary
Auxiliary Control Register Bit Assignments
Assignments
Register
The 6522 VIA Interrupt
Interrupt Flag Register
Block Diagram of the 6530 Multifunction
ultifunction Device
Block Diagram of the 6532 Multifunction
ultifunction Device
A Pushbutton
Pushbutton Circuit
Circuit
An Interface for a Toggle Switch
Based on Cross-coupled NAND
NANO Gates
Gates
A Debounce Circuit
Circuit Based
An Interface for a Multi-Position
ulti-Position Switch
Switch
A Multiple-Position
ultiple-Position Switch
Switch with
ith an Encoder
Interfacing
LED
Interfacing an LED
Interfacing
Interfacing a Seven-Segment Display
Seven-Segment Display Organization
Seven-Segment Representations of Decimal Digits
Interfacing
Interfacing Multiplexed
ultiplexed Seven-Segment Displays
A Small Keyboard
A Keyboard Matrix
1/0
Arrangement
I/O Arrangem
ent for a Keyboard Scan
I/O
1/0 Interface for an Encoded Keyboard
Signetics NE5018 D/A Converter
Interface for an 8-bit
8-bit Digital-to-Analog
Digital-to-Analog Converter
General
General Description and Timing
ing Diagram for the National
5357 A/D Converter
Connection
Connection Diagram and Typical
Typical Application
Application for the
National 5357 AID
A/D Converter
Interface for an 8-bitit Analog-to-Digital
Analog-to-Digital Converter
Teletypewriter Data Format
Teletypewriter
Flowchart
Receive Procedure
Flowchart for Receive
Flowchart for Transmit
Transmit Procedure
Flowchart
Block Diagram of the 6850 ACIA
Block Diagram of the 6551 ACIA
Definition
Definition of 6551 ACIA Control Register Contents
Definition
Definition of 6551 ACIA Command Register Contents
Definition of 6551 ACIA Status Register Contents
Definition

12-1
12-1
12-2
12-3

Saving the Status of the Microprocessor
Microprocessor in the Stack
Description
Enable Register
Description of the 6522 VIA Interrupt
Interrupt Enable
Description
Flag Register
Description of the 6522 VIA Interrupt
Interrupt Flag

12-4
12-7
12-7

11-31
11-31

xvii
xvii

11-99

11-100
11-100
11-103
11-104
11-108
11-114
11-119
11-120
11-121
11-121
11-122

Figures (Continued)
Figure

Page

13-1
13-1
13-2
13-3
13-4
13-5
13-6
13-7
13-8
13-9
13-10
13-11
13-11
13-12
13-13
13-14
13-15
13-16
13-17
13-18
13-19
13-20

Flowchart
Flowchart of Software
Software Development
Development
The Switch
Switch and Light
Light System
The Switch-Based
Switch-Based Memory
Memory Loader
Block Diagram of a Verification
Verification Terminal
Terminal
Verification
Verification Terminal
Terminal Keyboard
Verification
Verification Terminal
Terminal Display
Standard Flowchart
Flowchart Symbols
Flowchart
Response to a Switch
Flowchart of One-Second Response
Switch
Flowchart
Flowchart of Switch-Based
Switch-Based Memory
Memory Loader
Flowchart
Flowchart of Keyboard Entry
Flowchart
Process with
Flowchart of Keyboard Entry Process
ith Send Key
Flowchart
Process with
Keys
Flowchart of Keyboard Entry Process
ith Function
Function Keys
Flowchart
Flowchart of Receive Routine
Flowchart
Flowchart of an Unstructured
Unstructured Program
Flowchart
Flowchart of the If-Then-Else Structure
Structure
Flowchart
Do-While
Flowchart of the Do-W
hile Structure
Structure
Flowchart
Flowchart of the Do-Until
Do-Until Structure
Structure
Flowchart
Case Structure
Flowchart of the Case
Structure
Initial
Initial Flowchart
Flowchart for Transaction
Transaction Terminal
Terminal
Flowchart
KEYBOARD Routine
Flowchart for Expanded KEYBOARD

13-2
13-8
13-10
13-13
13-13
13-14
13-19
13-21
13-21
13-23
13-24
13-25
13-26
13-27
13-36
13-36
13-37
13-37
13-38
13-53
13-54

14-1
14-1
14-2
14-3
14-4
14-5
14-6

A Simple Breakpoint
Breakpoint Routine
Flowchart
Flowchart of Register Dump Program
Results of a Typical
Typical 6502 Register Dump
Results of a Typical
Typical Memory
Memory Dump
Flowchart
Flowchart of Decimal to Seven-Segment
Seven-Segment Conversion
Flowchart
Flowchart of Sort Program

14-2
14-5
14-5
14-6
14-15
14-20

16-1
16-1
16-2
16-3
16-4
16-5

I/O
Configuration for a Digital
Digital Stopwatch
Stopwatch
1/0 Configuration
1/0 Configuration
I/O
Configuration for a Digital
Digital Thermometer
Thermometer
Digital
Digital Thermometer
Thermometer Analog
Analog Hardware
Thermistor
Bead)
Thermistor Characteristics
Characteristics (Fenwal GA51J1 Bead)
Typical
E-I Curve for Thermistor
(25°C)
Typical E-l
Thermistor (25°C)

16-2
16-16
16-17
16-18
16-18

xviii
xviii

Tables
Table

Page
Page

1-1
1-1

Hexadecimal Conversion
Conversion Table
Table
Hexadecimal

1-4
1-4

2-1
2-2
2-3

The Fields
Fields of
of an
an Assembly
Assembly Language
Language Instruction
Instruction
The
Standard 6502
6502 Assembler
Assembler Delimiters
Delimiters
Standard
Assigning and
and Using
Using aa Label
Label
Assigning

2-1
2-1
2-2
2-2
2-3
2-3

3-1
3-2
3-3
3-4
3-5
3-6
3-7

Frequently Used
Used Instructions
Instructions ff the
the 6502
6502
Frequently
Occasionally Used
Used Instructions
Instructions of
of the
the 6502
6502
Occasionally
Seldom Used
Used Instructions
Instructions of
of the
the 6502
6502
Seldom
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set
AA Summary
6502 Instruction
Instruction Object
Object Codes
Codes inin Numerical
Numerical Order
Order
6502
Summary of
of 6502
6502 Object
Object Codes
Codes wwith
6800 Mnemonics
Mnemonics
Summary
ith 6800
Memory Addressing
Addressing Modes
Modes Available
Available on
on the
the 6800
6800and
and
Memory
6502 Microprocessors
Microprocessors
Comparison ofof 6800
6800 and
and 6502
6502 Assembly
Assembly Language
Language
Comparison
Instruction
Instruction Sets

3-2
3-2
3-2
3-2
3-3
3-3
3-19
3-19
3-31
3-31
3-34
3-34

3-8

3-106
3-106
3-107
3-107

6-1

Hex-ASCII Table
Table
Hex-ASCII

6-2
6-2

11-1
11-2
11-3
11-4
11-5
11-6
11-7
11-8
11
11-9
11-10
11-11
11-12
11-13
11-14
11-15

Addressing 6520
6520 PIA
PIA Internal
Internal Registers
Registers
Addressing
Organization ofof the
the PIA
PIA Control
Control Registers
Registers
Organization
Control of
of 6520
6520 PIA
PIA Interrupt
Interrupt Inputs
Inputs CA1
CA1 and
and CB1
CB1
Control
Control ofof 6520
6520 PIA
PIAInterrupt
Interrupt Inputs
Inputs CA2
CA2 and
and CB2
CB2
Control
Control of
of 6520
6520 PIA
PIA CB2
CB2 OOutput
Line
Control
utput Line
Control ofof 6520
6520 PIA
PIACA2
CA2 OOutput
Line
Control
utput Line
Addressing 6522
6522 VIA
VIA Internal
Internal Registers
Registers
Addressing
Configurations for
for 6522
6522 VIA
VIA Control
Control Line
Line CA2
CA2
Configurations
Configurations for
for 6522
6522 VIA
VIA Control
Control Line
Line CB2
CB2
Configurations
Internal Addressing
Addressing for
for the
the 6530
6530 MMultifunction
Device
Internal
ultifunction Device
Internal Addressing
Addressing for
for the
the6532
6532 MMultifunction
Device
Internal
ultifunction Device
Data
Data Input
Input vs.
vs.Switch
Switch Position
Position
Seven-Segment Representations
Representations ofof Decimal
Decimal Numbers
Numbers
Seven-Segment
Seven-Segment
Seven-Segment Representations
Representations ofof Letters
Letters and
and Symbols
Symbols
Comparison Between
Between Independent
Independent Connections
Connections and
and
Comparison
Matrix
atrix Connections
Connections for Keyboards
Definition
Definition ofof6850
6850 ACIA
ACIA Register
RegisterContents
Contents
Meaning ofofthe
the 6850
6850 ACIA
ACIA Control
Control Register
RegisterBits
Bits
Meaning
Addressing 6551
6551 ACIA
ACIA Internal
Internal Registers
Registers
Addressing

11-13
11-13
11-15
11-15
11-16
11-16
11-16
11-16
11-17
11-17
11-17
11-17
11-25
11-25
111-28
-28
11-29
11-29
11-41
11-41
11-42
11-42
11-56
11-56
11-66
11-66
11-69
11-69

11-16
11-17
11-18
12-1
12-1

11-81
11-81
11-112
11-112
11-113
11-113
11-119
11-119

12-2

Memory
Memory Map
Map for
for6502
6502 Addresses
Addresses Used
Used ininResponse
Responsetoto
Interrupts
Reset
Interrupts and Reset
Addressing
ultifunction Device
Addressing the
the 6532
6532 MMultifunction
Device

12-4
12-4
12-10
12-10

14-1
14-1

6502 Interrupt
Interrupt Vectors
Vectors
6502

14-2
14-2

16-1
16-1
16-2

Input Connections
Connections for
for Stopwatch
Stopwatch Keyboard
Keyboard
Input
Connections for
for Stopwatch
Stopwatch Keyboard
Keyboard
OOutput
utput Connections

16-2
16-2
16-2
16-2

xix
xix

Chapter
Chapter 1
INTRODUCTION
ASSEMBL V
INTRODUCTION TO ASSEMBLY
LANGUAGE PROGRAMMING
PROGRAMMING
This book describes assembly language programming. It assumes that
that you are
familiar
iliar with
ith An Introduction
Introduction To Microcomputers:
Microcomputers: Volume 1 -— Basic Concepts
Concepts1
(particularly Chapters 6 and 7). This book does not discuss
discuss the general features
features of
computers, microcomputers.
should
microcomputers, addressing methods, or instruction sets; you should
refer
refer to An Introduction To Microcomputers:
Microcomputers: Volume 1 for that
that information.

HOW THIS BOOK HAS BEEN PRINTED
Notice that
that text
x t in this book has been printed in boldface type and lightface
lightface type.
This has been done to help you skip those parts of the book that
that cover
cover subject
matter
atter with
ith which you are familiar. You can be sure that
that lightface type only exex­
pands on information presented
presented in the previous boldface type. Therefore.
Therefore, only read
boldface
more. at which
boldface type until
until you reach a subject
subject about
about which
hich you want
want to know more,
which
point
point start
start reading the lightface
lightface type.

THE MEANING
MEANING OF INSTRUCTIONS
INSTRUCTIONS
The instruction set of a microprocessor is the set
produce
set of binary inputs that
that produce
defined actions during an instruction cycle. An instruction
instruction set is to a microprocessor
microprocessor
gate. adder,
adder. or shift
what
hat a function
function table is to a logic device.
device, such as a gate,
shift register. Of
course, the actions
course.
actions that
that the microprocessor
microprocessor performs
performs in response to its instruction
instruction in­
inputs are far more complex
complex than the actions
actions that
that logic devices perform
perform in response to
their
their inputs.

An instruction is a binary bit pattern
pattern -— it must be available
available at BINARY
INSTRUCTIONS
the data inputs to the microprocessor at the proper time in INSTRUCTIONS
order to be interpreted
interpreted as an instruction. For example.
example, when
when the
6502 microprocessor
microprocessor receives the 8-bit
-b it binary pattern
pattern 11101000
11101000 as the input
input during an
6502
instruction fetch operation.
operation, the pattern
pattern means:
instruction
"Increment
"Increm
ent (add 1 to) the contents
contents of Register X".
Similarly.
Similarly, the pattern
pattern 10101001
10101001 means:
"Load
Accumulator
"Load the Accum
ulator with
ith the contents
contents of the next word of program
program memory"
memory".
The microprocessor
microprocessor (like any other computed
computer) recognizes only binary
binary patterns
patterns as inin­
structions
data; it does not recognize words or octal,
octal. decimal.
hexadecimal num­
numstructions or data:
decimal, or hexadecimal
bers.
bers.

1-1

A COMPUTER
COMPUTER PROGRAM
PROGRAM
program is a series of instructions that causes a computer
A program
computer to perform a particular
task.
Actually.
Actually, a computer
puter program includes
includes more than instructions:
instructions; itIt
COMPUTER
COMPUTER
also contains
contains the data and m emory
ory addresses
addresses thatt the
PROGRAM
microprocessor
microprocessor needs to accomplish
accomplish the tasks defined
defined by the inin­
structions.
Clearly. if the microprocessor
structions. Clearly,
microprocessor is to perform an addition.
addition, it must
have two
two
must have
numbers to add and a place to put the result. The computer
puter program must determine
determine
the sources of the data and the destination
destination of the result as well
well as the operation
operation to be
performed.
All microprocessors
microprocessors execute instructions
instructions sequentially
sequentially unless one of the instructions
instructions
changes the execution
execution sequence or halts the computer.
computer, i.e.,.. the processor gets the next
instruction
consecutive memory address unless the current
instruction from the next consecutive
current instruction
instruction
specifically
specifically directs
directs it to do otherwise.

Ultimately
ately every
every program is translated
translated into a set of binary numbers. For example,
example,
this is a 6502
6502 program that
that adds the contents
contents of memory locations 0 0 6
ig and
and
006015
006115 and places the result in memory location 0 0 6
06215:
006116
2 ig :
10100101
01100000
01100000
01100101
01100101
01100001
01100001
10000101
01100010
01100010

program. If this program
This is a machine language, or object, program.
were entered into the memory of a 6502-based
6502-based microcomputer.
microcomputer,
icrocomputer
the m icrocom
puter would
would be able to execute it
directly.
11directly.

THE PROGRAMMING
PROBLEM
M M ING PROBLEM
There are many difficulties
difficulties associated with
ith creating programs
programs
programs. These are
as object, or binary machine language, programs.
some of the problems:

OBJECT
PROGRAM
MACHINE
MACHINE
LANGUAGE
PROGRAM

1)
1)

ifficult
The programs
programs are d iffic
u lt to understand
understand or debug (binary numbers all look the
same. particularly
particularly after you have looked at them for a few hours)
same,
hours).

2)
2)

The programs
programs are slow to enter since you must determine
determine each bit individually.
individually.

3)

The programs
programs do not describe the task which
which you want
ant the computer
puter to perform in
anything
anything resembling
resembling a human readable format.

4)

The programs are long and tiresome to write.

5)
5)

1ff1cult
The programmer
programmer often makes careless errors that are very d ifficu
lt to locate and
correct.

example. the following
For example,
ing version of the addition object program
program contains a single
single
error. Try to find it:
bit error.
10100101
01100000
01100000
01110101
01110101
01100001
01100001
10000101
01100010
01100010
ease. people do not. People find
Although
lthough the computer
computer handles binary numbers
numbers with
ith ease,
binary programs long,
long. tiresome,
tiresome. confusing.
confusing, and meaningless. Eventually.
Eventually, a programmer
programmer
codes. but such effort
may start remembering
remembering some of the binary codes,
effort should be spent more
productively.
productively.

1-2
1-

USING OCTAL OR HEXADECIMAL
AL
We can improve the situation somewhat
somewhat by writingg instrucinstruc­
OCTAL OR
numbers.
HEXADECIMAL
tions using octal or hexadecimal, rather than binary numbers.
HEXADECIMAL
We will
ill use hexadecimal
hexadecimal numbers
numbers in this book because they are
shorter, and because they are the standard
1-1
standard for the microprocessor
microprocessor industry.
industry. Table 1-1
defines
program to add
defines the hexadecimal
hexadecimal digits
digits and their
their binary
binary equivalents.
equivalents. The 6502
6502 program
twoo numbers now becomes:
A5
60
65
61
85
62

least. the hexadecimal
At the very least,
hexadecimal version is shorter
shorter to write
rite and not quite
quite so tiring
tiring to
examine.

Errors are somewhat
Errors
ewhat easier to find in a sequence of hexadecimal
hexadecimal digits. The erer­
program, in hexadecimal
roneous version of the addition program,
hexadecimal form, becomes:
A5
60
75
61
85
62

obvious.
The mistake is far more obvious.
program? The microprocessor
microprocessor understands
What
hat do we do with
ith this hexadecimal
hexadecimal program?
codes. The answer
only binary instruction codes.
answer is that we must
must convert
convert the hexadecimal
hexadecimal
numbers
task. People who
numbers to binary
binary numbers. This conversion
conversion is a repetitive,
repetitive, tiresome task.
attempt
attem
pt it make all sorts of petty
petty mistakes, such as looking
looking at the wrong
wrong line, dropping
dropping a
bit, or transposing
transposing a bit or a digit.
repetitive, grueling
grueling task is,
perfect job for a comcom­
HEXADECIMAL
This repetitive,
is, however,
however. a perfect
HEXADECIMAL
makes
puter. The computer
computer never gets tired or bored and never makes
LOADER
LOADER
rite a program
that accepts
program that
silly mistakes The idea then is to write
hexadecimal
numbers. This is a standard
hexadecimal numbers and converts them into binary numbers.
program provided with
ith many microcomputers; it is called a hexadecimal
hexadecimal loader.
loader.
Is a hexadecimal
hexadecimal loader worth
worth having? If you are willing
illing to write
rite a program
program using binary
com­
numbers, and you are prepared to enter the program in its binary form into the computer, then you will
ill not need the hexadecimal
hexadecimal loader.
If you choose the hexadecimal
hexadecimal loader, you will
ill have to pay a price for it. The hexhex­
adecimal
adecimal loader is itself
itself a program that
that you must load into memory. Furthermore,
Furthermore, the
hexadecimal loader will
ill occupy
occupy memory
memory -— memory
memory that
that you may want
want to use in some
hexadecimal
other way.
The basic tradeoff.
tradeoff, therefore.
therefore, is the cost and memory
memory requirements
requirements of the hexadecimal
hexadecimal
loader versus the savings
savings in programmer
programmer time.
A hexadecimal
hexadecimal loader is well
ell worth
worth its small cost.

hexA hexadecimal
hexadecimal loader certainly
certainly does not solve every programming
programming problem. The hex­
adecimal
adecimal version of the program is still
still difficult
ifficu lt to read or understand;
understand; for example, it
does not distinguish
distinguish instructions
instructions from data or addresses,
program listing
listing
addresses, nor does the program
provide
DO mean?
provide any suggestion
suggestion as to what
what the program
program does. What
hat does 85 or DO
Memorizing a card full
full of codes is hardly an appetizing
appetizing proposition.
proposition. Furthermore,
Furthermore, the
Memorizing
recodes will
ill be entirely
entirely different
different for a different
different microprocessor.
microprocessor, and the program
program will
ill re­
quire a large amount
amount of documentation.
documentation.

1-3
1-

1-1. Hexadecimal
Table 1-1.
Hexadecimal Conversion Table

Hexadecimal
Hexadecimal
Digit

Binary
Equivalent

Decimal
Equivalent

0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F

0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1001
1010
1011
1011
1100
1101
1101
1110
1111
1111

0
1
2
3
4
5
6
7
8
9
10
10
11
11
12
12
13
14
15
15

INSTRUCTION
EMONICS
INSTRUCTION CODE M N E M
O N IC S
programming improvement
is to assign
assign a name to each instruction
An obvious programming
improvement is
code. The instruction code name is called a "m n em
code.
on ic" or memory jogger.
emonic"
jogger. The
should describe in some
some way what
instruction mnemonic should
hat the instruction does.
does.
fact. every microprocessor
PROBLEM
In fact,
microprocessor manufacturer
anufacturer (they can't
can't remember
PROBLEM
hexadecimal
hexadecimal codes either) provides a set of mnemonics
mnemonics for the
WITH
microprocessor
microprocessor instruction
instruction set.
set. You do not have to abide by the
MNEMONICS
MNEMONICS
manufacturer's mnemonics; there is nothing
nothing sacred about them.
manufacturer's
However. they are standard for a given microprocessor
However,
microprocessor and therefore understood by all
users. These are the instruction
users.
instruction codes that you will
ill find in manuals,
manuals. cards,
cards. books,
books. ar­
articles. and programs. The problem with
Is that not all
ticles,
ith selecting
selecting instruction
instruction mnemonics
mnemonics is
instructions have "obvious”
"obvious" names.
names. Some instructions
instructions do (e.g
instructions
(e.g.,.. ADD,
ADD. AND,
AND. OR),
OR). others
XOR for exclusive-OR),
exclusive-OR). while
have obvious contractions
contractions (e.g
(e.g.... SUB for subtraction.
subtraction, XOR
hile still
others have neither. The result is such mnemonics
mnemonics as WMP,
WMP. PCHL,
PCHL. and even SOB
SOB
(guess what
means!). Most
names
(guess
hat that means!).
Most manufacturers
manufacturers come up with
ith some reasonable names
and some hopeless ones.
ones. However,
However. users who
who devise their own mnemonics
mnemonics rarely do
much better
better than the manufacturer
manufacturer.
Along
names to
Along with
ith the instruction
instruction mnemonics.
mnemonics, the manufacturer
anufacturer will
ill usually assign names
CPU registers. As with
names. some register names are obvious (e.g
the CPU
ith the instruction
instruction names,
(e.g.,..
A for Accumulator)
Accumulator) while
Again. we will
hile others may have only historical
historical significance.
significance. Again,
use the manufacturer's
anufacturer's suggestions
suggestions simply
simply to promote standardization.

If we use standard 6502
6502 instruction and register mnemonics,
mnemonics,
proas defined by MOS Technology, Inc., our 6502
6502 addition pro­
gram becomes:
LDA
LOA
ADC
STA

-----

ASSEMBLY
LANGUAGE
PROGRAM

$60
$60
$61
$61
$62
$62

The program is still
still far from obvious.
obvious, but at least some parts are comprehensible. ADC
LOA and STA suggest loading and storing the
is a considerable
considerable improvement
provement over 65; LDA
contents
contents of the Accumulator.
ulator. We now know which
hich lines are instructions
instructions and which
which are
are
data or addresses. Such a program is
Is an assembly language
language program.
program.

1-4

THE ASSEMBLER
ASSEMBLER PROGRAM
PROGRAM
How do we
we get
get the
the assembly
language program
program into
into the
thecom­
comassembly language
HAND
puter? We have to translate
translate it,it. either
into bieither into
into hexadecimal
hexadecimal or into
bi­
ASSEMBLY
ASSEMBLY
pronary numbers. You can translate an assembly
assembly language pro­
gram by hand, instruction
instruction by instruction.
instruction. This is called hand assembly.
be illustrated
Hand assembly
assembly of the addition
addition program
program may he
illustrated as follows:
follows:
Instruction
Instruction Mnemonic
Mnemonic
LOA
LDA
ADC
STA

Addressing
Addressing Method
Method
Zero Page
Page (direct)
(direct)
Zero
Zero Page
Page (direct)
(direct)
Zero
Zero Page
Page (direct)
(direct)
Zero

Hexadecimal Equivalent
Equivalent
Hexadecimal

A5
65
85

As with
ith hexadecimal
hexadecimal to binary
binary conversion.
conversion, hand assembly is a rote task which
hich is uninunin­
teresting,
errors. Picking the wrong
line.
teresting, repetitive,
repetitive, and subject
subject to numerous
numerous minor
minor errors.
wrong line,
transposing
transposing digits,
digits, omitting
itting instructions,
instructions, and misreading
misreading the codes are only a few of the
mistakes that
make. Most microprocessors
that you may make.
microprocessors complicate
plicate the task even further
further by
having instructions
instructions with
ith different
different word
word lengths. Some instructions
instructions are one word long
while
hile others are two
two or three words
words long. Some instructions
instructions require data in the second
addresses. register
numbers. or who knows
and third words,
words, others require
require memory
memory addresses,
register numbers,
what?

Assembly
Assembly is another
another rote task that
that we can assign to the
ASSEMBLER
icrocomputer.
icrocomputer
m icro
com pu ter. The m icro co
m p u te r never
never makes
makes any
SOURCE
mistakes
mistakes when
when translating
translating codes; it always
always knows how many
PROGRAM
words
program
words and what
at format
at each instruction requires. The program
OBJECT
that
"assembler."
program
that does this job is an "assem
bler." The assembler
assembler program
PROGRAM
translates
translates a user program, or "source"
source" program written
ritte n with
mnemonics, into a machine language program,
program, or "o bject"
je c t"
"ii'ssiiinprogram, which
hich the microcomputer
microcomputer can execute.
execute. The assem­
bler's input is a source program and its output is an object
program.
object program.

tradeoffs that
that we discussed in connection with
ith the hexadecimal
hexadecimal loader are
The tradeoffs
magnified in the case of the assembler. Assemblers
Assemblers are more expensive, occupy
occupy
more memory, and require
require more peripherals
peripherals and execution
execution time than do hexadecimal
hexadecimal
loaders, few care to write
loaders. While
hile users may (and often do) write
write their own loaders,
rite their
own assemblers.
Assemblers
learn. These include
include the use of cer­
cerAssemblers have their
their own rules that
that you must learn.
tain markers (such as spaces,
spaces. commas, semicolons, or colons) in appropriate
places.
appropriate places,
correct
correct spelling,
spelling, the proper
proper control
control information,
information, and perhaps even the correct
correct placeplace­
ment
ment of names and numbers. These rules are usually simple and can be learned quickly.
quickly.

1-5

FEATURES OF ASSEMBLERS
A D DITIONAL
ITIO N A L FEATURES
Early assemblers did little
little more than translate
translate the mnemonic
mnemonic names of instructions
instructions and
registers into their
However. most assemblers now provide
their binary
binary equivalents.
equivalents. However,
provide such adad­
ditional
as:
ditional features
features as:

1)
1)

llowing
devices.
A llow
ing the user to assign names to memory locations.
locations, input
input and output
output devices,
and even sequences of instructions.
instructions.

2)

Converting
Converting data or addresses from various number
number systems (e.g.,.. decimal
decimal or hexhex­
adecimal) to binary and converting
ASCII or EBCDIC
EBCDIC binary
converting characters
characters into
into their
their ASCII
codes.
codes.

3)

Performing
arithmetic
process.
Performing some arithm
etic as part of the assembly process.
Telling
Telling the loader program
program where
where in memory
memory parts of the program
program or data should be
placed.

4)
5)

llowing
A llow
ing the user to assign areas of memory
memory as temporary
temporary data storage and to
place fixed data in areas of program memory.

6)

Providing
information
liProviding the inform
ation required to include
include standard
standard programs
programs from program li­
braries. or programs
time. in the current
braries,
programs written
ritten at some other
other time,
current program.

7)

llowing
A llow
ing the user to control
control the format
at of the program
program listing
listing and the input
input and
output
output devices employed.

All of these features,
features. of course,
course. involve
involve additional
additional cost and memo­
memoCHOOSING
icrocomputers
AN
ry. M icrocom
puters generally
generally have much simpler
simpler assemblers than
asASSEMBLER
do larger computers.
computers, but the tendency
tendency always is for the size of as­
ASSEMBLER
semblers to increase. You will
assemblers.
ill often have a choice of assemblers.
The important
criterion is not how many offbeat
offbeat features the assembler
portant criterion
assembler has.
has, but rather
how convenient
convenient it is to work
work with
ith in normal practice.

VANTAGES
DISA D VA
N TAG ES OF A SSEMBLY
BLY LANGUAGE
The assembler.
assembler, like the hexadecimal
hexadecimal loader, does not solve all the problems of
inprogramming. One problem is the tremendous
tremendous gap between
between the microcomputer
microcomputer in­
struction set
set and the tasks which the microcomputer
microcomputer is to perform. Computer
Computer inin­
structions
structions tend to do things
things like add the contents
contents of two registers.
registers, shift
shift the contents
contents of
the Accum
ulator one bit. or place a new value in the Program Counter. On the other
Accumulator
hand,
generally wants
wants a m icrocom
puter to do something
something like check if an analog
hand. a user generally
icrocomputer
reading has exceeded a threshold.
threshold, look for and react to a particular
particular command
command from a
teletypewriter, or activate
activate a relay at the proper
proper time. An assembly language
language programprogram­
teletypewriter.
mer must
must translate
translate such tasks into a sequence of simple
simple computer
puter instructions.
instructions. The
translation
translation can be a difficult.
ifficult, time-consuming
e-consuming job.
Furthermore, if you are programming in assembly language, you must have detailed
Furthermore.
knowledge of the particular microcomputer
microcomputer that
that you are using.
knowledge
using. You must know
what registers and instructions
instructions the m icrocom
puter has.
precisely how the instructions
instructions
what
icrocomputer
has. precisely
affect the various registers.
registers, what
hat addressing
addressing methods
methods the computer
puter uses,
affect
uses. and a myriad
of other
other information.
information. None of this information
information is relevant
relevant to the task which
which the
icrocomputer
ultimately
m icrocom
puter must ultim
ately perform.

In addition.
addition, assembly language programs are not portable.

I

I

| PORTABILITY
PORTABILITY |

icrocomputer
Each m icrocom
puter has its own assembly language.
language, which
which
reflects its own architecture.
architecture. An assembly language program
program written
ritten for the 6502 will
ill
6800, Z80. 8080.
8080, or 3870
3870 microprocessor.
microprocessor. For example.
example, the addition
addition propro­
not run on a 6800.
gram written
ritten for the 8080
8080 would
would be:
LDA
LOA
MOV
LDA
LOA
ADD
STA

60H
B.A
8.A
61 H
B
62H

1-6

The lack of portability
on't
portability not
not only
only means that
that you w o
n 't be able to use your
your assembly
language
on't
language program
program on another
another microcomputer.
microcomputer, but it also means that
that you w o
n 't be able
icrocomputer
to use any programs
programs that
that weren't
weren't specifically
specifically written
ritten for the m icrocom
puter you are
particular drawback
drawback for microcomputers.
microcomputers, since these devices
devices are new
using. This is a particular
and few assembly
result. too frequently.
assembly language
language programs
programs exist
exist for them. The result,
frequently, is that
your own. If you need a program
program to perform
perform a particular
particular task,
you are on your
task. you are not
likely
likely to find
find it in the small
small program
program libraries
libraries that most manufacturers
manufacturers provide. Nor are
you likely
likely to find
find it in an archive.
archive, journal
journal article.
article, or someone's
someone's old program
program file. You will
ill
probably
probably have to write
write it yourself.

HIGH-LEVEL
HIGH-LEVEL LANGUAGES
LANGUAGES

__________

The solution to many of the difficulties
difficulties associated with
ith as| COMPILER |
IcoMPILER!
sembly language programs is to use, instead, "h ig h-level"
-le v e l" or
sembly
"procedure-oriented" languages. Such languages allow you to describe tasks in
"procedure-oriented"
statement
forms that
that are problem oriented
oriented rather
rather than computer
computer oriented. Each statem
ent in
high-level language performs a recognizable function; it will
ill generally correscorres­
a high-level
pond to many assembly
assembly language instructions. A program called a compiler transtrans­
high-level language source program into object
object code or machine
lates the high-level
language instructions.
Many
Many different
different high-level
high-level languages
languages exist
exist for different
different types of
| FORTRAN |
!FORTRAN!
tasks. If,
example, you can express what
hat you want
ant the comcom­
If. for example.
puter
FORTRAN (Formula
puter to do in algebraic
algebraic notation.
notation, you can write
write your
your program
program in FORTRAN
Translation
Translation Language).
Language), the oldest
oldest and most widely
idely used of the high-level
high-level languages.
Now. if you want
computer:
Now,
ant to add twoo numbers.
numbers, you just tell the computer:
SUM== NUMB1 +
+ NUMB2

That
That is a lot simpler
simpler (and a lot shorter) than either
either the equivalent
equivalent machine
machine language
language propro­
gram or the equivalent
equivalent assembly
assembly language
language program. Other
Other high-level
high-level languages
languages inin­
clude
(another algebraic
algebraic language). PL/1 (a
clude COBOL (for business
business applications).
applications), PASCAL (another
FORTRAN. ALGOL,
ALGOL. and COBOL),
COBOL), and APL and BASIC (languages that
combination
bination of FORTRAN,
are popular
popular for time-sharing
e-sharing systems).

VANTAGES
A D VA
NTA G ES OF HIGH-LEVEL
HIGH-LEVEL LANGUAGES
Clearly, high-level
high-level languages make programs easier and faster
faster to write.. A common
estimate
ate is that
that a programmer can write
rite a program about ten times as fast in a
high-level
high-level language as compared to assembly
assembly language.1-3
language.1'3 That
That is just writing
riting the
program;
problem definition.
program design,
design. debugging,
debugging. testing,
testing. or
program: it does not include
include problem
definition, program
documentation.
documentation, all of which
hich become
become simpler
simpler and faster. The high-level
high-level language
language propro­
gram is,
is. for instance.
Even if you do not know
FORTRAN. you
instance, partly
partly self-documenting.
self-documenting. Even
know FORTRAN,
probably
probably could
could tell what
hat the statement
statement illustrated
illustrated above does.
High-level
associHigh-level languages solve many other
other problems associ­
MACHINE
MACHINE
ated
ated with
ith assembly
assembly language programming. The high-level
high-level
INDEPENDENCE
language
language has its own syntax
syntax (usually
(usually defined
defined by a national
national or
OF HIGH-LEVEL
international standard).
standard). The language
language does not mention
mention the inin­
international
LANGUAGES
struction
set. registers.
struction set,
registers, or other
other features
features of a particular
particular com-­
puter. The com
compiler
c.an concentrate
piler takes care of all such details. Programmers
Programmers can
concentrate on their
their
detailed understanding
understanding of the underlying
underlying CPU
architec­
own tasks; they do not need a detailed
CPU architecture -— for that
that matter.
matter, they do not need to know
know anything
anything about
about the computer
puter they are
programming.
programming.

Programs written
ritte n in a high-level
high-level language are portable -—
at least, in theory. They
They will
ill run on any computer
puter that has a
standard
standard compiler
compiler for that
that language.

1 -7

PORTABILITY
OF HIGH-LEVEL
HIGH-LEVEL
LANGUAGES

time. all previous programs
At the same time,
programs written
ritten in a high-level
high-level language
language for prior com-­
puters are available
available to you when
when programming
programming a new computer.
computer. This can mean thouthou­
sands of programs
programs in the case of a common
common language like FORTRAN
FORTRAN or BASIC.
BASIC.

VANTAGES
D ISA D VA
N TAG ES OF HIGH-LEVEL LANGUAGES
good things we have said about high-level
languages are true, if you
Well.
ell, if all the good
high-level languages
programs faster
ascan write programs
faster and make them portable besides, whyy bother with
ith as­
languages? Who wants
registers. instruction codes,
sembly languages?
ants to worry about registers,
codes,
mnemonics. and all that
garbage! As usual,
usual, there are disadvantages that
that balance
balance
mnemonics,
that garbagel
the advantages.
One obvious problem is that you have to learn the "rules"
s " or
SYNTAX
SYNTAX OF
language you want
HIGH-LEVEL
use. A high"s y ntax"
ta x " of any high-level language
ant to use.
rules. You will
LANGUAGES
level language
language has a fairly
fairly complicated
complicated set of rules.
ill find
that it takes a lot of time just
just to get a program that is syntactically
syntactically
correct
correct (and even then it probably
probably will
ill not do what
hat you want). A high-level
high-levelcomputer
computer
language is like a foreign
talent. you will
to the
foreign language. If you have a little
little talent,
ill get
getused to
the
rules and be able to turn out programs
programs that the compiler
compiler will
ill accept. Still.
Still, learning the
rules and trying
trying to get the program accepted
accepted by the compiler
compiler does not contribute
contribute
directly
directly to doing
doing your job.

Here. for example.
FORTRAN rules:
Here,
example, are some FORTRAN
• Labels must be numbers
numbers placed in the first five card columns
columns
• Statements
Statements must start in column
column seven
J. K,
• Integer
Integer variables
variables must start
start with
ith the letters I,I. J,
K. L,
L. M,
M. or N

------,

COST OF
Another
nother obvious
obvious problem is that you need a compiler
compiler to translate
programs written
programs
ritten in a high-level
high-level language. Compilers
Compilers are expenexpen­
COMPILERS
sive and use a large amount
amount of memory. While
hile most assemblers
occupy
K=
= 1024),
1024). compilers
occupy 2K to 16K bytes of memory (1K
compilers occupy
occupy 4K to 64K bytes. So
large.
the amount
amount of overhead involved
involved in using the compiler
compiler is rather large.
Furthermore. only some compilers will
Furthermore,
ill make the implementaimplementa­
ALGEBRAIC
simpler. FORTRAN,
FORTRAN. for example,
example. is well-suited
tion of your task simpler.
well-suited
NOTATION
NOTATION
to problems
problems that can be expressed as algebraic
algebraic formulas. If,
If.
however. your problem is controlling
however,
controlling a printer,
editing a string
string of characters.
characters, or monitoronitor­
printer. editing
system. your problem
ing an alarm system,
problem cannot
cannot be easily expressed in algebraic
algebraic notation. In
fact. formulating
fact,
ulating the solution
solution in algebraic
algebraic notation
notation may be more awkward
awkward and more
ifficult
d iffic
u lt than formulating
ulating it in assembly, language. One answer
answer is to use a more suitable
suitable
high-level
exist. but they are far less
high-level language. Some such languages exist,
idely used and
less widely
standardized
FORTRAN. You will
standardized than FORTRAN.
ill not get many of the advantages
advantages of high-level
high-level
languages if you use these so-called system implementation
implementation languages.

------

..

High-level
igh-level languages do not produce very e fficient
ie n t
INEFFICIENCY
machine language
language programs.
programs. The basic reason for this is that
machine
OF HIGH-LEVEL
automatic
compilation
pilation is an autom
atic process which
hich is riddled with
ith com-­
LANGUAGES
promises to allow
allow for many ranges of possibilities.
possibilities. The com-­
OPTIMIZING
OPTIMIZING
piler works much like a computerized
computerized language translator
translator -—
COMPILER
sometimes
sometimes the words
words are right
right but the sounds and sentence
structures
structures are awkward.
awkward. A simple compiler
compiler cannot
cannot know when
when a variable
variable is no longer
being used and can be discarded.
discarded, when a register
register should be used rather
rather than a memory
location.
location, or when variables have simple relationships.
relationships. The experienced
experienced programmer
programmer can
take advantage
advantage of shortcuts
shortcuts to shorten execution
A few
few
execution timee or reduce memory
memory usage.
usage A
compilers
compilers (known as optimizing
optimizing compilers) can also do this, but such compilers
are
compilers are
much larger and slower
slower than regular
regular compilers.

1-8

The general advantages
disadvantages of high-level
advantages and disadvantages
high-level languages are:
Advantages:
"'A_D_V_A_N_T_A_G_E_S,.
Advantages:
ADVANTAGES

OF
HIGH-LEVEL
LANGUAGES

• More convenient
convenient descriptions
descriptions of tasks
• Less time spent writing
ritin g programs
• Easier
documentation
Easier documentation
• Standard syntax
• Independence
Independence of the structure
structure of a particular
particular computer
puter
• Portability
Portability
• Availability
vailability of library
library and other programs

Disadvantages:
• Special rules
• Extensive hardware and software
software support
support required

DISADVANTAGES
DISADVANTAGES
OF
HIGH-LEVEL
LANGUAGES

Orientation of common
common languages to algebraic
algebraic or
• Orientation
business problems
• Inefficient
Inefficient programs

optimizing
• Difficulty
ifficu lty of optim
izing code to meet time and memory requirements
requirements
• Inability
Inability to use special features of a computer
puter conveniently
conveniently

HIGH-LEVEL LANGUAGES
LANGUAGES FOR
HIGH-LEVEL
FOR MICROPROCESSORS
Microprocessor users will
ill encounter several
several special difficultiess when
when using
Microprocessor
using highhighlevel languages.
level
languages. Among these are:

microprocessors
• Few high-level
high-level languages exist
exist for microprocessors
• Few standard languages are widely
idely available
• Compilers usually require a large amount of memory or even a comcom­
pletely different
different computer
pletely
ost microprocessor
ell-suited to high-level
• Most
microprocessor applications are not well-suited
languages
languages
• Memory
Memory costs are often critical in microprocessor applications
The lack of high-level
high-level languages is partly a result of the fact that microprocessors
microprocessors are
quite new and are the products
products of semiconductor
semiconductor manufacturers
manufacturers rather than computer
computer
quite
manufacturers. Very few high-level
high-level languages exist for microprocessors. The most comcom­
manufacturers.
mon are BASIC,
5 PASCAL,®
PL/l-type languages such as PL/M,7
PL/M,7
BASIC,5
PASCAL.6 FORTRAN,
FORTRAN, and the PL/I-type
MPL, and PLjuS.
PLJ.tS.
'
MPL,

Many of the high-level
high-level languages that exist do not conform
conform to recognized standards, so
that the microprocessor
access to
microprocessor user cannot
cannot expect
expect to gain much program portability,
portability, access
program libraries.
relibraries, or use of previous experience or programs. The main advantages
advantages re­
maining
maining are the reduction
reduction in programming
programming effort
effort and the smaller amount
amount of detailed
understanding
necessary.
understanding of the computer
puter architecture
architecture that is necessary.
The overhead involved in using a high-level
high-level language with
ith
OVERHEAD
microprocessors
microprocessors is considerable.
considerable. Microprocessors
Microprocessors themselves are
FOR
FOR
better
better suited to control
control and slow interactive
interactive applications
applications than they
HIGH-LEVEL
are to the character
character manipulation
anipulation and language analysis involved
LANGUAGES
in compilation.
compilation. Therefore.
Therefore, some compilers
compilers for microprocessors
microprocessors will
ill
not run on a microprocessor-based
microprocessor-based system. Instead, they require a much larger comcom­
cross-compilers rather than self-compilers.
self-compilers. A user must not only
puter; i.e.,.. they are cross-compilers
bear the expense of the larger computer
puter but must also physically
physically transfer the program
from the larger computer
puter to the micro.

1-9

icrocomputer
Some self-compilers
self-compilers are available. These compilers
compilers run on the m icrocom
puter for which
which
they produce
produce object
object code. Unfortunately.
Unfortunately, they require large amounts
amounts of memory (16K or
morel. plus special
more),
special supporting
supporting hardware
hardware and software.
High-level
to
UNSUITABILITY
UNSUITABILITY
High-level languages
languages also are not generally
generally well-suited
well-suited to
microprocessor
microprocessor applications.
applications. Most
Most of the common
common languages
languages
OF HIGH-LEVEL
HIGH-LEVEL
were devised either
to
LANGUAGES
LANGUAGES
either to help solve scientific
scientific problems
problems or to
andle
rge-scale
usiness
ata
rocessing.
ha
n d le la rg e
-s c a le b u s
in e s d a
ta p ro c
e s in g . Few
microprocessor
microprocessor applications
applications fall in either
either of these areas.
Most microprocessor
microprocessor
areas. Most
applications
information
applications involve
involve sending
sending data and control
control inform
ation to output
output devices and
receiving
information
receiving data and status
status inform
ation from input
input devices. Often the control
control and status
information
consists of a few binary
digits with
information consists
binary digits
ith very precise hardware-related
hardware-related
meanings. If you try to write
rite a typical
typical control
control program
program in a high-level
high-level language.
language, you
often feel like someone who
ho is trying
trying to eat soup with
ith chopsticks.
chopsticks. For tasks in such
systems. signal processing.
areas as test equipment.
equipment, terminals.
terminals, navigation
navigation systems,
processing, and business
equipment.
high-level
languages work
work much
better than they do in
equipm
ent, the high-level
languages
uch better
instrumentation.
automotive
instrumentation, communications,
communications, peripherals.
peripherals, and autom
otive applications.
applications.
Applications
Applications better
better suited
suited to high-level
high-level languages
languages are those which
which
APPLICATION
APPLICATION
require large memories. If,
If. as in a valve controller.
game.
AREAS FOR
controller, electronic
electronic game,
FOR
appliance
LANGUAGE
appliance controller.
controller, or small
small instrument.
instrument, the cost of a single
memory
LEVELS
LEVELS
memory chip is important.
important, then the inefficiency
inefficiency of high-level
high-level
languages
If. on the other
hand. as in a term
terminal
languages is intolerable.
intolerable. If,
other hand,
inal or
test equipment.
equipment, the system has many thousands
thousands of bytes of memory
memory anyway.
anyway, the ineffiineffi­
ciency of high-level
important. Clearly the size of the program
ciency
high-level languages
languages is not as important.
program and
the volume
volume of the product
product are important
portant factors
factors as
program will
ill greatly
greatly in­
as well. A large program
inhand. a high-volume
crease the advantages
advantages of high-level
high-level languages. On the other
other hand,
high-volume ap­
application
plication will
ill mean that
that fixed software
software development
development costs are not as important
portant as
as
memory
memory costs that
that are part of each system.

W HICH
IC H LEVEL SHOULD YOU USE?
USE?
That
That depends on your particular
particular application. Let us briefly note some of the factors
which
which may favor
favor particular
particular levels:
Machine
Machine Language:

• Virtually
Virtually no one programs in machine language
because it is inefficient
inefficient and difficult
ifficu lt to document.
An assembler
assembler costs very little and greatly reduces
programming time.
Assembly
Assembly Language:

• Short
Short to moderate-sized
moderate-sized programs
• Applications
Applications where
where memory
memory cost is a factor
factor

APPLICATIONS
APPLICATIONS
FOR MACHINE
MACHINE
LANGUAGE

APPLICATIONS
APPLICATIONS
FOR ASSEMBLY
FOR
LANGUAGE
LANGUAGE

• Real-time
Real-time control
control applications
applications
• Limited data processing
• High-volume
High-volume applications
• Applications
Applications involving more input/output
input/output or control than computation
computation

1-10
1-

High Level Languages:
Languages:
Long programs
programs
• Long
Low-volumee applications requiring
requiring long
long pro­
pro• Low-volum
grams
grams

APPLICATIONS
APPLICATIONS
FOR HIGH-LEVEL
FOR
LANGUAGE

large
• Applications where the amount of memory required is already very large
• Applications involving more computation than input/output
input/output or control

ompatibility
using larger computers
• C om
patibility with
ith similar applications using
vailability
programs in a high-level
language which can be
• A vaila
bility of specific programs
high-level language
used in the application
Many other factors are also important.
important, such as the availability
availability of a larger computer
computer for
use in development.
development, experience
experience with
ith particular
particular languages, and compatibility
patibility with
ith other
applications.
applications.
ultimately
If hardware will
ill ultim
ately be the largest cost in your application,
application, or if speed is critical,
critical,
you should favor assembly language. But be prepared to spend extra time in software
software
development
development in exchange
exchange for lower memory costs and higher
higher execution
execution speeds.
soft­
speeds. If software will
ill be the largest cost in your application,
application, you should favor a high-level
high-level language.
But be prepared to spend the extra money required for the supporting
supporting hardware and
software.
Of course, no one except
except some theorists will
ill object
object if you use both assembly and highlevel languages. You can write
rite the program
program originally
originally in a high-level
high-level language
language and then
patch some sections
sections in assembly language.
language.7 However, most users prefer not to do this
because of the havoc it creates in debugging,
debugging, testing, and documentation.
documentation.

FUTURE?
HOW ABOUT THE FUTURE?
We expect
languages for the follow
following
reasons:
expect that
that the future will
ill favor high-level languages
ing reasons:
• Programs always seem to add extra features and
grow larger

less expensive
• Hardware and memory are becoming
becoming less

FUTURE TRENDS
IN LANGUAGE
LEVELS
LEVELS

ex• Software
Software and programmers
programmers are becoming
becoming more ex­
pensive
• Memory
Memory chips are becoming
becoming available in larger sizes,
er bit"
sizes, at lower "per
bit" cost,
cost.
so actual savings in chips are less
less likely

• More suitable
suitable and more efficient
efficient high-level
high-level languages are being developed
• More standardization
standardization of high-level
high-level languages will
ill occur

Assembly
Assembly language programming
programming of microprocessors
microprocessors will
ill not be a dying
dying art any more
than it is now for large computers.
computers. But longer programs, cheaper memory, and more ex­
expensive programmers
programmers will
ill make software
software costs a larger part of most applications.
applications. The
edge in many applications
applications will
ill therefore go to high-level
high-level languages.

1-11
1-

WHY
Y THIS BOOK?
BOOK?
If the future would seem to favor high-level
languages, why
ashigh-level languages,
hy have a book on as­
language programming?
programming? The reasons are:
sembly language
1)
1)

Most
icrocomputer
Most current
current m icrocom
puter users program in assembly language
language (almost two
thirds.
thirds, according
according to one recent
recent survey).

2)

puter users will
ill continue
continue to program
program in assembly language
language since
Many m icrocom
icrocomputer
they need the detailed
detailed control
control that
that it provides.

3)

No suitable
suitable high-level
high-level language
language has yet become widely
idely available
available or standardized.
standardized.
Many applications
applications require the efficiency
efficiency of assembly language.
An understanding
understanding of assembly
assembly language
language can help in evaluating
evaluating high-level
high-level
languages.

4)
5)

The rest of this book will
ill deal exclusively
exclusively with
ith assemblers and assembly language
language propro­
gramming. However.
However, we do want
want readers to know that
that assembly language
language is not the
gramming.
only alternative.
alternative. You should
should watch
watch for new developments
developments that
that may significantly
significantly reduce
programming
programming costs if such costs are a major factor
factor in your
your application.
application.

1-12
1-

REFERENCES
1.
1.
2.
3.

A. Osborne,
Osborne. An Introduction
Basic Concepts.
Introduction to Microcomputers:
icrocomputers: Volume
Volume 1 -— Basic
Osborne/McGraw-Hill.
Berkeley, CA„
CA., 1976.
1976.
Osborne/McGraw-Hill, Berkeley,
H. Halstead, Elements of Software Science,
Elsevier, New York, 1977.
M. H.
Science. American
American Elsevier,
V. Schneider, "Prediction
"Prediction of Software Effort and Project Duration,"
Duration," SIGPLAN
SIGPLAN
Notices,
Notices. June 1978, pp. 49-55.

4.

M. Phister Jr.,.. Data Processing Technology
Technology and Economics,
Economics, Santa Monica PublishPublish­
Co., Santa Monica, CA,
CA, 1976.
1976.
ing Co.,

5.

Albrecht,
Finkel, and Brown, BASIC
York, 1978.
Albrecht, Finkel,
BASIC for Home Computers,
Computers. Wiley, New York,
1978.

6.

K. L.
L. Bowles, M icrocom
icrocomputer
K.
puter Problem Solving Using PASCAL, Springer-Verlag,
Springer-Verlag, New
York, 1977.
1977.

7.

D. D.
D. McCracken.
McCracken, A Guide to PL'M Programming
icrocomputer
D.
Programming for M icrocom
puter Applications,
Applications,
Addison-Wesley,
Reading. Mass
Addison-Wesley, Reading,
Mass.,.. 1978.
1978.

8.

P. Caudill, "Using
P.
"Using Assembly
Assembly Coding to Optimize High-Level Language Programs,"
Electronics,
1, 1979, pp. 121-124.
Electronics, February 1,

1-13
1-

Chapter 2
ASSEMBLERS
ASSEMBLERS
This chapter
chapter discusses the functions
functions performed by assemblers, beginning
beginning with
ith features
proceeding through
through more elaborate capabilities
capabilities such
common to most assemblers and proceeding
as macros and conditional
conditional assembly. You may wish to skim this chapter
chapter for the present
and return to it when you feel more comfortable
comfortable with
ith the material.

FEATURES OF ASSEMBLERS
ASSEMBLERS
asAs we mentioned previously, today's
today's assemblers do much more than translate as­
assembly language mnemonics into binary codes.
ill describe how an as­
codes. But we will
sembler handles the translation of mnemonics before describing additional assemassem­
sembler
used.
bler features. Finally, we will
ill explain how assemblers are used.

ASSEMBLER INSTRUCTIONS
ASSEMBLER
Assembly language
language instructions
instructions (or "sta te
m e n ts") are divided
divided
"statements")
Assembly
into a number
number of fields,
fields, as shown
shown in Table
Table 2-1.
into

ASSEMBLY
ASSEMBLY
LANGUAGE
FIELDS

operation code field
field is the only
only field
field that
that can never
never be
The operation
empty; it always
always contains
contains either
either an instruction
instruction mnemonic
mnemonic or a
empty;
directive to the assembler,
assembler, called
called a pseudo-instruction,
pseudo-instruction, pseudo-operation,
pseudo-operation, or
directive
pseudo-op.
pseudo-op.
blank.
The operand or address field may contain an address or data, or it may be blank.

The comment
comment and label fields are optional. A programmer will
ill assign a label to a
statem
ent or add a comment
comment as a personal convenience:
convenience: namely, to make the propro­
statement
gram easier to read and use.
Table 2-1. The Fields of an Assembly Language Instruction
Instruction

Operation Code
Label Operation
Label
or
Mnemonic
or Mnemonic
Field
Field
Field

Operand or
Address
Field

START
START

LDA
ADC
STA

VAL1
VAL2
SUM

NEXT
NEXT

?

?
?

VAL1
VAL2
SUM
SUM

’·=·+1
=*+1
*=
*+ 1
·=·+1
*=
*+ 1
·=·+1

Comment Field
Comment

;LOAD
INTO A
NUMBER INTO
FIRST NUMBER
:LOAD FIRST
;ADD SECOND
NUMBER TO A
SECOND NUMBER
iSTORE
;STORE SUM
:NEXT INSTRUCTION
INSTRUCTION

2-1

Table 2-2. Standard 6502 Assembler
Assembler Delimiters
Delimiters

'space' between
between label and operation
operation code and between operation
'space'
code and address
, between
between operands in the address field
:; or I! before a comment
comment
Note that
that 6502 assemblers vary greatly
greatly and some may not use these delimiters.

Of course,
course, the assembler must have some way
ay of telling
|FORM AT!
use
where one field ends and another begins.
begins. Assemblers that use
input often require that each field start in a specific
specific card column. This is
punched card input
a fixed format. However.
However, fixed formats are inconvenient
inconvenient when the input
input medium is
paper tape; fixed formats
formats are also a nuisance to programmers. The alternative
alternative is a free
format where the fields may appear anywhere
anywhere on the line.
format
line.

I

If the assembler cannot
cannot use the position
position on the line to tell the
|PEUMITERS|
!DELIMITERS
fields apart,
apart. it must
else. Most
use a
must use something
something else.
ost assemblers use
special symbol or delimiter
iter at the beginning or end of each field. The most common
delimiter
Commas. periods,
periods. semicolons,
semicolons. colons,
colons. slashes,
slashes. ques­
quesdelim
iter is the space character. Commas,
marks. and other
tion marks,
other characters
characters that
that would
would not otherwise
otherwise be used in assembly
language programs may also serve as delimiters. Table 2-2 lists standard 6502 assem­
assembler delimiters.
delimiters.

You will
ill have to exercise a little care with
ith delimiters. Some assemblers are fussy
ellabout extra spaces or the appearance of delimiters in comments or labels.
labels. A wellwritten
ritte n assembler
assembler will
ill handle these minor problems,
problems, but many assemblers are not
ll-written.
can.
w e ll-w
ritte n . Our recommendation is simple: avoid potential
potential problems if you can.
The following
ing rules will
ill help:
1)
1)

spaces. particularly
Do not use extra spaces,
particularly after commas that separate operands.

2)

delimiter
labels.
Do not use delim
iter characters
characters in names or labels.
Include standard delim
delimiters
iters even if your assembler does not require them. Your propro­
grams will
ill then run on any assembler.

3)

LABELS
The label field is the first field in an assembly language
language in­
inLABEL
LABEL
present. the assembler
struction: it may be blank. If a label is present,
FIELD
struction;
FIELD
defines the label as equivalent
equivalent to the address into which
hich the first
byte of the object
loaded. You may subse­
subseobject program resulting
resulting from that instruction
instruction is loaded.
quently
quently use the label as an address or as data in another
another instruction's
instruction's address field. The
assembler will
proill replace the label with
ith the assigned value when creating an object pro­
gram.
Labels are most frequently
frequently used in Jump, Call, or Branch
Branch in­
in- LABELS
LABELS
structions. These instructions
instructions place a new value in the Program
IN JUMP
JUMP
Counter
INSTRUCTIONS
Counter and so alter the normal sequential
sequential execution
execution of instrucinstruc­
INSTRUCTIONS
In the Program
tions. JUMP 15016
150-|6 means "place
"place the value
vakje 15016
1 0 in
Counter".
Counter". The next instruction
instruction to be executed will
ill be the one in memory location
START means "place
"p1ace the value assigned to the label
15015.
1 6. The instruction
instruction JUMP START
START in the Program Counter”
Counter". . The next instruction
START
instruction to be executed will
ill be the one at
START. Table 2-3 contains an example.
the address corresponding
corresponding to the label START.

2-2
2

Table 2-3. Assigning
Assigning and Using a Label
ASSEMBLY LANGUAGE
LANGUAGE PROGRAM
PROGRAM
ASSEMBLY
START
START

LOAD ACCUMULATOR 100

PROGRAM)
• (MAIN PROGRAM)

START
JUMP START
When the machine language version of this program is executed.
executed, the instruction
instruction
START causes the address of the instruction
START to be placed
JUMP START
instruction labeled START
in the Program Counter. That instruction
instruction will
ill then be executed.

Why
hy use a label? Here are some reasons:
1) AA label
label makes
makes aa program
program location
location easier
easier to
to find
find and
and remember.
remember.
1)
2) AA label
label can
can easily
easily be
be moved,
moved. ifif required,
required. to
to change
change or
or correct
correct aa program.
program. The as2)
as­
sembler will
ill automatically
atically change all instructions
instructions that use that label when the pro­
proreassembled.
gram is reassembled.
3) The
The assembler
assembler or
or loader
loader can
can relocate
relocate the
the whole
whole program
program by
by
3)
RELOCATION
adding a constant
constant (a relocation constant) to each address for
CONSTANT
CONSTANT
which
used. Thus we can move the program to
which a label was used.
allow for the insertion of other programs or simply
ply to rearrange memory.
memory.
The program
program is
is easier
easier to
to use
use as
as aa library
library program:
program; i.e
is easier
easierfor
forsomeone
someoneelse
else
4) The
i.e.,.. itit is
to take your program and add it to some totally
totally different
different program.
5)
5)

addresses. Figuring
addresses is
You do not have to figure out memory addresses.
Figuring out memory addresses
particularly
particularly difficult
ifficu lt with
ith microprocessors which
hich have instructions
instructions that vary in
length.

You should assign a label to any instruction
instruction that you might
ight want
ant to refer to later.
later.

The next
next question is how to choose a label. The assembler
CHOOSING
often places some restrictions
restrictions on the number of characters
LABELS
LABELS
6). the leading character
(usually 5 or 6),
character (often must be a letter),
letter). and
letters. numbers,
numbers. or one of a few special characthe trailing
trailing characters (often must be letters,
charac­
ters). Beyond these restrictions.
ters).
restrictions, the choice is up to you.
purpose, i.e.,.. mnemonic
Our own preference is to use labels that
that suggest their purpose,
labels.
mnemonic labels.
Typical
Typical examples are ADDW
ADDW in a routine that adds one word into a sum,
sum. SRETX
SRETX in a
routine that searches for the ASCII
character ETX,
ASCII character
ETX. or NKEYS
NKEYS for a location in data
memory that contains
contains the number
number of key entries. Meaningful
Meaningful labels are easier to
remember and contribute
contribute to program documentation.
documentation. Some programmers use a stan­
stanlabels. such as starting
dard format
at for labels,
starting with
ith L0000. These labels are self-sequencing
self-sequencing
(you can skip a few numbers to permit
insertions). but they do not help document
(you
permit insertions),
document the
program.

2-3
2-

Some label selection
selection rules will
ill keep
keep you out of trouble. We
recommend the following:
ing:

RULES OF
LABELING

1)

Do not use labels that
that are the same as operation
operation codes or
other
will. but it is
other mnemonics.
mnemonics. Most
Most assemblers will
ill not allow this usage; others will,
very confusing.
confusing.

2)

that are longer
longer than the assembler permits. Assemblers
Assemblers have
Do not use labels that
truncation rules.
various truncation

3)

Avoid
non-numeric) and lower-case letters.
Avoid special characters
characters (non-alphabetic
(non-alphabetic and non-numeric)
Some assemblers will
permitit them; others allow only certain
ones. The simplest
ill not perm
certain ones.
simplest
practice
practice is to stick to capital
capital letters and numbers.

4)

Start each label with
ith a letter. Such labels are always acceptable.
Start

5)

Do not use labels that
that could
could be confused
confused with
ith each other. Avoid
Avoid the letters
letters I,I. 0 and
Z. and the numbers
1. and 2. Also avoid things
Z,
numbers 0.
0, 1,
things like XXXX and XXXXX. There's
tempting
laws.
no sense tem
pting fate and Murphy's
urphy's laws.

6)

legal. do not use it. You will
real
When
hen you are not sure if a label is legal,
ill not get any real
benefit
benefit from discovering
discovering exactly
exactly what
hat the assembler will
ill accept.

These are recommendations.
them. but don't
recommendations, not rules. You do not have to follow
follow them,
on't blame
us if you waste
waste time on silly
silly problems.

EMONICS)
ASSEMBLER OPERATION CODES (M N EM
O N IC S)
The main task of the assembler
assembler is the translation of mnemonic operation codes
task using a fixed table
into their
their binary equivalents.
equivalents. The assembler performs this task
much as you would
would if you were doing
doing the assembly by hand.
The assembler
Just translate
codes. It must
assembler must.
must, however.
however, do more than just
translate the operation
operation codes.
also somehow
somehow determine
determine how many operands the instruction requires and what
hat
type they
they are. This may be rather complex
complex -— some instructions
instructions (like a Halt) have no
operands.
one. while
operands, others (like an Addition
ddition or a Jump
Jump instruction)
instruction) have one,
hile still others
(like a transfer
transfer between
between registers or a multiple-bit
ultiple-bit shift) require two. Some instructions
instructions
may even allow
Oike Shift
Clear)
allow alternatives;
alternatives; e.g.,.. some computers
computers have instructions
instructions (like
Shift or Clear)
that
Accumulator
that can apply
apply either
either to the Accum
ulator or to a memory location. We will
ill not discuss
how the assembler
so.
assembler makes these distinctions;
distinctions; we will
ill just
just note that it must do so.

PSEUDO-OPERATIONS
PSEUDO-OPERATIONS
assembly language instructions are not directly transtrans­
Some assembly
PSEUDOPSEUDO­
lated into machine language instructions. These instructions
OPERATIONS
directives to the assembler;
assembler; they assign the program
program to cer­
are directives
certain areas in memory.
memory, define
define symbols, designate
designate areas of RAM for temporary
temporary data
storage.
memory. allow
programs.
storage, place tables or other
other fixed data in memory,
allow references to other
other programs,
and perform
perform minor
inor housekeeping
housekeeping functions.
functions.
assembler directives
directives or pseudo-operattons
pseudo-operations a programmer
programmer places the
To use these assembler
pseudo-operation's
field. and,
and. if the specified
pseudo-operation's mnemonic
mnemonic in the operation
operation code field,
specified pseudopseudo­
operation
it. an address or data in the address field.
operation requires
requires it,

The most common
common pseudo-operations
pseudo-operations are:
DATA
EQUATE (=) or DEFINE
DEFINE
EQUATE
ORIGIN
ORIGIN
RESERVE
RESERVE

Linking
are:
Linking pseudo-operations
pseudo-operations (used to connect
connect separate programs) are:
ENTRY
ENTRY
EXTERNAL
EXTERNAL

2-4
2-

Different
operations. but their functions
Different assemblers use different
different names for these operations,
functions are
the same.
same. Housekeeping pseudo-operations
pseudo-operations include:
END
END
LIST
LIST
NAME
PAGE
PAGE
SPACE
SPACE
TITLE
TITLE
PUNCH
PUNCH
We will
ill discuss these pseudo-operations
pseudo-operations briefly.
briefly, although
although their functions
functions are usually
obvious.

THE DATA PSEUDO-OPERATION
PSEUDO-OPERATION
The D ATA
llowss the programmer to e nter
proA pseudo-operation
pseudo-operation a llo
ter fixed data into pro­
gram m emory. This data may include:
include:
• Lookup tables
• Code conversion
conversion tables
• Messages
• Synchronization
Synchronization patterns
patterns
• Thresholds
Thresholds
• Names
• Coefficients
Coefficients for equations
equations
• Commands
Commands
• Conversion factors
• Weighting
eighting factors
• Characteristic
Characteristic times or frequencies
frequencies
• Subroutine
Subroutine addresses
• Key identifications
identifications
• Test patterns
• Character
Character generation
generation patterns
patterns
• Identification
Identification patterns
patterns
• Tax tables
• Standard forms
• Masking
Masking patterns
transition tables
• State transition
The DATA pseudo-operation
pseudo-operation treats the data as a permanent
permanent part of the program.
a t of a D ATA
A pseudo-operation
pseudo-operation is usually q uite simple. An in struction
The format
like:

DZCON

DATA
DATA

12

12

will
ill place the number 12 in the n ext
x t available m emory lo cation and assign that
location the name DZCON.
DZCON. Usually every DATA pseudo-operation
pseudo-operation has a label,
label. unless it
is one of a series of DA TA pseudo-operations.
pseudo-operations. The data and label may take any form
that the assembler permits.
that
Most
ost assemblers allow
allow more elaborate DATA instructions
instructions that handle a large amount
amount of
data at one time.
time, e.g.:
EMESS
EMESS
SQRS
SORS

DATA
DATA
DATA
DATA

2-5
2-

'ERROR'
'ERROR'
1,4,9,16,25
1.4.9.16.25

A single instruction
instruction may fill many words of program memory.
memory, limited only by the length
of a line. Note that if you cannot
cannot get all the data on one line,
follow one
line. you can always follow
another. e.g.,
e.g.,
DATA instruction
instruction with
ith another,

MESSG
MESSG

DATA
DATA
DATA
DATA
DATA
DATA

'NOW ISISTHE
'NOW
THE''
'TIME
FORALL
ALL ' '
TIM
E FOR
'GOODMEN
MEN'
'GOOD
'TOCOME
COMETO
TOTHE
THE' '
'TO
'AID OF
OFTHEIR
THEIR' '
'AID
'COUNTRY'
'COUNTRY'

Microprocessor
Microprocessor assemblers typically
typically have some variations of standard DATA
pseudo-operations. DEFINE
DEFINE BYTE
BYTE or FORM
FORM CONSTANT
CONSTANT BYTE
BYTE handles 8-bit
B-bit numbers;
DEFINE WORD or FORM
FORM CONSTANT WORD handles 16-bit
addresses.
DEFINE
16-bit numbers or addresses.
Other special pseudo-operations
pseudo-operations may handle character-coded
character-coded data.
data.

DEFINE) PSEUDO-OPERATION
THE EQUATE (or DEFINE)
DEFINING
The EQUATE pseudo-operation allows the programmer to
DEFINING
equate names with
NAMES
NAMES
ith addresses or data. This pseudo-operation
is almost always
is
always given the mnemonic EQU or =.
=. The names
addresses, numeric
data. starting
addresses. fixed addresses,
may refer to device addresses,
numeric data,
starting addresses,
addresses. etc.
etc.
The EQUATE pseudo-operation
pseudo-operation assigns the numeric value in its operand field to
the label in its label field. Here
Here are two examples:
TTY
LAST

EQU
EOU
EQU
EOU

55
5000
5000

Most assemblers will
ill allow you to define one label in terms of another,
another. e.g.,..
LAST
ST1
ST1

EOU
EQU
EOU
EQU

FINAL
FINAL
START+1
START+1

must. of course,
course. have been previously
The label in the operand field must,
previously defined. Often,
Often. the
expressions. as we shall see
see later.
later. Double
operand field may contain
contain more complex expressions,
address) may be useful in patching
name assignments
assignments (two names for the same data or address)
patching
together
together programs that use different
different names for the same variable (or different
different spellings
spellings
of what
hat was supposed to be the same name).
namel.
Note that
that an EQU pseudo-operation does not cause the as­
asSYMBOL
SYMBOL
sembler
sembler to place anything in memory. The assembler simply
TABLE
enters an additional name into a table (called a symbol table)
which the assembler
table. unlike the mnemonic
table. must be in
assembler maintains. This table,
mnemonic table,
RAM since it varies with
ith each program. The assembler always needs some RAM to hold
table: the more RAM it has,
has. the more symbols it11can accept. This RAM is in
the symbol table;
addition
addition to any which
hich the assembler needs as temporary storage.
storage.
name7 The answer is:
Is: whenever
When do you use a name?
whenever you have a
USE OF
parameter that
has some meaning besides its ordinary
that has
ordinary numeric
NAMES
NAMES
value or the numeric
numeric value of the parameter might
ight be changed.
constants. device addresses,
addresses. masking patterns.
We typically
typically assign names to time constants,
patterns, concon­
factors. and the like.
like. A name like DELAY,
version factors,
DELAY. TTY,
TTY. KBD,
KBD. KROW,
KROW. or OPEN
OPEN not only
makes the parameter
change. but itIt also adds to program documentation.
makes
parameter easier to change,
documentation. We
also assign names to memory locations that have special purposes; they may hold data,
data.
program. or be available for intermediate
storage.
mark the start of the program,
intermediate storage.

What
hat name do you use? The best rules are much the same as
CHOICE
CHOICE
in the case of labels, except that here meaningful
eaningful names really
OF OF
X15. a bit
count. Why
hy not call the teletypewriter
teletypewriter TTY instead of X15,
NAMES
NAMES
BTIME or BTDLY rather than WW, the number
time delay BTIME
number of the
"GO" key on a keyboard GOKEY
GOKEY rather than HORSE?
straightfor­
HORSE? This advice seems
seems straightforward. but a surprising
surprising number
follow it.
ward,
number of programmers
programmers do not follow

2-6
2-

PLACEMENT
PLACEMENT
Where
Where do you place the EQUATE pseudo-operations? The
best place is at the start
OF
start of the program, under appropriate
appropriate
DEFINITIONS
comment
1/0 ADDRESSES,
ADDRESSES. TEMPORARY
TEMPORARY
DEFINITIONS
comment headings
headings such as I/O
STORAGE. TIME CONSTANTS,
CONSTANTS. or PROGRAM
PROGRAM LOCATIONS
STORAGE,
LOCATIONS. This
makes the definitions
definitions easy to find if you want
want to change
change them. Furthermore.
Furthermore, another
another
user will
ill be able to look up all the definitions
definitions in one centralized
centralized place. Clearly this pracprac­
tice improves
use.
improves documentation
documentation and makes the program easier to use.
Definitions
Definitions used only in a speoific
specific subroutine
subroutine should appear at the start of the
subroutine.
subroutine.

THE ORIGIN PSEUDO-OPERATION
The ORIGIN pseudo-operation
pseudo-operation (almost always
always abbreviated
abbreviated ORG) allowss the propro­
grammer to locate programs, subroutines, or data anywhere
anywhere in memory. Programs
and data may be located in different
different areas of memory depending
depending on the memory concon­
figuration.
figuration. Startup
Startup routines.
routines, interrupt
interrupt service routines.
routines, and other required programs
addresses.
may be scattered
scattered around memory at fixed or convenient
convenient addresses.
The assembler
LOCATION
assembler maintains a Location Counter (comparable to
COUNTER
the computer's
puter's Program Counter) which contains the location
proin memory of the next
next instruction or data item being pro­
ORG pseudo-operation
cessed. An ORG
pseudo-operation causes the assembler
assembler to place a new value in the
Location
CPU to place a new value in
Location Counter.
Counter, much as a Jump
Jump instruction
instruction causes the CPU
the Program Counter. The output
output from the assembler
assembler must not only contain
contain instructions
instructions
data. but must also indicate
and data,
indicate to the loader program where
where in memory
memory it should place
the instructions
instructions and data.
Microprocessor programs
programs often contain
contain several ORIGIN
ORIGIN statements
following
Microprocessor
statements for the following
purposes:
Reset (startup) address
Reset
Interrupt
Interrupt service addresses
Trap addresses
RAM storage
Memory
Memory stack
Subroutines
Subroutines
Memory addresses for in put/output
u t/o u tp u t devices or
Memory
functions
special functions
Still other
other ORIGIN
statements may allow
allow room for later insertions.
insertions, place tables or data in
Still
ORIGIN statements
memory.
memory, or assign vacant
vacant RAM space for data buffers. Program and data memory in
microcomputers may occupy
occupy widely
widely scattered
scattered addresses to simplify
plify the hardware.
microcomputers

Typical
statements
Typical ORIGIN statem
ents are:
ORG
ORG
ORG
ORG
ORG
ORG

RESET
RESET
1000
1000
INT3
INT3

ORG
Some assemblers assume an origin of zero if the programmer
programmer does not put an ORG
statement at the start
start of the program. The convenience
convenience is slight;
slight; we recommend
recommend the inin­
statement
clusion
ORG statement
clusion of an ORG
statement to avoid confusion.

THE RESERVE
RESERVE PSEUDO-OPERATION
allows the programmer to
The RESERVE
RESERVE pseudo-operation allows
allocate RAM for various purposes such as data tables, tem-­
porary storage, indirect addresses, a Stack, etc.

2-7
7

ALLOCATING
ALLOCATING
RAM

RESERVE pseudo-operation, you assign
assign a name to the memory area and
Using the RESERVE
assigned. Here
Here are some examples:
declare the number of locations to be assigned.
NOKEY
NOKEY
TEMP
TEMP
VOLTG
VOLTG
BUFR
BUFR

RESERVE
RESERVE
RESERVE
RESERVE
RESERVE
RESERVE
RESERVE
RESERVE

11
50
50
80
BO
100
100

RESERVEpseudo-operation
You can use the RESERVE
pseudo-operation to reserve
reserve memory locations in program
memory or in data memory; however,
however. the RESERVE
RESERVE pseudo-operation
pseudo-operation is more
meaningful
meaningful when applied
applied to data memory.
RESERVEpseudo-operation
In reality.
reality, all the RESERVE
pseudo-operation does is increase the assembler's Location
Counter
Counter by the amount
amount declared in the operand field. The assembler does not actually
actually
produce any object
code.
object code.

Note the following
ing features
features of RESERVE:
RESERVE:
1)
1)

RESERVEpseudo-operation
The label of the RESERVE
pseudo-operation is assigned the value of the first ad­
adreserved. For example,
example. the pseudo-operation:
dress reserved.
pseudo-operation:
TEMP
TEMP

RESERVE
RESERVE

20
20

TEMP to the address of the first
reserves 20 bytes of RAM and assigns the name TEMP
byte.
2)
2)

reserved. There is no default
You must specify the number
number of locations to be reserved.
default case.
case.

3)

that. by chance,
chance. may be in
No data is placed in the reserved locations. Any data that,
there.
these locations will
ill be left there.

Some assemblers allow the programmer to place initial
INITIALIZING
INITIALIZING
values in RAM. We strongly recommend that you do not
RAM
(along with
use this feature -— it assumes that the program (along
the initial
initial values) will
ill be loaded from an external device (e.g
(e.g.,.. paper tape or floppy disk)
disk)
programs. on the other hand,
hand. reside in non­
each time it is run. Most microprocessor
microprocessor programs,
nonvolatile
ROM and start when power comes on.
on. The RAM in such situations
volatile ROM
situations does not re­
retain its contents.
contents, nor is it reloaded. Always
Always include instructions
instructions to initialize
initialize the RAM in
your program.

LINKING PSEUDO-OPERATIONS
We often w ant
nt statements
statements in one program
program or subroutine to
EXTERNAL
use names that
use
that are defined elsewhere.
elsewhere. Such names are called
REFERENCES
REFERENCES
external
acexternal references;
references; a special linking
linking program is necessary to ac­
tually
names are
are undefined
tually fill in the values and determine
determine if any names
undefined or doubly
doubly defined.
The pseudo-operation EXTERNAL, usually abbreviated
abbreviated EXT, signifies that the
name is defined elsewhere.
elsewhere.

The pseudo-operation ENTRY, usually abbreviated
abbreviated ENT, signifies that the name
name is
is
available for use elsewhere;
elsewhere; i.e.... it is defined in
in this program.
The precise way in which
hich linking
linking pseudo-operations
pseudo-operations are implemented
plemented varies greatly
from assembler to assembler. We will
ill not refer to such pseudo-operations again,
again. but
they are very useful in actual applications.
applications.

2-8
2-

HOUSEKEEPING PSEUDO-OPERATIONS
There are various housekeeping pseudo-operations
pseudo-operations that
that affect
affect the operation of
the assembler
assembler and its program listing rather
rather than the output
output program itself. ComCom­
mon housekeeping pseudo-operations
pseudo-operations include:
END. which
• END,
hich marks the end of the assembly language
language source program.
LIST, which
• LIST,
hich tells the assembler to print
print the source program. Some assemblers allow
such variations
long. repetitive
variations as NO LIST or LIST SYMBOL TABLE to avoid long,
repetitive listings.
TITLE. which
• NAME or TITLE,
hich prints
prints a name at the top of each page of the listing.
• PAGE
PAGE or SPACE,
SPACE. which
line. respectively,
which skips to the next page or next line,
respectively, and imim­
proves the appearance
read.
appearance of the listing.
listing, making
making it easier to read.
PUNCH. which
• PUNCH,
hich transfers
transfers subsequent
subsequent object
object code to the paper tape punch. This
pseudo-operation
pseudo-operation may in some cases be the default
default option
option and therefore
therefore unnecesunneces­
sary.
sary.

LABELS WITH
LABELS
IT H PSEUDO-OPERATIONS
Users often wonder
wonder if or when
when they
they can assign a label to a pseudo-operation.
These are our recommendations:
recommendations:
EQUATE pseudo-operations
• All EQUATE
pseudo-operations must have labels; they are useless otherwise.
otherwise, since
the purpose of an EQUATE
EQUATE is to define
define its label
label.
RESERVEpseudo-operations
• DATA and RESERVE
pseudo-operations usually
usually have labels. The label identifies
identifies the
first
first memory
memory location
location used or assigned..
• Other
Other pseudo-operations
pseudo-operations should not have labels. Some assemblers allow
allow such
labels, but we recommend
recommend against
against their
their use because there is no standard
standard way to inin­
terpret
terpret them.

22-9

ADDRESSES AND THE OPERAND FIELD
programmer a lot of freedom in describing
describing the con­
conMost
ost assemblers allow the programmer
Operand or Address
Address field. But remember thatt the assembler has
tents of the Operand
has builtnames for registers and instructions
instructions and may have other built-in names.
in names
names.
Some common
common options
options for the operand
operand field are:

11 Decimal numbers
numbers
1)

DECIMAL
DECIMAL
DATA OR
ADDRESSES
ADDRESSES

Most assemblers assume all numbers to be decimal
decimal unless they
So:
are marked otherwise. So:

ADD

100

means "add the contents
10010 to the contents
means
contents of memory location 100-)o
contents of the Acc­
cumulator."
ulator."

21 Other number systems
2)
Most assemblers will
octal. or hexadecimal
ill also accept binary, octal,
entries. But you must identify
identify these number
number systems in some
way. e.g.,.. by preceding or follow
following
idenway,
ing the number with
ith an iden­
tifying
tifying character
character or letter. Here are some common identifiers:
identifiers:

NON-DECIMAL
NON-DECIMAL
NUMBER
SYSTEMS

B or % for binary

0. @. Q,
0. or C for octal (the letter O should be avoided because of the confu0,
confu­
zero).
sion with zero).
(or standard BCD).
BCD).
H or $ for hexadecimal (or
case.
D for decimal. D may be omitted;
omitted: it is the default
default case.
Assemblers generally require hexadecimal numbers to start with
(e.g.. 0A36
ith a digitit (e.g.,
labels. It is
instead of A36) in order to distinguish
distinguish between numbers and names or labels.
base in which
good practice
practice to enter numbers in the base
hich their meaning is the
clearest: i.e.,.. decimal constants
constants in decimal;
decimal: addresses and BCD
BCD numbers in hex­
hexadecimal; masking patterns or bit outputs
adecimal;
outputs in binary if they are short and in hex­
hexadecimal if they are long.
long.

3)
31 Names
Names can appear in the operand field: they will
ill be treated as the data that they
represent. But remember,
remember. there is a difference between
between data and addresses.
addresses. The
sequence:

FIVE
FIVE

EQU
EOU
ADD

5
FIVE
FIVE

will
ill add the contents
contents of memory location 0005 (not necessarily the number 5)
5) to the
contents
contents of the Accumulator.
Accumulator.

2-10
2-

41 The current value of the location counter (usually
(usually referred to as *• or $).
4)
This is useful mainly
mainly in Jump
Jump instructions:
instructions; for example:
JUMP

*+66

causes a Jump
Jump to the memory location six words beyond the word that
that contains
contains the
first
first byte of the JUMP instruction:
instruction:
Memory

6 code
} JUMP * +
·+e
code stored
stored here
here
6 locations <

- Jump here
!4---Jumphere

Most microprocessors
Thus. you will
microprocessors have many two- and three-word
three-word instructions.
instructions. Thus,
ill
ifficulty
determining
have d ifficu
lty determ
ining exactly
exactly how far apart two assembly language statements
statements
are. Therefore,
Therefore. using offsets from the Location Counter
are.
Counter frequently
frequently results in errors
that you can avoid if you use labels
labels.

5)
51 Character codes
Most assemblers allow text
ASCII strings. Such
text to be entered as ASCII
strings
strings may be surrounded
surrounded either
either with
ith single or double quotaquota­
tion marks:
marks; strings
strings may also use a beginning
beginning or ending symbol
C. A few assemblers also permitit EBCDIC
EBCDIC strings.
such as A or C.

ASCII
CHARACTERS

We recommend that
that you use character
character strings for all text. It improves the clarity
clarity and
readability
readability of the program.

6)

Combinations of 1)
etic, logical,
11 through 5)
51 with arithmetic,
logical, or special operators.
operators.
arithmetic
ARITHMETIC
Almost
ost all assemblers allow
allow simple
simple arithm
etic combinations
combinations
ARITHMETIC
AND LOGICAL
such as START+1. Some assemblers also permit
permit multiplication.
ultiplication,
EXPRESSIONS
division, logical functions.
functions, shifts.
shifts, etc. These are referred to as
division.
expressions. Note that
that the assembler evaluates expressions at
assembly time. Even
Even though
though an expression in the operand field may involve
promultiplication,
ultiplication, you may not be able to use multiplication
ultiplication in the logic of your own pro­
ram
g ra
m -— unless you write
rite a subroutine
subroutine for that specific
specific purpose.
hat expressions they accept and how they interpret
interpret them. ComCom­
Assemblers vary in what
plex expressions make a program difficult
ifficu lt to read and understand.

recommendations during
during this section but will
ill repeat them and
We have made some recommendations
add others here. In general, the user should
should strive for clarity and simplicity. There is
no payoff for being an expert in the intricacies
intricacies of an assembler or in having the most
complex expression on the block. We suggest the following approach:
approach:
complex

1)
1)

Use the clearest number
number system or character
character code for data.
Masks and BCD
decimal, ASCII
characters in octal,
ordinary numerieri­
BCD numbers in decimal.
ASCII characters
octal. or ordinary
used.
cal constants
constants in hexadecimal
hexadecimal serve no purpose and therefore
therefore should not be used.

2)

Remember to distinguish
distinguish data from addresses.
addresses.

3)

Don't use offsets from the Location Counter.

4)

Keep
simple and obvious. Don't rely on obscure features of the assem­
Keep expressions simple
assembler.
bler.
2 -11

CONDITIONAL ASSEMBLY
CONDITIONAL
include or exclude parts of the source
source program,
program, deSome assemblers allow you to include
de­
pending on conditions existing at assembly time. This is called conditional assemassem­
bly; it gives the assembler some of the flexibility
flexibility of a compiler. Most
ost microcomputer
is:
assemblers have limited capabilities for conditional assembly. A typical
typical form is:
COND
IF COND
.(CONDITIONAL PROGRAM)
PROGRAM)
.(CONDITIONAL

ENDIF
ENDIF
COND is true at assembly time,
time. the instructions
ENDIF
If the expression COND
instructions between IF and ENDIF
(two pseudo-operations)
pseudo-operations) are included
included in the program.

Typical uses of conditional assembly are:
1)
1)

To include
include or exclude
exclude extra variables.

2)

runs.
To place diagnostics
diagnostics or special conditions
conditions in test runs.

3)

To allow data of various bit lengths.

4)

To create specialized versions of a common
common program.

Unfortunately,
Unfortunately, conditional
conditional assembly tends to clutter
clutter programs
programs and make them difficult
ifficu lt
necessary.
to read. Use conditional
conditional assembly only if it is necessary.

2-122
2-

MACROS
You will
that particular
DEFINING
ill often find that
particular sequences of instructions
instructions ococ­
DEFINING A
cur many times in a source program. Repeated instruction
seinstruction se­
SEQUENCE OF
quences may reflect
INSTRUCTIONS
INSTRUCTIONS
reflect the needs of your
your program logic, or they
may be compensating
compensating for deficiencies
deficiencies in your microprocessor's
microprocessor's
instruction
set. You can avoid repeatedly
repeatedly writing
instruction set.
ritin g out the same instruction
instruction sequence b·{
by
macro.
using a macro.

Macros allow you to assign a name to an instruction sequence. You then use the
source program
program instead of the repeated
sequence.
macro name in your source
repeated instruction sequence.
The assembler will
inill replace the macro name with
ith the appropriate sequence of in­
structions. This may be illustrated
illustrated as follows:
follows:
Object
Program
Object Program

Source Program
Program
MACl

(macro definition)
definition)
(macro

MACRO
MACRO

}

instruction
instruction M 1 \
instruction
instruction M2

> --------------------------------

instruction
instruction M3
M3 /

ENDM

(end of
.of macro
macro definition)
definition)
(end

instruction
instruction P11

(main program) }

{
{

instruction P2
P2
instruction
instruction
instruction P3
P3

MAC1
instruction P4
instruction PS
instruction P6
instruction P7

instruction
instruction P11

instructtOnP2
P2
instruction
instruction P3
instruction
instructtOnM11
instruction
instruction
instruction M2

instruction Ml
instruction
M3
instruction
instruction P4
P4

}

{

instruction
instruction P5
PS

instruction P6
P6
instruction

instruction
instruction P7

-{
-

MAC1

instruction
instruction M11

instructtOnM2
instruction
instruction
instruction M3
instruction
instruction P8
P8

-1

instruction
PS
instruction P8

-

instruction
instructtOnP9
P9

instruction
instruction P9
P9

instruction
instruction M11

-{

instruction
instruction M2

MACl

instruction
instructK>nM3
M3

-{
-

instruction
instruction P1°
P10 }|
instruction
instruction P11
11 f "

instruction
P10
instructK>OPl0

instruction P11
11
instruction

Macros are not the same as subroutines. A subroutine
subroutine occurs once in a program.
program, and
program execution
execution branches to the subroutine.
subroutine. A macro is expanded to an actual inin­
struction
struction sequence each time the macro occurs; thus a macro does not cause any
branching.

2-133
2-

Macros
Macros have the following
ing advantages:
1) Shorter
Shorter source
source programs.
programs.
1)

ADVANTAGES
ADVANTAGES
OF MACROS

2) Better
Better program
program documentation.
documentation.

Use of
of debugged
debugged instruction
instruction sequences
sequences -— once
once the
the macro
macro has
has been
been debugged,
debugged.
3) Use
the macro.
macro.
you are sure of an error-free instruction
instruction sequence every time you use the
4)
4)

Easier changes.
changes. Change
Change the
the macro
macro definition
definition and
and the
the assembler
assembler makes
makes the
the change
change
Easier
for you every time the macro is used.
used.

Inclusion of
of commands,
commands. keywords,
keywords. or
or other
other com
computer instructions
instructions inthe
the basic in·
5) Inclusion
in­
struction
theinstruction
instruction set.
set.
struction set. You can use macros to extend or clarify
clarify the

The disadvantages of macros are:
1) Repetition
Repetition of
of the
the same
same instruction
instruction sequences
sequences since
since the
the
1)
used.
macro is expanded every time it is used.

DISADVANTAGES
DISADVANTAGES
OF MACROS

2)
2) AA single
single macro
macro may
may create
create aa lot
lot of
of instructions.
instructions.
3)
4)

Lack of standardization
standardization makes programs difficult
ifficu lt to read and understand.
Possible effects on registers and flags that may not be clearly described.

One problem is that
that variables used in a macro are only known
within
ith in it (i.e.,.. they are local rather than global). This can often
ithout
create a great deal of confusion
confusion w ith
o u t any gain in return. You
should be aware of this problem when
macros.1^
when using macros.

2 -14
14

----- ..
LOCAL OR
GLOBAL
VARIABLES

COMMENTS
COMMENTS
All assemblers
source program.
program. Comments have
assemblers allow
allow you to place comments
comments in a source
no effect
ffect on the object
object code, but they
they help you to read, understand, and document
the program. Good commenting
language
commenting is an essential
essential part of writing
ritin g assembly language
ithout
programs; programs w ith
o u t comments
comments are very difficultlt to understand.

We will
ill discuss commenting
commenting along with
ith documentation
documentation in a later chapter, but here
We
are some guidelines.:
1)

Use comments
comments to tell what
hat application
application task the program is
performing,
icrocomputer
inperforming, not how the m icrocom
puter executes the in­
structions.
structions.

COMMENTING
COMMENTING
TECHNIQUES
TECHNIQUES

Comments
TEMPERATUREABOVE
ABOVE LIMIT?",
FEED
Comments should say things
things like "IS TEMPERATURE
LIMIT?". "LINE FEED
TO TTY".
TTY", or "EXAMINE
"EXAMINE LOAD SWITCH".
Comments
Comments should not say things
things like "ADD
"ADD 1 TO ACCUMULATOR",
ACCUMULATOR". "JUMP TO
START", or "LOOK AT CARRY”
CARRY". You should describe how the program is affecting
affecting
the system: internal
CPU are seldom of any interest.
internal effects on the CPU
2)

Keep comments
comments brief
brief and to the point. Details should be available elsewhere in
the documentation.
documentation.

3)

Comment
Comment all key points.

4)

ent standard
standard instructions
instructions or sequences that change counters
counters or
Do not comm
comment
pointers;
meanpointers; pay special attention
attention to instructions
instructions that may not have an obvious mean­
'
ing.

5)

Do not use obscure abbreviations.
abbreviations.

6)

Make the comments
comments neat and readable.
readable.

7)

Comment
purposes. Also mark all tables and data
Comment all definitions,
definitions, describing
oescribing their purposes.
storage areas.
areas.

8)

Comment
Comment sections of the program as well as individual
individual instructions
instructions.

9)

Be consistent
consistent in your
your terminology.
terminology. You can and should be repetitive:
repetitive; you need not
consult
consult a thesaurus.

10)

e.g., "REMEMBER
"REMEMBER CAR­
CARLeave yourself
yourself notes at points which
hich you find confusing:
confusing: e.g.,
SET BY LAST INSTRUCTION".
INSTRUCTION". You may drop these in the final documenRY WAS SET
documen­
tation.

well-commented
use. You will
A well-comm
ented program is easy to use.
ill recover the time spent in commentent­
over. We will
menting
ing many times over.
ill try to show good com m
enting style in the programming
programming
purposes.
examples, although
although we often over-comment
over-comment for instructional
instructional purposes.

2-155
2-

TYPES OF ASSEMBLERS
Although
Although all assemblers
assemblers perform
perform the
the same tasks,
tasks, their
their implementations
implementations vary
vary
greatly.
greatly. We willill not
not try to describe
describe all the
the existing
existing types
types of assemblers;
assemblers; wee willill
merely define the terms and indicate some of the choices.
choices.
runs on a computer
A cross-assembler
cross-assembler is an assembler
assembler that
that runs
other than the one for which it assembles object programs.
programs.

CROSSASSEMBLER

The computer
puter on which
which the cross-assembler runs is typically
typically a
large computer
computer with
ith extensive software support
support and fast peripherals -— such as an IBM
IBM
360 or 370, a Univac 1108, or a Burroughs 6700. The computer
cross-asputer for which
hich the cross-as­
cross-assembler assembles programs is typically
typically a micro like the 6502 or 8080. Most cross-as­
FORTRAN so that they are portable.
semblers are written
ritten in FORTRAN

A self-assembler
self-assembler or resident
resident assembler is an assembler
assembler that
that
runs on the computer
computer for which it assembles programs.
runs
programs. The
self-assembler will
ill require some memory and peripherals, and it
may run quite slowly.

RESIDENT
ASSEMBLER

A macro assembler
assembler is an assembler
assembler that
that allows you to define
macros.
sequences of instructions as macros.

MACRO
ASSEMBLER

A microassembler is an assembler used to write
rite the
microprograms that
that define the instruction set of a computer.
icroprogramming
M icroprogram
m ing has nothing specifically
specifically to do with
ith
microcomputers.2,3
microcomputers.2,3

MICROMICROASSEMBLER

A meta-assembler
meta-assembler is an assembler
assembler that
that can handle many
different
different instruction sets. The user must define the particular
particular in­
instruction
used.
struction set being used.

METAMETA­
ASSEMBLER

A one-pass assembler
assembler is an assembler
assembler that
that goes through the
assembly language program only once. Such an assembler must
references, e.g.,
e.g., Jumpp inhave some way of resolving forward references,
in­
structions
structions which
hich use labels that have not yet been defined.

ONE-PASS
ASSEMBLER

A two-pass
two-pass assembler
assembler is an assembler
assembler that
that goes through
through the
TWO-PASS
TWO-PASS
assembly
firstt timee the
assembly language
language source
source program
program twice.
ice. The firs
ASSEMBLER
ASSEMBLER
assembler
assembler simply
simply collects
collects and defines
defines all the symbols;
symbols; the
second
second time
time it replaces
replaces the references
references with
ith the actual
actual definitions.
definitions. A two-pass
two-pass asas­
sembler has no problems
problems with
sembler
ith forward
forward references
references but
but may be quite
quite slow
slow if no
backup
backup storage
storage (like
(like a floppy
floppy disk)
disk) is available;
available; then
then the assembler
assembler must
must
physically
physically read the program
program twice
ic e from
from a slow
slow input
input medium
medium !like
(like a tele
typew riter
teletypewriter
paper
passes.
paper tape reader).
reader). Most
ost microprocessor-based
microprocessor-based assemblers
assemblers require
require twoo passes.

2-16
2-

ERRORS
Assemblers
Assemblers normally provide error messages, often consisting of a single coded
letter.
letter. Some typical
typical errors are:
,• Undefined
Undefined name (often a misspelling
misspelling or an omitted
itted definition)
definition)
,• Illegal character
(e.g., a 2 in a binary
character (e.g.,
binary number)
format
delimiter
•, Illegal
Illegal form
at (wrong delim
iter or incorrect
incorrect operands)
,■ Invalid
Invalid expression (e.g.,.. two operators in a row)
• Illegal value (usually too large)
large)
• Missing
Missing operand
• Double
name)
Double definition
definition (i.e.,.. twoo different
different values assigned to one name)
(e.g., a label on a pseudo-operation
one)
• Illegal
Illegal label (e.g.,
pseudo-operation that
that cannot
cannot have one)
• Missing
Missing label
• Undefined
Undefined operation
operation code
In interpreting
interpreting assembler
assembler errors, you must remember
remember that the assembler
assembler may get on the
wrong
space. or incorrect
aswrong track if it finds a stray letter.
letter, an extra space,
incorrect punctuation.
punctuation. Many as­
semblers will
ill then proceed to misinterpret
misinterpret the succeeding
succeeding instructions
instructions and produce
produce
meaningless
messages. Always
meaningless error messages.
Always look at the first error very carefully:
carefully; subsequent
subsequent
ones may depend on it. Caution
Caution and consistent
consistent adherence
adherence to standard formats will
ill
eliminate
eliminate many annoying
annoying mistakes.

LOADERS
LOADERS
asThe loader is the program
program which
which actually
actually takes the output
output (object code) from the as­
sembler
sembler and places it in memory
memory Loaders range from the very simple
simple to the very comcom­
types.
plex. We will
ill describe
describe a few different
different types.

BOOTSTRAP
A bootstrap loader is a program that
that uses its own first few
w inin­
itself or another loader program
LOADER
structions to load the rest of itself
LOADER
ROM, or you may
into memory. The bootstrap
bootstrap loader may be in ROM,
have to enter it into the computer
computer memory using front
front panel switches. The assembler
may place a bootstrap
bootstrap loader at the start of the object
object program
program that
that it produces.
A relocating loader can load programs anywhere
anywhere in memory. It
RELOCATING
LOADER
typically
typically loads each program into the memory space immediately
mediately
following
follow
ing that
that used by the previous program. The programs,
however.
however, must
must themselves
themselves be capable of being moved around in this way:
way; i.e.... they
must be relocatable. An absolute loader, in contrast, will
ill always
always place the propro­
grams in the same area of memory.
A linking loader loads programs and subroutines that
that have
LINKING
been assembled separately;
separately; it resolves cross references
references -—
LOADERS
that
is, instructions
that is,
instructions in one program that refer to a label in another
another
program. Object
Object programs
programs loaded by a linking
linking loader must be created by an assembler
that
that allows
allows external
external references.
alternative approach
approach is to separate the linking
linking and loading
An alternative
functions
functions and have the linking
linking performed by a program called a
link editor.

2-17
217

LINK
EDITOR

REFERENCES
1.
1.

A complete
complete monograph on macros is M. Campbell-Kelly, "Ann Introduction
Introduction to
Macros." American Elsevier. New York,
York. 1973.
1973.

2.
2.

A. Osborne.
Osborne. An Introduction
A.
Introduction to Microcomputers:
icrocomputers: Volume 1 - Basic Concepts.
Concepts.
OSBORNE/McGraw-Hill. Berkeley.
Berkeley, CA,
CA. 1977.
1977.
OSBORNE/McGraw-Hill,

3.
3.

A. K.
K. Agrawala and T.
T. G.
G. Rauscher.
Rauscher. Foundations of Microprogramming.
icroprogramming. Academic
Academic
Press. New York,
York. 1976.
1976.
Press,

4.

D. W. Barron,
Barron. "Assemblers
Elsevier. New York,
York. 1972
D.
"Assemblers and Loaders." American
American Elsevier.

5.
5.

C.W. Gear,
Gear. Computer
C.W.
Computer Organization and Programming.
Programming, McGraw-Hill.
McGraw-Hill, New York,
York.
1974.
1974.
~

2-188
2-

Chapter 3
THE 6502
6502 ASSEMBLY
V LANGUAGE
INSTRUCTION SET
begin in this
programs. We begin
language programs.
We are now ready to start
start writing
riting assembly language
We
inchapter by defining the individual instructions of the 6602
6502 assembly language
language in­
chapter
assembler.
struction set, plus the syntax
syntax rules of the MOS Technology assembler.
interfaces. or
discuss any aspects of microcomputer hardware, signals, interfaces,
We do not discuss
CPU
architecture in this book. This inform
ation is described in detail in An Introduction
Introduction
information
CPU architecture
-Some
to Microcomputers:
Microcomputers: Volum
Microprocessors and Volume 3 —
Some
Real Microprocessors
Volumee 2 -— Some Real
Devices.
Real
Support Devices.
Real Support

prolanguage pro­
In this book, wee look at programming techniques from the assembly language
grammer's viewpoint,
point, where
signals are irrelevant
irrelevant and there are no im·­
where pins and signals
microcomputer.
portant differences
differences between
between a minicomputer and a microcomputer.
portent
deInterrupts, direct
direct memory access,
architecture for the 6502 will
ill be de­
access, and the Stack architecture
Interrupts,
scribed in later chapters
chapters of this book,
conjunction with
ith assembly language programprogram­
book. in conjunction
discussions of the same subjects.
ming discussions
chapter contains
contains a detailed definition
definition of each assembly language instruction.
instruction.
This chapter
The detailed
detailed description
description of individual
individual instructions
instructions is preceded by a general discussion
instruction set that divides
divides instructions
instructions into those which
hich are frequently
frequently
of the 6502 instruction
3-3). If you are
(Table 3-3).
used (Table 3-1),
occasionally used (Table 3-2), and seldom used (Table
). occasionally
experienced assembly language programmer, this categorization
categorization is not particularly
particularly
an experienced
important
portant -— and.
depending on your own programming
programming prejudices, it may not even be
and, depending
accurate. If you are a novice assembly language programmer,
programmer, we recommend that you
used" category.
"frequently used”
begin by writing
ritin g programs
programs using only instructions
instructions in the "frequently
concepts of assembly language programming,
programming, you may
Once you have mastered the concepts
other instructions
instructions and use them where appropriate.
examine other

31
3-1

Table 3-1. Frequently
Frequently Used Instructions
Instructions of the 6502
6502

Instruction
Code
ADC
AND
ASL
BCC
BCS
BEO
BEQ
BMI
BNE
BNE
BPL
CMP
DEC
DEC
(DEY)
DEX (DEY)
INC
(INY)
INX (INY)
JMP
JSR
LOA
LDA
LOX (LDY)
(LOY)
LDX
LSR
LSR
PHA
PLA
ROL
ROL
ROR
ROR
RTS
RTS
SBC
SBC
STA
(STY)
STX (STY)

Meaning
Meaning
Add
Add with
ith Carry
Logical
Logical AND
rithmetic
A rithm
etic Shift
Shift Left
Branch
Branch if Carry Clear
Branch if Carry Set
Branch
Branch
1)
Branch if Equal to Zero (Z = 1)
Branch
1)
Branch if Minus
Minus (S = 1)
Branch
Branch iiif Not Equal to Zero (Z = 0)
Branch if Plus (S = 0)
Branch
Compare
Accumulator
Compare Accum
ulator to Memory
Memory
Decrement
1)
Decrement (by 1)
Decrement
(Y) by 1
Decrement Index
Index Register
Register X (Y)
Increment
1)
Increment (by 1)
Increment
(Y) by 1
Increment Index Register
Register X (Y)
Jum
Location
Jumpp to New Location
Jump
Jump to Subroutine
Subroutine
Load Accum
Accumulator
ulator
Load Index
(Y)
Index Register
Register X (Y)
Logical
Logical Shift
Shift Right
Right
Push Accum
Accumulator
ulator onto
onto Stack
Pull Accum
Accumulator
ulator from Stack
Rotate Left
Left through
through Carry
Rotate Right
Right through
through Carry
Return from Subroutine
Subroutine
Subtract
Subtract with
ith Borrow
Borrow
Store
Accumulator
Store Accum
ulator
Store
(Y)
Store Index
Index Register
Register X (Y)

Table
Table 3-2. Occasionally
Occasionally Used Instructions
Instructions of the 6502
6502

Instruction
Code

Meaning
Meaning

BIT
BRK
BRK
CLC
CLO
CLD
CLI
CLI
(CPY)
CPX (CPY)
EOR
EOR
NOP
ORA
RTI
RTI
SEC
SEC
SED
SEO
SEI
SEI
TAX (TAY)
(TAY)
TXA (TYA)
(TYA)

Bit Test
Break
Clear Carry
Clear Decimal
Decimal Mode
Mode
Clear Interrupt
Interrupt Mask (Enable Interrupts)
Interrupts)
Compare
(Y)
Compare with
ith Index Register
Register X (Y)
Logical
Logical Exclusive-OR
Exclusive-OR
No Operation
Operation
Logical
Logical (Inclusive)
(Inclusive) OR
Interrupt
Return from Interrupt
Set Carry
Set Decimal
Decimal Mode
Mode
Set Interrupt
Interrupt Mask (Disable Interrupts)
Interrupts)
(Y)
Transfer
Accumulator
Transfer Accum
ulator to Index Register
Register X (Y)
Transfer
(Y) to Accum
Accumulator
Transfer Index Register
Register X (Y)
ulator

33-2

Table 3-3. Seldom Used
Used Instructions
Instructions of the 6502

Instruction
Code

Meaning
Branch if Overflow
Overflow Clear
Branch if Overflow
Overflow Set
Clear Overflow
Overflow
Push Status Register onto Stack
Push
Pull Status Register from Stack
Transfer Stack Pointer to Index Register X
Transfer Index Register X to Stack Pointer

BVC
BVS
BVS
CLV
PHP
PHP
PLP
PLP
TSX
TXS

CPU REGISTERS
STATUS FLAGS
REGISTERS AND STATUS
FLAGS
The 6502
microprocessor has an Accumulator, a Status (or P)
Pl register, twoo index
6502 microprocessor
registers, a Stack Pointer, and a Program
Program Counter. These registers may be illustrated
illustrated
as follows:
follows:
n
7
0
15
8
Accumulator A
Accumulator
Index.Register
Index
.Register X
X
Index
Register Y
Index Register
Y
Program
Program Counter
Counter PC
PC

t--------1

I

.-----------------1

-------r-------"1

Stack
Stack Pointer
Pointer SP
SP
_, Status
Status Register
Register P
P

t--------1._ ______

The 6502's
6502's Status register
register contains six status flags and an interrupt
interrupt control bit.
These are the six status
status flags:

(C)
Carry (C)
(Z)
Zero (Z)
Overflow
(V)
Overflow (V)
(S)
Sign (S)
Decimal Mode (D)
(D)
(B)
Break (B)
Flags are assigned bit positions
Flags
positions within
ith in the Status register as follows:
follows:
7 6 5 4 3 2 1 0 ~8;1
~6502

-B it Number

(Pl reg,ster
. 6 5 0 2 Status
Status (P)
register

The Accumulator (A)
(Al is a primary accumulator as described in An Introduction to
Microcomputers:
icrocomputers: Volume 1.

long, unlike the typical
The Index Registers IX
(X and YI
Y) are only eight bits long,
typical microcomicrocom­
puter index registers described in An Introduction
Introduction to Microcomputers:
icrocomputers: Volume 1. They
puter
are more like classical computer
computer index registers that are used to hold indexes,
indexes. short
offsets. or counters.
offsets,

3-3
3-

deThe 6502
6502 has a Stack implemented
plemented in memory and indexed by the Stack Pointer
Pointer as de­
scribed in Volume
1. The only difference
Volume 1.
difference from that
that description
description is that the 6502
6502 Stack
wide, which
which means that maximum
maximum Stack length is 256
Pointer is only eight bits wide,
CPU always inserts 0 1
115
address, which
bytes. The CPU
1 6 as the high-order
high-order byte of any Stack address,
which
means that memory locations O lO
Oig through 01FF16
O1FF-|0 are permanently
permanently assigned
010015

to the Stack:
01

x,.x
___

____

!_4
__ )
*

—

l

SPI ------ XX-----------------I s p

f —

ti

011 XX is the Stack address

significant about the shorter 6502
6502 Stack Pointer if you are
There is nothing very significant
using this CPU as a stand-alone product. A 256-byte
256-byte Stack is usually
usually sufficient
sufficient for
any typical
typical m icrocom
puter application:
application; and its location
location in early memory
memory simply
simply means
icrocomputer
implemented as read/write
read/write memory. 6502
that low memory addresses must be implemented
literature
,by the letter S;
S: we use the letters SP
SP to prevent
literature represents the Stack Pointer
Pointer .by
prevent
confusion
confusion with
ith the Sign status.
The 6502
6502 Program Counter
Counter is a typical
typical program counter
counter as described in Volume 1.
The Carry status flag holds carries out of the most significant
significant bit in any arithmetic
etic
operation. The Carry flag is also included
included in Shift
Shift and Rotate instructions.
instructions. The only
Is that it has an inverted
unusual
unusual feature
feature of the 6502
6502 Carry flag is
inverted meaning in subtractjon
ion operations. After
After an SBC
instruction, the Carry is cleared if a borrow
borrow was required
SBC instruction,
SBC (Subtract
Carry) instrucand set if no borrow
borrow was required. Note also that
that the SBC
(Subtract with
ith Carry)
instruc­
tion results in (A)
(A) =
= (A)
(Al - (M)
(M) - (1
(1 - C)
C) where M is the other
other operand. This usage is
different
different from most microprocessors
microprocessors or other computers
computers of recent vintage
vintage and the user
should
Id take heed of it.
The Zero status flag is standard. It is set to 1 when
arithmetic
when any arithm
etic or logical operation
produces a zero result. It is set toOO when
arithmetic
when any arithm
etic or logical
logical operation
operation produces a
It.
non-zero result.
The Sign status flag is standard. It will
(Sign) bit of
ill acquire
acquire the value of the high-order
high-order (Sign)
any arithm
arithmetic
etic or logical
logical result. Thus, a Sign status value of 1 identifies
identifies a negative
negative result
O identifies
and a Sign value of 0
identifies a positive
positive result. The Sign status will
ill be set or reset on
the assumption
assumption that
that you are using signed binary arithmetic.
arithmetic. If you are not using signed
arithmetic, you can ignore the Sign status, or you can use it to identify
identify the value
binary arithmetic,
of the high-order
It.
high-order bit of the result.
The Decimal Mode status, when
when set, causes the Add-with-Carry
Add-with-Carry and SubtractSubtractwith-Carry
operations, Thus, when
with-Carry instructions to perform BCD operations.
when the Decimal
Decimal Mode
status is set and an Add-with-Carry
CPU
Add-with-Carry or Subtract-with-Carry
Subtract-with-Carry instruction
instruction is executed, CPU
-and
logic assumes that
that both source 8-bit
-b it values are valid BCD numbers
numbers —
and the result
generated will
BCD number. Because the 6502
CPU performs
ill also be a valid BCD
6502 CPU
performs decimal
decimal
add1t1onand subtraction,
addition
subtraction, there is no need for an intermediate
intermediate or Half-Carry
Half-Carry status. This
described in Volume
Volume 1.
problem with
ith the 6502
6502 approach
approach is that
that the same
status is described
1. One problem
instruction
instruction sequence will
ill produce
produce different
different results, depending
depending on whether
hether the Decimal
Mode status
status has been set or cleared. Thus, confusion
confusion and errors can occur
occur ,f
if the
Decimal Mode status has accidentally
value.
accidentally been given the wrong
wrong value.
inThe Break status pertains
pertains to software
software interrupts.
interrupts. When
When a software
are interrupt
interrupt (BRK in­

struction) is executed,
executed, 6502
6502 CPU logic will
ill set the Break status flag.
master interrupt
interrupt enable/disable
enable/disable or interrupt
interrupt mask flag. When I
I is a standard master
disabled; when
equals 1, interrupts are disabled:
when I equals 0, interrupts are enabled.

3-4

The Overflow
overflow,, except
verflow status is a typical overflow
except that
that it can be used as a control
input on the 6502
6502 microprocessor.
Recall that,
that. during
during signed binary
binary arithmetic.
arithmetic, OverOver­
microprocessor. Recall
magnitude too great to be represented in the given word
flow status flags a result of magnitude
size. The Overflow
size.
Overflow status has been discussed in detail
detail in Volume
Volume 1 of An Introduction
Introduction to
M icrocom
puters; it equals the exclusive-OR of carries out of bits 6 and 7 during
during
icrocomputers;
arithmetic
Overarithm
etic operations. The 6502 microprocessor
microprocessor allows external
external logic to set the Over­
flow status,
status. in which
which case it can be used subsequently
subsequently as a general logic indicator;
indicator; you
must be very careful when
when using the Overflow
Overflow status in this way.
way, since the same status
arithmetic
you. as a programmer.
flag will
ill be modified
modified by arithm
etic instructions.
instructions. It is up to you,
programmer, to
make sure that an instruction
instruction which
which modifies the Overflow
Overflow status is not executed in
between the time external
external logic sets this status and subsequent
subsequent program logic tests it.
literature refers to the Sign bit as a negative bit. given the
DIFFERENCES
DIFFERENCES
6502 literature
symbol N,
N. Statuses (except for Carry)
Carry) are nevertheless set and
IN NOTATION
reset as described for our hypothetical
hypothetical m icrocom
puter in An InIn­
icrocomputer
troduction
icrocomputers:
troduction to M icrocom
puters; Volume
Volume 1. Henceforth.
Henceforth, we will
ill use the standard symsym­
bols S for Sign bit,
remember these
bit. as well as SP
SP for the Stack Pointer; you should remember
minor differences
cards.
differences when using the 6502 literature
literature and instruction
instruction set summary cards.

6 502
0 2 M EMORY
R Y ADDRESSING MODES
The 6502 offers eleven basic addressing methods:
1)
1)

Memory- — immediate
Memory
mediate

2)

Memory -— absolute or direct.
direct, non-zero-page
Memory
Memory
Memory -— zero page (direct)

3)
4)

Implied or inherent
inherent

5)

Accumulator
Accum
ulator

6)

Pre-indexed indirect
indirect
Post-indexed
Post-indexed indirect
indirect
page. indexed (also called base page,
page. indexed)
8) Zero page,
9) Absolute
Absolute indexed
10) Relative
10)
11) Indirect
Indirect
7)

There are tremendous
tremendous variations
variations in terms of which
hich methods
methods are allowed
allowed with
ith which
which inin­
structions. See Table 3-4 for the addressing options available
available with
ith each instruction.
instruction.
structions.

3-5
3-

M emory -— Im mediate
In this form of addressing.
addressing, one of the operands is present in the byte immediately
immediately
following
follow
ing the first
first byte of object
object code. An immediate
mediate operand is specified
specified by prefacing
# symbol. For example,
example.
the operand with
ith the #
AND

# $08
08

requests the Assembler
Assembler to generate the instruction
instruction that
that will
ill logically
logically AND the value
0815
08-|6 with
ith the contents
contents of the Accumulator.
Accumulator.
Data

SVBDIZC

PIXI I I I IXI i

A

xx \ 08

xx

X
Program

y

SP
PC

Memory
mm

mm

t--:i;;;:--i
t-----1

AND

::::

# $08
08

~~
76543210

76543210

1stBvtejojoj
1 oj, jojoj, f
1st Byte

2nd

--.,,----

These bits
select the AND
operation

select
These bits select
immediate addressing
immed,ate
with one operand in
in A

3-6
3-

+ 1

mmmm + 2

Byte
!olololo!1lo!olol

M emory -— Direct
addressing uses the second -— or second and third (if not on zero,
This form of addressing
zero. or base,
base.
page) -— bytes of the instruction
instruction to identify
identify the address of an operand in memory. The
zero page version
specified when
version is specified
when the expression
expression used as the operand
operand in the instrucinstruc­
tion reduces to a value
0015g and FF15
value between
between 00-]
FF-|g. For example.
example,
AND

$30

requests the Assembler
Assembler to generate
generate an AND instruction
instruction which
hich will
ill logically
logically AND the
memory location
location 003015
OO3O-]0 with
ith the contents
contents of the Accumulator.
Accumulator.
value in memory
Data
Data

s V

B D

I

Memory

z C

Pjxj I I I Ixj I
yy

A

0030

xx

X
y

Program
Memory

SP
mm

PC

25
30

mmmm
mmmm + 1
mmmm + 2

The non-zero-page
non-zero-page (absolute) version is similar
similar except
except that
that the address of the operand
occupies
occupies twoo bytes. For example.
example,

AND

$31
$31F6

requests the Assembler
Assembler to generate
generate an AND instruction
instruction that
that will
ill logically
logically AND the
value in memory
memory location
location 31F615
31F6-]g with
ith the contents
contents of the Accumulator.
Accumulator.
Data

s V B D I z C

p

Memory

!xi I I I jx I I
yy

A

xx

X
y

Program
Memory

SP

PC

31 F6

mm

2D

mmmm

F6

mmmm

31

+ 1
mmmm + 2
mmmm + 3

You should
STORING
should note that
that 16-bit
16-bit addresses are stored with
ith the eight
eight
STORING
least significant
significant bits first
first (at the lower
lower address) followed
followed by the
ADDRESSES
ADDRESSES
eight
eight most significant
significant bits (at the higher
higher address). This is the same
technique
technique that
that is used in the 8080,
8080, 8085.
8085, and Z80 microprocessors.
microprocessors, but
but the opposite
opposite of
that
that used in the 6800
6800 microprocessor.
microprocessor.
3 -7

Implied or Inherent Addressing
Addressing
This mode means that no addresses are required to execute the instruction.
instruction. Typical
Typical ex­
exCLC (Clear
(Clear Carry)
Carry) and TAX (Transfer Register A to
amples of inherent
inherent addressing are CLC
Register X)
X).

Accumulator
ulator Addressing
Addressing
This mode means that the instruction
instruction operates on the data in the Accumulator.
Accumulator. On the
Accumulator
6502 microprocessor.
microprocessor, the only Accum
ulator instructions
instructions are the shifts
shifts ASL (Arithm
etic
(Arithmetic
Shift
Left). LSR
LSR (Logical Shift
Right). ROL
ROL (Rotate
(Rotate Left through
Carry). and ROR
Shift Left),
Shift Right),
through Carry),
ROR (Rotate
(Rotate
Right through
Carry).
through Carry).

3-8
3-

Pre-lndexed Indirect Addressing
Pre-Indexed
Addressing
This mode means that
that the second byte of the instruction
instruction is added to the contents
contents of the·
X Index register
register to access a memory location
location in the first
first 256 bytes of memory, where
used. which
the indirect
indirect address will
ill be found. Wraparound
raparound addition
addition is used,
hich means that any
carry formed in address addition
example.
addition will
ill be discarded. For example,
AND

($20.X)
($20,X)

requests the Assembler
Assembler to generate the instruction
instruction which
which will
ill logically
logically AND the concon­
tents of the A ccum
ccumulator
ulator with
ith the contents
contents of the byte addressed by the zero-page
register.
memory location
location given by the sum of 2 016
1 6 and the contents
contents of the X Index register.
Note the use of parentheses in the address field to indicate
indicate indirection
indirection or "contents
"contents of'
of"
Data
Data

Memory

SVBOIZC

PlXi I I I iXi I

qq
pp

00rr+20
00rr+21

yy

ppqq

Program
Memory

21
20

mmmm
mmmm + 1
mmmm ◄ • 2

Remember that the carry from the address addition
addition is ignored.
ignored, i.e.,.. the address of the
first
first address byte is a number
number in mod 256. Note that the indirect
indirect address is stored with
ith
address); note also that an address occupies
its least significant
significant bits first
first (at the lower address);
two bytes of memory.
Only the X Index register can be used for pre-indexed
pre-indexed indirect
indirect addressing.

3-9
3-

Post-Indexed
Post-Indexed Indirect Addressing
This mode means that
that the second byte of the instruction
instruction contains
contains an address in the first
256 bytes of memory. That
That address and the next location
location contain
contain an address which
which is
added to the contents
address.
contents of the Y Index register
register to obtain the effective
effective address.
Note the differences
differences between
between this method
method and pre-indexed
pre-indexed indirect
indirect addressing:
1)
1)

2)
3)

In pre-indexed
indexing is performed
performed before the indirecindirecpre-indexed indirect
indirect addressing
addressing the indexing
tion.while
tion.w
hile in post-indexed
post-indexed indirect
indirect addressing
addressing the indirection
indirection is performed
performed before
the indexing.
indexing.
Pre-indexed
inPre-indexed indirect
indirect addressing
addressing uses the X Index register, while
hile post-indexed
post-indexed in­
direct
direct addressing
addressing uses the Y Index register.
Pre-indexed
adPre-indexed indirect
indirect addressing
addressing is useful
useful for choosing
choosing one of a set of indirect
indirect ad­
use. while
eledresses to use.
hile post-indexed
post-indexed indirect
indirect addressing
addressing is useful for accessing ele­
ments
ments in an array or table for which
hich the base address has been obtained
obtained indirectly.
indirectly.

An example
example of post-indexed
post-indexed indirect
indirect addressing
addressing is
AND

($20).Y
($20),Y

which
which requests the Assembler
Assembler to generate
generate the instruction
instruction which
hich will
ill logically
logically AND the
contents
Accumulator
contents of the Accum
ulator with
ith the contents
contents of the byte addressed by adding
adding the Y
002015.
Index register
register to the address at memory
memory location
location 0020-|
6- Note that here only the $20 is
inside the parentheses.
parentheses, since only that part of the address is used indirectly.
indirectly.
Data
Memory

S V B D I Z C

P!X(I I I IxI I

A

qq

0020
0021

VY

PPQQ+rr

xx

X
y
SP
PC

pp

Program
Memorv
mm

mm

31
20

mmmm
mmmm + 1
mmmm + 2

Here again the indirect
indirect address is stored with
ith its least significant
significant byte first (at the lower
address). Unlike
adaddress).
Unlike that in pre-indexed
pre-indexed indirection,
indirection, this address addition
addition is a full 16-bit
16-bit ad­
dition; however.
however, it
wraparound so any carry from bit 15 is ignored. Only the Y Index
11 is wraparound
dition:
register
register can be used with
ith post-indexed
post-indexed indirect
indirect addressing.

3-10
3-

Indexed Addressing
This form of addressing uses the second -— or second and third (if not on zero page)
page) -—
address. That base address is then added to
bytes of the instruction
instruction to specify
specify the base address.
address. X and Y are not inthe contents
contents of Index Register X or Y to get the effective
effective address.
in­
terchangeable
terchangeable since no instructions
instructions have both forms of simple indexing
indexing with
ith both X
LOX
and Y. In fact.
fact, the only instructions
instructions which
which allow zero-page indexing
indexing with
ith Y are LDX
(Load Index Register X) and STX (Store Index Register X).
X). You should consult
(Load
consult Table 3-4
to determine
determine which
hich addressing options
options are available with
ith each instruction.
instruction.
A typical
typical example of zero-page indexed addressing is
AND

$20.X

which requests the Assembler
Assembler to generate the instruction
instruction that will
ill logically
logically AND the
which
contents
Accumulator
contents of the Accum
ulator with
ith the contents
contents of the byte at the address given by the
sum of 2015
20-)g and the contents
contents of the X Index register. This is a two-byte
two-byte instruction
instruction
because the address is within
ith in the first 256 bytes of memory. Note that
that there is no twobyte form of AND $20.Y
$20.Y although
although there is a more general three-byte
three-byte form of this inin­
struction.
struction.
Data
Memory

SVBOIZC

pix!

I I I lxl I
,.,...,_---'--YY'---.1

A
X

xx
Program

y

Memory

SP
PC

0020+rr

mm

35
20

mmmm

rnmmm + 1
mmmm + 2

A typical
typical example of absolute
absolute indexed addressing is
AND

$31FE.Y
FE.Y

which
hich requests the Assembler
Assembler to generate the instruction
instruction that will
ill logically
logically AND the
contents
Accumulator
contents of the Accum
ulator with
ith the contents
contents of the byte at the address given by the
sum of 31FE-|6
FE15 and
3-byte instruction
instruction
ancl the contents
contents of the Y Index register. This is a 3-byte
since the base address is not within
ith in the first
first 256 bytes of memory.

3-11

Data
Data
Memory

s V B D I z C

PjX! I I I jxj I
VY

A

XK

X
y

rr

SP
PC

mm

31FE+rr

Program
Memory
mm

39
FE
31

mmmm
mmmm+ 1
mmmm + 2
mmmm + 3

Either Index Register X or Index Register Y could be used here. However,
instruc­
However. some instrucASL. DEC.
DEC. INC,
INC. LSR,
LSR. ROL,
ROL. and ROR)
ROR) only allow Index Register X in this
tions (such as ASL,
,s also the case (more logically)
LOY (Load
(Load Index
mode. This is
logically) with
ith the instructions
instructions LDY
Y) and STY (Store Index Register Y).
Y).
Register Y)

3-12
3-

Indirect Addressing
Indirect
Indirect addressing
addressing only applies
applies to the JMP (Jump to New Location) instruction.
instruction. In this
mode. the second and third
mode,
third bytes of the instruction
instruction contain
contain the address at which
which the
effective address is located. Note that
effective
that the indirect
indirect address can have any value and can
be located anywhere
anywhere in memory. Obviously,
Obviously, this mode can be regarded as a special
case of either
either post-indexed
post-indexed indirect
indirect addressing
addressing or pre-indexed
pre-indexed indirect
indirect addressing in
which
zero. A typical
is:
which the Index register
register contains
contains zero.
typical example
example is:
JMP

($31FE)
($31
FE)

which
which requests the Assembler
Assembler to generate
generate a JMP instruction
instruction that will
ill load the Program
Counter from the memory
memory locations
locations addressed by the contents
contents of memory locations
Counter
31
q and 31 FFi
6- Remember that
that absolute
absolute addresses are 16 bits long and occupy
occupy
31 FE
FE15
FF15.
two memory
memory bytes;
bytes: however, the data located at an address is eight
eight bits long. This concon­
applies to all 8-bit
-b it processors, but is a particular
particular problem
problem with
ith the 6502 because
fusion applies
modes. Indirect
deof its numerous
numerous indirect
indirect and indexed addressing
addressing modes.
Indirect addressing is de­
scribed more fully
6.
fully in Volume
Volume 1 of An Introduction
Introduction to Microcomputers,
Microcomputers. Chapter
Chapter 6.
Remember that
that all addresses are stored with
ith their
their least significant
significant byte first
first (at the
lower address).
address).
Data
Data
Memory
Memory

D iI z c
C
s vV 8b d

PJ

IIIIIII

qq
pp

31 FE
31 FF

A

X
Program

y

SP
PC

Memory
mm

mm

6C
FE
31

mmmm
mmmm + i1
mmmm ·t+2

The final
final value of the Program Counter
Counter is ppqq.

FF). Although
Never let an indirect
indirect address cross a page boundary,
boundary, as in JMP ($31FF).
Although the
high-order
high-order byte of the indirect
indirect address is in the first
first location
location of the next page (in this
example, memory
0015),
CPU will
memory location
location 3 2 0
0ig), the CPU
ill fetch the high-order
high-order byte from the
first
0015
first location
location of the same page (location 3 1 0
0 1 g in our example).

3-133
3-

Relative Addressing
Addressing
Branch-on-Condition
Branch-on-Condition instructions
instructions use program relative addressing:
addressing; a single byte dis­
displacement
placement is treated as a signed binary
binary number
number which
hich is added to the Program Counter,
Counter.
after the Program Counter
incremented to address the next se­
Counter contents
contents have been incremented
sequential
quential instruction.
instruction. This allows displacements
displacements in the range +1291
129-|o to - 1 2
6 iq bytes.
26,o
bytes.
A typical
typical example is

BCC
BCC

*+5
'+

which
Assembler to generate a BCC
BCC (Branch on Carry Clear;
Clear: i.e.,.. branch if
hich requests the Assembler
Carry== 0) instruction
instruction that
that will
ill load the Program Counter with
ith its current
current value plus five
if the Carry is, in fact,
fact. zero.
zero. If the Carry is one,
one. the instruction
instruction does nothing.
nothing. Note that
the instruction
instruction itself occupies
occupies two bytes of memory and the offset is measured from the
end of the instruction.
instruction. Thus the offset should be 3 to generate a branch to the location
five beyond the one in which
hich the first
first byte of the instruction
instruction is located. Note that the
symbol** is used for the current
(actually. the Assembler's
symbol
current value of the Program Counter
Counter (actually,
Location Counter
2).
Counter as described in Chapter
Chapter 2).
The execution
execution of the BCC
BCC *+
•+55 instruction
instruction may be described
described as shown below. Note that
the entire
entire instruction
instruction is fetched
fetched from memory before the destination
destination address is calcucalcu­
lated. Note also that
that there are no other
other addressing modes available with
ith Branch-onCondition
Condition instructions.
instructions.
Data
S V B D

p

A

I

Z C

Memory

IIIIIIII

---◄

___ __,

xt-----t

y

SPl-----+---V"'

PC __ m_m
___

Program
Memory
m_m
_ _..,.,
90
1---03--t

mmmm
mmmm + l
mmmm + 2

3 -14
4

6502 INSTRUCTION
INSTRUCTION SET
6502
programming.
Instructions often frighten microcomputer users who are new to programming.
Taken in isolation, the operations involved in the execution
single instruction
execution of a single
are usually easy to follow.. The purpose
purpose of this chapter is to isolate and explain
those operations.
operations.
icrocomputer
Why
hy are the instructions
instructions of a m icrocom
puter referred to as an instruction
instruction "set"?
"set"?
icrocomputer
Because the m icrocom
puter designer
designer selects (or at least should
should select) the instructions
instructions
with
ith great care; it must
must be easy to execute
execute complex
complex operations
operations as a sequence
sequence of simple
events, each of which
which is represented
represented by one instruction
instruction from a well-designed
well-designed instrucinstruc­
tion "set".
"set".

Remaining consistent
consistent with
ith An Introduction to Microcomputers:
icrocomputers: Volume 2, Table
3-4 summarizes the 6602
6502 microcomputer instruction set,
set. with
ith similar instructions
grouped together.
grouped
together. Individual instructions are listed numerically by object
object code in
Table 3-6
3-5 and in alphabetical
alphabetical order by instruction mnemonic in Table 3-6. Table 3-6
also compares
compares the 6800
6800 instruction
instruction set with
ith that
that of the 6502. We will
ill discuss the 6800
set.
and 6502
6502 much
much later in this chapter.
chapter, after detailing
detailing the 6502
6502 instruction
instruction set.
does. the individual
In addition
addition to simply
simply stating
stating what
hat each instruction
instruction does,
individual instruction
instruction
descriptions
descriptions discuss the purpose of the instruction
instruction within
ith in normal programming
programming logic.

ABBREVIATIONS
ABBREVIATIONS
These are the abbreviations
abbreviations used in this chapter:
The registers:
A
X
yY
PC
PC
SP
SP
p
P

Accum
ulator
Accumulator
Index Register X
Index Register Y
Counter
Program Counter
Stack Pointer
Status register.
register, with
ith bits assigned as follows:
follows:
Status
7

6 5 4 3

! vj
S!

2

1 00 ^
...-0;1

Bit Numb••
Number

!

! B ! DI I! Z C .,.._Status

t

~-------Reserved

■Reserved for expans,on
expansion

(unused
(unused at this
this time)
time)

Statuses:

ss
V
B
D
I

z
Z
C
c

,eg,s1e, (Pl

Sign or Negative
Negative status
Overflow status
Overflow
Break status
Decimal
Decimal Mode status
Interrupt Disable status
Interrupt
Zero status
status
Carry status

3-15
315

Symbols in the column
column labeled STATUS:
(blank)
(blank)
X
0
1
6
7
addr
[addr+
1.addrl
[addr+1,addr]

6

addr166
addrl
data
disp
label
PC(HI)
PC(HI)
PC(LO)
PC(LO)
pp
PP
qq
qq
[[]]

[[
[[ ]]]

+

A
V

-¥V-

Operation
Operation does not affect
affect status
Operation
Operation affects
affects status
Operation clears status
Operation
Operation sets status
Operation
Operation
Operation reflects bit 6 of memory location
Operation
Operation reflects bit 7 of memory location
base address
8 bits of absolute
absolute or base
The address constructed
constructed from the contents
contents of memory locations
addr and a ddr+
add r+ 11. This address is used in post-indexed
post-indexed indirect
indirect ad­
dressing.
16 bits of absolute
absolute or base address
8 bits of immediate
mediate data
An 8-bit.
8-bit. signed address displacement
displacement
16-bit
address. destination
16-bit absolute
absolute address,
destination of Jumpp or Jump-top-toSubroutine
Subroutine
The high-order
high-order 8 bits of the Program Counter
The low-order
low-order 8 bits of the Program Counter
The second byte of a two- or three-byte
three-byte instruction
instruction object code
The third byte of a three-byte
three-byte object
object code
Contents
Contents of the memory location designated
designated inside the brackets.
For example.
contents of memory location
example, [FFFE]
[FFFE] represents the contents
FFFE15; [addrl
adFFFE-|6:
(addrl 6+X]] represents the contents
contents of the location ad­
ddr16;
[SP] repre­
repredressed by adding
adding the contents
contents of register X to a ddrl
6: [SP]
sents the value at the top of the Stack (contents
(contents of the memory
location
Pointer).
location addressed by the Stack Pointer).
Indirect
addressed
Indirect addressing: the contents
contents of the memory byte addressed
inby the contents
contents of the memory location designated
designated within
ith in the in­
[[addr+Xll]] represents the contents
ner brackets. For example.
example, [[addr+X
contents of a
memory location
location addressed via pre-indexed
pre-indexed indirect
indirect addressing.
deAddition
ddition -— either
either unsigned binary addition
addition or BCD addition.
addition, de­
pending
pending on the condition
condition of the Decimal Mode status.
Binary or BCD
BCD subtraction.
subtraction, performed by adding
adding the twos complecomple­
ment of the subtrahend
subtrahend to the minuend.
bar:
The ones complement
complement of the quantity
quantity denoted beneath the bar;
for example. A
complement
A_represents the complem
ent of the contents
contents of the
C represents the complem
complement
Accumulator;
Accum
ulator; C
ent of the value of the
Carry status.
Logical AND
Logical OR
OR
Logical
Exclusive-OR
Logical Exclusive-OR
Data is transferred in the direction
direction of the arrow.

3-166
3-

INSTRUCTION M N E M
O N IC S
MONICS
Table 3-4 summarizes the 6502
6502 instruction set. The INSTRUCTION
INSTRUCTION column shows
(LOA, STA, CLC)
CLC) and the operands, if any, used with
the instruction mnemonic (LDA,
ith the
mnemonic.
instruction mnemonic.
language instruction is shown in UPPER
UPPER CASE. The
The fixed part of an assembly language
er case.
variable part (immediate data, address, or label)
label) is shown in lower
case.
If a mnemonic
mnemonic has more than one type of operand.
operand, each type is listed separately withith ­
out repeating
repeating the mnemonic.
mnemonic. For instance.
instance, some examples
examples of the format
at entry
STX

addr
addr.Y
addr166
addrl
are:

STX $75
STX $60,Y
STX $4276
$4276

CODES
INSTRUCTION OBJECT CODES
ithout
For instruction bytes w ith
o u t variations, object codes are represented
represented as two
o
hexadecimal
SA). For instruction bytes with
hexadecimal digits (e.g.,.. 8A).
ith variations.
variations, the object
code is shown as eight binary digits (e.g., 101aaa01).
101aaa01).
The object
object code and instruction length in bytes is shown in Table 3-4 for each inin­
struction variation. Table 3-5 lists the object codes in numerical order, and Table
3-6 shows the corresponding
corresponding object codes for the mnemonics, listed in alphabetialphabeti­
cal order.
order.

INSTRUCTION EXECUTION TIMES
periods. Actual
Table 3-4
3-4 lists the instruction execution
execution times in numbers of clock periods.
Actual
execution timee can be derived by dividing
dividing the given number
execution
number of clock periods by the
clock speed. For example.
periods. a 2 MHz clock
example, for an instruction
instruction that
that requires 5 clock periods,
will
ill result
result in a 2.5 microsecond
microsecond execution
execution time.

STATUS
(P) as follows:
The status
status flags are stored in the Status register
register (P)
follows:

ECU1

7 6
5 4
65432

3

2

1 0 .

-CCarry
arry status
status (carry out of bit
bit 7)

~---Zero
.,_ ____

(1 for
-Z e ro status
status (1
for zero, 0 for
for nonzero)
nonzero)

Interrupt disable
-Interrupt
disable status
status
(1 means interrupts
(1
interrupts are disabled)
disabled)

.,_ _____
.._ ______

Decimal
(1 for decimal
-D ecim
al Mode
Mode status
status (1
decimal mode)

(1 means
means a
a Break
Break instruction
-BBreak
reak status
status (1
instruction
has been executed)
executed)

L--------This

'----------Overflow
.,_ _________

-T h is bit is not used
-O v erflo w status

Sign status
(value o
of bit
7)
-S ig
status (value
bit 7)

33-17

descriptions, the effect
In the individual instruction descriptions,
ffect of instruction execution on
status is illustrated as follows:
s:
SVDIZC
V D

I

Z C

Modified
Modified to reflect
reflect results of execution
execution
-------._ _____

'-------Bit
'--------Bit

Unchanged

Unconditionally
Unconditionally reset to 0
Unconditionally
set to
to 11
Unconditionally set
Bit 6 of tested byte
Bit 7 of tested byte

identifies a status that
that is set or reset.
identifies a
An X identifies
reset. AO0 identifies
status that is always cleared. A 1 identifies
identifies a status that is
always set.
set. A blank means the status does not change. The
that the flag contains
contains the value of
numbers 7 and 6 show that
bit 7 or bit 6 of the byte tested by the instruction.
instruction.

3 -18
8

STATUS CHANGES
WITH
WITH INSTRUCTION
EXECUTION

Table
Instruction Set
6502 Instruction
the 6502
of the
Summary of
3-4. A Summary
Table 3-4.
Instruction

C
Load Accumulator from memory.
A-laddr]

Absolute indexed

a -a

Ol O
) 'D
to 0)

a

X

X-[addr1

to

X

i l l

"O "O "O "O

X

X

T3 T3 T3 TJ
to CO co to

T

ro x

X

6+ YI

Absolute indexed
w 05
Q) (0

" a
w _
™ P

Store Index Register X to memory. Index through Register Y only.
Zero page direct
[addr]-X
Zero page indexed
[addr+Y]-X
Extended direct
[addr16]-X
_ c
P ®

2 O) OS T5
05 tO tO CD
a> Q. a -o

Load Index Register Y from memory. Index through Register X only.
Zero page direct
Y-[addr]
Zero page indexed
Y-[addr+XI
Extended direct
Y-[addr16]
Absolute indexed
Y-[addr16+XJ

= „ + 2 2
5 t5 ■& "O T>

X

■n T3 TJ T ) T5
^ co co co co

X

X
X
X
X

05 TJ
CO ®
a. t >

n

X

X
X
X
X

^s T> T> T1
> >

X

a a cr o'
Q a Q Q

T3 TJ T3 T3
TJ T5 T! T3

=

Pre-indexed indirect
Post-indexed direct
Extended direct

Load Index Register X from memory. Index through Register Y only.
Zer~ page direct
X-[addr]
Zero page indexed
X-[addr+YJ
Extended direct
X-[addr16]

register: x == 0 for
Index register:
the Index
designates the
"x" designates
code. "x"
object code,
the object
crossed. Inn the
boundary iss crossed.
page boundary
period ifif page
clock period
one clock
Add one
• Add
Register
Register X.
for Register
Y, x = 1 for
Register Y,

Zero page direct
Zero page indexed

—

X

X
X
X
X

<

TJ T3

X

X
X
X
X

*X. 2^ .£
3
■8 ■§ s
•E •§ 3

iV

= 1 ZZ

[addr+X]-A
[[addr+X]]-A
[[addr+ 1,addr]+ Y]-A
[addr16]-A
or [addr16+YJ-A
[addr16+X]-A

Extended direct
Absolute indexed

N N Q. Q.

O J°

Store Accumulator to memory.
[addr]-A

3
4
6
6
4
5

Zero page direct
Zero page indexed
Pre-indexed indirect
Post•indexed indirect
J, c o
w ® CO
o >< -9

CO CD

X
,—, +

A-[addr+X]
A-l(addr+Xll
1,addr]+Y]
A-lladdr+
A-[addr16]
or A-[addr16+Y]
A-[addr16+X]

CL UJ <

i 1 1 1 1 I

< < < < < <

X

3
4
4
4

2
2
3
3

X
X
X
X
X
X

X

A4 pp
B4 pp
AC ppqq
BC ppqq

X

LOY
addr
addr,X
addr16
addr16.X

X

3
4
4

X

2
2
3

X

86 pp
96 pp
BE ppqq

X
X
X
X
X
X

X

STX
addr
addr,Y
addr16

z

X

g

I

LO

..

"O
C

'I

~

2
2
3
3

0

X

3
4
4
4·

CM CM CO CO

~

81 PP
91 pp
80 ppqq
10011x01 ppqq

V

X

CO «* CO CD

B6 PP
AE ppqq
BE ppqq

CM CM CO CO

..
"..
.5
E

2
2
2
2
3
3

4
4•

Operation Performed

s

X

{*) » t ID If l

CM CM CM CM CO CO

Q a. a a
Q a. Q Q

),,

l5

85 pp
95 pp

B5 pp
A1 pp
B1 pp
AD ppqq
11011x01 ppqq

3
4
6
5•

Status

X

CM CM CM CM CO CO

q
a a a cr
a. a a a q ;

(0

2
2
2
2
3
3

A5 pp
a. a

3 -19

Cf

STA
addr
addr,X
laddr,X)
(addr).Y
addr16
addr16,X or Y

Q -Q .Q -Q .C T
Q q Q- '

AB pp

CO CO CO

~

•

IC

Clock
Periods

CO

a o u eje jea Ajotueyy Ajeiuud pue o /l

"..
C

Bytes

LOX
addr
addr,Y
addr16
addr16,Y

addr16
addr16,X or Y

..

Code

T3 "O "O "O
T3 T3 T> -O

LOA
addr
addr,X
(addr,X)
(addr),Y

Object

o ■=
O ®

lype

Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction Set
Table
(Continued)
Set (Continued)
Type

Operation Performed

s

V

D

I

z

C
Store Index Register Y to memory. Index through Register X only.

1a5> <
E
d T3

UJ

a. -o

N

05 05 "O
(0 CO ©

a

Zero page direct
Zero page indexed
Extended direct

o o i
x

4
4·

, a> a)

3
4
6
5-

[addr]-Y
laddr+XJ-Y
[addr16]-Y

1N

3
4
4

>

2
2
3

>

84 PP
94 PP
SC ppqq

05

t g

..

Status

Clock
Periods

“
II
5 I X to
? i t .
2 'O 'O -o

"::i; ·E

STY
addr
addr.X
addr16

Bytes

— T3 -O "0

(penuiiuoQ) e o u sje jey
~

Code

CM CM CM CM CO CO

Ajoiueyy Ajeuiud pue o /l

0 '=ti

Object

co r-- co

..

>

E

Instruction

(J

E -

~

-~

A.

C

...,"
~

C

.. .f

0" IC

:::,

ADC

X

X

X

X

X

X
X

A-A+(addr16+X)+C

4-

9

n

X

XI £ |
; 5 1

<

.£ -o J

< <

X

or A-A,\(addr16+Y]

a>

X

addr]+YI

a . Q. u j <

< <

X

BIT

A-AA(addr16+XJ

Zero page direct
Zero page indexed
Pre-indexed indirect
Post-indexed indirect
Extended direct
a.

X

X

A-A,\(addr(

A-AAladdr+XI
A-AA!laddr+X]I
A-AAl!addr+1,
A-AA(addr16]

a

X

X

X
X
X
X
X

■Sa) S
T « S 8
® c o >< -9

<

X
X
X
X

• N

X

X

c <<<<<<
O < < < < < <
“ 1 1 1 1 1 1

X

X

4
4·

X

X

Absolute indexed

ANO contents of Accumulator with those of memory location. Only the status
o a> ro ra

C

0

"".,

3
4
6
5•

X

>

i...,

2
2
2
2
3
3

CO ■<* CD 10 ■<*

addr 1 6,X or Y

>

5

..

a. cr
a o. '

::i;

IC

CO -12

E

addr,X
laddr,XI
(addr),Y
addr16

ANO contents of Accumulator with those of memory location.

25 PP
35 pp
21 pp
31 pp
2D ppqq
00111 x01 ppqq

CM CM CM CM CO CO

addr

a a
o. a

-;

AND
X

C

a
a.

""

Extended direct
Absolute indexed

(Zero flag is not valid in Decimal Model.

!"
i"

or A-A+(addr16+Y]+C

Zero page direct

Zero page indexed
Pre-indexed indirect
Post-indexed indirect

Qu Q.

X

X

X

X
X

X
X
X
X

A-A+(addr]+C
A-A+(addr+Xl+C
A-A+lladdr+X]]+C
A-A+[laddr+1,
addr]+Y]+C
A-A+laddr16]+C

N

X

X

X

X

X
X

X
X

X
X
X

N

X

X

X

X
X
X

X

< < < < <
111 11 f a
< < < < < <

X

X

X

X

X

X

X
X

X

cr

X
X

X

Q. Q. Q.

2
2
2
3
3

X

2

X

Q.

O'

addr1 6,X or Y

Q. Q. Q. Q. '
a c

>

5
E

ifl <- >-

I!

65 pp
75 pp
61 pp
71 pp
6D ppqq
0111 lxOl ppqq
Q.

..

a.
0

addr,X
(addr,X)
laddr).Y
addr16

Add contents of memory location, with carry, to those of Accumulator.

in

0

(e;eJ9do A-iouieyy) e o u e je je y Ajoweyy Ajepuooes

3-20

w

N

!

CD (0 -is •

addr

bits are affected.
addr

addr16

24 pp
2C ppqq

2
3

3
4

7
7

6
6

X
X

AA[addr]
AA[addr16]

• Add
Add one
one clock
clock period
period ifif page
page boundary
boundary iss crossed.
crossed. Inn the
the object
object code,
code, "x"
"x" designates
designates the
the Index
Index register:
register: x = 0 for
Register
Register Y,
Y, x = 1 for
for Register
Register X.

Zero page direct
Extended direct

Set (Continued)
Instruction Set
6502 Instruction
the 6502
of the
Table
Summary of
3-4. A Summary
Table 3-4.
Instruction

Object

Code

Bytes

* -o
OI
O ®

Type

Clock
Periods

Status

Operation Performed

s

V

D

I

z

C
Compare contents of Accumulator with those of memory location. Only the

CMP

CL CL i

■O .E •
©) Q
))
O
CT

Exclusive-OR contents of Accumulator with those of memory location.
Zero page direct
A-A-V-{addr]
Zero page indexed
A-A-V-laddr+X]
Pre-indexed indirect
A-A-V-{[addr+X]]
Post-indexed indirect
Extended direct

addrl+Y]
A-A-V-l[addr+1,
A-A-V-{addr1 61
or A-A-V-{addr16+Y]
A-A-V-{addr16+X]

Absolute indexed

X

C
0

..
"

U)

register: x = 0 for
*• Add
Index register:
the Index
designates the
"x" designates
code. "x"
object code,
the object
crossed. Inn the
boundary iss crossed.
page boundary
period ifif page
clock period
one clock
Add one
Register Y, x = 1 for Register X.

N

X

X

A-AVlladdr+X]]
addrl+Y]
A-AV[laddr+1,
6]
A-AV[addrl
or A-AV(addr16+Y]
A-AV[addr16+X]

>• N

O

E

OR contents of Accumulator with those of memory location.
Zero page direct
A-AV(addr]
Zero page indexed
A-AV(addr+ X]

> > > > > >
< < < < < <
i I 1 I 1 1
< < < < < <

X

X
X
X
X
X
X

X

4
4•

X
X
X
X
X
X

X

3
4
6
5·

X

a
a
a . q. ;

2
2
2
2
3
3

X

a
a a

q

,.

:;;

"Cl

•~-S (Dro

~

E

,;"

q

",.

IC

a

:?.

X

C

Absolute indexed

N

X

"!

2
2
3
3

Post-indexed indirect
Extended direct

N

X

..

X

..
!
E

2

X
X
X
X
X
X

Q . CL

X

X

~

2

N

X

X

N

CD CD

3-21

Cf

a a a a c
a
a a. o. a ;

EOR
addr
addr,X
(addr,X)

!
l!
"a.
0

N

X

X

!:!

Zero page direct
Zero page indexed
Pre-indexed indirect

A-[addr+X]
A-lladdr+Xll
A-((addr+1, addr]+YI
A-(addr16]
or A-[addr16+Y]
A-[addr16+Xl

<
I
<

X

X

N

X
X
X
X
X
X

< < < < < <
: I 1 I i 1 i
< < < < < <

X

X

X

N

2
2
2

jo
“ JS J5,
T T T i i i
< < < < < <

X

X

X

X

X

X

X

X

X

05 PP
15 pp
01 pp
11 pp
OD ppqq
00011x01 ppqq

[addrl.Y
addr16
addr16,X or Y

X

X

X

X

X

ORA
addr
addr,X
(addr,X)
(addr),Y
addr16
addr1 6,X or Y

to ^ to in

X

X

X

51 PP
4D ppqq
01011x01 ppqq

3
4
6
5·

CM CM CM CM CO CO

X

co in

(addrl.Y
addr16
addr16,X or Y

CM CM CM CM CO CO

X

co

CO CO

X

N

4
4·

X
X
X
X
X
X

N

C
0

3
3

a a a a. c
a a a o. a *
in in r- r-

(penuj^uoQ) (e ie je d o Ajoiueyv) e o u e je je y Ajoiuey\| Ajepuooes

"::s
.g

6
5•

2

45 pp
55 pp
41 pp

[addr,X)

'ii

C5 pp
D5 pp
C1 pp
D1 pp
CD ppqq
11011x01 ppqq

X
X
X
X
X
X

X
X
X
X
X
X

3
4

4
4•

addr
addr,X

status bits are affected.
A-(addr]

Pre-indexed indirect
Post-indexed indirect
Extended direct
Absolute indexed

Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Table
Instruction
Instruction

Object
Object Code

Bytes

Status

Clock
Clock

Operation P erformed
Operation

z

C

O

I

N

0

-

V

Q

s

>

Periods

</)

1
*

Type

Subtract contents
contents of
of memory
memory location,
location, with
with borrow,
borrow, from
from contents
contents of
Subtract
f Ac-

SBC

11111x01
xO 1 ppqq

5•

4
4·

X

X

X

X

X

X

X

X
X

Zero page
page indexed
Zero
Pre-indexed indirect
Pre-indexed

X

X
X
X

X

A —
—[[addr+X]]—C
- A-[[addr+XIJ-C
A — A -[[a d d
r+ 1 ,ad d r]+ Y ]-C
-A-[[addr+1,addr]+Y]-C

Post-indexed indirect
Post-indexed

A -— A -[ad
d r16 ]-C
-[addr16]-C

Extended direct
Extended

-[addr16+X]-C
A -— A -[a d d
r1 6 + X ]-C or
A -— A-[addrl
—[addrl 6+Y]-C
]-C

Absolute
Absolute indexed

X

0

g
]

(Note that
that Carry
Carry value
value is
is the
the complement
the borrow.)
(Note
complement of
of the

t!

•

F66 pp
PP
EEE ppqq
FEE ppqq

l:i

addrl
addr166

CEE ppqq

•

addrl
6.X
addr16,X

DEE ppqq

E

:E
t

..
..

X

[addr]*—[addr]+11
[addr]-[addr]+

X
X

X

[addr+X
]— [a d d r+ X ]+ 1
[addr+X]-[addr+Xl+1

Zero page
page indexed
Zero

X

[addrl 6 ]—
[addrl 6]+1
[addr16l-[addr16]+1

Extended direct
Extended

X

X

[addrl 6 + X
]— [addrl 6+X ]+1 1
[addr16+X]-[addr16+X]+

Absolute indexed
Absolute

2
2
3
3

X

[addr]—
[addr]—1
[addr]-[addr]-1

X

[addr+X
]— [a d d r + X ]-1
laddr+X)-[addr+X]-1

Zero page
page indexed
indexed
Zero

X

[addrl 6
]— [addrl 6 ]-1
[addr16]-[addr16]-1

Extended direct
Extended

X

[addrl 6 + X ]
— [addrl 6 + X ] —1
[addr16+X]-[addr16+X]-1

Absolute indexed
indexed
Absolute

5

6
6
7

X
X
X
X

Zero page
page direct
Zero

Compare
Compare contents
contents of
of X register
register with
with those
those of
of memory
memory location.
location. Only
Only the
the status

CPX

-a

X

flags
flags are
are affected.
X-[addr]
-[addr]

Zero
Zero page
page direct

X

X-[addr16]
-[a d d r1 6 ]

Extended direct
Extended

C

2
3

3
4

X
X

X
X

X X

E44 pp
ECC ppqq

X X

addr
addrl
addr166

co

u

en

CMCO

0

Zero page
Zero
page direct

X

Decrement
Decrement contents
contents of
of memory
memory location.
location. Index
Index through
through Register
Register X only,
only.

addr
addr
addr.X
addr,X

►

5
6
6
7

OEC
DEC
C6
6 pp
D6
6 pp

a:

2
2
3
3

X X X X

C

E66 pp
PP

X X X X

•
•
u
•
~

!

addr
addr.X
addr,X
addrl
addr166
addrl
6,X
addr16,X

m co co

E

Increment
Incrementcontents
contentsof
of memory
memory location.
location. Index
Indexthrough
throughRegister
RegisterX only,
only.

INC
INC
i n co co r -

N
N

t0

CMCMOOCO

3 -22

w

CM CM CO 00

•
0.

0

Zero page
page direct
Zero

A -— A-[addr+X]-C
—[addr+X ]—(T

X

addr16,X
or Y
addrl
6,X or

pp

X

X

E

Fl
FI

EDD ppqq
DPQQ

X

X

X

"
C

X

X

(addr),Y

addr166
addrl

(penui)uoQ) (e jB jedo Aj o iu o w ) e o u e je je u Ajoiueyv Ajepuooes

'a

6

X
X
X
X
X

X

El
1 pp
PP

3
4

X

(addr.X)

2
2
2
2
3
3

X X X X X X

F55 pp

co^tcoiftTtTt

E55 pp

addr.X
addr,X

(N CM CM CM CO 00

..

addr

cumultor.
A—
A —[addr] —(T
-A-[addr]-"C°

Compare
Compare contents
contents of
of Y register
register with
with those
those of
of memory
memory location.
location. Only
Only the
the status

CPY

X
X

X
X

X X

3
4

X X

2
3

co^f r

C4
4 pp

cc
C
C ppqq

(MOO

addr
addrl
addr166

X
X

flags
flags are
are affected.
Y-[addr]
-[addr]

Zero page
page direct
Zero

Y -[a d
d r1 6 ]
-[addr16]

Extended
Extended direct

• Add
Add one
one clock
clock period
period ifif page
page boundary
boundary iss crossed.
crossed. Inn the
the object
object code,
code, "x"
"x" designates
designates the
the Index
Index register:
register: x = 0 for
Register
for Register
Register X.
Register Y.
Y. x = 1 for

Set (Continued)
Instruction Set
6502 Instruction
the 6502
of the
Table
Summary of
3-4. A Summary
Table 3-4.
Type

Instruction

Object Code

Bytes

Clock
Periods

Status

Operation Performed

s

V

D

I

z

C
Rotate contents of memory location one bit left through Carry. Index through

AOL

Register X only.

[addr)
[addr+X)
{addr16)
iaddr16+X)

4H1

!

Cl

i0.

5

X
X
X
X

X
X
X

6
6
7

X

2
2
3
3

lo cd co r*

66 pp
76 pp
SE pp
7E ppqq

a a o. a

u

addr
addr,X
addr16
addr16,X

o. o. Q. O’

..
!
..
..
i
E

X
X
X
X

[addr)

X
X
X
X

[addr+X)
[addr16l
[addr16+X)

C

4iH1

►

~

:i;

X

co co'

"'

06 PP
16 pp
OE ppqq
1E ppqq

2
2
3
3

in cd to r**

0

only.

addr
addr,X
addr16
addr16,X

a a a a
a. a a a

C

u

0~

Arithmetic shift left contents of memory location. Index through Register X

ASL

U T3 T) T!
TJ T3 TJ -D

..
t..
..,
..

..
o

a:

A

'i

E

j:]

Register X only.

T3 -a -O T3
T5 -D "D T5

3-23

N

w

t0

0

Rotate contents of memory location one bit right, through Carry. Index through

ROA

0

w

4

□L

0

r*»

I

·S
C

2

<0 +

X
X
X
X

- X

X
X
X
X

w <°

X
X
X
X

t

5
6
6
7

’ ■2^5

~

addr16
addr16,X

2
2
3
3

>

(panujiuoo) (eiejedQ Ajouioj/vj) e o u e je je y Ajouiey\j Ajepuooes

..

'a

26 pp
36 PP
2E ppqq
3E ppqq

in co cd r»

"D
"O "O "O
■D -O TD T3

addr
addr,X

5
6
6
7

X
X
X
X

X
X
X
X

[addr)
[addr+XJ
[addr16)
[addr16+X)

X
X
X
X

~o

Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Table

j o y A jo u ia ^ i A j e p u o a e s

e

Object Code

Bytes

Clock
Periods

Status

Operation Performed

s

V

D

I

z

C

X
X

X
X
X
X

Logical shift right contents of memory location. Index through Register X only.

LSR

O -o + ^ <o

( l u o o ) ( e i s j e d o Ajo u i » w )

..,:';:!

Instruction

11

Type

C

0
0
0
0

X

X

[addr]
[addr+X]
[addr16]
[addr16,X]
<° * -

5
6
6
7

X

2
2
3
3

in co co

::E0.
•

46 pp
56 pp
4E ppqq
5E ppqq

S g

~~
E !

addr
addr,X
addr16
addr16,X

OJ CM CO CO

0

■D -D -O TJ

..
.,,
".
"'

1::0

►

•
C

~

0

0~

o E

.:!

2

CM

<M

LOY data

AO pp

CM

CM

Load Accumulator with immediate data.

X

A-data
Load Index Register X with immediate data.

x

X

2

3-24

X

x

(o)

;..,
_,,.

E

.5

2

X

X

X-data
Load Index Register Y with immediate data.
Y-data
(0

.
..

!

~

2

«J T5

CM

A2 pp

X

CO 'O

CM

LOX data

2

o

2

<re T< -re TX -re 7>•

A9 pp

x

LOA data

Set (Continued)
Instruction Set
Table
6502 Instruction
the 6502
of the
Summary of
Table 3-4. A Summary
Type

Instruction

Object

Code

Bytes

Clock
Periods

Status

Operation Performed

2

2

X

X

X

CMP data

C9 pp

2

2

CM

X

X

X

;...

EOR data

49 pp

2

2

CM

X

X

X

!

ORA data

09 pp

2

2

CM

X

.!!

X

E

SBC data

E9 pp

CM

X

<
E

X

i }
><

A-data
Exclusive-OR immediate with Accumulator.

0

CM

X

X

X

X

X-data
Compare immediate with lnde,c;Register Y. Only the status flags are affected.

X

2

2

X

Y-data

dum p

...
E
..,
:,

4C ppqq
6C ppqq

3
3

3
5

Jump to new location, using extended or indirect addressing.
PC-label or PC-[label]

IE a.^

JMP label
(label)

(A

co pp

X

A-A-data-C
(Note that Carry value is the complement of the borrow.I
Compare immediate with Index Register X. Only the status flags are affected.

>
—r o
«o
5 =
tf>
to 3
5 2

CM

CPY data

2

X

X

Ex

2

X

I

EO pp

X

CPX data

X

® I
E S

2

CM

N

u,

2

CM

3-25

w

E

A-A:.J.data
OR immediate with Accumulator.
data
A-AV
Subtract immediate, with borrow, from Accumulator.
c w
.h "O
I
£ <
£ i
3 <

.,,
..

X

A-AAdata
Compare immediate with Accumulator. Only the status flags are affected.
— i -j i
E
< o <

eiejedo eiBjpeuiuii
!

A-A+data+C
ANO immediate with Accumulator.
J.

29 pp

5 TJ c® ^T>

AND data

Add immediate with Carry, to Accumulator. The Zero flag is not valid in
Decimal Mode.

E

X

.i 1

2

CM

X

69 pp

CM

X

ADC data

CM

C

CM

z

CM

X

I

CM

2

0

CM

V

CM

s

Table
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Table 3-4. A Summary
Set (Continued)
I
Status

I

Operation Performed

D

I

z

o

V

-

s

>

Periods

1

Clock

J

Bytes

i

O bject C ode

i

lnItruction

■

Ty
pe
ype

C
Note
Note the
the following
following for
for all
all Branch-on-Condition instructions:
instructions:
IfIf the
the condition
condition iss satisfied, the
the displacement
displacement

iss added
added too the
the Program

Counter after the
the Program
Program Counter has
has been
been incremented to
to point to
to the
the in­
instruction
struction following
following the
the Branch
Branch instruction.
instruction.
BC
C disp
ecc

90 pp
90

2

2 ..

Branch relative
Branch
relative ifif Carry
Carry flag
flag iss cleared.

BC
S disp
ecs

B
O pp
80

2

2 ..

Branch
Branch relative
relative ifif Carry
Carry flag
flag iss set.

BEEQ
Q disp

F-0
0 pp

2

2··

Branch relative
Branch
relative ifif result
result is
is equal
equal too zero.

BMI
BMI disp

30
30 pp

2

2 ..

Branch
Branch relative
relative ifif result
result is
,s negative.

BNNE
E disp

DOO pp
PP

2

2 ..

Branch
Branch relative
relative ifif result
result iss not
not zero.

BPPL
L disp
disp

100 pp

2

2 ..

Branch relative
Branch
positive.
relative ifif result
result iss positive.

eve disp
BVC
disp

50
0 pp

2

2 ..

Branch relative
Branch
relat,ve ifif Overflow
Overflow flag
flag iss cleared.

BVS
disp
evs disp

70
0 pp

2

2 ..

Branch relative
relative ifif Overflow
Branch
Overflow flag
flag iss set.
set.

j

IfIf C=0,
PC+disp
C=0. then
then PC—
PC-PC+disp
IfIf C=l.
C=1, then
PC+disp
then P C—
C-PC+disp
IfIf Z 1 . then
PC+disp
=l.
then PC—
PC-PC+disp
IfIf S
=1, then
PC+disp
5=1.
then PC—
PC-PC+disp
UOjljpUOQ u o i p u e j g

w

N

C)

C

0

'ii
C

0

IfIf Z =0., then
PC+disp
then PC—
PC-PC+disp
IfIf S~0.
=0, then
PC+disp
then PC—
PC-PC+disp

0

C

0

.c

..
iii

=

IfIf V = 0,
PC+disp
0. then
then PC—
PC-PC
+disp

u

C

IfIf V~
=1 ,1, then
PC+disp
then PC—
PC-PC+d;sp

•· Add one clock period if branch occurs to location in same page; add two clock periods if branch to another page
occurs.

j

Set (Continued)
Instruction Set
6502 Instruction
the 6502
of the
Summary of
3-4. A Summary
Table 3-4.
Table
Instruction

Bytes

Clock
Periods

6

60

1

6

D

I

z

C
Jump to subroutine beginning at address given in bytes 2 and 3 of the instruction. Note that the stored Program Counter points to the last byte of the JSR instruction.
[SP]-PCIHII
[SP-11-PCILOI
SP-SP-2
PC-label
Return from subroutine, incrementing Program Counter to point to the instruction after the JSR which called the routine
PC(LOI-ISP+ 1]
PC(Hl)-[SP+2]

2 ° .2 ±1 I "1 1

3

Operation Performed

V

z
d

20 ppqq

Status

s

a
E

JSR label

Object Code

£
o

&
>
H

Type

0

ATS

~

.0

~

1

2

X

X

TXA

BA

1

2

X

X

TAY

AB

1

2

X

X

TVA

98

1

2

X

X

TSX

BA

1

2

X

X

TXS

9A

1

2

>
0

.•

:IE

!

at

'l:
~

at
a:

•

Move Accumulator contents to Index Register X.
X-A
Move contents of Index Register X to Accumulator.
A-X
Move Accumulator contents to Index Register Y.
Y-A
Move contents of Index Register Y to Accumulator.
A-Y
Move contents of Stack Pointer to Index Register X.
X-SP
Move contents of Index Register X to Stack Pointer.
SP-X

in

AA

S X

TAX

5

oaow JOisiBey-JOisiBoy

•

SP-SP+2
PC-PC+l
o

3 -27

"

cl

"'
w
,..,

<v Hi05 «n *£ IT + +
T
JL
I
q.
o
S .
o Q- o X
© o=
Qo >- O C/> O I
c J I I 1 < < 8 x < < a)
I
o) I a> ffi
I
®
I
0
3
I
>i >v >
o < o > o «*• o x o
5
5
5
ro o a

C Q .fl.W Q .

•
-s
e

0 | QI_

.

C

;;

CL r L

•
..,

i 1 (N

r , c l a.
3 w w

u j n j e y p u e ||e o e u u n o j q n s

E
3

a:

Table 3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Table
Set (Continued)
Object Code

1
o 1e

Instruction

•* TJ

Type

Status

Clock

Bytes

Periods

Operation Performed

s

V

D

I

z

C

CA

1

2

CNJ

X

X

X

Decrement contents of Index Register X.

DEY

BB

1

2

CN

X

X

X

Decrement contents of Index Register Y.
Y-Y-1

INX

EB

1

2

CM

X

X

X

Increment contents of Index Register X.

INY

CB

1

2

CN

X

X

X

Increment contents of Index Register Y.

AOL A

2A

1

CN

X

X

» i 55 1 S + «= V+ °8
E >- g x E | 8
E? ?I 2
2
I I I
x a >■ b x £ >- 2

DEX

x-x-1

X-X+l

X

X

^ T- C

Y-Y+l

2

Rotate contents of Accumulator

left through Carry.

n

l.riH ..
7

N

!

..
I!

0~

A

ROA A

Q.

6A

1

2

X

X

X

0

Rotate contents of Accumulator

right, through Carry.

..

4ij.j1

;

..

·;;,
IC

r x

00

eiBJedQ jejSjOey

3-28

w

0~

A
ASL A

OA

1

2

X

X

X

Arithmetic shift left contents of Accumulator.

~o
A

LSR A

4A

1

2

0

X

X

Logical shift right contents of Accumulator.

0~

A

Set (Continued)
6502 Instruction Set
the 6502
of the
Summary of
Table 3-4. A Summary
Table
Instruction

48

Code

Bytes

1

Status

Clock

Periods

Operation Performed

s

V

D

I

z

C
Push Accumulator contents onto Stack.

3

! < Q.
I w
:i i

PHA

Object

O X
O
©

£
■
I->
Type

CO

[SP]-A
SP-SP-1

68

1

4

Load Accumulator from top of Stack ("Pull").

X

X

to <

.

PLA

A-[SP+l]
SP-SP+l

PHP

08

1

3

Push Status register contents onto Stack.

ISPI-P
SP-SP-1
Load Status register from top of Stack ("Pull"I.
P-(SP+l)
SP-SP+l

w

/ii

(/)

H081S

.,.
u

C/)

X

X

ro Q. w

X

28

1

4

CLI

58

1

2

0

Enable interrupts by clearing interrupt disable bit of Status register.

SEI

78

1

2

1

Disable interrupts

RTI

40

1

6

X

X

X

“ ~o
®
5
a
a.
n
C/3
5 oO. i I- iT- Q.1
|
. 1 a! 1
I »- (N (/> Ti
■ ss (/) I
- O
S -CL CL1 CL1 i 1
S
a a>
w w w S;
s I -s 1 1 1a. au . oa. cl
co a . o c

PLP

,-0

3-29

w

t,J

ID

1-1

X

X

X

X

X

X

Return from interrupt; restore Status

P-[SP+l]
PC(LO)-[SP+2]
PC(Hll-[SP+3)
SP-SP+3
PC-PC+l

;dnjje;u|

;.

E
BAK

00

1

7

1

Programmed interrupt. BAK cannot be disabled. The Program Counter is incre-

£

!

mented twice before it is saved on the Stack.

E

E.

[SP]-PC(HI)
[SP-1 J-PC(LO)
[SP-21-P

SP-SP-3
PC(Hl)-[FFFF)
PC(LOl-[FFFE)
1-1
s-1

Table 3-4.
3-4. A Summary
Summary of
of the
the 6502
6502 Instruction
Instruction Set
Set (Continued)
Table
Type

..

a
0

Instruction

Object Code

Bytes

Clock
Periods

Status
Operation Performed

s

V

D

I

z

C

CLC

18

1

2

0

Clear Carry flag

SEC

38

1

2

1

Set Carry flag

CLO

DB

1

2

0

Clear Decimal Mode
D-0

SED

F8

1

2

1

Set Decimal Mode
0-1

CLV

BB

1

2

NOP

EA

I

2

c-o
c-1

0

Clear Overflow flag

v-o
w

<,J
0

No Operation

Table 3-5. 6502 Instruction
Instruction Object Codes in Numerical
Numerical Order
Instruction

Object
bjec t Code
00

\

;

Instruction

Object
bjec t Code

BRK
BAK

68

PLA

01 pp

ORA
ORA

(addr,X)
(addr.X)

69 pp

ADC

data

05 pp

ORA
ORA

addr

6A

ROR
ROA

A

06 pp

ASL

addr

6C ppqq

JMP

(label)
!label)

08

PHP
PHP

ADC

addrl
addr166

ROA
ROR

addrl
addr166

BVS
BVS

disp

09 pp

ORA
ORA

OA
OA

ASL
ASL

data
A

OD ppqq
00
OE
OE ppqq
10 pp
PP
11
PP
11 pp
15 pp
16 pp
18
19 ppqq
1D
10 ppqq
1E ppqq
20 ppqq
21 PP
pp
21
24 pp
25 pp
26 pp
PP
28
29 pp
2A
2C ppqq
2D ppqq
20
2E
2E ppqq
30 pp
pp
31 PP
31
35 pp
36 pp
38
39 ppqq
3D ppqq
30
3E ppqq
40
41
41 pp
45 pp
46 pp
48
49 pp
4A
4C ppqq
4D ppqq
40
4E ppqq
50 pp
51
51 pp
55 pp
56 pp
58
59 ppqq
5D ppqq
50
5E ppqq
60
61
61 pp
PP
65 pp
PP
66 pp

ORA
ORA

addrl
addr166

ASL

addr166
addrl

6D ppqq
60
6E ppqq
70 pp
PP
71 pp
75 pp

BPL
BPL

d,sp
disp

ORA
ORA

laddr),Y
(addr),Y

ORA
ORA

addr,X
addr.X

ASL

addr.X
addr,X

ADC

(addr),Y
(addrl,Y

ADC

addr.X
addr,X

76 pp
PP

ROR
ROA

addr.X
addr,X

78

SEI
SEI

AOC
ADC

a ddrl
d rl66,Y
.Y

ADC

addrl
6.X
addr16,X

ROR
ROA

addr16.X
16.X

ORA
ORA

addrl
6.Y
addr16,Y

79 ppqq
7D ppqq
70
7E ppqq
81 pp

ORA
ORA

a ddrl
6.X
ddr16,X

ASL
JSR

CLC
CLC

STA

(addr.X)
laddr,X)

84 pp
PP

STY

addr

addrl
6.X
addr16,X

85 pp

STA

addr
addr

label
label

86 pp

STX

addr

AND
ANO

(addr,X)
(addr.X)

88

DEY
DEY

BIT

addr
addr

8A
BA

TXA

AND
ANO

addr

8C
SC ppqq

STY

a ddrl6
d r l6

ROL
AOL

addr

8D
80 ppqq

STA

a ddrl6
d r l6

8E
SE ppqq

STX

addrl
addr166
disp

PLP
PLP
AND
ANO

data

90 pp

BCC
BCC

ROL
AOL

A

91 pp

STA

(addr).Y
(addr),Y

BIT
BIT

addr166
addrl

94 pp

STY

addr.X
addr,X

AND
ANO

addrl
addr166

95 pp

STA

addr.X
addr,X

ROL
AOL

a ddrl6
d r l6

96 pp

STX

addr.Y
addr,Y

BMI
BMI

d1sp
disp

98

TYA
TVA

AND
ANO

(addr).Y
laddr),Y

99 ppqq

STA

AND

addr.X
addr,X

9A

TXS

ROL
AOL

addr.X
addr,X

SEC
SEC
AND

add
rl6 .Y
dr16,Y

AND
ANO

a ddrl
d rl66,X
.X

ROL
AOL

addrl 6.X
6,X
addrl

RTI
RTI
EOR
EOR

(addr.X)
(addr,X)

EOR
EOR

addr
addr

LSR
PHA
PHA
LSR
LSR

data
A

JMP

label
label

EOR
EOR

a ddrl
d r l6

LSR
LSR

addrl
addr166

BVC
ave

disp

EOR
EOR

EOR
EOR

(addr),Y
laddr),Y

EOR
EOR

addr.X
addr,X

LSR
LSR

addr.X
addr,X

CLI
CLI
EOR
EOR
EOR
EOR
LSR
LSR

addrl 6,Y
addrl
addrl
6.X
addr16,X
addrl 6.X
6,X
addrl

RTS
ATS
ADC

(addr.X)

ADC

addr
addr

ROR
ROA

addr
addr

3-31

addrl 6.Y
6,Y
addrl

9D ppqq
90

STA

addrl
6.X
addr16,X

AO pp

LDY
LOY

data

A1 pp
Al
A2 pp
A4 pp
A5 pp
A6 pp
A8
AB
A9 pp
AA
AC ppqq
AD ppqq
AE ppqq
BO
BO pp
B1
81 pp
B4 pp
B5 pp
B6 pp
B8
BB
B9 ppqq
BA
BC
BC ppqq
BD
BO ppqq
BE
BE ppqq
CO
co pp
pp
Cl PP
C4 pp

LDA
LOA

(addr,X)
(addr.X)

LDX
LOX
LDY
LOY

data
addr

LDA
LOA

addr
addr

LDX
LOX

addr

TAY
LDA
LOA

data

TAX
LDY
LOY

addrl6
ddrl 6

LDA
LOA

addrl
addr166

LDX
LOX

add
r l6
dr16

BCS
BCS

disp

LDA
LOA

(addr),Y

LDY
LOY

addr.X
addr,X

LDA
LOA

addr.X
addr,X

LDX
LOX

addr.Y
addr,Y

CLV
CLV
LDA
LOA

addrl
6 .Y
addr16,Y

TSX
LDY
LOY

addrl 6.X
6,X
addrl

LDA
LOA

a ddrlrl66,X
.X

LDX
LOX

addrl 6.Y
6,Y
addrl

CPY
CPY

data

CMP
CMP

(addr.X)
(addr,X)

CPY
CPY

addr
addr

Codes in Numerical Order (Continued)
(Continued)
Table 3-5. 6502 Instruction
Instruction Object Codes
Object Code
Code

Instruction

Instruction
ln1truction

O bjec t Code

C5 pp

CMP
CMP

addr
addr

E4 pp

CPX
CPX

C6 pp

DEC
DEC

addr
addr

E5 pp
E5

SBC
SBC

addr

C8
ca

INY
INY

E6 pp

INC
INC

addr
addr

C9 pp

CMP
CMP

E8
ES

INX
INX

CA

DEX
DEX

E9 pp

SBC
SBC

cc ppqq
CC

CPY
CPY

EA
EA

NOP
NOP

data

addr166
addrl

addr
addr

data

CD
CD ppqq

CMP
CMP

addrl
addr166

EC ppqq
EC

CPX
CPX

addr166
addrl

CE
CE ppqq

DEC
DEC

dr16
add
r l6

ED ppqq
ED

SBC
SBC

addr16
addrl

DO
DO pp

BNE
BNE

disp

EE ppqq
EE

INC
INC

addr16
addrl

D1 pp
D1

CMP
CMP

(addr),Y
(addr),Y

FO pp
FO

BEQ
BEQ

disp

D5 pp

CMP
CMP

addr,X
addr.X

FlI pp

SBC
SBC

(addrl,Y
(addr),Y

D6 pp

DEC
DEC

addr,X
addr.X

F5 pp
F5

SBC
SBC

addr,X
addr.X
addr,X
addr.X

D8
D8

CLD
CLO

D9 ppqq

CMP
CMP

F6 pp

INC
INC

addr16,Y
addrl
6 ,Y

F8
F8

SED
SED

DD ppqq
DD

CMP
CMP

addr16,X
addrl
6 ,X

addrl
,Y
addr16.Y

DEC
DEC

dr16,X
add
rl6

F9 ppqq
ppqq
F9
FD ppqq
FD

SBC
SBC

DE
DE ppqq

SBC
SBC

a d dr16,X
rl6 .X

EO pp
EO

CPX
CPX

data

FE ppqq
FE

INC
INC

addr16,X
addrl
6,X

El
pp
E1 PP

SBC
SBC

(addr,X)
(addr.X)

3-322
3-

The follow
following
object codes in Table 3-6.
ing symbols are used in the object
Address-mode
Address-mode Selection:
Selection:
aaa

000
001
010
011
100
101
110
111
111

pre-indexed
(addr,X)
pre-indexed indirect
indirect - (addr.X)
direct - addr
immediate -- data
data
immediate
extended direct
addr166
direct - addrl
post-indexed
(addr),Y
post-indexed indirect
indirect - (addri.Y
base page
page indexed
indexed - - addr.X
addr.X
base
absolute
6,Y
absolute indexed
indexed- - addrl
addr16,Y
absotute indexed
indexed -- addrl
addr16.X
absolute
6,X

00
01
10
11
11

direct -- addr
addr
direct
extended direct
addr16
extended
direct -- a d
d rl6
base page
page indexed
indexed - -addr.X
addr.X
base
absolute
6.X
absolute indexed
indexed -- addrl
addr16,X

001
010
011
101
101
111
111

direct -- addr
addr
direct
accum
ulator -- AA
accumulator
extended
extended direct
direct - ad dr16
rl
base page
page indexed
indexed -- addr.X;
addr,X; addr.Y
addr,Y in
in STX
STX
base
absolute indexed
indexed -- addr16,X;
addr16.X: addr16,Y
addr16,Y in
in STX
STX
absolute

00
01
I11
I

immediate
data
im
mediate -- data
direct -- addr
addr
direct
extended direct
ddr16
extended
direct -- a d
d rl6

000
001
011
101
101
111
II
I

immediate
data
im
mediate -- data
direct -- addr
addr
direct
extended
addr16
extended direct
direct - addrl
base page
page indexed
indexed -- addr.Y
addr.Y inin LDX;
LOX; addr.X
addr,X inin LDY
LOY
base
absolute indexed
indexed -- addr16,Y
addr16,Y inin LDX;
LOX; addr16,X
addr16,X in
absolute
in LOY
LDY

bb

bbb

cc

ddd

pp

the second
second byte
byte of
of aa twothe
two- or
or three-byte
three-byte instruction
instruction

qq

the
the third
third byte
byte of
of aa three-byte
three-byte instruction
instruction

x
X

one bit
bit choosing
choosing the
the address mode: address mode:
one
direct -- addr
addr
0
direct
1
extended
direct -- addrl
extended direct
addr166

y

one
JMPmode:
address mode:
one bit
bit choosing
choosing the
the JMP address
0
extended
direct -- label
extended direct
label
indirect - - (label)
Uabel)
1
indirect

3-33
3-

Codes with
ot 6502 Object Codes
Table 3-6. Summary of
ith 6800 Mnemonics
M nemonic

Operand

ADC

Bytes

Clock
Clock

M C6800
6800

Periods

Instruction
Instruction

01
1aaa01
11aaa01

ADCA

data

pp
PP

2

2

data8

addr
addr

PP
PP

2

3

addr8

addr.X
addr,X

pp
PP

2

4

index
index

(addr.X)
(addr,X)

pp
PP

2

6

s·

(addr).Y

PP
PP

2

5*

addrl
addr16

ppqq
ppqq

4

a ddrl
6.X
ddr16,X

ppqq
ppqq

3
3
3

a ddrl
6 ,Y
ddr16,Y

ppqq
ppqq

addrl
addr166

4•
4*
4'

001aaa01
aaa01

AND

ASL

Object
bjec t Code

ANDA

data

pp
PP

2

2

data8

addr

pp
PP

2

3

addr8

addr.X
addr,X

pp
PP

2

4

index
index

(addr,X)
(addr.X)

pp
PP

2

6

(addr).Y
(addr),Y

pp
PP

2

5'
5*

addrl
addr166

ppqq
PPqq

3

4

addrl
addrl 6.X
addrl
6,Y
addrl 6.Y

ppqq
ppqq

3

4*
4'

A

addr
addr,X
addr.X
addrl
addr166
a ddrl
6.X
ddr16,X

ppqq

3

4*
4'

OOObbblO

1

2

PP
PP

1

5

a ddr16
d r l6

ASLA

PP
PP

2

6

ASL index
index

ppqq

3

6

ASL addrl
addr166

ppqq
ppqq

3

7

BCC
ace

disp

90 pp

2

2 "..
2

ace disp
BCC

BCS
BCS

disp

BO
BO pp

2

2 "..
2

BCS disp
BCS

BEQ
BEQ

disp

FO
FO pp

2

2”..
2

BEQ
SEQ disp

pp
pp

2

3

addr8

BIT
BIT

10,100
001
0x100
addr

BITA
SITA

a ddrl
ddr166

ppqq
ppqq

3

4

addrl
addr166

BMI
BMI

disp
disp

3 0 pp
PP

2

2··
"

BMI
8MI disp

BNE
BNE

disp

DO
DO pp

2

22”..

BNE
8NE disp

BPL
8PL

disp
disp

10 pp
PP

BPL
BPL disp

BRK
8RK

2

2

2
2"..

00

(SWI)
ISWI)
BVC
eve disp

1

7

BVC
eve

disp

5 0 pp

2

2 ”..
2

BVS

disp

7 0 pp

2

2 "..
2

BVS
8VS disp

CLC
CLC

18

1

2

CLC
CLC

CLD
CLO

D8

1

2

CLI
cu

58
5B

1

2

CLI
CLI

CLV

B8

1

2

CLV

dd one clock period
crossed.
boundary is crossed.
page boundary
period if page
•'AAdd
"A d
d one clock period if branch
another
branch to another
periods if branch
occurs to location in same page; add two clock periods
branch occurs
Add
..
page
occurs.
page occurs.

3 -34
4

Table 3-6. Summary
Summary of 6502
6502 Object
Object Codes with
ith 6800
6800 Mnemonics
Mnemonics (Continued)
M nemonic
onic

Operand
Operand

CMP

Objectt Code

Bytes

Clock

C6800
MC
6800

Periods

Instruction

110aaa01
data

pp
PP

2

addr

pp
PP
pp
PP
pp
PP
pp
PP
ppqq
PPqq
ppqq
ppqq

2

3

CMPA
CMPA
data8
addr8

2

4

index

2

6

addr,X
addr.X
(addr,X)
(addr.X)
(addr),Y
(addr).Y
ddr166
a ddrl
a ddrl
6.X
ddr16,X

6,Y
addrl
ddrl 6.Y
CPX

2

2

s·

5*

3

4

3
3

4•
4*
4•
4*

2

2

10cc00
111
0ccOO
data

addr
ddr166
a ddrl

pp
PP
pp
PP
ppqq

2

3

3

4

2

ddr186
a ddrl

CPX
data8
addr8
ddr166
a ddrl

1100cc00
nooccoo

CPY
CPY
data

PP
p
p

2

addr

pp
p

2

3

dr16
add
r l6

ppqq

3

4

DEC
DEC

0bb110
1 10b
b 1 10

DEC
DEC

addr

pp
PP

2

5

addr,X
addr.X
addr166
addrl
addrl
ddrl 6.X
6,X

pp
PP
ppqq
ppqq
ppqq

2

6

index

3

6

a ddr16
d r l6

3

7

DEX
DEX

CA

1

2

DEY
DEY

88

1

2

2

2

2

3

data8
addr8

2

4

index

2

6
8

2
3

5'
4

3

4•'
4

3

4·'

EOR
EOR

010aaa01
10aaa01

data
data
addr

addr,X
addr.X
(addr,X)
(addr.X)
(addr).Y
addrl
ddrl 6
8
addrl
ddrl 6.X
8,X
a ddrl
d rl68,Y
.Y

INC
INC

pp
PP
pp
PP
pp
PP
pp
PP
pp
PP
ppqq
ppqq
ppqq
PPqq
ppqq
ppqq

DEX
DEX

EORA
EORA

s·

11 1lbbl
b b 1 110

a ddrl
ddr186

INC
INC

addr

pp
PP

2

5

addr.X
addr,X

pp
PP
ppqq
ppqq
ppqq
ppqq

2

6
8

index

3

6
8

a ddrl
ddr186

3

7

INX

E8
ES

1

2

INY

C8
ca

1

2

3

3

(label)
(label)

ppqq
ppqq
ppqq
ppqq

3

5

label
label

20 ppqq

3

6
8

a ddrl
ddr186
a ddrl
6.X
ddr18,X

y01100
01y0
1 100

JMP
label
label

JSR

INX

JMP

ddr186
a ddrl

JSR addrl
addr186

•Add one clock period if page boundary is crossed..
'Add
"..AAdd
d d one clock period if branch occurs to location in same page; add two
o clock periods if branch to another
page occurs.

3 -3 5
3-35

Table 3-6. Summary of 6502 Object Codes with 6800 Mnemonics
Mnemonics (Continued)
(Continued)
M nemonic
onic

Operand

LDA
LDA

Clock

M C 6800
00

Periods
Periods

Instruction

addr.X
addr,X

(addr.X}
(addr.X)

PP
PP

2

6

addr

LDAA
2

2

data8

2

3

addr8

2

4

index
index

s·

(addr),Y
(addr).Y

pp
PP

2

5*

addrl
addr166

ppqq

3

addrl
6.X
addr16,X

ppqq
ppqq

3

4
4·
4*

3

4•
4*

addrl
6,Y
addrl 6.Y
LDX

101ddd10
dd10

addr166
addrl

LDX

data
data

pp
PP

2

2

(data8}
(data8)

addr

PP
PP

2

3

addr8

addr.Y
addr,Y

pp
PP
ppqq
ppqq
ppqq
PPqq

2

4

(index}
(index)

3

4

addr166
addrl

3

4•
4*

2

add
r l6
dr16
addrl 6.Y
addrl
6,Y
LDY

pp
PP

2

addr

pp
PP

2

3

addr.X
addr,X

pp
PP
ppqq
PPqq
ppqq
ppqq

2

4

3

4

3

4•
4*

A
A

bbb10
010b
bb10

11

22

addr
addr

pp
PP

2

5

addr16,X
addrl
6.X

LSRA
LSRA

addr.X
addr,X

pp
PP

2

6

LSR
LSR index
index

dr16
add
r l6

ppqq
PPqq

3

6

LSR addrl
LSR
addr166

addrl 66.X
addrl

ppqq
PPqq

3

7

NOP
NOP

EA
EA

1

2

NOP
NOP

ORA
ORA

000aaa01
OOOaaaOl
pp
PP
pp
PP
pp
PP
pp
PP
pp
PP
ppqq
ppqq
ppqq
PPqq
ppqq
ppqq

2

2

data8

2

3

addr8

2

4

index
index

2

6

data
addr

addr,X
addr.X
(addr.X}
(addr.X)
(addr).Y
laddr}.Y
addrl
addr166
addrl
,X
addr16.X
addrl
6.Y
addr16,Y

ORAA
DRAA

2

s·

5*

3

4

3

4•
4*

3

4•
4*

PHA
PHA

48

1

3

PHP
PHP

08

1

3

PLA
PLA

68

1

4

PLP
PLP

28

1

4

ROL
ROL

{

101ddd00
d00
data

addr166
addrl

!

Bytes

101aaa01
aaa01
pp
PP
pp
PP
pp
PP

data
data

LSR
LSR

O bject
jec t Code
Code

addr166
addrl

PSHA
PSHA
PULA
PULA

A

1bbb10
001
bbb10

1

2

addr

pp
PP

2

5

addr,X
addr.X

pp
PP
ppqq
PPqq
ppqq
ppqq

2

6

ROL
ROL index

3

6

ROL addrl 6
ROL

3

7

addr166
addrl
6,X
addrl
ddrl 6.X

ROLA
ROLA

•*Add one clock
clock period
period if page
page boundary
boundary is crossed.
crossed.
Add
one clock period
period if branch
branch occurs
occurs to
to location in same
"..A d
d one
same page;
page; add two clock periods
periods if branch
branch to
to another
another
page occurs.
occurs.
page

3-366
3-

j

Codes with
(Continued)
Table 3-6. Summary of 6502 Object Codes
ith 6800 Mnemonics (Continued)
M nemonic

ROA
ROR

Operand
Operand

Object Code
Code

Bytes

Clock

M C6800
6800

Periods
Periods

Instruction

11bbb10
01
1bbb10

1

2

pp
PP
pp
PP
ppqq
PPQQ
ppqq
ppqq

2

5

2

6

ROA index
ROR

3

6

ROA addrl
addr166
ROR

3

7

RTI
RTI

40

1

6

RTI
RTI

ATS
RTS

60

1

6

ATS
RTS

SBC
SBC

111
1 aaa01
aaa01

pp
PP
pp
PP
pp
PP
pp
PP

2

2

data8

2

3

addr8

2

4

index
index

2

6

A
addr

addr,X
addr.X
ddr166
a ddrl
ddr16,X
a ddrl
6.X

data

addr
addr,X
addr.X
(addr,XI
(addr.X)
(addrl.Y
(addr).Y
addr166
addrl
addr16,X
addrl
6 .X
addr16,Y
addrl
6 .Y

RORA
RORA

SBCA
SBCA

PP
PP

2

s·

ppqq
ppqq
ppqq
ppqq
ppqq
ppqq

3

4

3

4•
4*

3

4•
4*

SEC
SEC

3B
8

1

2

SED
SEO

F8
FS

1

2

SEI
SEI

78

1

2

SEI
SEI

STA

100aaa01
OOaaaOl

STAA
addr8
index
index

5*

addrl
ddrl 6

SEC
SEC

addr

pp
PP

2

3

addr,X
addr.X

pp
PP

2

4

(addr,XI
(addr.X)

PP
PP

2

6

(addrl,Y
(addr).Y

PP
PP

2

6

a ddr16
d r l6

ppqq
ppqq
ppqq
ppqq
ppqq
PPqq

3

4

3

5

3

5

2

3

2

4

(index)

3

4

addrl
addr166

6,X
addrl
ddrl 6.X
ddr16,Y
a ddrl
6 .Y
STX

100b
b 1 10
bb110
addr
addr.Y
addr,Y

addr166
addrl

pp
PP
pp
PP
ppqq
ppqq

dr16
add
r l6

STX
addr8

1 0 0 bb100
b100

STY
addr
addr

pp
PP

2

3

addr.X
addr,X

pp
PP

2

4

addrl
ddrl 6

ppqq
ppqq

3

4

TAX

AA

1

2

TAY

A8
AS

1

2

TSX

BA

1

2

TXA

8A
SA

1

2

TXS

9A

1

2

TYA
TVA

98

1

2

TSX

TXS

'A
·Add one clock period
period if page boundary
boundary is crossed.
crossed.
"A
••Add one clock period
period if branch
branch occurs
occurs to location in same page;
page; add two clock periods
periods if branch
branch to another
another
page occurs.

3-377
3-

ADC-ADD
— ADD MEMORY,
MEMORY, WITH
WITH CARRY, TO ACCUMULATOR
ACCUMULATOR
instruction uses eight
eight methods of addressing data memory and allows the concon­
This instruction
Accumulator.
ulator. The eight
eight
tents of data memory and the carry status to be added to the Accum
are:
methods of addressing memory are:

1)
1)
2)
2)
3)
4)
5)
6)
7)
8)

Immediate
Immediate - ADC data
ddr16
Absolute (direct) - ADC a d
d rl6
Absolute
Zero page (directl
(direct) - ADC addr
(addr.X)
ith Index Register X - ADC (addr.X)
Pre-indexed with
ith Index Register Y - ADC (addr).Y
(addri.Y
Post-indexed with
ith Index Register X - ADC addr.X
Zero-page indexed with
Absolute indexed with
ith Index Register X - ADC addr16.X
addr16,X
Absolute
ddr16.Y
Absolute indexed with
ith Index Register Y - ADC a d d
rl6,Y
Absolute

The first
first byte of object
object code determines
determines which
hich addressing mode is selected as follows:
follows:
7 6 5 44

~Bit
3 2 1 0 ^

i l l l al al al l

| 0O | l1| l 1| a | a | a | 0O| l 1 .,._

Bit Number
Object Code

Bit Value
for aaa
aaa

Hexadecimal
Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
Number
of bytes

000
001
010
011
100
101
101
110
111
111

61
65
69
6D
71
71
75
79
7D

Indirect.
Indirect, pre-indexed
pre-indexed with
ith X
Zero page (direct)
Immediate
Immediate
Absolute
Absolute (direct)
Indirect, post-indexed
post-indexed with
ith Y
Indirect.
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith Y
Absolute indexed with
ith X
Absolute

2
2
2
3
2
2
3
3

We may illustrate
illustrate the ADC instruction
instruction with
ith immediate
mediate addressing
addressing as shown below. For
consult either
either the discussion of addressing modes or the
modes. consult
other addressing modes,
description of other arithm
etic or logical instructions
instructions since other illustrations
illustrations show
arithmetic
description
different addressing modes.
modes.
different
SVBOIZC

A

X

Program

V

Memory

SP
PC

mm

mm

l--6"'9'----t

mmmm
_____YY_--1 mmmm + 1
mmmm ♦ 2

___...,

3 -38

"

Add the contents
contents of the next program memory byte (addressing mode selected by bits
2. 3. and 4 of the byte in the instruction
instruction register) and the Carry status to the Accum
ula­
Accumulator. Suppose xx = 3 A
3A15.
7C15.
1. After
tor.
-|6 yy = 7 C
ie C = 1.
fter the instruction
instruction
ADC

#$7C
#$7C

has
ulator will
ill contain
contain B7-|g.
has been executed,
executed. the Accum
Accumulator
B715.
3A =
7C =
Carry =

000 1 11 1 0
1011 00
1000
0 1 11 11 111 0
___________ 1

101
101 1 1111
0 110
LNonzero
Nonzero result sets Z to 0
L

r

No carry,
carry. set C to 0-*
1 sets S to 1-*

0
=1 ,1. Set V to 1
O ¥-V-11 =
ADC is the only 6502 addition
addition instruction.
instruction. To use it in single-byte
single-byte operations or to add
numbers. a previous instruction
the low-order
low-order bytes of two multibyte
ultibyte numbers,
instruction must explicitly
explicitly set
Carry to zero so that it does not affect
affect the operation. Note that the 6502 microprocessor
microprocessor
has no addition
Carry. ADC will
has
addition instruction
instruction that does not include
include the Carry.
ill perform either bi­
binary or decimal
decimal (BCD)
(BCD) addition.
addition, depending
depending on whether
whether the Decimal Mode status is
Is 0 or
1..

3.39
339

AND MEMORY
MEMORY WITH
WITH ACCUMULATOR
ACCUMULATOR
-AND
AND —
This instruction
instruction logically
logically ANDs the contents
contents of a memory location with
ith the contents
contents of
the Accum
ulator. This instruction
instruction offers the same memory addressing options
options as the
Accumulator.
ADC instruction.
instruction. The first
first byte of object
object code selects the addressing mode as follows:
follows:
5 4

7 6

3

4---e;,
2 1 0 ^

Bit Number

Obiecl
~
| 0 |0 | 1 | a | a |
a | o| 1
Object Code

Bit Value
aaa
for aaa

Hexadecimal
Hexadecimal
Object
Object Code

Addressing Mode
Addressing

Number
of Bytes

000
001
010
011
100
101
101
110
111
111

21
25
29
2D
31
35
39
3D

Indirect.
Indirect, pre-indexed with
ith X
(directl
Zero page (direct)
Immediate
Immediate
(directl
Absolute
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute
Absolute indexed with
ith X

2
2
2
3
2
2
3
3

disill illustrate
illustrate the AND instruction
instruction with
ith zero page (directl
(direct) addressing. See the dis­
We will
examcussion of addressing methods
methods and other arithm
etic and logical instructions
instructions for exam­
arithmetic
modes.
ples of the other addressing modes.
Data
Memory

SVBDIZC
p jxj

I I I Ixj I

__ vv_-1 00qq

Program
Memory

25
qq

mmmm
mmmm+

1

mmmm + 2

Logically
contents of the selected memory byte with
ith the Accum
ulator and
Accumulator
Logically AND the contents
inand yy
Accumulator.
store the result in the Accum
ulator. Suppose xx =FC15
FC-|6 ar|d
VY = 1315.
16- After
fte r the in­
struction
struction
AND

$40

contain 1015:
Accumulator
(assuming that
that yy is in memory location
location 0040),
ulator will
ill contain
q:
0040). the Accum
FC =
13 =

1 11 11 111 1
0 0
1100
000
100 1 1
0010011

000
10000
0010000

_J

u
Nonzero result sets
sets Z to 0
LNonzero

O__J
0 in bit 7 sets S to 0

AND is a frequently
frequently used logical instruction.
instruction.

3-40
3-40

LEFT
ASL -— SHIFT A C CU MULATOR
TO R OR M E MORY
Y BYTE LEFT
arithmetic
Perform a one-bit
one-bit arithm
etic left shift
shift of the contents
contents of the Accum
ulator or the con­
Accumulator
conbyte.
tents of the selected memory byte.
First. consider
Accumulator:
First,
consider shifting
shifting the Accum
ulator:
Data
Data

s v

b

d i z c

Memory

0

x,_ __

_.

YL-.----1
SPL,__
__

_.. ____

PCL.., ___

_._m~m---.J,-

Program

_,

Memory
Memory

OA

mmmm
mmmm
mmmm -+ l

Accumulator
Suppose that the Accum
ulator contains
contains 7A15.
7A-|g. Performing
Performing an
ASL

A

instruction
1, the Zero status to 0,
0, and
instruction will
ill set the Carry status to 0, the Sign status to 1,
will
ill store F415
F4-JQ in the Accumulator.
Accumulator.
Carry

Accumulator
Accum
ulator

x-01111010-0
1 1 1 0 1 0->— 0
X-«------0
0

111111110100
0 1 0

_j

L _
Nonzero
sets Z to 0
Nonzero result sets

Sets S to 1-*------1

The ASL instruction
instruction uses four data memory addressing options:
1) Zero page (directl
1)
(direct) - ASL addr
2)

Absolute (direct) - ASL addr16
Absolute

3)
4)

Zero page indexed with
addr,X
ith Index Register X - ASL addr.X
Absolute
dr16,X
Absolute indexed with
ith Index Register X - ASL a d d
rl6,X

The first
first byte of object
determines which
object code determines
hich addressing mode is selected as follows:
77

6 5 44 3

2

.,__B,t
1 0 ^

Number
Bit Number

~Ob1ect
IOl
OTO] b I b T 1 I 1 | 0 M ----- Obiect Code
Code

3 -41

Bit Value
for bb

Hexadecimal
Hexadecimal
Object
Object Code

Addressing Mode
Addressing

Number
Number
of Bytes

00
01
10
11
11

06
OE
0E
16
1E

Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

2
3
2
3

addressing. The other addresWe will
ill show the ASL instruction
instruction with
ith absolute (direct) addressing
addres­
shown in other
other instruction
instruction descriptions.
descriptions.
sing modes are shown
Data
Memory

0
o

'H4TTTTw
'ppqq

A._ __

__.

.___ __.

xl-----.1
y

SP 1---~.._

Program

____

Memory

.,,.--T

PCL..,_..m~m-..1..--m=m-...,_

mmmm + 3

OE

mmmm

qq

mmmm + 1
mmmm

pp

mmmm + 2
mmmm
mmmm
mmmm + 3

Suppose ppqq = 3FB615
CB15. After
3F86-|g and the contents
contents of ppqq are CB-|g.
fte r executing
executing an
ASL

$3F86
$3FB6

instruction, the contents
contents of location
location 3FB6,e
3F86-|g will
ill be altered to 9615
96-|g and Carry will
ill be
InstructIon.
set to 1:

Carry
(3F8615)
(3F86-]g)
x--11001011-0
X - ------1
1 0 0 1 0 1 1 -— 0
100 0 1
101
1
1
0 1 1 0

__J

Sets
e t sS
S tto l -1 * ------- 1

LNonzero
I----*- Nonzero result
result sets
sets Z to 00

instruction is often
often used in multiplication
ultiplication routines
routines and as a standard logical inin­
The ASL instruction
struction.
2.
struction. Note that
that a single ASL instruction
instruction multiplies
ultiplies its operand by 2.

3 -42

BCC -— BRANCH IF CARRY
CARRY CLEAR
CLEAR (C == 0)
BCC
This instruction
instruction is a branch with
ith relative addressing in which
hich the branch is only ex­
executed if the Carry status equals 0; otherwise.
otherwise, the next instruction
instruction is executed.

sec
..__,
90
following
In the follow
ing instruction
instruction sequence:

-------ii4:C

NEXT
NEXT
C= 1
#$7F
A D
#$7F

$40

SCC instruction
the ADC $40 instruction
instruction is executed right
right after the BCC
instruction if the Carry status
equals 0. The AND #$7F
#$7F instruction
instruction is executed if the Carry status equals 1.
1. The rela­
relative addressing operates as shown in the next illustration
illustration and as shown in the discusdiscus­
earlier. No statuses and no registers -— except
sion of addressing methods presented earlier.
the Program Counter
Counter -— are affected.
Data

SVBDIZC
s v
b oi

z c

Memory

III
I IL IJI
-L
ii.lI.E

p

AL-

__

X1---....1
Y1- __

SPa,__

_.

-,1

_. ____

Program

/

Memory

PC L.. ......
m..m_.i,__m_m_"""'
---=-90;;..._-,1 mmmm
mmmm + 1

___ _,,

mmmm + 2

1----,I

''

'

'

Hmmmm+ro m m m m + ri

zero. this instruction
If the Carry is zero,
instruction adds the contents
contents of the second object
object code byte
(taken as a signed 88-bitit displacement!
displacement) to the contents
contents of the Program Counter
Counter plus 2;
this becomes the memory address for the next instruction
instruction to be executed. The previous
contents
contents of the Program Counter
Counter are lost.
lost.

3-43
3-

= 1)
BCS -— BRANCH IF CARRY SET (C
<C =
BCC instruction
This instruction
instruction operates like the BCC
instruction except
except that
that the branch is only ex·
ex­
ecuted if the Carry status
1: otherwise,
status equals 1;
otherwise, the next instruction
instruction is executed.
BCS

..-.,-,
BO
following
In the follow
ing instruction
instruction sequence:
C=1
NEXT
NEXT

__.-----!!1-'4S

C =0
=0
A D

#$7F
#$7F

I•

$40

BCS instruction
the ADC $40 instruction
instruction is executed
executed right
right after
after the BCS
instruction if the Carry status
1. The AND #$7F
0.
equals 1.
#$7F instruction
instruction is executed
executed if the Carry status equals 0.

BEQ -— BRANCH IF EQUAL TO ZERO (Z = 1)
This instruction
just like the BCC
instruction except
except that
instruction is just
BCC instruction
that the branch is executed if the
1: otherwise,
Zero status equals 1;
otherwise, the next instruction
instruction is executed.

BEO
..-.,-,

FO
following
In the follow
ing sequence:

Z =1
.-------t-tttO

NEXT

Z =0
A D

#$7F
#$7F

$40
the ADC $40 instruction
instruction is executed right
right after
after the BEQ
instruction if the Zero status
BEO instruction
equals 1.
1. The AND #$7F
#$7F instruction
instruction is executed if the Zero status equals 0.

3-44
344

BIT -— BIT TEST
Accumulator
This instruction
instruction logically
logically ANDs the contents
contents of the Accum
ulator with
ith the contents
contents of a
selected memory location,
location. sets the condition
does not alter the
condition flags accordingly,
accordingly, but does
contents
ccumulator
contents of the A ccum
ulator or memory byte. The only addressing modes allowed are
absolute (direct) and zero page (direct)
ad(direct). The first byte of object
object code determines
determines the ad­
dressing mode as follows:
7 6 5 4 3 2 1 0 ^
..,_Bit

Bit m 0
No.

I 0 1
0 | 1 j Q |X f 1 1 o l 'o V ^ -------- O bject Code
~Object
Code

Bit Value
for x

Hexadecimal
Object
Object Code

Addressing
Addressing Mode

Number
of Bytes

0
1
1

24
2C

(direct)
Zero page (direct)
Absolute (direct)
(direct)
Absolute

C
M CO

2
3

We will
ill illustrate
illustrate the BIT instruction
instruction using absolute (direct) addressing. For the zero
mode, see the AND instruction
modes. We
page mode,
instruction and the discussion
discussion of addressing modes.
has a rather unusual effect
flags. since it sets the Z
should note that BIT has
effect on the status flags,
flag according
according to the result of the logical AND operation but sets the Sand
and V flags ac­
according to bits 7 and 66 of the contents
contents of the memory location being tested: that is,
is.

(M) = 0:
0; Z = 0 if A A (M)
(M) £;bO
Z = 1 if A A (M)
0

= bit 7 of (M)
(M)
S=
(M)
V = bit 66 of (M)
Data
ata

S V B D

p

I

Memory

Z C

I1I I I I IX I I
6

--------{_~

A
X
y

xx
Program
Memorv

SP

PC

_-_-__
v~vC:]ppqq

mm

mm

mmmm + 3

2C

mmmm

qq

mmmm + 1
mmmm + 2

PP

mmmm + 3

3-45
3-

Logically
Accumulator
Logically AND the contents
contents of the Accum
ulator with
ith the contents
contents of the specified
memory location and set the Zero condition
condition flag accordingly.
accordingly. Set the Sign and Overflow
Overflow
condition
condition flags according
according to bits 7 and 66., respectively.
respectively, of the selected memory location.
E015. and ppqq = 1641
164115.
Suppose xx = A 6615.
-|0 , yy = EOig,
ig After
fte r the instruction
instruction
BIT

$1641

has executed.
Accumulator
has
executed, the Accum
ulator will
ill still contain
contain A 6615.
-|g, and location 1641
ig will
ill still
164115
contain
E015. but the statuses will
contain E0-|g.
ill be modified
modified as follows:

=
A6
6
EO
EOJ-

1 0 1 0 0 111100
1 f

1

L

1 0 0 0 0 0

1 00000

100000
10 1
0 000
Sets S to 1-

Set V to 1

It sets Z to 0
- Nonzero result
BIT instructions
instructions frequently
frequently precede conditional
conditional Branch instructions.
instructions. BIT instructions
instructions are
also used to perform masking functions
functions on data.
data.

3-46
3-

= 1)
BMII -— BRANCH IF M INUS
U S (S =
BMI
SMI

..._,-.,
30
instruction works like the BCC
instruction except
except that the branch is executed only
SCC instruction
This instruction
otherwise, the next instruction
instruction is executed.
1; otherwise.
if the Sign status is 1:

following
In the follow
ing instruction
instruction sequence:

S= 1
NEXT
NEXT

.----t,Hj/11

S =0)
A D

#$7F
#$7F

$40

....._MAH--ADC

the Sign status is
SMI instruction
the BMI
the ADC $40 instruction
instruction is executed
executed right
right after
after the
instruction if the
0.
Is 0.
1.
#$7F instruction
instruction is
executed if the Sign status is
Is executed
1. The AND #$7F

BNE -— BRANCH IF NOT EQUAL TO ZERO (Z = 0)
BNE
SNE
___,

DO
instruction is
identical to the BCC
instruction except
except that the branch is executed
SCC instruction
Is identical
This instruction
otherwise, the next instruction
instruction in sequence is executed.
Is 0; otherwise.
only if the Zero status is
In the follow
ing instruction
instruction sequence:
following

Z =0
.-----1,ffl/E

NEXT
NEXT
Z =
=1
#$7F
#$7F
A ID
E

...__'-11-'1='---ADC

$40

the ADC $40 instruction
instruction is executed
executed right
right after the BNE
instruction if the Zero status is
SNE instruction
1.
0. The AND #$7F
#$7F instruction
instruction is executed
executed if the Zero status is 1.

33-47

BPL -— BRANCH IF PLUS
PLUS (S =
= 0)
BPL
BPL
BPL
-,-,
10
This instruction
BCC instruction
instruction operates like the BCC
instruction except that the branch is executed
only if the Sign status is 0; otherwise.
otherwise, the next instruction
instruction in sequence is executed.
following
In the follow
ing instruction
instruction sequence:
S =00

------~L

NEXT
NEXT
S=
=1
#$7F
AND
D
#$7F

-B1 L

the ADC $40 instruction
instruction is executed
executed right
right after the BPL
instruction if the Sign status is
BPL instruction
0. The AND #$7F
$7F instruction
instruction is executed if the Sign status is 1.
1.

3-48
3-

BRK — FORCE BREAK (TRAP OR SOFTWARE INTERRUPT)
BAK-FORCE
BRK
..._,,_,
00
1. then the
Break status is set to 1.
The Program Counter
Counter is incremented
incremented by two and the Break
Stack. The registers and
Program Counter
Counter and Status (P)
(P) register are pushed onto the Stack.
as follows:
the corresponding
corresponding memory locations into which
which they are pushed are as
M emory
m o r y Location
Location
Register
instruction execution.)
start of instruction
contains ss at start
(Stack Pointer contains
Counter
Program Counter
of Program
byte of
High byte
01 ss
High
Counter
Program Counter
of Program
byte of
Low byte
01ss
ss -- 1 1 Low
register wwith
(P)register
Status (P)
01 ss -- 2 2 Status
ith BB ==11
(Stack Pointer
Pointer contains
containsssss- - 3 3atatend
endofofinstruction
instructionexecution.)
execution.)

1. This disables the 6502's
The Interrupt
Interrupt Mask bitit is then set to 1.
6502's interrupt
interrupt service ability.
ability,
conill not respond to an interrupt
interrupt from a peripheral device. The con­
i.e.,.. the processor will
FFFF15) are then loaded
tents of the Interrupt
Interrupt Pointer
Pointer (memory addresses FFFE-|g
FFFE15 and FFFFi6>
into the Program Counter.
The BRK
instruction can be used for a variety
variety of functions.
functions. It can provide a breakpoint
breakpoint
BRK instruction
softfacility for debugging
debugging purposes or it can transfer control
control to a particularly
particularly important
portant soft­
facility
programmer
ware system such as a disk operating
operating system or a monitor. Note that the programmer
response.
BRK instruction
instruction from a regular interrupt
interrupt response.
must insert the code required to tell a BRK
The coding
coding to do this checks the value of the B status flag in the Stack as follows:
PLA
PHA
AND
BNE
BNE

# $10
10
BRKP
BRKP

REGISTER
STATUS REGISTER
;GET
GET STATUS
STACK
LEAVE IT ON STACK
;BUT ALSO LEAVE
SET?
STATUS SET?
BREAK STATUS
;IS BREAK
YES, GO
BREAK
PROCESSBREAK
GO PROCESS
;YES.

Note that
that the operation code for BRK
BRK is 00. This choice of operation code means that
BRK
be used to patch programs in fusible-link
fusible-link PROMs
blowing all the fuses
PROMs since blowing
BRK can ·be
makes the contents
contents of the word
word 00. Thus an erroneous instruction
instruction can be corrected by
changing the first object
object code byte to 00 and inserting
inserting a patch via the interrupt
interrupt vector
changing
zero (by blowing
tci zero
routine. Remember that
that a bit in a fusible-link
fusible-link PROM
blowing the
PROM can be set to
PROMs are not
fuse)
cannot be reset to one after
after the fuse has
has been blown. Such PROMs
fuse) but cannot
erasable.
erasable.
The operation
operation of the BRK
instruction may be illustrated
illustrated as follows:
BRK instruction

ljzjcl
!slvl l1'D!
SVBDIZC

Pj I 1,51 I I

___

...,71----1
mm+ 2
mm

1

A
X
V

----t
t----t

SPt--:::,,--1--C--,
_.____
PC___

Data
Memory

0lss - 2
Olss - 1
Olss

Program
Memory

,_
----t

mmmm
mmmm + 1

qq
.,__PP--t

FFFE
FFFF

00

___

3 -49

_,

The final contents
contents of the Program Counter
Counter are ppqq where pp represents the contents
contents
FFFE,a. Note
of the memory location FFFF,a
FFFF-|g and qq
PQ the contents
contents of memory location
location FFFE-|g.
that the Stack is always on page 1 of memory:
memory; i.e..
e. the eight
oi the
eight most significant
significant bits of
Stack address are always 0115.
iq .

3 -50

CLEAR (V = 0)
BVC
eve -— BRANCH IF OVERFLOW CLEAR
BVC
SVC
--.--50

This instruction
instruction operates like the BCC
instruction except that the branch is executed
SCC instruction
Overflow status is 0;
instruction in sequence is executed.
otherwise. the next instruction
O: otherwise,
only if the Overflow
In the follow
ing instruction
instruction sequence:
following
V =00
.-----tll'VC

NEXT
NEXT
V =11
#$7F
D
A <ID

-B»'C

-----►ADC

$40

SVC instruction
the ADC $40 instruction
instruction is executed right
right after the BVC
instruction if the Overflow
1.
status is 0. The AND #$7F
#$7F instruction
instruction is executed if the Overflow
Overflow status is 1.

1)
= 1)
BVS -— BRANCH IF OVERFLOW SET (V =
BVS
SVS
--..70

This instruction
instruction is just like the BCC
instruction except that the branch is executed only
SCC instruction
if the Overflow
instruction in sequence is executed.
otherwise. the next instruction
1: otherwise,
Overflow status is 1:
In the follow
ing instruction
instruction sequence:
following

V =1

NEXT

.---~S

V =0
#$7F
A D

SVS instruction
the ADC $40 instruction
instruction is executed right
right after the BVS
instruction if the Overflow
Overflow
status equals 1.
$7F instruction
instruction is executed if the Overflow
Overflow status equals 0.
1. The AND #$7F

3 -51

CLC -— CLEAR CARRY
CLC
CLC

-.,-,
18
18

status. No other status or register's contents
are affected. Note that this
Clear the Carry status.
contents are
instruction
instruction is required as part of a normal addition
addition operation since the only addition in­
instruction
ADC, which
also adds in the Carry
struction available on the 6502 microprocessor
microprocessor is ADC,
hich also
Carry
status. This instruction
status.
instruction is also required at the start of a multi-byte
ulti-byte addition
addition since there is
never a carry into the least significant
significant byte.
Data
Data

S V B D

I

Z C

M em ory

I IO I HI I I 1°1

p=[

Program
Program
M emory

18

m mmm
m mmm -+ l

3-52
3-

CLD
IM A L MODE
CLO -— CLEAR D ECIMAL
CLD
CLO

-.,-,
088
D

Clear the Decimal Mode status. No other status or register's
register's contents
contents are affected. This
instruction is used to return the 6502 processor to the binary mode in which
hich ADC and
instruction
BCD results. This instruction
SBC
instructions produce binary rather than BCD
instruction may be used
SBC instructions
to ensure that
that the mode is binary in situations
situations where it may be uncertain
uncertain whether
whether the
Decimal Mode status has been set or cleared most recently.
Data
Data

s v
B d i
SVBOIZC

2

M em ory

c

pl I I l0 11I I

A
X
Program
M em
ory
emory

D8
DB

m mmm
m mmm
m + l1

3 -53

CU
CLEAR INTERRUPT M ASK (ENABLE
(ENABLE INTERRUPTS)
INTERRUPTS)
CLI -— CLEAR
CLI
CLI

-._.,--,
58

Clear the interrupt
interrupt mask bit in the Status (P)
instruction enables the
(P) register. This instruction
6502's
6502's interrupt
interrupt service ability.
ability, i.e.... the 6502 will
ill respond to the Interrupt
Interrupt Request con­
conline. No other registers or statuses are affected. Note that the I bit is a mask or disatrol line.
disa­
ble bit. It must be cleared to enable interrupts
interrupts and set to disable them.
Data
M em ory

SVBOIZC

plI I I I0 1 I I

Program

J:I

~mm~...__m_m

M em
ory
emory

-~mmm+0

58

m mmm
m mmm
m ■
+1

3-54
3-

CLV -— CLEAR
CLEAR OVERFLOW
OVERFLOW
CLV
CLV
CLV

--..,-,
B8
B8
Clear the
the overflow
overflow b
in the
the Status
Status register.
register. No
No other
other registers
registers or
or statuses
statuses are
are affected.
affected.
bitit in
Clear
Note that
that the
the 6502
6502 has
has no
no SET
SET OVERFLOW
OVERFLOW instruction.
instruction.
Note
Data
Data
SVBDIZC
p

M em ory

t z c

I I0 1I Ic ImI I

Program
Program
Memory
M em ory

mm

88
-----t

3-5
5
3-55

l

mmmm
mm
m
+ 1
mmmm
mm
mm +
1

CMP-COMPARE
WITH ACCUMULATOR
— COMPARE MEMORY
MEMORY WITH
ACCUMULATOR
This instruction
instruction subtracts
contents of a selected memory byte from the Accum
Accumulasubtracts the contents
ula­
tor, sets the condition
condition flags accordingly.
accordingly, but does not alter the contents
contents of the Acc­
cumulator
ulator or memory byte. This instruction
instruction offers the same memory addressing options
options
as the ADC instruction.
instruction. The first
first byte of object
object code selects the addressing
addressing mode as
follows:
7 6 55 44 33 2 2 1 1 0 0 ..--0;1

Number
Bit Number

! 1 |Il1|!Q |
oJaa J| a J| a |JoJ| l1] ^
.,._ObjectQ biect Code
Code
Number
of Bytes

Bit Value
aaa
for aaa

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

000
001
010
01
01
011
100
10
101
10
1
11
110
111
11
1

C1
C1
C5
C9
CD
D1
D1
D5
D9
DD

Indirect.
Indirect, pre-indexed
pre-indexed with
ith X
Zero page (directl
(direct)
Immediate
Immediate
Absolute
Absolute (directl
(direct)
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X

0 00
001

2
2
2
2
2
3
2
2
2
2
3
3

2

We will
ill illustrate
illustrate the CMP instruction
instruction with
ith pre-indexed
pre-indexed indirect
indirect addressing (using Index
X). See the discussions
Register X).
discussions of addressing methods
methods and other
other instructions
instructions for examexam­
modes.
ples of the other addressing modes.
Data
Data
S V B D I
p

Ix) I I I )x)xi

A

xx

X
y

rr

SP
PC

Memory

Z C

qq

OOrr + cc

PP

OOrr +cc+

yy

ppqq

1

Program
Memory
mm

mm

Cl
cc

mmmm
mmmm + 1
mmmm + 2

Subtract
AccumulaSubtract the contents
contents of the selected memory byte from the contents
contents of the Accum
ula­
tor and set the Sign, Zero.
It of the subtraction.
subtraction.
Zero, and Carry statuses to reflect
reflect the result
Suppose
F15.
815.
015.
2315.
(004315)
6D15.
Suppose xx== F F
i 6 - yy = 1 8
ig
rr = 2 0
t 6 - cc== 2 3 |6
<0043•)g) = 6 D
1 0 , and
+ cc and we have assumed that
(004415)
(00 4
4 1 g) = 1515.
i 6- Note that
a t 0043
0043 = rr +
(156D15)
yy = 1815.
056
ie = vv

3-56
3-

After the instruction
instruction
After

CMP
CMP

($23.X)
($23,X)

and memory
has been
beenexecuted.
executed,thethe Accum
ulatorwill
w illstill
stillcontain
contain F6615.
6 ,and
memory location
Accumulator
follows:
modified was
be statuses
statuses willthe
1815.
156D15
1 6 will
ill still contain
contain 1
8 -]0 ,but the
but
ill be
modified asfollows:
F6 = = 1 11 1 1 01 01 1 01 0
Twos complem
ent ofof18
18 = 1—1 1 0 1 0 0
10
1 10 10 0 0
complement
110
101 1 11 111100

s,<sc m 1 :

L,

•Nonzero "'""
result ""
sets Z
m0O
z to
LNoornm

11

Sets S to 1-«-------

complement
carry. not to its complem
Note that C is equal to the resulting
resulting carry,
ent as is true on many
borrow is required and C = 1 if no borrow is
other microprocessors. Thus C = 0 if a borrow
necessary.
necessary.
execution of
Compare instructions
instructions are most frequently
frequently used to set statuses before the execution
Branch-on-Condition instructions.
instructions.
Branch-on-Condition

3-57

REGISTER X WITH
CPX -— COMPARE
COMPARE IN DEX
EX REGISTER
IT H M E MORY
ORY

>
InThis instruction
instruction is the same as CMP except
except that the memory byte is subtracted
subtracted from In­
dex Register X instead of the Accumulator.
Accumulator. The only addressing modes allowed are im­
immediate, zero page (direct), and absolute (direct). The first byte of object code selects
the addressing mode as follows:
follows:
7

6 5 4

3 2

1 0 .._B,t

Number
Bit Num
ber

| l | l l l l Q | c | c
| Q | o | ^
Ob1ect
bject Code
~
Code

Bit Value
for cc

Hexadecimal
Object Code

00
01
01
10
11
11

EO
E0
E4
E4

Number
of Bytes

Addressing
Addressing Mode
Immediate
Immediate
(direct)
Zero page (direct)
Used for INX instruction
instruction
Absolute
(direct)
Absolute (direct)

EC
EC

2
2
3

CPX instruction
See the discussion of
We will
ill illustrate
illustrate the CPX
instruction with
ith immediate
mediate addressing. See
addressing methods
arithmetic
methods and other arithm
etic and logical instructions
instructions for examples of the
the
other addressing modes.
modes.
Data
Data
SVBDIZC

I I I lX!XI

P!X!

rr - yy

At----t

X

v._ __
SP._

t-~-----,..,

Program

-t

______

PC.,__rn_,_n_.___m_m_

Memory

..,,,....

_,,..,.

mmmm + 2

'--t----1

EO

-----

----1

YY

mmmm
mmmm + 1
mmmm + 2

Subtract the contents
Subtract
contents of the selected memory byte from the contents
contents of Index Register
Zero. and Carry statuses reflect the result of the subtraction
X. The Sign, Zero,
subtraction in the same
same
way as shown for the CMP instruction.
instruction.

3-588
3-

CPY -— COMPARE INDEX REGISTER
WITH MEMORY
MEMORY
V WITH
REGISTER Y
InThis instruction
instruction is the same as CMP
except that the memory byte is subtracted
subtracted from In­
CMP except
dex Register Y instead of the Accumulator.
Accumulator. The only addressing
addressing modes allowed are im-­
mediate. zero page (direct),
(direct). The first byte of object code selects
(direct). and absolute (direct).
the addressing mode as follows:
7

6

5 4 3

2 1 0 ^
..-a,t

| 1|
1 | 0 10 | c | c I Q | o | ^
~Ob1ect

Bit Value
for cc

Hexadecimal
Hexadecimal
Object Code

00
01
10
11
11

CO
co
C4
CC
cc

Bit Num
ber
Number

Code
--------O bject Code

Number
of Bytes

Addressing Mode
Addressing

2
2

Immediate
Immediate
(direct)
Zero page (direct)
Used
instruction
Used for INY instruction
Absolute (direct)
Absolute

3

discusSee the discus­
We will
ill illustrate
illustrate the CPY
instruction with
ith zero page (direct) addressing. See
CPY instruction
sion of addressing methods and other arithm
etic and logical instructions
instructions for examples
arithmetic
of the other addressing modes.
modes.
Data
Data
Memory

SVBDIZC

p

!xi I I I Ixixj

AL-

__

VY

OOqq

_,

X .,_----1.-

Program
Memory

Y L-_;,;--I

SPL--------~
PC '--m_m_"'-_m_m_.....,

mmmm + 2
t---'-C4_-I

mmmm

L---'qq-'---1

mmmm + l
mmmm + 2

t----1

Subtract the contents
contents of the selected memory byte from the contents
contents of Index Register
Subtract
Y.
subtraction in the same
Zero, and Carry statuses reflect the result of the subtraction
Sign. Zero,
Y. The Sign,
way as shown for the CMP instruction.
instruction.

33-59

1)
DEC-— DECREMENT MEMORY
MEMORY (BY 1)
DEC
This instruction
instruction decrements
decrements by 1 the contents
contents of a selected memory location.The
location.The DEC
instruction
instruction uses four data memory addressing options:
1)
1)
2)
3)
4)

Zero page (direct) -— DEC
DEC addr
Absolute
DEC addr16
Absolute (direct) -— DEC
Zero page indexed with
DEC addr.X
ith Index Register X -— DEC
Absolute
DEC addr16,X
Absolute indexed with
ith Index Register X -— DEC

The first
first byte of object
object code determines
determines which
which addressing mode is selected as follows:
7 66 55 4 4 3 32 21 01 -0 *......_B,t Bit Number

~Object
1
i O b

b

i

O bject Code

1 0

Bit Value
for bb

Hexadecimal
Hexadecimal
Object Code
Object

Addressing
Addressing Mode

0
00
01
10
1
11
1
1

C6
6
CE
CE
D
066
DE
DE

(direct)
Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Absolute indexed with
ith X
Absolute

01

Number
of Bytes

2

2

3

2

2

3

DEC instruction
adWe will
ill illustrate
illustrate the DEC
instruction with
ith absolute indexed addressing. The other ad­
dressing modes are shown elsewhere.
Data

5 V 8

p

D I Z C

Memory

Ixi I I I !xiI

yy

ppqq + rr

A
X
Program

y

SP
PC

Memory

mm

mm

DE

mmmm

qq

mmmm + 1

PP

mmmm + 2
mmmm + 3

Decrement the contents of the specified memory byte.
10015.
OA15,
0
If yy = A515.
A5-|6' ppqq
PPdQ = 0 1 0
0 ig , and rr = OA-|
then after execution
execution of the instruction
instruction
DEC $0100,X
DEC
$0100,X
contents of memory location OIOA
1 0 will
ill be altered to A 4415.
i0.
the contents
01OA16

A5 =
Ones complement
complement of 1 =

1 0100
1 0 0 101 1
1 11 11 111111111 1

LL

10100100
0 10 100
Carry is not alteredj
Sets S to 1-

Nonzero result sets Z to 0

(V) is not altered
Overflow
verflow (V)

3-60
3-

1)
DEX-— DECREMENT
DECREMENT INDEX
INDEX REGISTER X (BY 1)
This instruction
X. The Zero and Sign
instruction decrements
decrements by 1 the contents
contents of Index Register X.
statuses are affected.
DEX
'-v-'

CA
The effects
DEC except
effects of this instruction
instruction are the same as those of DEC
except that the contents
contents of
Index Register X are decremented
decremented rather than the contents
contents of a memory location.
Data
Memory

SI/BDIZC
s v
b o i z c

x[
3 l3l
■
GEI lJlJIx

Pl

,..
X
y

rr -

1

t~rr~:J;.~::::::-----

Program

Memory

SPl-----4

PC

---------

Cl\

3 -61

mmmm
mmmm + 1

REGISTER Y (BY 1)
DEY -— DECREMENT INDEX REGISTER
1)
This instruction
instruction decrements
decrements by 1 the contents
contents of Index Register Y.
Y. The Zero and Sign
statuses are affected
affected just
just as they are by DEC
DEC and DEX.
DEX.
DEY
DEY

----88

S V
B
VBDIZC

Data
Data
Memory

I I I lXI I

lXlm
-p E

C

A
X
y

rr

~

SP
PC

mm

mm

rr - 1
Program

...

Memory

mmmm

+ 1
mmmm
...__8::.,:B:..._...t
mmmm

1----...tmmmm mmmm h
+l

33-62

EOR-— EXCLUSIVE-OR
MULATOR
EMORY
EOR
EXCLUSIVE-OR AC CU M
ULA TO R WITH
IT H M EM
ORY
Exclusive-OR the contents
Accumulator
contents of the Accum
ulator with
ith the contents
contents of a selected
selected memory
memory
byte. This instruction
instruction offers the same memory
memory addressing
addressing options
options as the ADC instrucinstruc­
tion. The first
first byte of object
object code selects the addressing
addressing mode as follows:
follows:
-4--B,t
7 66 55 44 3 3 2 2 1 1 0 ^
^

Bit Number
Number

Obiect Code
Code
-------- Object

Bit Value
for aaa

Hexadecimal
Hexadecimal
Object
Object Code

Addressing
Addressing Mode

Number
Number
of Bytes

000
001
001
010
011
011
100
101
101
110
111
111

41
41
45
49
40
4D
51
51
55
59
50
5D

Indirect.
Indirect, pre-indexed
pre-indexed with
ith X
Zero page (direct)
Immediate
Immediate
Absolute
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed
indexed with
ith X
Absolute
Absolute indexed
indexed with
ith Y
Absolute
Absolute indexed
indexed with
ith X

2
2
2
3
2
2
3
3

EOR instruction
We will
ill illustrate
illustrate the EOR
instruction with
ith post-indexed
post-indexed indirect
indirect addressing
addressing (using InIn­
dex Register Y).
Y). See the discussion
arithmetic
discussion of addressing
addressing methods
methods and other
other arithm
etic and
logical
logical instructions
instructions for examples
examples of the other
other addressing
addressing modes.
Data

VBDIZC
S V
B D

Memory

z c

Pix! Il Il Il lI xxji II

P|X|

A t--'-'
X
y..._ __

-i

i

pp
PP

00cc
OOcc
00cc
OOcc + 1

yy

ppqq + rr

....L

_

SP
PCl-_m_m
___

qq
qq

Program
Memory

m_m_....,~-r
51
cc

mmmm
mmmm

mmmm + 1
mmmm + 2
mmmm
mmmm + 3
mmmm

3-633
3-

Logically Exclusive-OR
Exclusive-OR the
the contents
contents of
of the
the Accum
Logically
ulator wwith
ith the
Accumulator
the contents
contents ofof the
the
selected memory
memory location,
location. treating
treating both
both operands
operands as
selected
assimple
simple binary
binary data.
data.Suppose
Supposethat
that
xx= E3-|0
E315 and
and yy
yy == AO
A015.
Afterr the
the instruction
instruction
xx
ig. A fte
EOR ($40,Y)
EOR
($40.Y)
has executed,
executed. the
the Accum
Accumulator wwill
contain 4 3
has
ill contain
t6 . W
e assume
-|6_
4315.
We
assume also
also that
that rrrr == 10
1015.
qq == (40 1
(4015)
= 1E-|6,
1E15. pp
pp== (41
(4115)
2515. and
and (251
(251E15)
yy == AOig.
A015.
qq
q) =
ig ) == 25-|6’
E i©) == VV
E3 =
E3
AO ==
A0

11 11 1 0
1000 00 11 11
1100 110000000000

L

0 10
0 0 0 11
01000011

sets SS to
00 sets
to 00

_J

Nonzero result
LNonzero
result sets
sets ZZ to
to 00

EORisis used
used to
to test
test for
for changes
changes in
in bit
bit status.
status. Note
EOR
Note also
also that
that the
the instruction
instruction EOR
EOR#$FF
#$FF
complements the
the contents
contents of
of the
the Accum
Accumulator.
complements
ulator, changing
changing each
each 'V
·1· bit
bit to
to aa 'O'
·o·and
and each
each
·o·bit
bit to
to aa T.
'0'
'1'.

3
-64
3-64

1)
INC -— INCREMENT
INCREMENT MEMORY
MEMORY (BY 1)
INC
This instruction
instruction increments
increments by 1 the contents
contents of a selected memory location. The INC
instruction
instruction uses four
four data memory addressing options:
1)
1)
2)
3)
4)

Zero page (direct) -— INC addr
Absolute
Absolute (direct) -— INC addr16
-INC
addr,X
Zero page indexed with
ith Index Register X —
INC addr.X
Absolute
INC addr16,X
Absolute indexed with
ith Index Register X -— INC

The first
first byte of object
object code determines
determines which
hich addressing mode is selected as follows:
7 6

5 4

3

Numbe,
2 1 0 ..,_B,t
-------- Bit Number

~Ob1ect
| 11
1 | 1 | b| b | 1 | 1 |0

Code
--------Object Code

Bit Value
for bb

Hexadecimal
Object
Object Code

Addressing
Addressing Mode

Number
of Bytes

00
01
10
11
11

E6
E6
EE
EE
F6
FE
FE

Zero page (direct)
Absolute
(direct)
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

2
3
2
3

We will
ill illustrate
illustrate the INC instruction
instruction with
ith absolute (direct) addressing. The other adad­
dressing modes are shown elsewhere.
Data
Data
SVB

DI

Memory

ZC

Ptx!l I l lxlI
VY+

1

_-,t-_;..;vv_--t ppqq

Program

Memory

EE

mmmm

QQ

mmmm + 1
mmmm + 2

t--pp---1

mmmm + 3

3-65
3-

I

Increment
Increment the selected memory
memory byte.
115,
C015. then after executing
If pp== 0 1
1@
. qq = A215,
A2-|g, and yy = COigexecuting an:
INC

$01A2
01A2

instruction,
instruction, the contents
contents of memory location
location 01 A215
A2-|e will
ill be incremented
incremented to C 116.
115.

co =
CO
1 =
=

1 100
0 0 00 00 0000
0000001
000
00001
11000001
1 0 00 1

__J

Sets S to 1 ---------1

LNonzero
1 ►
Nonzero result sets Z to 0
Carry and Overflow
Overflow
altered

are not

The INC instruction
instruction can be used to provide a counter
counter in a variety
variety of applications
applications such as
counting the occurrences
counting
occurrences of an event dr specifying
specifying the number
number of times a task is to be
performed.

3-666
3-

INX
1)
INX -— INCREMENT
INCREMENT INDEX
INDEX REGISTER X (BY 1)
This instruction
X. The Zero and Sign
instruction increments
increments by 1 the contents
contents of Index Register X.
statuses are affected
affected just
just as by the INC instruction.
instruction.

---INC

EB

Data

sSVBOIZC
v b o i z c

Memory

Ixf I I I Ixf I
’
EETEEEO

p

X
y

SP
PC

J:__
--

rr + 1

A
rr

Program
Memory

~

mm

mm

(~

mmmm+1
mmmm
.__EB-"--~mmmm
mmmm -+ 1

---~

Add 1 to the contents
contents of Index Register X and set the Zero and Sign flags according
according to
the result. Suppose that
that Index Register X contains
contains 7A15.
7A-|0, After
fter the instruction
instruction
INX
has executed.
executed, Index Register X will
ill contain
contain 7815.
7B-|0, the Zero status will
ill be cleared since
the result is nonzero, and the Sign status will
ill be cleared since the result has 0
O in its
most significant
significant bit.

'

3-67
3-67

l

INY -— IN C REMENT
EM EN T IN DEX REGISTER
REGISTER Y (BY 1)
This instruction
instruction increments
increments by 1 the contents
contents of Index Register Y.
Y. The Zero and Sign
statuses are affected
affected just
just as by the INC instruction.
instruction.
INY
--..-

cs
C
8

Data
Data

SVBOIZC
s V
B D
p p m T

I

Z

M em ory

C

n l
P[xl! l ! ilXi

A

x,____

_,

rr +

1
Program
Program

y

SP 1--"-"~PC __

m_m
_ _.__m_m __

M emory
_

CB

m mmm

mmmm++ 1
mm

Add 1 to the contents
contents of Index Register Y and set the Zero and Sign flags according
according to
the result.
result. Suppose that
0C15.
the
that Index Register Y contains
contains OC
1 5 . Afterr the instruction
instruction INY has
has
executed,
executed. Index Register Y will
ill contain
contain 0015.
0D-|g, the Zero status will
ill be cleared since the
result is nonzero,
nonzero. and the Sign status will
ill be cleared since the result has 0 in its most
significant bit.
significant

3-68

OR INDIRECT ADDRESSING
J MP -— J UMP
P VIA ABSOLUTE OR
Is the only in­
inThis instruction
instruction will
ill be illustrated
illustrated using indirect
indirect addressing. Note that it is
struction
has the true indirect
struction that
that has
indirect addressing mode.
deter­
mode. The first byte of object code determines the addressing mode as follows:
7

6

5 4 3 2

.,__B,t
1 0 ^

B it Number
Number

| 0 I
1 I y I 0 I 1 I 1 I o | o K ^ ------- O bject Code
~Ob1ect
Code

Bit Value
for y

Hexadecimal
Object Code

Addressing
Addressing Mode

Number
of Bytes

0
11

4C
6
6C

Absolute
(direct)
Absolute (direct)
Indirect
Indirect

3
3

0

Data
S V B D

Pl

I

Memory

Z C

IIIIIII

ccdd
ccd d+ 1

A----1

xt----1
yt----1

Program

SP----+----

PC.__m_m
___

Memory

m_m
___ lk

ppqq

-----

6C
dd
t--cc--t

mmmm
mmmm + 1
mmmm + 2

Jump to the instruction
instruction specified by the operand by loading the address from the
selected memory bytes into the Program Counter.
following
In the follow
ing instruction
instruction sequence:
CLC
CLC
LDA
LOA
ADC
STA
STA
LDA
ADC
STA
JMP

;CALCULATE LSB'S
LSB'S OF
OF DESTINATION
DESTINATION ADDRESS
ADDRESS
#BASEL CALCULATE
INDXL
JADDR
;CALCULATE MSB'S OF
OF DESTINATION
DESTINATION ADDRESS
ADDRESS
#BASEU CALCULATE
INDXU
INDXU
JADDR+1
(JADDR) TRANSFER
;TRANSFER CONTROL
CONTROL TO DESTINATION
DESTINATION
(JADDR)

The JMP instruction
instruction will
ill perform an indexed jumpp relative to the 16-bit
16-bit address concon­
sisting of BASEU
BASEU ((8 MSBs)
MSBs) and BASEL
BASEL ( 8
(8 LSBs).
LSBs) The index here is assumed to be 16 bits
LSBs) and INDXU
INDXU ( 8
(B MSBs).
MSBs). The ad­
long and to be initially
initially stored at addresses INDXL ((8 LSBs)
addresses follow
following
dresses
ing the start of the table could then contain
contain absolute JMP instructions
instructions
that transfer control
control to the proper routines.

1nd1rectaddress crosses
crosses a page boundary
Is. if
JMP will not work properly
properly if the indirect
boundary -— that is,
dd = FF15
In the illustration
illustration above. The discussion of indirect
i q in
indirect addressing earlier in this
chapter
pecul1ar1ty in more detail.
chapter discusses this peculiarity
mode. In this case,
The JMP instruction
instruction can also use the absolute (direct) addressing mode.
case.
the second byte of the instruction
Is loaded into the low byte of the Program Counter,
Counter.
instruction is
and the third byte of the instruction
instruction is loaded into the high byte of the Program
Counter. Instruction
Instruction execution
execution continues
continues from this address.
address.

3-69
3-

l

JSR -— J UMP
M P TO SUBROUTINE
This instruction
instruction pushes the Program Counter
Counter onto the Stack and then transfers
transfers control
control
to the specified
specified instruction.
instruction. Only absolute
absolute (direct) addressing
addressing is allowed.
allowed. Note that
that the
Stack Pointer
Pointer is decremented
decremented after
after the storage of each data byte and that
that the Program
Counter
Counter value that
that is saved is the address of the last (third) byte of the JSR instrucinstruc­
tion:
tion: i.e.,.. the initial
initial program counter
counter value plus 2. Remember also that
that the Stack grows
down
down in memory
memory and that
that the most significant
significant half of the Program Counter
Counter is stored
first
first and thus ends up at the higher
higher address (in the usual 6502
6502 address form).
S V

p

B

D I

Data
Data
Memory

z C

IIIIIIII

mm+ 2
mm

01 ss - 2
01ss - 1
01 ss

A

X
y

Program

SP

ss

PC

mm

Memory

20

mmmm

qq

mmmm + 1

pp

mmmm + 2

The Program Counter
Counter is incremented
incremented by 2 and then is pushed onto the Stack. The Stack
Pointer
Pointer is adjusted
adjusted to point
point to the next empty
empty location
location in the Stack. The address part of
the instruction
instruction is then stored in the Program Counter
Counter and execution
execution continues
continues from that
point.

Assume that mmmm
E34F16
E315.
mmmm = E34F-]
0 and that ss = E3-]
0 Then after
after the execution
execution of the inin­
struction
struction
JSR
JSR

$E100

the Program Counter
Counter will
ill contain
contain E100-|
q, the Stack Pointer
Pointer will
ill contain
contain El
E1 115.
0 , and the
E10015.
Stack locations
locations will
ill be as follows:
follows:

E3) = PC(HI)
(01 ss)
(01
ss) = (01E3)
PC (HI) = E3
(01 ss - 1)
1) = (01E2)
E2) = PC(LO)
(LO) = 5 115
(01
16
0015.
The next instruction
instruction to be executed
executed will
ill be the one at memory
memory address El1 OO-|
0.

3-70
3-

LOA-— LOAD
LOAD A C CU M
CUMULATOR
FROM M EM
EMORY
LDA
ULA TO R FROM
ORY
Load the contents
contents of the selected memory byte into the Accumulator.
ulator. This instruction
instruction
offers the same memory addressing options
options as the ADC instruction
instruction and will
ill be illusillus­
X. See
See the discussion of
trated using zero-page indexed addressing with
ith Index Register X.
arithmetic
addressing methods and other arithm
etic and logical instructions
instructions for examples of the
other addressing modes.
modes. The first byte of object code selects the addressing mode as
follows:
follows:
7 6 5 44

3 22 1 0 ^
-4-B,t

~Obiect
| l|
0 | l | a | a | a | 0 | 1~t^

Bit Number
Number

Code
------- O bject Code

Bit Value
for aaa
aaa

Hexadecimal
Object Code

Addressing Mode
Addressing

Number
of Bytes
Bytes

000
001
001
010
011
011
100
101
101
110
111
111

A1
A5
A9
AD
81
B1
B5
85
B9
89
BD
BO

Indirect.
Indirect, pre-indexed with
ith X
(direct)
Zero page (direct)
Immediate
Absolute
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X

2
2
2
3
2
2
3
3
Data
Data

Memorv

SVBOIZC

plxj i ! ! !X!l

..

---.,.i---_-.;_Y:;;:Yc:joorr + cc

yy

X

Program

y

Memorv

SP
P(

mm

mm
85

rnmmm

cc

mmmm + 1

Load the contents
Load
contents of the selected memory byte into the Accumulator.
Accumulator.
Suppose that Index Register X contains
contains 1015
1 q and cc== 43-|g.
4315. If memory location
005315
OO53-|0 contains
contains AA,e.
AA-|6, then after

LOA
LDA

$43.X

has executed.
has
executed, the Accum
ulator will
ill contain
contain AA-|g.
Accumulator
AA15.
AA

=

I

1 00 1 00 1 00 1 00

__J

L

LNonzero
result
1 sets S to 1 -•------ 1
'— ^N onzero result
sets Z to
0 sets Z to 0

3-71
3-

LOX -— LOAD
LOAD IN DEX REGISTER
REGISTER X FROM M E MORY
LDX
RY
X. The addressing
Load the contents
contents of the selected memory byte into Index Register X.
are:
modes allowed are:
1)
1)
2)
3)
4)
5)

Immediate
LOX data
Immediate -— LDX
Absolute
LOX addr16
Absolute (direct) -— LDX
LOX addr
Zero page (direct) -— LDX
Absolute
LOX addr16,Y
Absolute indexed with
ith Y -— LDX
LOX addr.Y
Zero page indexed with
ith Y -— LDX

Note that there are no indexing
indexing modes with
ith Index Register X, and there is no post-inpost-in­
dexing. The first
first byte of object
object code selects the addressing
addressing mode as follows:
follows:
7 66 55 4

..,._0;1
3 2 11 0 ^

| l |
0 | l | d |d|d|1 |0
~Ob1ect

Number
Bit Number

------- Object Code
Code

Bit Value
for ddd

Hexadecimal
Object
Object Code

Addressing
Addressing Mode

000
001
010
011
100
101
101
110
111
111

A2
A6
AA
AE
B2
B6
BA
BE
BE

Immediate
Immediate
Zero page (direct)
Used for TAX instruction
instruction
Absolute
Absolute (direct)
Not used
Zero page indexed with
ith Y
Used for TSX instruction
instruction
Absolute
Absolute indexed with
ith Y

Number
of Bytes
2
2
3
2
3

We will
LOX instruction
ill illustrate
illustrate the LDX
instruction with
ith absolute indexed addressing using Index
arithmetic
Register Y. See the discussion
discussion of addressing methods and other arithm
etic and logical
instructions
modes.
instructions for examples of the other
other addressing modes.
S V B D

P

I

Data
Data
Memory

Z C

IXI I I I IXI I
VY

A
X
y

Program

SP

Memory

ppqq + rr

PC
BE

mmmm

qq

mmmm + 1

pp

mmmm + 2
mmmm + 3

33-72

Loadthe
thecontents
contents ofofthe
theselected
selected memory
memory byte
byte into
Load
into Index
IndexRegister
RegisterX.X.Suppose
Supposethat
that In­
Index Register
RegisterYY contains
contains 2Q-\
2815.
ppqq == 2E1
dex
q, ppqq
ig . then
2E1A 15.and
and yy
yy== (2E42-|e)
(2E4215)== 4 F
4F15.
then after
after
the execution
execution ofofthe
the instruction
instruction
the
LOX $2E1
LDX
A,Y
$2E1A.Y

Index Register
RegisterXX wwill
contain 4 F-|
4F15.
Index
ill contain
q.
4F == 00 1100001 11 11 1 1
4F
0 sets S to O

LLNonzero
Nonzero result
result sets
setsZZ toto 00

__J

3-73
3
-73

LOY -— LOAD IN DEX REGISTER
REGISTER Y FROM M EMORY
LDY
RY
Load the contents
contents of the selected memory byte into Index Register Y.
Y. The addressing
are:
modes allowed
allowed are:
11
1)
2)
3)
3)

Immediate
Immediate -— LDY data
Absolute
Absolute (direct) -— LDY addr16
Zero page (direct) —
- LDY addr

4)

Absolute
Absolute indexed with
ith X -— LDY addr16.X

5)

addr.X
Zero page indexed with
ith X -— LDY addr,X

Note that there are no indexing
indexing modes with
ith Index Register Y nor is there any pre-indexpre-indexing.
The first byte of obIect
object code selects the addressing mode as follows:
follows:
7

6 5 4 3 2

1 0 .--0,1

~Ob1ect
| 1|
0 | 1 | d | d | d | o| 0

Bit Number

--------Object Code
Code

Bit Value
for ddd

Hexadecimal
Hexadecimal
Object
Object Code

Addressing
Addressing Mode

Number
Number
of Bytes

000
001
001
010
011
100
101
101
110
111
111

AO
A0
A4
AB
A8
AC
BO
B0
B4
BS
B8
BC
BC

Immediate
Immediate
Zero page (direct)
TAY instruction
Used forT A
instruction
Absolute
Absolute (direct)
BCS instruction
Used for BCS
instruction
Zero page indexed with
ith X
Used for CLV instruction
instruction
Absolute
Absolute indexed with
ith X

2
2
3
2
3

We will
ill illustrate
illustrate the LDY instruction
instruction with
ith immediate
mediate addressing. See the discussion
discussion of
addressing methods and other
arithmetic
other arithm
etic and logical instructions
instructions for examples of the
other addressing
modes.
addressing modes.
Data
Data
Memory

SVBOIZC

plXI l l I IXj I

Al------1
•.._ __
--4
y l--'-yy'-----1

__ ___

SPl---~---•--PC '-...,._

Program
Memory
mmmm + 2

AO
yy

3 -74

Load the
the contents
contents ofof the
the selected
selected memory
memory byte
Load
byte into
into Index
Index Register
Register Y.
Y. Suppose
Suppose that
that
yy == OO-i60015. then
then after
after the
the execution
execution ofof the
the instruction
instruction
yy
LDY
0
LOY ##0

Index Register
Register YY wwill
contain zero.
zero.
Index
ill contain

00 ==
00

000000000000000 0

Lzero
result sets
-Zero result
sets ZZ to
U
to 11

0 sets S to O__J

0

3
-75
3-75

LSR -— LOGICAL
LOGICAL SHIFT RIGHT OF A C CU MULATOR
LSR
ULA TO R OR M EMORY
RY
This instruction
Accumulator
instruction performs a one-bit
one-bit logical right
right shift
shift of the Accum
ulator or the selected
memory byte.
First. consider shifting
First,
shifting the Accumulator.
Accumulator.

----LSR A
LSR
4A

Data
Cata

s VBDIZC
8 D I Z c

Memory

___
...__

Program

0

y
SPl-----4
PC

mm

Memory
Memory

.....,_
4A

mmmm
mmmm + 1

Shift the contents
contents of the Accum
ulator right
right one bit. Shift
hift the low-order
low-order bit into the Car­
Shift
Accumulator
Carry status. Shift
Shift a zero into the high-order
high-order bit.
Suppose the Accum
ulator contains
contains 7A15.
7A-|g. After
After the
Accumulator
LSR
LSR A

instruction
Accumulator
instruction is executed.
executed, the Accum
ulator will
ill contain 3 D16
i 6 and the Carry status will
ill be
zero.
set to zero.
Accumulator
Accum
ulator

Carry
Carry

-01111010-x
0 1 1 1 1 0 1 0 — ►X
0 ------

0 0 11111 1
01
1101

00

L

_j

LSR always sets S to O
LSR
0-«------ 1

'

sets Z to 0
■» Nonzero result sets

LSR instruction:
Four methods
methods of addressing data memory are available with
ith the LSR
instruction; they
are:
are:
1)
1)

LSR addr
Zero page (direct) -— LSR

21 Absolute
Absolute (direct)
(direct) —
- LSR
LSRaddr16
addr16
2)
3) Zero
Register
LSR addr.X
addr.X
Zero page
pageindexed
indexedw ith
withIndex
Index
Register X—
- LSR
4)

Absolute indexed with
ith Index Register X -— LSR
addr16,X
Absolute
LSR addr16.X

The first byte of object
object code determines
determines which
hich addressing mode is selected as follows:
follows:
7

6 5 4

3 2

11 00 ^-4--811

| 0|
1 | 0 | b | b | 1 1 1 |0
~Object

BitNumber
Number

----------Object Code
Code

3-76
3-

Bit Value
for bb

Hexadecimal
Object Code

Addressing
Addressing Mode

Number
of Bytes

00
01
01
10
11
11

46
4E
56
5E
5E

(direct)
Zero page (direct)
Absolute
(direct)
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

2
3
2
3

LSR instruction
adWe will
ill illustrate
illustrate the LSR
instruction with
ith absolute (direct) addressing. The other ad­
dressing modes are shown elsewhere.
Data
Memory

0

A ___

__

x.,_ __

-t

Y.,_ __

SP.,___

-t

_..,__

Program

--. _ _,

Memory

PC..__m_m_....,_,_nm_ _,..._
4E
qq

mmmm

PP

mmmm-++ 2
m
mmmm ♦+ 3

mmmm ++ l1

Logically
location right one bit.
Logically shift
shift the
the contents
contents of the selected memory location

one bit.

Suppose that ppqq =
=04FA-|g
04FA15 and
and the
the contents
contents of
of memory
memorylocation
location04FA-|6
04FA15are
are0D-|g.
0D15.
After
After the instruction
instruction
LSR $04FA
LSR
has been executed.
executed, the Carry status will be 1 and the contents
contents of memory location
04FA-|g will
ill be 06-|g.
04FA15
0615.

(04FA15)
(04FAig)

Carry
Carry

o

0 ------0 0 0 0 1 1 0 1-x
1--------- ►X
-000011

000
0 0 110
0000110

I
O___J

LSR always sets S to 0LSR

33-77

L

11

I___ Nonzero result sets
sets Z to 0

NOP -— NO OPERATION
OPERATION

-NOP
NOP
EA
EA

This is a one-byte
one-byte instruction
instruction which
hich does nothing except
except increment
increment the Program
Counter. This instruction
instruction allows
allows you to give a label to
object program byte,
to an object
byte. to fine
(each NOP
NOP instruction
tune a delay (each
instruction adds two clock cycles),
instruction
cycles). and to replace instruction
bytes that are no longer needed because of corrections
corrections or changes. NOPs
NOPs can also be
JSRs) which
used to replace instructions
instructions (such as JSRs)
which you may not want
ant to include in
debugging
runs. NOP
NOP is not very frequently
debugging runs.
frequently used
used in finished programs,
programs. but it is often
useful in debugging
debugging and testing.
Data
Data

SVBDIZC
s v
B o

I

z c

Memory

I I I I I Im I I

p
PL 1 —L..L1

J:I

==m=m==-m_m_.,~mmm

+

0

Program
Program
Memory

EA

mmmm
mmmm -i+ 1

3-78
3-

ORA —
LOGICALLY OR MEMORY
MEMORY WITH
WITH ACCUMULATOR
ACCUMULATOR
-LOGICALLY
instruction logically
logically ORs
contents of a memory
memory location
location with
ith the contents
contents of
ORs the contents
This instruction
ulator. This instruction
instruction offers the same memory addressing options
options as the
Accumulator.
the Accum
ADC instruction.
instruction. The first
first byte of object
object code selects the addressing
addressing mode as follows:
follows:
7 6

5 4 3 2

1 0 ^
--------Bit Number
Number
.,__Bit

~Object
10
| 0 [ 0 1a 1 a | a | Q | '

Code
-------Obiect Code

Bit Value
for aaa

Hexadecimal
Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
of Bytes

000
001
001
010
011
011
100
100
101
101
110
111
111

01
01
05
09
0D
OD
11
11
15
19
1D

Indirect.
Indirect, pre-indexed
pre-indexed with
ith X
Zero page (direct)
Immediate
Immediate
Absolute
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X

2
2
2
3
2
2
3
3

ill illustrate
illustrate the ORA instruction
instruction using absolute
absolute indexed addressing
addressing with
ith Index
We will
arithmetic
discussion of addressing
addressing methods and other arithm
etic and logical
Register Y. See the discussion
modes.
instructions for examples
examples of the other addressing
addressing modes.
instructions
S V B 0

Data
Data
Memory

I Z C

Pjx( I I I jxj I
yy

A
X

,x

y

rr

Program

Memory

SP
PC

ppqq + rr

mm

{

19
qq
pp

mmmm
mmmm + l
mmmm + 2

Logically OR the contents
contents of the Accum
ulator with
ith the contents
contents of the selected memory
Accumulator
Logically
byte, treating
treating both operands
operands as simple binary
binary data.
data.
byte.

3 -79

162315.
1015. xx== E3-|g,
Suppose that
that ppqq =
— 1623
1 g, rr = 10-|g,
fter the execuexecu­
E315. and yy = AB-|g.
AB15. After
tion of the instruction
instruction
ORA

$1623.Y
$1623,Y

the Accum
Accumulator
ulator will
ill contain
contain EB15.
1 g.
E3 =
AB =

1 111100
000 11
1 00 1 00 1 00 111

_J

L

110101
111
0 1 0 111

_j

Sets S to 1

~onzero
Nonzero result sets Z to 0

This is a logical instruction;
instruction; it is often used to turn bits "on".
n ", i.e.,.. make them Ts.
'1's. For
example. the instruction
example,
instruction

ORA

#$BO
80

will
ill unconditionally
unconditionally set the high-order
high-order bit in the Accum
ulator to 1.
Accumulator
1.

3-80
3-

PUSH ACCUMULATOR
PHA-— PUSH
ACCUMULATOR ONTO STACK
This instruction
instruction stores the contents
contents of the Accum
Accumulator
ulator on the top of the Stack.
Stack. The
1. No other registers or statuses are affected.
Stack Pointer is then decremented
decremented by 1.
ccumulator
Note that the A ccum
ulator is stored in the Stack before the Stack Pointer is decre­
decremented.

--PHA
PHA
48

Data
Data
Memory

SVBDIZC

pl I I I I I I I
~------

A

Olss - 1

......,---::-..::--10, ss

xx

X
Program

y
SP
PC

Memory

ss
mm

4B

mmmm
mmmm + 1

Accumulator
3A15
Suppose that the Accum
ulator contains 3 A
- | 0 and the Stack Pointer contains
contains F7-]gF715.
After
fter the instruction
instruction PHA has been executed, 3A15
3A-|6 will
ill have been stored in memory
location O1 F
01F716
- | 0 and the Stack Pointer will
ill be altered to F6615.
-|0
The PHA instruction
instruction is most frequently
frequently used to save
save Accum
Accumulator
ulator contents
contents before ser­
servicing
vicing an interrupt
interrupt or calling
calling a subroutine.

3-81
3-

-

----------,--.

REGISTER (P)
(P) ONTO STACK
PHP-PUSH
— PUSH STATUS REGISTER
This instruction
(Pl register
instruction stores the contents
contents of the Status (P)
register on the top of the Stack.
Stack.
The Stack Pointer
1. No other registers or statuses are affected.
The
Pointer is then decremented
decremented by 1.
Note that the Status register
register is stored in the Stack before the Stack Pointer
Pointer is decredecre­
mented.
The organization
organization of the status in memory is as follows:
follows:
7

6 5 4 3 2

1 00 ^
------ Bit Number
.,__B,t
Number

~RegisterP
|SIV
I I B I D I I | z | c ( - < ---- Register P

Bit 5 is not used and its value is arbitrary.
arbitrary.

..__.
PHP
PHP
08

-----lS!Vl1°1°1
ilZlCI

SVBOIZC

Pi

I IIIIIt

A

Data

x----t
Program

y

SP t--::-:,s:---1--:::i
PC .,__m_m_..,_

___

Memory
,._

mmmm + 1

08

mmmm
mmmm + 1

The PHP
PHP instruction
instruction is generally
generally used to save the contents
contents of the Status register
register before
calling
calling a subroutine.
subroutine. Note that
that PHP is not necessary before servicing
servicing an interrupt
interrupt since
the interrupt
interrupt response (to IRQ
IRO or NMI) and the BRK
BAK instruction
instruction autom
atically save the
automatically
contents
contents of the Status
Status register
register at the top of the Stack.
Stack.

33-82

PLA-— PULL CONTENTS OF ACCUMULATOR
ACCUMULATOR FROM
FROM STACK
Accumulator
This instruction
instruction increments
increments the Stack Pointer by 1 and then loads the Accum
ulator
incremented before the AcPointer is incremented
from the top of the Stack. Note that
that the Stack Pointer
c­
loaded.
cumulator
ulator is loaded.
PLA
--.-,

68
Data

Memory

SVBDIZC

Pix!l l l lxl I
_

--------

A

_,_ __

yy---t

~;::

+1

VY

X

Program

y
SP

ss

PC

mm

Memory

68

mmmm
mmmm-+-1

CE15.
Suppose the Stack Pointer
Pointer contains
contains F6-|g
memory location
location 01F716
01F7-|g contains
contains CE-|6
F615 and memory
16 and the
Accumulator
After the instruction
instruction PLA has executed.
executed, the Accum
ulator will
ill contain
contain CE-|g
After
Stack Pointer
Pointer will
ill contain
contain F7-|g.
F716·

_J

=
F7 =

L

101 1 1111
1 11 111 0

,___J

0
to 0
Z to
sets Z
result sets
LNonzero
Nonzero result

Set S to 1-«

have
Accumulator
restore Accum
to restore
used to
is most
PLA instruction
The PLA
The
instruction is
most frequently
frequently used
ulator contents
contents that
that have
a
or after
an interrupt.
Stack: e.g
the Stack:
on the
saved on
been saved
been
e.g.,.. after
after servicing
servicing an
interrupt, or
after completing
completing a
subroutine.
subroutine.

3 -83

(P) FROM
PLP -— PULL CONTENTS
CONTENTS OF STATUS
STATUS REGISTER (P)
FROM STACK
This instruction
instruction increments
increments the Stack Pointer by 1 and then loads the Status (P)
(P) register
Stack. No other registers are affected but all the statuses may be
from the top of the Stack.
changed. Note that the Stack Pointer is incremented before the Status register is
loaded.
loaded.

PLP
'-.,-'

28
as follows:
The organization
organization of the status in memory is as
7 6 5 4

3 2 1 0 ,...._..B,t
Numbe•
-------- Bit Number

~Reg,ster
|s |v
| |Bl d | I lz |c t< ^ —

Register P

Bit 5 is not used.
used.
S V B D I

Data
Data
Memory

Z C

Olss

--J----101ss

SP 1-....;;;••;_➔;,...__
PC,___m_m
_ _,_ ___

.....,.._._
7

~.__

+1

Program
Memory
mmmm + 1

28

mmmm
mmmm + 1

PLP instruction
The PLP
instruction is generally used to restore the contents
contents of the Status register after
alter
completing
subroutine. Thus, it serves
completing a subroutine.
instruction mentioned
serves to balance the PHP
PHP instruction
PLP is not necessary alter
earlier. Note that PLP
after servicing an interrupt
interrupt since the RTI
instruc­
RTI instruction autom
automatically
atically restores the contents
contents of the Status register from the top of the Stack.
Stack.

3-844
3-

ROL -— ROTATE AC CU M
MULATOR
MORY
ROL
ULA TO R OR M E M
O R Y LEFT THROUGH
CARRY
Accumulator
This instruction
instruction rotates the Accum
ulator or the selected memory
memory byte one bit to the left
through
Carry.
through the Carry.
First. consider
First,
consider rotating
rotating the Accumulator.
Accumulator.
ROL A
ROL
~

2A
Data

VBOIZC
S V
B D

I

Memory

Z C

___
...___
_

y
SPt----1

PC

mm

Program
Prograrn
Memory
Memory

mm

2A

mmmm
mmmm-++ 1
mmmm

Accumulator's
Rotate the Accum
ulator's contents
contents left one bit through
through the Carry status.
Accumulator
Suppose the Accum
ulator contains
contains 7A15
7A-|g and the Carry status is set to 1.
1. After
After the
ROL A
ROL
instruction
Accumulator
instruction is executed.
executed, the Accum
ulator will
ill contain
contain F57
F5-|g6 and the Carry status will
ill be
reset to zero.
zero.
Accumulator
Accum
ulator

Carry
Carry

0 1 11 11 1 0
101 1 00
1 11 11 110101
10 1

_j

Set S to 1 Set

J

IL_

11
00
Nonzero result sets Z to zero

ROL instruction
The ROL
instruction allows
allows four methods
methods of addressing
addressing data memory;
memory; they are:
1)
1)

ROL addr
Zero page (direct) -— ROL

2)
2)

Absolute
ROL addr16
Absolute (direct) -— ROL

3)

Zero page indexed with
ith Index Register X -— ROL
ROL addr.X
addr,X

4)

Absolute
Absolute indexed with
ith Index Register X -— ROL
addr16,X
ROL addr16,X

The first
first byte of object
determines which
object code determines
hich addressing
addressing mode is selected as follows:
follows:
7 6 5 4

J3 2 1 0 .,._

~Ob1ectCod•
|g| °
| 1 1b[b11111~

3-85
3-

Bot Number
Bit
Object Code

Bit Value
for bb

Hexadecimal
Hexadecimal
Object Code

Addressing
Addressing Mode

00
01
0
1
10
1
1
11

26
2E
36
3E

Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

00

Number
Bytes
of Bytes
2
3
2
2
3

2

ROL instruction
We will
ill illustrate
illustrate the ROL
instruction with
ith zero page indexed addressing (using Index
X). The other addressing modes are shown elsewhere.
Register X).

A

X

rr

y
SP
PC

mm

mmmm + 2

mm

___ _,
36

mmmm

cc

mmmm ♦ 1
mmmm + 2

-----1

Rotate the selected memory byte left one bit through
through the Carry status. Suppose that
2E15. and the Carry
cc== 3415.
34-|g. rr = 16615., the contents
contents of memory location 0 04A
4 A i16 are 2E-|6status is zero.
zero. After
fter executing
executing a

ROL $34.X
ROL
$34,X
instruction.
5C15
instruction, memory location
location 004A15
004A-|g will
ill contain
contain 5C-|6
(004A
ig)
(004A15)
0101110
001
0 110
0 10
1100
1011100

_J

Set S to 0-«
O_J

Carry
Carry

L

00

00

LNonzero
Nonzero result
result sets
sets ZZ to
to 00

3-86
3-

ROR
ULA TO R OR M E MORY
O R Y RIGHT,
CUMULATOR
ROR-— ROTATE A C CU M
THROUGH CARRY
to the
instruction rotates the Accum
ulator or the selected memory byte one bit to
Accumulator
This instruction
Carry.
right through
through the Carry.
right
First consider
consider rotating
rotating the Accumulator.
Accumulator.
ROR
ROR A
.._..,-,,
6A
Data

V

S V 8
C
Z c
O I 2
B D

Memory

.._
___

Program
Memory

SPl-----t
PC

___
mm

___

mmmm + 1

6A

mmmm
mmmm + 1

Rotate the Accum
ulator's contents
contents right
right one bit through
through the Carry status. Suppose that
Accumulator's
1. Execution of the
the Accum
ulator contains
contains 7A15
7A-|g and the Carry status is
Is set to 1.
Accumulator
ROR
ROR A

CarAccumulator
instruction will
ill produce
produce these results: the Accum
ulator will
ill contain
contain 8D15
BD-)6 and the Car­
instruction
ry status
status will
ill be 0.
Carry

Accum
ulator
Accumulator

_J

L

0 1 1 11 1 0
101 1 00
101
0 1 1 11 1 0
101 1

Set S to, 1

_._j

11
00

to 00
Z to
sets Z
LNonzero
Nonzero result
result sets

are:
they are:
memory; they
data memory:
addressing data
of addressing
four methods
ROR instruction
The ROR
instruction allows
allows four
methods of
1)
1)
2)
2)
3)

4)

ROR addr
page (directl
Zero page
(direct) -— ROR
addr
addr16
Absolute
Absolute (direct)
(direct) -— ROL
ROL addr16
addr,X
ROR addr.X
X -— ROR
Index Register
with
page indexed
Zero page
indexed w
ith Index
Register X
ROR addr16,X
X -— ROR
with
Absolute
Absolute indexed
indexed w
ith Index
Index Register
Register X
addr16,X

as follows:
selected as
is selected
mode is
addressing mode
which
The first
first byte of object
object code determines
determines w
hich addressing
follows:
7
7 6
6 5
5 4
4 3
3 2
2

Number
1
1 0
0 ......_B,t
^
Bil Number

~Ob1ec1Code
i o] 1 I 1
I b I b | 1 I 1 | o h ^ --------Object Code

3 -87
7

Bit Value
for bb

Hexadecimal
Object Code

Addressing
Addressing Mode

Number
of Bytes

00
01
01
10
11
11

66
6E
76
7E

(direct)
Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith X

2
3
2
3

ROR instruction
We will
ill illustrate
illustrate the ROR
instruction with
ith absolute indexed addressing (using Index
X). The other addressing modes are shown elsewhere.
Register X).
Data
Memory

ppqq + rr

A
X

rr
Program

y

SP
PC

Memory

mm

mm

7E

mmmm

qq

mmmm+

pp

mmmm + 2

1

mmmm + 3

1415. ppqq = 0 1 0
0015.
Suppose that rr = 14-|q.
0 ig , the contents
contents of memory location 0 1 1
4 1 g are
1415
ED15. and the Carry status is 1.
1. Afterr executing
executing a:
a:
ED-|6ROR $0100.X
ROR
S0100.X
instruction.
instruction, the Carry status will
ill be 1 and memory location 011415
0114-|g will
ill contain
contain F6-]g.
F615.
(011415)
-] g)

Carry
Carry

101 1 1 0
1 11 1 0
101 1
101 1 11 00
1 1 11 1 0

__J
_J

11
11

L

Set S to 1

LNonzero
Nonzero result
result sets
sets ZZ to
to 00

33-88

RTI-— RETURN FROM INTERRUPT
(P) register and the Program Counter
Pull the Status (P)
Counter off the top of the Stack.
Stack. The
registers and the corresponding
as
corresponding memory locations from which
which they are loaded are as
follows. assuming
follows,
assuming that the Stack Pointer
Pointer contains
contains ss at the start of instruction
instruction execuexecu­
tion:
Memory
Memory Location

Register

01ss+1
01
ss+1
01
01 ss+2
01ss+3
01ss+3

Status (P)
(P) register
Low byte of Program Counter
Counter
High byte of Program Counter
Counter

The final value of the Stack Pointer is its initial
initial value plus 3. The old values of the Status
register
register and Program Counter
Counter are lost.
lost.

RTI

--,-,
40

Data

S V B

Z C

jsjvj jejojI jzjcl

Memory
01ss
ss
01ss
ss + 1

qq
pp

A
X
y
SP
PC

01ss
ss + 2
01ss
ss + 3

Program
Program

ss
mm

Memory

mm

40

mmmm

Suppose that the Stack Pointer contains
contains E8-|g,
location 01E9-|
contains C 115.
16.
E815. memory location
01E916g contains
01EA15
memory location
location 01
EAi g contains
contains 3E-|g,
location 01
EB-| 6 contains
contains D5-|6
3E15. and memory location
01EB15
0515.
After
RTI has been executed.
After the instruction
instruction RTI
executed, the Status register will
ill contain
contain Cl
C1 115.
6, the
EB15. and the Program Counter
Stack Poin!er
Pointer will
ill contain
contain EB-|g.
Counter will
ill contain
contain D53E-|g
D53E15 (this is
the address from which
which instruction
instruction execution
execution will
ill proceed). The statuses will
ill be as
as
follows:
BDIZC
sSV v
b
d i z c
C1
|0 | 0 | 1 |
Cl== |1 |1 | 0 | 0 |0
j,j,jojojojojoj1I
Note that the Interrupt
Interrupt Mask bit will
ill be set or reset depending
depending on its value at the time
stored. assuming that the interrupt
the Status register was stored,
interrupt service routine
routine did not
change it while
hile it was on the Stack.
Stack.

33-89

RTS -— RETURN
RETURN FROM SUBROUTINE
RTS
This instruction
instruction fetches a new Program Counter
Counter value from the top of the Stack and in­
increments
crements it before using it to fetch an instruction.
instruction. Note that the Stack Pointer
Pointer is increincre­
mented before the loading of each data byte and its final value is thus two greater
greater than
ATS is normally
its initial
initial value. RTS
normally used at the end of a subroutine
subroutine to restore the return adad­
JSR instruction.
dress that was saved in the Stack by a JSR
instruction. Remember that the return adad­
dress saved by JSR is actually
actually the address of the third byte of the JSR
instruction itself;
itself:
JSR instruction
hence. RTS
RTS must increm
increment
hence,
ent that address before using it to resume the main program.
The previous contents
lost. Every subroutine
contents of the Program Counter
Counter are lost.
subroutine must contain
contain
RTS instruction.
at least one RTS
instruction.
Data
Data

S V

Pl

B 0

I

z C

Memory

I I IIIII

qq

PP

Olss
Olss + 1
01ss + 2

A
X

Program

V
SP

PC

Memory

ss
ppqq + 1

,60

mmmm

RTS
--..-60

No statuses are altered by an RTS
instruction.
RTS instruction.
Suppose that
that the Stack Pointer
Pointer contains
contains DF-|g,
location 01E016
01E0-|g contains
DF15. memory location
contains
0815.
08-]
5 , and memory location
location 0 1E115
E1 1 g contains
contains 7C15.
ig After
After the instruction
instruction RTS
RTS has been
executed.
E115
executed, the Stack Pointer
Pointer will
ill contain
contain E1
ig and the Program Counter
Counter will
ill contain
contain
7C0916
7C09-|g (this is the address from which
which instruction
instruction execution
execution will
ill proceed).
proceed).

3-900
3-

MULATOR
SBC -— SUBTRACT M E MORY
O R Y FROM A C CU M
ULA TO R WITH
H
BORROW
Subtract the contents
contents of the selected memory byte and the complement
complement of the Carry
Subtract
contents of the Accumulator.
ulator. This instruction
instruction offers the
C) from the contents
status (i.e.... 1 -— C)
same memory addressing options as does the ADC instruction.
instruction. The first byte of object
code selects the addressing mode as follows:
7

6 55 44 33 22 1 1 0 0 ^
~Bit

I~Obiect
l M l H

. H

o

h

U

Bit Number
Number

Code
Object Code

Bit Value
aaa
for aaa

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

Number
Number
of Bytes

000
001
010
011
100
101
101
110
111
111

E1
E1
E5
E5
E9
E9
ED
ED
F1
F1
F5
F9
F9
FD

Indirect, pre-indexed
pre-indexed with
ith X
Indirect.
Zero page (direct)
Immediate
Immediate
(direct)
Absolute
Absolute (direct)
Indirect, post-indexed
post-indexed with
ith Y
Indirect.
Zero page indexed with
ith X
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X
Absolute

2
2
2
3
2
2
3
3

(via Index
ill illustrate
illustrate the SBC
instruction using pre-indexed
pre-indexed indirect
indirect addressing (via
SBC instruction
We will
Register X).
X). See the discussion
discussion of addressing methods and other arithm
etic and logical
arithmetic
instructions for examples of the other addressing modes.
modes.
instructions
Data
Data

Memory

SVBDiZC

qq

A 1-_.;;.;••;._-f"'.._---

rr

X
y

.:._______

OOrr + cc
00rr+cc+1

VY

ppqq

------ti.,,...-:--....

Program
Memory

SPt-----1

PC

PP

--------mm

mm

El
cc

mmmm

mmmm + 1
mmmm + 2

Subtract the contents
contents of the selected memory byte and the complement
complement of the Carry
Subtract
ulator, treating
treating all register
register contents
contents as simple binary
Accumulator.
C), from the Accum
(1 -— C).
status (1
set.
data. Note,
ill be treated as decimal
decimal (BCD)
(BCD) if the D status is set.
however. that all data will
Note. however,

3-91
3-

715,
Suppose that
that xx== 1 415,
ig cc== 1515,
1 g- rr = 3 7
-|g, ppqq = 07E215,
07E2-|g, yy = (07E215)=
1 g) = 3415,
34-|g,
and C = 0. After
fter executing
executing a
SBC
SBC

($15,X)

instruction,
Accumulator
instruction, the contents
contents of the Accum
ulator would
would be altered to DF-|g.
DF15.
=00010100
14 = 0
0010100
Twos complement
complement of

35 = 1 1 0 0 1 0 1 1
1 1101 1 11 111111

Set Carry to 0
o~LNonzero
•
Set S to 1

(see
(see note below)

result sets Z to 0
..._
0
-¥-0 - 0, set V to 0
O-V-O

(1 - C)
C) = xx -— (yy+C):
(yy+C);
Note: xx -— yy -— (1
hence, 1415
-|g - 3415
34-|g - (1
ig - (34-|g
1 g - 3515
35-|6
(1 - 0) = 1 4
415
(3415 + 1)
1) = 1415
is, rather, the inverse of a borrow
Note that the resulting
resulting Carry is not a borrow. It is,
borrow since it
is set to 1 if no borrow
borrow is required
required and cleared if a borrow
borrow is required. You should be
careful of this usage since it differs
careful
differs from that of most other
other microprocessors.
microprocessors, which
which
complement
following
complement the Carry before it is stored follow
ing a subtraction.
subtraction.
SBC is the only binary
SBC
binary subtraction
subtraction instruction.
instruction. To use it in single-byte
single-byte operations
operations or to
subtract
subtract the low-order
low-order bytes of two multibyte
ultibyte numbers, a previous instruction
instruction (SEC)
(SEC)
must explicitly
explicitly set C to 1 so that
that it does not affect
affect the operation. Remember that C must
be set (not cleared) before a subtraction
subtraction since its meaning
meaning is
inverted from the usual
Is inverted
borrow. Note also that the 6502
6502 microprocessor,
microprocessor, unlike
unlike most others, has no subtraction
subtraction
✓
nstruction
in s tru
c tio n that
that does not include
include the Carry.
Carry.

33-92

SEC -— SET CARRY
SEC
SEC
--.,-38
Set the Carry status to 1. No other status or register's
register's contents
contents are affected. Note that
this instruction
instruction is required
required as part of a normal subtraction
subtraction operation
operation since the only
subtraction
SBC, which
subtraction instruction
instruction available on the 6502
6502 microprocessor
microprocessor is SBC,
which also
subtracts
subtracts the complemented
complemented Carry status. This instruction
instruction is also required at the start
start of
a multi-byte
ulti-byte subtraction
subtraction since there is never a borrow
borrow from the least significant
significant byte.
Data

SVBDIZC
s v
a d i z c

Memory

PlI I I I I 111

Program

Memory
Memory

3B

mmmm

mmmm + 1

3-933
3-

ECIMAL
SED -— SET D ECIM
AL MODE

---SED
SED

F8
F8

Set
1. No other status or register's contents
Set the Decimal
Decimal Mode status to 1.
contents are affected.
This instruction
instruction is used to place the 6502
6502 processor in the decimal
decimal mode in which
hich ADC
SBC instructions
and SBC
instructions produce
produce BCD rather than binary results. The programmer
programmer should
be careful
be
careful of the fact that
that the same program will
ill produce different
different results,
depending
results. depending
on the state of the Decimal Mode status. This can lead to puzzling and seemingly
seemingly ran­
random errors if the state of the Decimal Mode status is not carefully
carefully monitored.
Data
Data
Memory

SVBDIZC

Pi I I 111I I I

Program
Memory

mm

F8

3-94

mmmm
mmmm + l1

-

~

TS)
(DISABLE INTERRUPTS)
SEI -— SET INTERRUPT M ASK (DISABLE

-SE!
SEI
78

Set the interrupt
he 6502's
interrupt mask in the Status register. This instruction
instruction disables the
6502's interinter­
rupt
rupt service ability.
ability, i.e., the 6502
6502 will
ill not respond to the Interrupt
Interrupt Request control
control line.
(P)
No other
other registers
registers or statuses are affected.
affected. The Interrupt
Interrupt Mask is bit 2 of the Status (P)
register.
D
ata
Oala

Memory

s
v B
b o
S V
D I Z C

Pi

I I I Iq i I

:jl I
mm

Program
Prog,a
,y
Memory

mm

~mmm+~

78

33-95

l
■

m mmm
---lmmmm
m m m m •♦ 1

------------------------~-

STORE ACCU MULATOR
STA-— STORE
R IN M E MORY
Y
ccumulator
Store the contents
contents of the A ccum
ulator into the specified memory location. This instrucinstruc­
tion offers the same memory addressing modes as the ADC instruction.
instruction, with
ith the excepexcep­
tion that an immediate
mediate addressing mode is not available. The first byte of object
object code
selects the addressing mode as follows:
follows:
7

4 3 2 1 0 ^
4--e,1
6 5 4

~Object
[jJ^££oJ^aJ^aJ^aJ^O ^J ^

Number
Bit Number

Code
Object Code

Bit Value
aaa
for aaa

Hexadecimal
Object Code

Addressing
Addressing Mode

000
001
001
010
011
100
101
101
110
111
111

B1
81
B5
85
B9
89
BD
8D
91
91
95
99
9D

Indirect.
Indirect, pre-indexed
pre-indexed with
ith X
(direct)
Zero page (direct)
used
Not used
Absolute
(direct)
Absolute (direct)
Indirect.
Indirect, post-indexed
post-indexed with
ith Y
Zero page indexed with
ith X
Absolute
Absolute indexed with
ith Y
Absolute
Absolute indexed with
ith X

Number
Bytes
of Bytes
2
2
3
2
2
3
3

We will
ill illustrate
illustrate the STA instruction
instruction with
ith zero page direct
direct addressing. See the discusdiscus­
arithmetic
sion of addressing methods and other arithm
etic and logical instructions
instructions for examples
modes. No statuses are affected.
of the other addressing modes.
Data
Memory

SVBDIZC

p

I II I IIII
___ __,
:--{::-_xox;:;:j
OOqq

AL...._:;";.__-1XL....---I
YL-

__

Program

__.

Memory

SP~------•~--./-,
PC

mm

mm

~ mmmm+2
85
mmmm
1-.....;.qq"----4 mmmm + 1
1----4

mmmm + 2

Accumulator
Store the contents
contents of the Accum
ulator in memory. Suppose that xx== 6315
63-|6 and
3A15.
qq = 3 A
-|6 - After
fter the instruction
instruction
STA

$3A

has been
has
been executed.
executed, the
the contents
contents of
of memory
memory location
location 003A15
003A-|6 will
will be
be 63
1 0 . No registers
registers
6315.
or statuses
statuses are
are affected.
affected.
or

3-96
3-

STX -— STORE
Y
REGISTER X IN M EMORY
STORE IN DEX REGISTER
Store the contents
contents of Index Register X in the selected memory location. The addressing
modes allowed
allowed are:

1)
1)

Zero page (direct) -— STX addr

2)

Absolute
Absolute (direct) -— STX addr16

3)

Zero page indexed with
ith Y -— STX addr.Y

X. There is also no absolute
Note that there are no indexed modes using Index Register X.
instructions that use the zero page indexed
indexed mode. STX and LDX are the only instructions
mode with
ith Index Register Y. No statuses are affected.
follows:
first byte of object
object code selects the addressing mode as follows:
The first
7

6 5 4

3 2

1 0 ^
~B,t

| l |
0 | 0 [ b | b [ l | 1| 0
~Object

Bit Number

--------Object Code
Code

Bit Value
for bb

Hexadecimal
Object Code
Object

Addressing Mode
Addressing

00
01
10
11
11

86
B6
8E
BE
96
9E

(direct)
Zero page (direct)
(direct)
Absolute
Absolute (direct)
Zero page indexed with
ith Y
Not used

Number
Bytes
of Bytes
2
3
2

We will
ill illustrate
illustrate the STX instruction
instruction using zero page indexed addressing with
ith Index
arithmetic
discussion of addressing methods and other arithm
etic and logical
Register Y. See the discussion
modes.
instructions for examples of the other
other addressing modes.
instructions
Data
Da1a

S V B 0

pl

I

z C

Memory

IIIIIII
yy

A
X

yy

y

rr

SP
PC

mm

OOrr + cc

Program
Memory

mm

96
cc

mmmm

mmmm + 1
mmmm + 2

Store the contents
contents of Index Register X in the selected memory byte. Suppose that
E916· After
and yy = E9l6B16,
cc== 2 8
6- rr = 2016,
2016- ar|d
fter executing
executing the
STX

$28,Y

instruction, memory location
location 004815
0048-|g will
ill contain
contain E915.
1 6- No registers or statuses are
instruction.
affected.

3-97

MORY
STY -— STORE IN DEX
EX REGISTER Y IN M E M
ORY
Store the contents
contents of Index Register Y in the selected memory
memory location. The addressing
modes allowed
allowed are:
are:

1)
1)
2)
2)
3)

Zero page (direct) -— STY addr
Absolute
Absolute (direct) -— STY addr16
Zero page indexed with
ith X -— STY addr.X

Note that there are no indexed
Y. There is also no absolute
indexed modes using Index Register Y.
indexed mode. No statuses or registers are affected.
The first byte of object
object code selects the addressing
addressing mode as follows:
follows:
7

6

5 4

3 2

1

0 ^
~B,t

I 1|
0 1 Q| b | b | 1 | o | o t ^
~Object

Bit Number
Number

--------Object Code
Code

Bit Value
for bb

Hexadecimal
Hexadecimal
Object Code
Object

Addressing
Addressing Mode

00
01
01
10
11
11

84
BC
8C
94
9C

Zero page (direct)
Absolute
Absolute (direct)
Zero page indexed with
ith X
Not used

Number
Number
of Bytes
2
3
2

We will
ill illustrate
illustrate the STY instruction
instruction with
ith absolute
absolute direct
direct addressing. See the discusdiscus­
sion of addressing
methods and other
instructions for examples
addressing methods
other arithmetic
arithm etic and logical instructions
modes.
of the other
other addressing
addressing modes.
Data
Data
Memory

SVBOIZC

Pl

IIIIIII
---,:--]1-....!.:YV:.____j ppqq

A

.___ _.

X

v l--vv---1-~SP l- __
_____
PC

mm

4

mm

Program
Memorv

.,_.,,,.

I~

mmmm + 3
t----"'BC'---4
t---'-qq'--....1

mmmm
mmmm ♦ 1

1----'-'PP_....I mmmm + 2
t----4

mmmm + 3

Store the contents
contents of Index Register Y in the selected memory
memory byte. Suppose that
VY= 0 1
115
yy
1 6 and ppqq = 08F316·
08F3i@. After
fte r the
STY

$08F3

instruction
F315
instruction has executed.
executed, memory
memory location
location 0 8 F
3 i6 will contain
contain 01
ig No registers or
0115.
statuses are affected.
affected.

I

3-98
398

l
I

I
I
I

REGISTER X
T AX -— M OVE FROM ACCU MULATOR
R TO IN DEX REGISTER
TAX

_.,-,

Move the contents
Accumulator
contents of the Accum
ulator to Index Register X. Set the Sign and Zero
statuses accordingly
accordingly.
Data
I

i
I
I

AA

S V B D
O

I

I,

Memory

Z C

I

PlxlI I I pqI
p i» i i i i i * n

I

I

A

xx

X

y
Y
SP

PC

mm

---..

-mm

Program

Memory

~

r~

mmmm+l

----AA

I---~

mmmm
mmmm + 1

0015. After
Accumulator
Suppose that xx = 00-|6
fter executing
executing the TAX instruction.
instruction, both the Accum
ulator
and Index Register X will
ill contain
contain 0015.
OOtg.
000
0 000
0000000

O__J

Set S to 0-*-------^

^LZero
"Z e ro result sets Z to 1

following
The follow
ing instruction
instruction sequence will
ill restore the contents
contents of Index Register X from
the Stack after
after completion
completion of a subroutine
subroutine or interrupt
interrupt service routine:
PLA
TAX

;GETOLD
OLD XX REGISTER
REGISTERFROM
FROMSTACK
STACK
;GET
;RESTORETO
TO XX REGISTER
REGISTER
: RESTORE

I

I

3-999
3-

L...._

TAY-MOVE
FROMACCUMULATOR
TAY —
MOVE FROM
ACCUMULATORTO
TOINDEX
INDEXREGISTER
REGISTERYY
TAY
TAY

-----A8
AB

Movethe
thecontents
contents ofofthe
theAccum
Accumulator
Move
ulator totoIndex
IndexRegister
RegisterY.Y.Set
Setthe
theSign
Signand
andZero
Zero
statusesaccordingly.
accordingly.
statuses
S SVBDIZC
V B D I

Data
Data
Z C

Memory

[xJ
IxI1 l
1l I I I l I XT

P
p<xi

A

xx
XX

X
y

SP
PC

.>
mmm
m

Program
Program
Memory
Memory

mm

AB

mmmm
mmmm
mmmm + 1
mmmm + 1

Suppose that xx== Fl
F1 115.
@ After
fter executing
executing the
instruction, both the Accumulator
ulator
the TAY instruction.
and Index
Index Register
Register Y
Yw
will
F115.
and
ill contain
contain F1
-|g.

-J

111
1110
001
10001

,__J

Set
Set S
S to
to 1-<

L

Nonzero result
result sets
LNonzero
sets Z
Z to
to 0
0

The follow
following
willill restore
ing instruction
instruction sequence
sequence w
restore the contents
contents of Index Register Y from
the
the Stack
Stack after
after completion
completion of
of aa subroutine
subroutine or
or interrupt
interrupt service
service routine:
routine:
PLA
PLA
TAY
TAY

:GET OLD
OLD Y REGISTER
REGISTERFROM
;GET
FROM STACK
STACK
:RESTORETO
TOYY REGISTER
REGISTER
;RESTORE

3-100
3
-100

POINTER TO INDEX REGISTER
TSX -— M OVE FROM STACK POINTER
REGISTER X
TSX
TSX
-.--

BA

I

X. Set the Sign and Zero
Move the contents
contents of the Stack Pointer to Index Register X.
acstatuses accordingly.
accordingly. Note that TSX is the only 6502 instruction
instruction that allows you to ac­
saves the value
cess the value in the Stack Pointer. A typical
typical instruction
instruction sequence that saves
of the Stack Pointer in memory location TEMP
TEMP is:
is:
TSX
STX
STX

:MOVE STACK
STACK POINTER
POINTERTO X
;MOVE
:SAVE STACK
STACK POINTER
POINTER IN MEMORY
MEMORY
;SAVE

TEMP
TEMP

I

Data
Data

VBDIZC
S V
B D

I Z C

Memory

Pjxj
I I NI
JxJI
p
l
*l IMI

A
x1-----1~

I

\

Program
Memory

~

SP

ss

PC __

m_m_...,__m_m_

_,[,.~._

I

mmmm + l

BA

mmmm
m mmm+
m m + l1

If, for example,
example. the Stack Pointer contains
ED15. after executing
executing the TSX instruction.
If,
contains ED-|g,
instruction,
ED15.
both the Stack Pointer and Index Register X will
ill contain
contain EDi
g.

L

1101
1011
111
0 110
Set S to 1Set
1__J

LNonzero
Nonzero result sets Z to 0

3-101
3-1

L

_

TXA- — MOVE FROM IN DEX REGISTER
TO ACCU MULATOR
REGISTER XTO

_,

TXA
8A
SA

Accumulator
Move the contents
contents of Index Register X to the Accum
ulator and set the
the Sign and Zero
following
save the contents
statuses accordingly.
accordingly. The follow
ing instruction
instruction sequence will
ill save
contents of In­
Index Register X in the Stack before execution
execution of a subroutine
subroutine or interrupt
interrupt service routine:
TXA
PHA

;MOVE XX REGISTER
REGISTERTO
TO ACCUMULATOR
ACCUMULATOR
;MOVE
;SAVE XX REGISTER
REGISTERIN
IN STACK
STACK
;SAVE
Data
Data

VBOIZC
S V
B O

i

Z C

Memory

xl l l I IxlO I

Pl
’E O T

A
X

rr

~

y

Program

SP
PC

Memory

~

mm

mm

r~mmmm+1
8A

mmmm
mmmm + 1

3816·
Suppose that rr = 3B-|
g. After
fter executing
executing the TXA instruction.
instruction, both Index Register X and
the Accum
ulator will
ill contain
contain 3 B
i0
Accumulator
815.

L

1101
0 0 111 1
0 1 11
O__J
Set S to 0-

LNonzero
sets Z to 0
Nonzero result sets

3-1022
3-1

•

TXS -— MOVE
VE FROM INDEX
EX REGISTER XTO
TO STACK POINTER
TXS
'-v-'

9A

Move the contents
contents of Index Register X to the Stack Pointer
Pointer. No other
other registers or
statuses are affected.
affected. Note that TXS is the only 6502
6502 instruction
instruction that
that allows
allows you to
determine
determine the value in the Stack Pointer. A typical
typical instruction
instruction sequence that loads the
is:
Stack Pointer
Pointer with
ith the value LAST is:
LOX
LDX
TXS

#LAST
#LAST

:GET LOCATION OF
OF STACK ON PAGE
PAGE 1
;GET
:PLACE STARTING
STARTING LOCATION IN STACK POINTER
POINTER
;PLACE

statuses. unlike TSX which
Note that
that TXS does not affect
affect any statuses,
hich affects
affects the Zero and Sign
statuses.
Data

z c

SVBDIZC

~
Memory

pCI I I I I IE IDt
p

A

x--"y

D

iI
j
r

....

!~__m_m_....,~_m_m_._[..-:c_---:-,

mmmm +

1_)

'

Program
Memory

9A

mmmm
mmmm
mmmm
mmmm + 1

F216·
Suppose that
that rr =
— F2-]
g After
fter executing
executing the TXS InstructIon.
instruction, both Index Register X and
the Stack Pointer
Pointer will
ill contain
contain F215.
1 q, making 0 1 F
2 ig the current
current Stack location. No
F216
statuses or other
other registers are affected.

3-103
3-1
03

L

I
I

t

--

TYA
MOVE FROM
ACCUMULATOR
REGISTER Y TO ACCUMULATOR
FROM INDEX REGISTER
TVA-— MOVE

--TYA
98

ccumulator
Move the contents
contents of Index Register Y to the A ccum
ulator and set the Sign and Zero
Insave the contents
statuses accordingly.
accordingly. The follow
ing instruction
instruction sequence will
ill save
contents of In­
following
dex Register Y in the Stack before execution
execution of a subroutine
subroutine or interrupt
interrupt service routine:
ACCUMULATOR
REGISTERTO ACCUMULATOR
;MOVE Y REGISTER
STACK
REGISTERIN STACK
;SAVE Y REGISTER

TYA
PHA

Data
Data
SVBDIZC
v B D

I

Memory

Z C

~rm
lXl I
I II

pfxI
een

A
X
y

rr

~
b

SP
PC

mm

mm

Program
Memory

r

mmmm + 1
9B

mmmm
mmmm + 1

Suppose that rr =
i g. After
fter executing
executing the TYA instruction.
instruction, both Index Register Y and
= A F16·
the Accum
ulator will
ill contain AF-|g.
AF15.
Accumulator
1 0101
1 0 1 111111

L
LNonzero
Nonzero result sets Z to 0

,___J
Set S to 1Set

3-104
3-104

00/6502
6800
/6 5 0 2 COMPATIBILITY
COMPATIBILITY
Although the 6502
6502 microprocessor can certainly be used on its
6800/6602
6800/6502
own merits, one of its important characteristics is its
SIMILARITY
SIMILARITY
microprocessor. This
similarity to the widely
idely used 6800
6800 microprocessor.
programs writtenn for one of these processors
similarity is not sufficient
sufficient to allow programs
processors at
the machine or assembly level
level to be run on the other, but it is sufficient
sufficient so that pro­
programmers can easily move from one CPU
CPU to the other. Most of the external support
devices designed for one of these processors can also be used with the other. Chapters
troduction
icrocomputers:
Volumee 2 —
-Some
Real
9 and 10 of An In tro d
u ctio n to M icrocom
puters: Volum
Some Real
Microprocessors
Microprocessors discuss this hardware compatibility
patibility in more detail.
We will
ill briefly
briefly describe and compare the 6800 and 6502 microprocessors
microprocessors w ith regard
registers. statuses,
statuses. addressing modes,
modes. and instruction
sets. You should note
to their registers,
instruction sets.
that
images. but they are
that the two processors are far from mirror images,
are much closer to each
each
other than either is to an 8080,
8080. Z80,
Z80. F8,
F8. or 2650 microprocessor. This description
description
should give you some idea as to what
hat problems you would
would encounter
encounter in going from one
one
CPU to the other.
CPU

As for registers, both the 6800
6800 and the 6502
6502 have an 8-bit
-b it pri­
pri6800/6602
6800/6502
mary Accumulator
Accumulator (A register) and a 16-bit
16-bit Program
Program Counter
REGISTER
REGISTER
(or PC register). The other registers, however,
however, are slightly
COMPARISON
COMPARISON
different. The 6800 has a second 8-bitit Accum
Accumulator
register). a
ulator (B register),
16-bit
register. and a 16-bit
6502. on the other hand,
hand. has
has two
16-bit Index register,
16-bit Stack Pointer. The 6502,
8-bitit Index registers and an 8-bitit Stack Pointer. Thus the 6502 Index registers cannot
hold a complete
complete 16-bit
16-bit memory address while
hile the 6800 Index register can.
can. Furthermore
the 6800's
6800's RAM Stack can be located anywhere
anywhere in memory because of its 16-bit
16-bit Stack
Pointer while
1.
hile the 6502's
6502's RAM Stack is always located on page 1.
statuses. the 6800
As for statuses,
6800 and 6602
6502 have identical Zero, OverOver­

6800/6502
6800/6602
flow,, Sign, andjn.terrupt
Interrupt Mask
Mask statuses. The difference in the
STATUS
Carry status is that
that the 6800
6800 and 6602
6502 version of this flag
COMPARISON
COMPARISON
have opposite meanings after
after subtraction operations.
operations. The
6800 Carry is set to 1 if a borrow is necessary and to 0 otherwise;
otherwise; the 6502 Carry is set
to 0 if a borrow
borrow is necessary and to 1 otherwise. This difference
difference means that,
that. before a
multi-byte
ulti-byte subtraction
subtraction operation.
operation, the programmer
programmer must clear the Carry on
on the 6800 and
set the Carry on the 6502. The 6800
6800 and 6602
6502 also differ in how they perform
perform
decimal arithmetic;
etic; the 6800 has a Half-Carry flag (or
hile the 6502
(or carry from bit 3)
3) while
has a Decimal Mode flag. The 6502
6602 also has a Break flag which is not present in
in the
6800;
6800; it is not necessary in the 6800 because the 6800 Trap or Software Interrupt
Interrupt in­
instruction
automatically
response.
struction is autom
atically vectored separately from the regular interrupt
interrupt response.

The 6502
6502 microprocessor has many more addressing
addressing modes
modes
6800/6602
6800/6502
than does the 6800.
6800. This is partly necessitated by the fact that
ADDRESSING
the 6502 index registers are only 8 bits long. Table 3-7 compares
MODE
processors. The 6800
COMPARISON
the addressing modes available
available on the two processors.
COMPARISON
microprocessor
modes. no combinations
microprocessor has no indirect
indirect modes,
combinations of indexindex­
ing and indirection.
indirection, and no absolute indexed modes.
modes. There are also some other
differences
differences in terms of which
hich modes are available with
ith particular
particular instructions;
instructions; we will
ill
not discuss those differences.
differences, but they are enumerated in Table 3-6.

3-105
3-1
05

Table
Table

ailable
ory A d d re
ssin g Modes
odes A v a
ila b le
dressing
emory
3-7. M em
Microprocessors
Microprocessors

on

the 6 800
00

and

6800
6800

6502
6602

Immediate
Immediate
(zero-page)
Direct
Direct (zero-page)
Extended (absolute direct)
(absolute)
Indexed (absolute)

Immediate
Immediate
Zero Page (direct)
Absolute
Absolute (direct)
Absolute Indexed
Absolute
Page Indexed
Zero Page
Indirect
Post-Indexed Indirect
Pre-indexed
Indirect
Pre-Indexed Indirect
Indirect
Indirect
Relative (branches only)

Relative (branches only)

6502
502

Note that many different
different variations
variations of indexed addressing
addressing are available on the
microprocessor, but remember that the 6502 index registers are only 8 bits
6502 microprocessor.
long while
hile the 6800 Index register is 16 bits long.
long.

6800/6502
The 6800
6800 and 6502
6502 instruction
6800/6502
instruction sets are similar but not identisets. listing
INSTRUCTION
cal (see
listing first
INSTRUCTION
3-6). Table 3-8 compares the two sets,
(see Table 3-6).
COMPARISON
both. then the 6800 instructhe instructions
instructions which
hich are present in both,
instrucCOMPARISON
tions which
which have no 6502 equivalent.
equivalent, and finally
finally the 6502 instrucinstruc­
tions which
hich have no 6800 equivalent.
equivalent. Obviously
Obviously some of these differences
differences are a direct
direct
minor.
registers. Most of the differences
differences in the statuses and registers.
differences are minor,
result of the differences
and involve instructions
instructions that are a small part of common
common applications
applications programs. One
noticeable difference
difference is that the 6800 has Add and Subtract
Subtract instructions
instructions that do not inin­
noticeable
not. This means that the
SUB) while
volve the Carry status (ADD and SUB)
hile the 6502 does not.
programmer must explicitly
explicitly clear or set the Carry status when
6502 assembly language programmer
its value should not affect
affect an addition
addition or subtraction
subtraction operation. Note that this similarity
ilarity
level: the actual machine
in the instruction
instruction sets does not extend to the object
object code level;
codes are
entirely different
different on the two microprocessors.
are entirely

3-1
06
106

Table 3-8. Comparison of 6800 and 6502 Assembly Language Instruction
Instruction Sets
Sets

I.
1

Common Instructions
Instruction

Meaning

ADC
AND
ASL
sec
BCC
BCS
BCS
BEG
BEQ
BIT
BMI
BMI
BNE
BNE
BPL
BPL
BVC
BVC
BVS
CLC
CLC
CLI
CLI
CLV
CMP
CMP
cpx1
CPY on 6502)
CPX1 (also CPY
DEC
DEC
DEY on 6502)
DEX1 (also DEY
EOR
EOR
INC
INC
INX1 (also
(also INY on 6502)
JMP
JSR
JSR
LOA
LDA
LDX1 (also
(also LDY
LOY on 6502)
LDX1
LSR
LSR
NOP
NOP
ORA
ORA
PHA (PSH
(PSH on 6800)
(PUL on 6800)
PLA (PUL
ROL
AOL
ROR
ROA
RTI
RTI
RTS
ATS
sBc2
SBC2
SEC
SEC
SEI
SEI
STA
STx1
(also STY on 6502)
STX1 (also
TSX
TXS

Add with
ith Carry
Logical AND
rithmetic
A rithm
etic Shift
Shift Left
Branch if Carry Clear
Branch if Carry Set
1)
Branch if Equal to Zero (Z = 1)
Bit Test
1)
Branch if Minus (S = 1)
(Z = 0)
0)
Branch if Not Equal to Zero (Z
(S = 0)
0)
Branch if Plus (S
Branch if Overflow
Overflow Clear
Branch if Overflow
Overflow Set
Clear Carry
(Enable Interrupt)
Clear Interrupt
Interrupt Mask (Enable
Interrupt)
Clear Overflow
Accumulator
Compare Accum
ulator with
ith Memory
Compare Index Register with
ith Memory
Decrement
1)
Decrement (by 1)
Decrement
1)
Decrement Index Register (by 1)
Logical Exclusive-OR
Exclusive-OR
Increment
1)
Increment (by 1)
Increment
1)
Increment Index Register (by 1)
Jump to New Location
Jump to Subroutine
Subroutine
Accumulator
Load Accum
ulator
Load Index Register
Logical Shift
Shift Right
No Operation
Logical (Inclusive) OR
OR
Push
ulator onto Stack
Push Accum
Accumulator
Pull Accum
ulator from Stack
Accumulator
Rotate Left through
through Carry
Rotate Right through
through Carry
Return from Interrupt
Interrupt
Return from Subroutine
Subroutine
Subtract
Subtract with
ith Carry
Set Carry
Set Interrupt
Interrupt Mask
Store Accum
ulator
Accumulator
Store Index Register
Transfer Stack Pointer to Index Register (X)
(X)
(X) to Stack Pointer
Transfer Index Register (X)

11ndex
Index Register X is 16 bits long on 6800.
6800, 8 bits long on 6502 which
which has
has Index
Register Y as well.
SBC has a different
2Note that SBC
different meaning on the 6502 than on the 6800 since.
since.
for subtraction
subtraction operations, the 6800 Carry is the inverse of the 6502 Carry.
Carry.

107
3-1
07

Table 3-8. Comparison
Comparison of 6800
6800 and 6502
6502 Assembly
Assembly Language
Language Instruction
Instruction Sets
(Continued)
(Continued)

II.

Unique 6800
Unique
6800 Instructions
Instruction
ASA
ABA
ADD
ASR
BGE
BGE
SGT
BGT
SHI
BHI
BLE
BLE
BLS
BLT
BRA
BSR
BSR
CSA
CBA
CLR
CLR
COM
. DAA
DES
DES
INS
LOS
LDS
NEG
NEG
SBA
SEV
SEV
STS
STS
SUB
SUB
SWI
TAB
TAP
TBA
TPA
TST
WAI
WAI

III.
Ill.

Meaning
Add
Accumulators
Add Accum
ulators
Add
Add (without
ithout Carry)
rithmetic
A rithm
etic Shift
Shift Right
Branch if Greater than or Equal to Zero
Branch
Branch if Greater than Zero
Branch
Branch if Higher
Higher
Branch if Less than or Equal to Zero
Branch if Lower
Lower or Same
Branch if Less than Zero
Branch Unconditionally
Unconditionally
Branch to Subroutine
Subroutine
Compare
Compare Accumulators
Accumulators
Clear
Logical
Logical Complement
Complement
Decimal
Accumulator
Decimal Adjust
Adjust Accum
ulator
Decrement Stack Pointer
Decrement
Pointer (by 1)
1)
Increment
1)
Increment Stack Pointer
Pointer (by 1)
Load Stack Pointer
Pointer
Negate (Twos Complement)
Complement)
Subtract
Accumulators
Subtract Accum
ulators
Set Overflow
Overflow
Store Stack Pointer
Pointer
Subtract
Subtract (without
ithout Carry)
Software
BRK)
Software Interrupt
Interrupt (like 6502
6502 BRK)
ulator A to Accum
ulator B
Accumulator
Move from Accum
Accumulator
Move from Accum
Accumulator
CCR
ulator A to CCR
ulator B to Accum
ulator A
Move from Accum
Accumulator
Accumulator
ulator A
Move CCR
CCR to Accum
Accumulator
Minus
Test Zero or Minus
Wait
ait for Interrupt
Interrupt

Instructions
Unique 6502
6502 Instructions
Instruction

Meaning

BRK
BRK
CLD
CLO
PHP
PHP
PLP
PLP
SED
SEO
TAX (TAY)
(TAY)
(TYA)
TXA (TYA)

Break (like 6800
6800 SWI)
Clear Decimal
Decimal Mode
Push Status
Status Register onto Stack
Status Register from Stack
Pull Status
Set Decimal
Decimal Mode
Transfer Accum
ulator to Index
Register X (Y)
Transfer
Accumulator
lnde?<Register
(Y)
Transfer
(Y) to Accum
Accumulator
Transfer Index Register X (Y)
ulator

3-108
3 -1
08

MOS TECHNOLOGY 6502
6502 ASSEMBLER
CONVENTIONS
CONVENTIONS
The standard
standard 6502
6502 assembler
assembler is available
available from
from 6502
6502 manufacturers
manufacturers and on many
many
major
networks;
included in most
development
major time-sharing
time-sharing netw
orks; it is also included
ost developm
ent systems.
systems.
Cross-assembler
Cross-assembler versions
versions are available
available for
for most
most large computers
computers and many
many
minicomputers.
minicomputers.

ASSEMBLER
ASSEMBLER FIELD STRUCTURE
The assembly
assembly language
language instructions
instructions have the standard
standard field
field structure
structure (see Table
2-1). The required
delimiters
required delim
iters are:
space after
after aa label.
label. Note
Note that
that all
all labels
labels must
must start
start in
in column
column 1.
1.
1) AA space
space after
after the
the operation
operation code.
code.
2) AA space
comma between
operands in
in the
the address
address field,
field, i.e.,
i.e., between
the offset
3) AA comma
between operands
between the
offset adad­
dress
dress and X or Y to indicate
indicate indexing
indexing with
ith Index
Index Register
Register X or Y respectively.
respectively.
4) Parentheses
Parentheses around
around addresses
addresses that
that are
are to
to be
be used
used indirectly.
indirectly.
5) AA semicolon
semicolon or
or exclamation
exclamation point
point (we
(we w
will use
use the
the semicolon)
semicolon) before
before aa com­
comment.
ment.
Typical
Typical 6502
6502 assembly
assembly language
language instructions
instructions are:
START
LAST

LOA
LDA
ADC
BRK

(1000.X)
(1000.X)
NEXT
NEXT

;GET LENGTH
LENGTH
;GET
SECTION
;END OF SECTION

LABELS
The Assembler
allowss only
Assembler often
often allow
only six characters
characters in labels
labels and truncates
truncates longer
longer
ones. The firs
first t character
character must
must be a letter
tte r wtiile
hile subsequent
subsequent characters
characters must
must be
letters
X. and Y are reserved
letters or numbers.
numbers. The single
single characters
characters A, X,
reserved for
for the AcAc­
cumulator
cumulator and the twoo index
index registers.
registers. The use of operation
operation codes
codes as labels
labels is
often
often not
not allowed
allowed and is not
not good programming
programming practice
practice anyway.
anyway.

PSEUDO-OPERATIONS
PSEUDO-OPERATIONS
Assembler has the
the follow
ing exp
licit pseudo-operations:
pseudo-operations:
The Assembler
following
explicit

.BYTE
.DBYTE
.END
.TEXT
.WORD
=

Byte-Length Data
Data
-— Form Byte-Length
Double-Byte-Length Data with
ith MSBs
MSBs First
First
-— Form Double-Byte-Length
-— End of Program
Program
String of ASCII Characters
Characters
-— Form String
Double-Byte-Length Data with
ith LSBs First
First
-— Form Double-Byte-Length
-— Equate

Other pseudo-operations
pseudo-operations may be implemented
implemented by setting
setting the assembler's
assembler's location
location
Other
counter
counter (denoted
(denoted by *) to a new
new or updated
updated value.
value. Examples
Examples are:
•* = ADDR

*• = •+N
*+N

- Set
Set Program
Program Origin
Origin toto ADDR
ADDR
—
- Reserve
Reserve NN Bytes
Bytes for
for Data
Data Storage
Storage
—

TEXT. and .WORD
.BYTE, .OBYTE
.DBYTE... .TEXT,
.WORD are the Data
.BYTE, .DBYTE,
pseudo-operations
In ROM... .BYTE is
pseudo-operations used to place
place data in
.TEXT,
■TEXT, .WORD
-b it data... .TEXT for 7-bit
7-bit ASCII characters
characters
used for 8-bit
PSEUDO-OPERATIONS
(MSB is zero)... .DBYTE for 16-bit
16-bit data with
ith the most
most sigsig­
nificant
first. and .WORD
16-bit addresses
addresses or data with
s1gn1ficant bits
nificant bits
bits first,
.WORD for 16-bit
ith the least significant
bits
first. Note
Note particularly
particularly the difference
difference between
between .DBYTE and .WORD.

3 -1
09
-109

Examples:
ADDA
ADDR

.WORD
.WORD

$3165
$3165

(ADDA)== 665
(hex).
results in (ADDR)
5 and
and (ADDR+1) = 3131(hex).
TCONV

.BYTE
.BYTE

32
32

(2015)
ROM and
This pseudo-operation
pseudo-operation places the number
number 32 (20-|
6> in the next byte of ROM
assigns the name TCONV to the address of that byte.
ERROR
ERROR

.TEXT
.TEXT

/ERROR/
/ERROR/

This pseudo-operation
ASCII characters E,
E, R,
R, R,
R. 0.
pseudo-operation places the 7-bit
7-bit ASCII
0, and R into the next
five bytes of ROM
ROM and assigns the name ERROR
ERRORto the address of the first byte. Any
single character
just/)/) may be used to surround the ASCII text,
text. but
character (not just
but we will
ill always
use / for the sake of consistency.
consistency.
MASK

.DBYTE
.DBYTE

$1000
$1000

results in (MASK)=
(MASK) =10
10 and
and (MASK+1) ==00.
00.
OPERS
OPERS

.WORD

FADD, FSUB.
FSUB. FMUL.FDIV
FMUL.FDIV
FADD.

FADD. FSUB.
FSUB. FMUL,
FMUL. and FDIV in the next
This pseudo-operation
pseudo-operation places the addresses FADD,
eight
OPERS to the
eight bytes of memory (least significant
significant bits first) and assigns the name OPERS
address of the first
first byte.
•+N
Reserve pseudo-operation
The operation
operation '• = *+
N is the Reserve
pseudo-operation
SET ORIGIN
PSEUDO-OPERATION
used to assign locations in RAM; it allocates a specified
number
number of bytes. = is the Equate or Define pseudo-operanames. •* = ADDR
ADDA is the standard Origin pseudo-operation.
tion used to define
define names.
pseudo-operation.
6502
6502 programs usually have several origins
origins which
which are used as follows:
follows:
1)
1)

Reset and interrupt
addresses. These addresses must be
To specify
specify the Reset
interrupt service addresses.
FFFA15 through
placed in the highest
highest memory addresses in the system (usually FFFA-|g
through
FFFF16).
FFFF15).

2)

Reset and interrupt
To specify
specify the starting
starting addresses of the actual Reset
interrupt service routines.
The routines themselves may be placed anywhere
anywhere in memory.

To specify
specify the
the starting
starting address
address of
of the
the main
main program.
program.
3) To
To specify
specify the
the starting
starting addresses
addresses of
of subroutines.
subroutines.
4) To
To define
define areas
areas for
for RAM
RAM storage.
storage.
5) To
To define
define an
an area
area (always
(always on
on page
page 1)
1) for
for the
the RAM
RAM Stack.
Stack.
6) To
7) To
To specify
specify addresses
addresses used
used for
for I/O
1/0 ports
ports and
and special
special functions.
functions.
7)

Examples:
RESET
RESET

=$3800
=$3800
•=$FFFC
*=$FFFC
.WORD
*=RESET
*=RESET

RESET
RESET

"hexadecimal".
Note: $ means "hexadecim
al".
This sequence places the Reset
Reset instruction
instruction sequence in memory
memory beginning
beginning at address
0015.
an~ places that address in the memory locations
(addresses FFFC-|6
FFFC15 and
380
0 ig , and
locations (addresses
CPU retrieves the Reset
Reset address.
address.
FFFD15)
1 6 ) from which
which the 6502 CPU
The instruction
instruction sequence which
hich follows
follows is stored in memory beginning
beginning at location
C000-|6.
C00015
MAIN

=$C000
=$COOO
•=MAIN
*=M
A IN
.END simply
.END
ply marks the end of the assembly language program.

3-110
3-110

LABELS WITH
LABELS
IT H PSEUDO-OPERATIONS
PSEUDO-OPERATIONS
The rules and recommendations for labels with
ith 6502
6502 pseudo-operations are as
follows:
1)
1)
2)
2)
3)

Simple
Simple equates, such as MAIN =$C000.
=$C000, require labels since their purpose is to
define
labels.
define the meanings
meanings of those labels.
.BYTE, .DBYTE
TEXT.. .WORD,
WORD. and * =
•=•+N
.BYTE.
.DBYTE,.. .TEXT,
'+ N pseudo-operations
pseudo-operations usually
usually have labels.
.END should not have a label,
label. since the meaning of such a label is unclear.
.END

ADDRESSES
The 6502 Assembler
Assembler allows
allows entries in the address field in any
of the follow
following
ing forms:

1)
1)
2)
3)
4)
5)
6)

Decimal
case)
Decimal (the default
default case)
Example: 1247
Hexadecimal
Hexadecimal (must start with
ith $)
$CEO0
Example: $CE00
Octal (must start with
ith @)
@)
Example: @1247
Binary (must start
%)
start with
ith %)
Example: %11100011
ASCII (single character
character preceded by an apostrophe)
Example: 'H

NUMBERS AND
CHARACTERS IN
ADDRESS FIELD

(•)
As an offset
offset from the Program Counter
Counter (*)
Example: •+
*+ 77

addressing modes are distinguished as
The various 6502
6502 addressing
follows:
s:

ADDRESSING
MODES

•

Absolute
Absolute or Zero Page (direct) are the default
default modes
(the Assembler
Assembler chooses Zero Page if the address is less than 256, and Ab­
Absolute
solute otherwise).
# for immediate
immediate mode (precedes the data)
address)
,X or ,Y for indexing
indexing (follows
(follows the offset
offset address)

•

Parentheses around
around addresses that
that are used indirectly
indirectly so that
that

•

•

(addr.X) indicates
(addr.X)
indicates pre-indexing
pre-indexing (indexed address used indirectly)
indirectly)
(addri.Y indicates
post-indexing (indirect
ndexed)
(addrl.Y
indicates post-indexing
(indirect address is indexed)

(addr) indicates
(addri
indicates indirection
indirection with
ith JMP instruction
instruction only

______

In the indexed modes, as in the direct
direct modes,
Assembler autom
atically chooses the
modes. the Assembler
automatically
Zero Page version if it is permitted
permitted and if the address is less than 256.

,.

ASSEMBLER
The Assembler
Assembler also allows
allows expressions
expressions in the address field. These
ARITHMETIC
ARITHMETIC
consist of numbers
numbers and names separated by the
expressions consist
EXPRESSIONS
arithmetic
operators+.+ , -, "• (multiplication).
arithm
etic operators
(multiplication), or// (integer
(integer division).
The Assembler
Assembler evaluates
evaluates expressions from left to right;
right; no
allowed to group
group operations,
operations, nor is there any hierarchy
hierarchy of operations.
parentheses are allowed
Fractional results are truncated.
truncated.
Fractional
that you avoid expressions w ithin
in address fields whenever
whenever possi­
We recommend that
possible. If you must compute
compute an address, comment
ent any unclear
unclear expressions and be sure
that the evaluation
evaluation of the expressions never produces a result
result which
which is too large for its
ultimate
use.
ultim
ate use.

3-111
3-111

OTHER ASSEMBLER
ASSEMBLER FEATURES
The standard 6502 Assembler
Assembler has neither
neither a conditional
conditional assembly capability
capability nor a
macro capability.
capability. Some 6502 assemblers have one or both of these capabilities.
capabilities, and
you should consult
consult your manual for a description.
description. We will
ill not use or refer to either
capability
capability again.
again, although
although both can be quite
quite convenient
convenient in actual applications.
applications.

3-1
12
112

Chapter 4
SIMPLE PROGRAMS
programming is through experience.
language programming
ay to learn assembly language
experience. The
The only way
programs that
next six chapters of this book contain examples
examples of simple programs
that perform
next
should read each example carefully and try to
actual microprocessor tasks. You should
should work
execute the program on a 6502-based
6502-based microcomputer. Finally, you should
ork
execute
insure
programs to insure
the problems at the end of each chapter and run the resulting programs
that you understand the material.
chapter contains
contains some very elementary
elementary programs.
This chapter

GENERAL
GENERAL FORMAT OF EXAMPLES
EXAMPLE
FORMAT
FORMAT

Each
ing parts:
program example contains the following
Each program
1)
1)

A title
title that
that describes
describes the general problem.

2)

A statement
statement of purpose that describes
describes the specific
specific task that
that the program
program performs
uses.
and the memory locations
locations that it uses.

3)

results.
and results.
data and
with data
A
problem w
sample problem
A sample

4)

complex.
is complex.
logic is
A
chart ifif the
program logic
the program
flowchart
A flow

listing.
language listing.
assembly language
or assembly
5) The
program or
source program
The source
6) The
language listing.
listing.
machine languag.e
hexadecimal machine
or hexadecimal
program or
object program
The object
7)

Explanatory notes that discuss the instructions
instructions and methods
methods used in the program.
Explanatory

You should
examples as guidelines for solving the problems at the end of
should use the examples
ineach chapter. Be sure
6502-based microcomputer to in­
sure to run your solutions on a 6502-based
sure
that they are correct.
sure that
programs in the examples have been constructed
constructed as follows:
follows:
The source programs

-----

..

GUIDELINES
FOR
FOR
EXAMPLES

1)
1)

assembler notation
notation is used,
summarized in
used. as summarized
Standard 6502 assembler
Chapter 3.
Chapter

2)

which data and addresses appear are selected for
The forms in which
clarity rather than for consistency.
consistency. We use hexadecimal
hexadecimal numnum­
clarity
bers for memory addresses,
instruction codes,
decimal for numeric
numeric
codes. and BCD data; decimal
addresses. instruction
constants; binary
binary for logical
logical masks; and ASCII for characters.
constants;

3)
3)

Frequently used instructions
instructions and programming
programming techniques
techniques are emphasized.
Frequently

4)

Examples illustrate
illustrate tasks that microprocessors
microprocessors perform
perform in communications.
communications, instruinstru­
mentation, computers.
computers, business equipment.
equipment, industrial.
industrial, and military
ilitary applications.
applications.
mentation.

5)
5)

comments are included.
Detailed comments

6)

Simple and clear structures
structures are emphasized,
but programs
programs are as efficient
efficient as possipossi­
emphasized. but
Simple
ble within
ith in this guideline.
guideline. The notes often describe
describe more efficient
efficient procedures.

7)

Programs use consistent
allocations. Each program
program starts in memory loca­
locaconsistent memory allocations.
icrocomputer
tion 0000 and ends with
ith the Break (BRK)
instruction. If your m icrocom
puter has no
(BRK) instruction.
inmonitor
onitor and no interrupts,
interrupts, you may prefer to end programs
programs with
ith an endless loop in­
struction, e.g.,..
struction.
HERE
HERE

JMP

4-1

HERE
HERE

Some 6502-based
JSR instruction
6502-based microcomputers
icrocomputers may require a JMP or JSR
instruction with
ith a
specific
specific destination
destination address to return
return control
control to the monitor.
monitor. Other microcomputers
icrocomputers
may require you to specify
BAK instruction
specify the monitor
onitor address to be used by the BRK
instruction. For
example.
COOinto addresses
example, if you are using the popular
popular KIM-1.
KIM-1, you will
ill have to load 1COO
17FE
- the 00 must
17FE and the 1C into
17FE and 17FF.
17FF. Be carefu
carefulI —
must be loaded into address 17FE
address 17FF.
17FF. Wee will
ill explain
explain later how the 6502
6502 stores addresses and how it impleimple­
ments the BRK
BAK instruction
(see Chapter
12).
instruction (see
Chapter 12).
Consult the User's Manual
Manual for your
your m icrocom
puter to determ
ine the required memory
Consult
icrocomputer
determine
allocations
your particular
particular system.
allocations and terminating
inating instruction
instruction for your

GUIDELINES FOR SOLVING PROBLEMS
Use the following
ing guidelines in solving the problems at the end of each chapter:
1)
1)

Comment
Comment each
each program
program so
so that
that others
others can
can understand
understand it.
it.
PROGRAMMING
PROGRAMMING
The comments
comments can be brief
brief and ungrammatical:
ungrammatical; they
GUIDELINES
explain the purpose of a section
section or instruction
instruction in
should explain
the program. Comments
Comments should
should not describe
describe the operation
operation
of instructions;
instructions; that
that description
description is available
available in manuals. You do not have to com-­
ment
exment each statement
statement or explain
explain the obvious. You may follow
follow the format
at of the ex­
but provide
provide less detail.
amples but

2)

Emphasize clarity.
clarity, simplicity,
plicity, and good structure
structure in programs. While
hile programs
should be reasonably efficient.
efficient, do not worry
worry about saving a single byte of program
memory
memory or a few microseconds.
microseconds.

3)

Make programs
programs reasonably
reasonably general.
general. Do
Do not
not confuse
confuse parameters
parameters (such
(such as
as the
the num
num-­
Make
1r or ASCII C).
C).
ber of elements
elements in an array) with
ith fixed constants
constants (such as it

4)

Never assume
assume fixed
fixed initial
initial values
values for
for parameters;
parameters; i.e.,
i.e.. assume
assume that
that the
the parameters
parameters
Never
RAM.
are already in RAM.

5)

Use
Chapter 3.3.
Use assembler
assembler notation
notation as shown
shown in
in the
the examples
examples and defined
defined ininChapter

6)

Use
Use hexadecimal
hexadecimal notation
notation for
for addresses.
addresses. Use the clearest
clearest possible
possible form
form for data.
data.

7)

If your m icrocom
icrocomputer
it. start
puter allows
allows it,
start all programs
programs in memory location 0000 and
4016
use memory
memory locations
locations starting
starting with
ith 0 0 4
0 -|q for data and temporary
temporary storage. OtherOther­
establish equivalent
equivalent addresses for your
your m icrocom
puter and use them consisconsis­
wise. establish
icrocomputer
tently. Again.
Again, consult
consult the user's manual.

8)

CHECK rather
Use meaningful
meaningful names for labels and variables: e.g.... SUM or CHECK
rather than X.
Y,
Y. or Z.

9)

Execute each
each program
program on
on your
your microcomputer.
There isis no
no other
other way
way of
of ensuring
ensuring
Execute
microcomputer. There
that
Be
that your
your program
program is correct. We have provided
provided sample data with
ith each problem. Be
cases.
sure that
that the program
program works
works for special
special cases.

We now summarize some useful information that you should
We
should keep in mind when
programs.
writingg programs.
Almost
Subtract. AND,
AND.
ost all processing
processing instructions
instructions (e.g.. Add. Subtract,
USING THE
OR) use the contents
Accumulator
OR)
contents of the Accum
ulator as one operand and
ACCUMULATOR
ACCUMULATOR
place the result
cases. you
result back in the Accumulator.
Accumulator. In most cases,
Accumulator
LOA. You will
will
ill load the initial
initial data into
into the Accum
ulator with
ith LDA.
ill store the result from
the Accum
ulator into memory
memory with
ith STA.
Accumulator

4-2
4-

USING
Frequently
Frequently accessed data and frequently
frequently used base addresses or
ZERO
PAGE ZERO
pointers should be placed on page zero of memory. This data can
OF MEMORY
MEMORY
(direct). pre-indexed.
then be accessed with
ith zero-page (direct),
pre-indexed, postpost­
indexed. and zero-page indexed addressing. Note in particular
indexed,
particular that
pre-indexing
zero.
pre-indexing and post-indexing
post-indexing both assume that an address is stored on page zero.
The zero-page direct
direct and indexed modes both require less time and memory than the
corresponding
modes.
corresponding absolute addressing modes.
1). and decrement
1) can act
Some instructions.
instructions, such as shifts.
shifts, increment
increment (add 1),
decrement (subtract
(subtract 1)
directly
directly on data in memory. Such instructions
instructions allow you to bypass the user registers but
they require extra execution
CPU
execution time since the data must actually
actually be loaded into the CPU
and the result must be stored back into memory.

4-3

PROGRAM EXAMPLES
PROGRAM
8 -Bit
it Data Transfer
Purpose: Move the contents
contents of memory location 0040 to memory location 0041.
Sample Problem:

Result:

(0040)

=

6A

(0041)

=

6A

Source Program:
LDA
STA
BRK
BRK

$40
$40
$41
$41

;GET
:GETDATA
DATA
;TRANSFERTO
TONEW
NEWLOCATION
LOCATION
TRANSFER

Object
Object Program:
Program:
Memory
Memory Location
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004

A5
40
85
41
41
00

Instruction
Instruction
(Mnemonicl
(Mnemonic)
LDA

$40

STA

$41
$41

BRK
BRK

LOA (Load
(Load Accumulator)
(Store Accumulatorl
need an address to deterThe LDA
Accumulator) and STA (Store
Accumulator) need
deter­
mine the source or destination
destination of the data.
data. Since the addresses used in
in the example are
is. the eight most significant
zero), the zero
zero page (direct)
on page zero (that is,
significant bits are all zero),
(direct)
used with
form of the instructions
instructions can be used
ith the address in the next word. The leading
zeros can be omitted.
addresses are really 0040 and 0041, but the shorthand
zeros
omitted. The addresses
shorthand form
can be used just as in everyday conversation
conversation (e.g
(e.g.,.. we say "sixty
"sixty cents"
cents" rather than
"zero dollars and sixty cents").
BRK (Force
(Force Break)
Break) is used to end all the examples and return control
BRK
control to the monitor.
Remember that you may have to replace this instruction
instruction with
ith whatever
whatever your microcomicrocom­
puter requires.
requires.

4-4
4-

8-Bitit Addition
Purpose: Add the contents
contents of memory
memory locations
locations 0040
0040 and 0041, and place the result
in memory location
location 0042.
Sample Problem:

Result:

(0040)
(0041)

=
=

38
28
2B

(0042)

=

63

Source Program:
CLC
CLC
LOA
LDA
ADC
STA
BRK
BRK

$40
$41
$42

;CLEAR CARRY
CARRY TO START
START
;CLEAR
;GET FIRST
FIRST OPERAND
OPERAND
;GET
;ADD SECOND
SECOND OPERAND
OPERAND
;STORE RESULT
RESULT
;STORE

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0005
0006
0007

18
A5
40
65
41
85
42
00

Instruction
Instruction
(Mnemonic!
(Mnemonic)
CLC
CLC
LOA
LDA

$40

ADC

$41

STA

$42

BRK
BRK

Carry),
The only addition
addition instruction
instruction on the 6502 microprocessor
microprocessor is ADC (Add with
ith Carry),
which
(Al =
= (A)
(A) + (M)
(Ml++ (Carry)
(Carry) where
which results in (A)
where M is the addressed memory location.
Carry) instruction
Thus, we need the initial
initial CLC (Clear Carry)
instruction if the value of Carry is not to
affect
affect the addition.
addition. Remember
Remember that the Carry will
ill be included
included in all additions
additions and
subtractions.
subtractions.
The zero-page (direct) forms of all instructions
instructions are used, since all the addresses are in
the first
first 256 bytes of memory.

LOA and STA do not. Only arithm
arithmetic
ADC affects
affects the Carry bit, but LDA
etic and shift
shift instrucinstruc­
tions affect
affect the Carry; logical
logical and transfer
transfer instructions
instructions do not.
LDA
affect the contents
contents of memory. STA changes the contents
contents of the
LOA and ADC do not affect
addressed memory location
location but does not affect
affect the contents
contents of the Accumulator.
Accumulator.

(D) flag is cleared when
Be·sure
sure that
that the Decimal
Decimal Mode (D)
when you execute this program. To be
absolutely
CLO instruction
(0815)
absolutely certain
certain of the D flag's
flag's state, you could add a CLD
instruction (D8-|
0 ) to the
start of the program. If you are using the KIM-1
KIM-1 microcomputer,
microcomputer, you should clear
memory location
OOF1 to ensure that
location OOF1
that the Decimal
Decimal Mode flag does not interfere
interfere with
ith
your programs or with
ith the monitor.

4-5
4-

Shift Left One Bit
Purpose: Shift
Purpose:
Shift the contents
contents of memory location 0040 left one bit and place the result
into memory location 0041. Clear the empty
empty bit position.
Sample Problem:

Result:

(0040)

=

6F

(0041)
(0041)

=

DE
DE

Program:
Source Program:
LOA
LDA
ASL
STA
BRK
BRK

$40
A
$41
$41

:GET DATA
;GET
:SHIFT LEFT
LEFT
;SHIFT
;STORE RESULT
RESULT
;STORE

Object
Program:
Object Program:
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005

A5
40
OA
OA
B5
85
41
41
00

Instruction
Instruction
(Mnemonic)
LOA
LDA

$40

ASL
STA

A
$41
$41

BRK
BRK

Accumulator
The instruction
instruction ASL A shifts the contents
contents of the Accum
ulator left one bit and clears the
Carry. The result is twice
least significant
significant bit. The most significant
significant bit is moved into the Carry.
(why?).
the original
original data (why?).
inNote that we could
Id also shift
shift the contents
contents of memory location 0040 one bit with
ith the in­
struction
struction ASL $40 and then move the result to memory location 0041. This method
would.
however. change the contents
would, however,
contents of memory location 0040 as
contents
as well as the contents
of memory location 0041.

4-6
4

Mask Off Most
s t Significant
Significant Four
Four Bits
sigleast sig­
Purpose: Place the least significant
significant four bits of memory location 0040
0040 in the least
nificant four bits of memory location
location 0041. Clear the most significant
significant four
nificant
location 0041.
bits of memory location
Sample Problem:

It:
Result:

30
3D

(0040)

=

(0041)

= OD
0D

Source Program:
LDA
LOA
AND
STA
BRK
BRK

$40
#% 00
00
1
00001111
$41

;GET
DATA
:GETDATA
MSB'S
;MASK
;MASK44MSB'S
RESULT
;STORE
;STORERESULT

mediate addressing and % means binary constant
constant in standard 6502
Note: # means immediate
Assembler notation.
Assembler

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006

A5
40
29
OF
OF
85
41
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$40

AND

#% 00
0 0 1 111
00001111

STA

$41
$41

BRK
BRK

Accumulator
AND # % 0 0
00
1 logically
logically ANDs the contents
contents of the Accum
ulator with
ith the number
00001111
OOOF.Immediate
OF-]6
contents of memory location
location 000F.
Immediate addressing (indicated by
OF15 -— not the contents
#)) means that
that the actual data, not the address of the data,
instruc­
data. is included in the instruction.
Bireader. Bi­
The mask (00001111)
(00001111) is written
ritten in binary
binary to make its purpose clearer to the reader.
nary notation
notation for masks is clearer than hexadecimal
hexadecimal notation
notation since logical operations
course. does
result. of course,
are performed
performed bit-by-bit
it-by-bit rather than digits
digits or bytes at a time. The result,
not depend on the programm
ing notation.
notation. Hexadecimal notation
notation should be used for
programming
masks longer than eight
eight bits because the binary versions become long and cumbercumber­
some.
comments should explain the masking operation.
some. The comments
example. the
use. For example,
A logical AND instruction
instruction may be used to clear bits that are not in use.
four least significant
significant bits of the data could be an input
input from a ten-position
ten-position switch
switch or an
four
output
output to a numeric
numeric display.

4-7

Clear a M emory
ory Location
Purpose: Clear memory location 0040.

Source Program:
LOA
LDA
STA
BRK
BRK

#0
#0
$40
$40

;CLEAR LOCATION 40
40
:CLEAR

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0004

A9
00
85
40
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

#0

STA

$40

BRK
BRK

has no explicit
Zero is handled no differently
differently than any other number -— the 6502 has
explicit Clear
instruction.
However. remember
LOA #00 does set the Zero flag
instruction. However,
remember that LDA
flag to one.
one. Always
watch
(Zero) flag is set to
to one if the last result was zero.
zero.
watch this logic -— the Z (Zero)
STA does not affect
flags.
affect any status flags.

4-8
4-

Word Disassembly
and
Purpose: Divide the contents
contents of memory location 0040 into two 4-bitit sections and
Place the four most signifi·
store them in memory locations 0041 and 0042. Place
signifi­
significant bit positions
cant bits of memory location 0040 into the four least significant
of memory location 0041;
0041; place the four least significant
significant bits of memory
significant bit positions of memory location
location 0040 into the four least significant
significant bit positions of memory locations 0041
0042. Clear the four most significant
and 0042.
Sample Problem:

Result:
Result:

(0040)

=

3F

(0041)
(0042)

=
=

03
OF
OF

Source Program:
LDA
LOA
AND
STA
LDA
LOA
LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA
BRK
8RK

;GET
;GET DATA
MS8'S
OFF MSB'S
;MASK OFF
LS8'S
;STORE
;STORE LSB'S
;RESTORE
;RESTOREDATA
LOGICALLY
TIMES
RIGHT 4 TIMES
SHIFT DATA RIGHT
:LOGICALLY SHIFT

$40
#% 00
0 0 1 111
%00001111
$42
$40
A
A
A
A
$41

;STORE
MS8'S
:STORE MSB'S

Object Program:
Object

Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
0008B

A5
40
29
OF
F
85
42
A5
40
4A
4A
4A
4A
85
41
00

oooc
oooc
000D
00D
000E
OOOE

Instruction
Instruction
(Mnemonic)
LDA

$40

AND

#% 00
0 0 1 111
00001111

STA
STA

$42

LDA

$40

LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA
STA

A
A
A
A
$41
$41

BRK
8RK

A logical shift
shift right
right of four positions requires four executions
executions of the LSR
LSR A instruction.

Thus. the four most
result. Thus,
Each
instruction clears the most significant
significant bit of the result.
LSR instruction
Each LSR
been executed four
has been
LSR A has
significant bits of the Accum
ulator are all cleared after LSR
Accumulator
significant
times.
times.
You might
ight wish to try rewriting
riting the program so that it saves
saves a copy of the data in Index
Register X rather than loading the same data twice. Which
hich version do you prefer and
why?

4 -9

Find Larger of T wo Numbers
Find
Purpose: Place the larger of the contents
contents of memory locations
locations 0040 and 0041 into
memory location 0042. Assume that the contents
contents of memory locations
locations 0040
0040
and 0041 are unsigned
unsigned binary numbers.
Sample Problems:
a.
a.
Result:

b.
Result:

(0040)
(0041)

=
=

3F
2B
28

(0042)

=

3F

(0040)
(0041)

=
=

75
A8
AB

(0042)

=

A8
AB

Program:
Source Program:

STRES
STRES

LDA
LOA
CMP
BCS
BCS
LOA
LDA
STA
BRK
BRK

$40
$41
$41
STRES
STRES
$41
$41
$42

:GET FIRST
FIRST OPERAND
OPERAND
;GET
;IS SECOND
SECOND OPERAND
OPERAND LARGER?
:IS
LARGER?
:YES. GET
GET SECOND
SECOND OPERAND
OPERAND INSTEAD
INSTEAD
;YES.
:STORE LARGER
LARGER OPERAND
;STORE
OPERAND

Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA

A5
40
C5
41
41
BO
B0
02
A5
41
41
85
42
00

Instruction
Instruction
(Mnemonic)

STRES
STRES

LOA
LDA

$40

CMP
CMP

$41
$41

BCS
BCS

STRES
STRES

LDA
LOA

$41
$41

STA

$42

BRK
BRK

CMP $41 subtracts
subtracts the contents
contents of memory
memory location
location 0041 from the contents
contents of the Acc­
cumulator
Is used merely to set
cum
ulator but does not store the result anywhere. The instruction
instruction is
the flags for a subsequent
subsequent conditional
conditional branch.
CMP affects the flags as follows:
follows:

1) N takes
takesthe
the value
value of
1)
of the
the most
most significant
significant bit
bit of
of the
the result
result of the
the subtraction.
subtraction.
2)

Z isis set
set to
to 11 ifif the
the result
O otherwise.
result of
of the
the subtraction
subtraction Is
is zero
zero and
and to
to 0
otherwise.

3)

set toto 11 ifif the
the subtraction
C isisset
subtraction does
does not
not require
require aa borrow
borrow and
and to
to O
0 ifif itit does.
does. Note
Note
that
that C is an inverted
inverted borrow, not the actual
actual borrow
borrow as it is on many other
microprocessors.

4)

not affected.
affected.
V isisnot

4-100
4-

Note the follow
following
ing cases:
1)
1)

If the operands
equal. Z = 1; if they are not equal.
0.
operands are equal,
equal, Z = 0,

2)

Accumulator
If the contents
contents of the Accum
ulator are greater
greater than or equal to the contents
contents of the
other address (considering
(considering both as unsigned
unsigned binary
borother
binary numbers), C = 1,
1, since no bor­
= 0.
row would
would then be needed. Otherwise,
Otherwise, C =

Allll 6502
6502 conditional
conditional branch
branch instructions
instructions use relative
relative addressing.
addressing, in which
hich the second
word
CPU adds to the
word of the instruction
instruction is an 8-bit
-b it twos complement
complement number
number which
which the CPU
address of the next instruction
instruction to calculate
calculate the destination
destination address. In the example,
example, the
relative
following
relative offset
offset is 0008
0008 (destination
(destination address) - 0006
0006 (address immediately
immediately follow
ing the
branch) or 02. Obviously,
Obviously, calculating
calculating relative
relative offsets
offsets is error-prone,
error-prone, particularly
particularly if the
result
result is negative;
negative: however,
however, if you label all target
target instructions,
instructions, the assembler
assembler will
ill perper­
form the calculations
calculations for you.

BCS causes a branch
zero. the processor
BCS
branch if the Carry is one. If the Carry is zero,
processor continues
continues exex­
ecuting
ecuting instructions
instructions in their
their normal
normal sequence
sequence as if the Branch instruction
instruction did not exist.
STRES is a label.
that the programmer
programmer assigns to a memory
STRES
label, a name that
memory address so that
that it is
easier to remember
remember and locate. Note that
that labels are followed
followed by a space on the line
where
where they are defined.
defined. The label makes the destination
destination of the branch
branch clear, particularly
particularly
when
when relative
relative addressing
addressing is being used. Using a label is preferable
preferable to just
|ust specifying
specifying the
offset
(ie, 8CS"+4)
6502's instructions
another user of
offset (i.e.,
BCS*+4) since the 6502's
instructions vary in length. You or another
determining
the program
program could
could easily make an error in determ
ining the offset
offset or the destination
destination.

4-11

1 6-Bit
-B it Addition
Purpose: Add the 16-bit
Purpose:
16-bit number
number in memory locations 0040
0040 and 0041 to the 16-bit
number
number in memory locations 0042 and 0043. The most significant
significant eight bits
locaare in memory locations 0041 and 0043. Store the result in memory loca­
tions 0044
0044 and 0045.
0045, with
ith the most significant
significant bits in 0045.

Sample Problem:
(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

2A
67
F8
F8
14

Result=672A
+ 14F8
14F8 =
= 7C22
Result=672A +
(0044)
(0044)
(0045)
(0045)

22
= 7C

Program:
Source Program:
CLC
CLC
LOA
LDA
ADC
STA
LOA
LDA
ADC
ADC
STA
BRK
BRK

$40
$42
$44
$41
$41
$43
$45

;CLEAR CARRY
CARRY TO START
START
;CLEAR
LEAST SIGNIFICANT
SIGNIFICANT BITS
BITS
;ADD LEAST

:ADD MOST SIGNIFICANT
SIGNIFICANT BITS
BITS WITH CARRY
CARRY
;ADD

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
000A
000B
000B
oooc
OOOC
000D

18
18
A5
40
65
42
85
44
A5
41
41
65
43
85
45
00

Instruction
Instruction
(Mnemonic)
CLC
CLC
LDA
LOA

$40

ADC

$42

STA

$44

LDA
LOA

$41
$41

ADC

$43

STA
STA

$45

BRK
BRK

You must clear the Carry before the first addition
addition since there is never a carry into the
bits.
least significant
significant bits.

automatically
ADC then autom
atically includes the Carry from the least significant
significant bits in the addition
addition
of the most significant
significant bits. Thus the microprocessor
microprocessor can add data of any length:
length; it adds
numbers eight
eight bits at a time with
ith the Carry transferring
transferring information
ation from one 8-bitit sec­
secNote. however,
tion to the next. Note,
addition requires the execution of three
however. that each 8-bitit addition
instructions
(LOA. ADC,
ADC. STA)
instructions (LDA,
accumulator.
STA) since there is only one accumulator.

4 -12
12

- --------------=

Squares
Table of Squares
Purpose: Calculate the square of the contents
contents of memory location 0041 from a table
and place the result in memory location 0042. Assume that memory location
7.
$ 7.
$ (0041) <
O and 7 inclusive
0041 contains
contains a number
number between 0
inclusive -— 0 <
0050 to 0057.
The table occupies memory locations 0050

Entry

Memory Address
Memory
(Hex)

(Hex)

0050
0051
0052
0053
0054
0055
0056
0057

00
01
04
09
10
19
24
31
31

(Decimal)
0
1
1
4
9
16
25
36
49

(02)
(0?)
(12)
(1?
(22)
(2Z)
(32)
(3
j
(42)
(4‘
(52)
(5,)
(62)
(6,)
(72)
(7

Sample Problems:
(0041)

=

Result:

(0042)

= 09
09

(0041)

= 06
06

Result:

(0042)

= 24
24

a.
a.

b.

03

Remember that the answer is a hexadecimal number.

Source Program:

SOTAB

LDX
LOX
LDA
LOA
STA
BRK
BAK
*=
$50
·=$50
BYTE
.BYTE

;GET
:GET DATA
;GET
OF DATA
SQUARE OF
:GET SQUARE
;STORE
SQUARE
:STORE SQUARE

$41
$41
$50,X
$50,X
$42

TABLE
;SQUARES
;SQUARES TABLE
16,25,36.49
0, 1,4,9,16,25,36,49

4 -13
3

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006

A6
41
41
B5
50
85
42
00

0050
0051
0052
0053
0054
0055
0056
0057

00
01
04
09
10
19
24
31

Instruction
Instruction
(Mnemonic)
LOX
LDX

$41

LOA
LDA

$50,X
$50.X

STA

$42

BRK
BRK
SOTAB
SQTAB

.BYTE
BYTE

0
1
4
9
16
25
36
49

Note that
that you must also enter the table of squares into memory (the assembler pseudopseudo­
operation .BYTE
data. not parameters
BYTE will
ill handle this). The table of squares is constant
constant data,
that may change; that is why you can initialize
.BYTE pseudo-operainitialize the table using the .BYTE
pseudo-opera­
tion. rather than by executing
that.
tion,
executing instructions
instructions to load values into the table. Remember that,
in an actual application.
application, the table would
would be part of the read-only program memory. The
.BYTE
BYTE pseudo-operation
pseudo-operation places the specified data in memory in the order in which
which it apap­
pears in the operand field.

pseudo-operation•=* = simply
assembler) will
The pseudo-operation
ply determines
determines where the loader (or assembler)
ill place
microcomputer's
the next section of code when
when it is finally
finally entered into the microcom
puter's memory for
execution.
execution. Note that
that the pseudo-operation
pseudo-operation does not actually
actually result in any object
object code
being generated.
Indexed addressing (or indexing) means that the actual address used by the instruction
instruction
(often referred to as the effective
effective address) is the sum of the address included
included in the inin­
struction
LOA $50.X
(.X or ,Y
.Y indicates instruction and the contents
contents of the Index register. Thus LDA
$50,X (,X
in­
dexed addressing with
ith the specified Index register in 6502
6502 assembly language) is
equivalent
LOA $50+(X)
LOA $53 if (X)
(X) =
= 03. In the example program,
program. Index
equivalent to LDA
$50+(X) or LDA
Register X contains
contains the number
number to be squared and the address included
included in the instrucinstruc­
squares. Note that there is a special zero-page
tion is the starting
starting address of the table of squares.
indexed mode using Index Register X.
X.
Indexing always takes extra time since the m icrocom
puter must perform an addition
addition to
Indexing
icrocomputer
calculate
address. Thus LDA
LOA $50.X
LOA
calculate the effective
effective address.
$50,X requires four
four clock cycles while
hile LDA
would clearly take a great deal more time to access
$50 requires only three. However,
However. it would
access
icrocomputer
the table entry if the m icrocom
puter lacked indexing
indexing and the address calculation
calculation had to
be performed
performed with
ith a series of instructions.
instructions.
Remember that the Index registers are only 8 bits long so the maximum
maximum offset from the
(FF15). Note also that the offset
base address is 255 (FF-ig)offset is an unsigned number
number (unlike the
offset in relative addressing) so that it can never be negative. However,
However. we do get wrapwrap­
around. That is,
is. if the sum of the base address and the contents
contents of the index register
value. the most significant
exceed the maximum
aximum allowed value,
significant bits of the sum are simply
dropped. In the case of zero page indexing.
FF15. If,
If. for
indexing, the maximum
maximum allowed value is FF-|g.
example,
example. the base address on the zero page is F0-|g
F015 and the index register contains
effective address for zero page indexing
indexing is 000815;
000B-|g; there is no carry to the
1B-|0,
B15. the effective
more significant
significant byte. Thus we can get the effect
effect of a negative
negative offset.

4 -14
14

There are a few special instructions
instructions that
that operate on one of the Index registers rather
than on the Accum
Accumulator.
are:
ulator. These are:

CPX. CPY - Compare
CPX,
Compare Memory
Memory and Index Register
DEX.
1)
DEX, DEY - Decrement
Decrement Index Register (by 1)
1)
INX. INY - Increment
Increment Index Register (by 1)
LOX. LDY
LOY - Load Index Register from Memory
LDX,
Memory
STX, STY - Store Index Register into Memory
Memory
TAX. TAY - Transfer
Accumulator
Transfer Accum
ulator to Index Register
TXA.
Accumulator
TXA, TYA - Transfer
Transfer Index Register to Accum
ulator
Remember
CPX. CPY,
CPY. LDX,
LOX.
Remember that
that there are only a few addressing
addressing modes available
available with
ith CPX,
LOY. STX,
STX. and STY.
STY. Consult
LDY,
Consult Table 3-4 for more details.
rithmetic
A rithm
etic that
that a microprocessor
microprocessor cannot
cannot do directly
directly in a few
ARITHMETIC
ARITHMETIC
instructions
WITH
WITH
instructions is often
often best performed
performed with
ith lookup tables. Lookup
tables simply
simply contain
contain all the possible answers to the problem;
problem;
TABLES
they are organized
organized so that
that the answer
answer to a particular
particular problem
problem
arithmetic
can be found
found easily. The arithm
etic problem
problem now becomes an accessing
accessing problem
problem -—
how do we get the correct
correct answer
answer from the table? We must
must know
know two
two things:
things: the
position
base. or starting.
position of the answer
answer in the table (called the index) and the base,
starting, address
Is then the base address plus the index.
of the table. The address of the answer
answer is
The base address,
address. of course,
course. is a fixed
fixed number
number for a particular
particular table. How can we deterdeter­
mine the index? In simple
cases. where
simple cases,
where a single piece of data is involved.
involved, we can organorgan­
squares. the 0th
ize the table
table so that
that the data is the index. In the table of squares,
Oth entry
entry in the tata­
ble contains
cases.
contains zero squared.
squared, the first
first entry
entry one squared.
squared, etc. In more complex
complex cases,
where
where the spread of input
input values is very large or there are several data items involved
involved
(e.g.,.. roots of a quadratic
quadratic equation
equation or number
number of permutations).
permutations), we must
must use more comcom­
plicated
plicated methods
methods to determine
determine indexes.
faster. since no comThe basic tradeoff
tradeoff in using a table
table is time vs. memory. Tables are faster,
com­
putations are required.
required, and simpler.
simpler, since no mathematical
mathematical methods
methods must
must be devised
putations
and tested. However.
However, tables
tables can occupy
occupy a large amount
amount of memory
memory if the range of the
input
input data is large. We can often
often reduce the size of a table by limiting
iting the accuracy
accuracy of
the results.
data. or organizing
results, scaling
scaling the input
input data,
organizing the table cleverly. Tables are often
trigonometric
used to compute
compute transcendental
transcendental and trigonom
etric functions.
functions, linearize inputs.
inputs, convert
convert
codes,
perform other
other mathematical
athematical tasks.
codes. and perform
tasks.

4-15
4-

Ones Complement
ent
complement
Purpose: Logically
Logically complem
ent the contents
contents of memory location 0040
0040 and place the
resultIt in memory location 0041.
Sample Problem:
(0040)

= 6A

Result=(0041)
Result=(0041) = 95
Source Program:

LOA
LDA
EOR
EOR
STA
BRK
BRK

$40
11111111
#% 1
1111111
$41
$41

;GETDATA
DATA
;GET
;LOGICALLY COMPLEMENT
COMPLEMENT DATA
:LOGICALLY
;STORERESULT
RESULT
;STORE

Object
Object Program:

Memory
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006

A5
40
49
FF
FF
85
41
41
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$40

EOR
EOR

11111111
#% 1
1111111

STA

$41
$41

BRK
BRK

as Clear or Complement
The 6502 microprocessor
microprocessor lacks some simple instructions,
instructions, such as
Complement,
that are available in most other sets.
sets. However, the required operations are easily ac­
accomplished
complished with
ith the existing
existing instructions
instructions if the programmer
programmer simply gives the matter
atter a
little thought.
thought.
Exclusive-ORing a bit with
ith 'V
complements the bit since
'1' complements
1 -V-0
-¥-0== 1

and

-¥-1 = 00
1 -V-1

Exclusive-OR function
'O' bit into a '1' and each T
So the Exclusive-OR
function turns each 'O'
'1' bit into a 'O',
'O', just
inverse. Note, however, that the instruction
like a logical complement
complement or inverse.
instruction EOR
EOR
11111111
#% 1
1111111 occupies two bytes of memory, one for the operation code and one for
mask. An explicit
the mask.
explicit Complement
Complement instruction
instruction would
would require only one byte.
One problem with
ith this approach is that the purpose of the instructions
instructions may not be im­
immediately obvious. A reader would
would probably
probably have to think about exactly
mediately
exactly what
hat an Ex­
Exclusive-OR function
function with
ith an all-ones word actually
actually does.
Adequate documentation
documentation is
does. Adequate
here, and the use of macros can also help clarify
essential here,
clarify the situation.

4-16
4-16

PROBLEMS
PROBLEMS
1) 1 6-Bit
-B it Data Transfer
Purpose: Move the contents
contents of memory location 0040 to memory location 0042 and
the contents
contents of memory location 0041 to memory location 0043.
Sample Problem:

Result:

2)

(0040)
(0041)

=
=

3E
B7

(0042)
(0043)

=
=

3E
B7

8-Bit
it Subtraction

Purpose: Subtract
Subtract the contents
contents of memory location 0041 from the contents
contents of memory
location 0040. Place the result into memory location 0042.
Sample Problem:

Result:

3)

(0040)
(0041)

=
=

77
39

(0042)

=

3E

Shift Left Two
o Bits

Purpose: Shift
Shift the contents
contents of memory location 0040 left two bits and place the result
into memory location 0041. Clear the two least significant
significant bit positions.
Sample Problem:
5D

(0040)
Result:

4)

(0041)

=

=

5D

74

Mask Off Least Significant Four
Four Bits

Purpose: Place the four most significant
significant bits of the contents
contents of memory location 0040
location 0041. Clear the four least significant
significant bits of memory
into memory location
location 0041.
Sample Problem:
C4

(0040)

It:
Result:

5)

(0041)

=

=

C4

CO
CO

Ones
Location to All Ones
Set a M emory
ory Location

Purpose: Memory location 0040 is set to all ones (FF-|g).
(FF15).

6)

Word Assembly

Purpose: Combine the four least significant
significant bits of memory locations 0040 and 0041
sig­
into a word and store them in memory location 0042. Place the four least significant
posisignificant bit posi­
nificant bits of memory location 0040 into the four most significant
0042: place the four least significant
significant bits of memomemo­
tions of memory location 0042;
ry location 0041 into the four least significant
significant bit positions
positions of memory loca­
location 0042.
Sample Problem:

Result:

(0040)
(0041)

=
=

6A
B3

(0042)

=

A3

4-17
4-17

7)

Find Smaller of Two
o Numbers

Purpose: Place the smaller of the contents
contents of memory locations 0040 and 0041 in
con­
memory location 0042. Assume that memory locations 0040 and 0041 connumbers.
tain unsigned binary numbers.
Sample Problems:
(0040) = 3F
(0040)
3F
(0041) = 2B
2B

a.

(0042) = 2B
It: (0042)
Result:
2B
(0040) = 75
(0040)
75
(0041) = A8
AB

b.
b.

(0042)
Result: (0042)

8)

75
= 75

2 4-Bit
-B it Addition

Purpose: Add the 24-bit
24-bit number
number in memory locations 0040.
0040, 0041, and 0042 to the 240044. and 0045. The most significant
0043. 0044,
number in memory locations 0043,
significant
bit number
eight bits are in
0045, the least significant
significant eight
In memory locations 0042 and 0045.
eight
locabits in memory locations 0040 and 0043. Store the result in memory loca­
tions 0046, 0047.
0047, and 0048 with
ith the most significant
significant bits in 0048 and the
least significant
significant bits in 0046.
Sample Problem:

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)

=
=
=
=
=

2A
67
35
FB
F8
A4
51
51

(0046)
(0046)
(0047)
(0047)
(0048)
(0048)

=
=
=

22
oc
OC
87

=

35672A
Is. 35672A
that is,
+51A4F8
+51A4F8
870C22

9)

Sum of Squares

Purpose: Calculate the squares of the contents
conten-ts of memory locations 0040 and 0041
In memory location 0042. Assume
and add them together. Place the result in
and
between 0and
numbers between
contain numbers
that memory locations 0040 and 0041 both contain
table of
Use the table
(0041)
<( 0 0
7 inclusive: 1.e
i.e.,0
and 00 <
4 1 )<
< 77. Use
< (0040) << 7 and
.0 <
Squares~
ofSquares.
squares from the example entitled
entitled Table of
Sample Problem:
(0040)
(0041)
(0041)

= 03
=
=
= 06

Result = (0042) =

2D

2D15e
52 = 9 + 36 = 45 == 2D-]
is. 32 + 62
that is,

4 -18
8

10)

T wos Complement

Purpose: Place the twos complement
complement of the contents
contents of memory location
location 0040
0040 in
memory location
location 0041. The twos complement
complement is the ones complement
complement plus
one.
one.
Sample Problem:

Result:

(0040)

=

3E

(0041)

=

C2

zero. So the twos compleThe sum of the original
original number
number and its twos complement
complement is zero.
comple­
ment
complement
one. or
ment of X is 0-X. Which
hich approach
approach (calculating
(calculating the ones complem
ent and adding
adding one,
subtracting
zero) results in a shorter
subtracting from zero)
shorter and faster program?

4 -19
19

Chapter 5
SIMPLE
LOOPS
SIMPLE PROGRAM LOOPS
The program
program loop
loop is the basic
basic structure that forces the CPU to repeat a sequence
sequence
instructions. Loops
Loops have four sections:
of instructions.
1)

The initialization section that
that establishes the starting
starting values of counters, pointpoint­
ers, indexes,
indexes, and other variables.
ers,

2)

The processing
anipulation occurs. This is the
processing section where the actual data manipulation
that does the work.
section that

3)
counters and indexes for the next iteration.
31 The loop
loop control section that updates counters
4)

concluding section that analyzes and stores the results.
results.
The concluding

SecNote that the computer
computer performs
performs Sections 1 and 4 only once while
hile it may perform Sec­
tions 2 and 3 many times. Thus, the execution
execution time of the loop will
ill mainly
mainly depend on
the execution
execution time of Sections 2 and 3. You will
ill want
ant Sections
Sections 2 and 3 to execute as
quickly
quickly as possible;
possible: do not worry
worry about
about the execution
execution time of Sections 1 and 4. A typitypi­
procal program loop can be flowcharted
flowcharted as shown in Figure 5-1, or the positions of the pro­
proces~cessing and loop control
control sections may be reversed as shown in Figure 5-2. The process­
ing section in Figure 5-1 is always executed at least once, while
hile the processing section
natural. but Figure 5-2
in Figure 5-2 may not be executed at all. Figure 5-1 seems more natural,
is often more efficient
efficient and avoids the problem of what
hat to do when there is no data (a
bugaboo for computers
computers and the frequent
frequent cause of silly situations
situations like the computer
puter dundun­
ning someone for a bill of $0.00).
this. the
The loop structure
structure can be used to process entire
entire blocks of data. To accomplish
accomplish this,
program must increment
increment an Index register after each iteration
iteration so that the effective
effective adad­
dress of an indexed instruction
instruction is the next element
element in the data block. The next iteration
will
ill then perform the same operations
operations on the data in the next memory
memory location. The
computer
puter can handle blocks of any length (up to 256, since the Index registers are 8
bits long) with
ith the same set of instructions.
instructions. Indexed addressing is the key to processing
blocks of data with
ith the 6502 microprocessor, since it allows you to vary the actual (or
effective) memory address by changing
changing the contents
contents of Index registers. Note that in the
direct
modes, the address used is completely
direct and immediate
mediate addressing modes,
completely determined
determined by
the instruction
instruction and is therefore fixed if the program memory is read-only.

5-1
5-

Start

Initialization
Section

Processing
Section

Loop Control
Section

Concluding

Section

End

Figure 5-1. Flowchart
Flowchart of a Program Loop

5-2
5-

Start

Initialization
Section

Loop Control
Section

Yes

Processing

Concluding

Section

Section

End

Allowss Zero Iterations
Figure 5-2. A Program Loop that Allow
Iterations

5-3

EXAMPLES
Sum of Data
Purpose: Calculate the sum of a series
series of numbers.
numbers. The length of
8-BIT
the series is in memory location 0041. and the series
series
SUMMATION
SUMMATION
begins in memory location 0042. Store the sum in
memory location 0040. Assume that the sum is an 8-bitit number so that you
vou
carries.
can ignore carries.
Sample Problem:

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
ResuIt:
lt:

03
28
55
26

(0040)
(0040)
=
=

(0042) + (0043)
+ +
(0044)
+ (0043)
(0044)
+55+26
28+5
5+26
A3

sum. since (0041)=03.
There are three entries in the sum.
Flowchart:
Flowchart:
Start

Sum =0
Index= 0

Sum= Sum+
(0042+1ndex)

Index = Index + 1

(0040) = Sum

End

Index) is the contents
Note: (0042 + Index)
contents of the memory location whose address is the sum
of 0042 and Index. Remember that on the 6502 microprocessor,
microprocessor. 0042 is a 16-bit
address. Index is an 8-bitit offset,
offset. and (0042 + Index)
address.
Index) is an 8-bitit byte of data.
data.

5-4

Program:
Source Program:

SUMD
SUMO

LOA
LDA
TAX
CLC
CLC
ADC
INX
INX
CPX
CPX
BNE
BNE
STA
BAK
BRK

##0
0

$42,X
$42,X
$41
$41
SUMO
SUMD
$40
$40

;SUM== ZERO
ZERO
SUM
;INDEX
ZERO
INDEX = ZERO
;DO NOT
NOT INCLUDE
INCLUDE CARRY
CARRY
;SUM== SUM++ DATA
SUM
;INCREMENT
INDEX
INCREMENT INDEX
:HAVE ALL ELEMENTS
ELEMENTS BEEN
BEEN SUMMED?
SUMMED?
;NO,
CONTINUE SUMMATION
NO, CONTINUE
;YES.
STORE SUM
YES, STORE

Object
Object Program:
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
OOOB
000B
oooc
OOOC
000D

A9
00
AA
1B
18
75
42
E8
EB
E4
E4
41
DO
DO
FB
F8
85
40
00

Instruction
Instruction
(Mnemonic)

SUMO
SUMD

LOA
LDA

#0

TAX
CLC
CLC
ADC

$42,X
$42,X

INX
INX
CPX
CPX

$41
$41

BNE
BNE

SUMO
SUMD

STA

$40

BAK
BRK

The initialization
initialization section of the program is the first two instructions,
instructions, which
hich set the sum
and index to their starting
starting values.
values. Note that TAX transfers the contents
contents of the Acc­
leaves the Accum
cumulator
ulator to Index Register X but leaves
ulator as it was.
Accumulator
was. The base
base address
of the array and the location of the counter
counter are fixed within
ith in the program and need
need not
be initialized.
The processing section of the program consists of the single instruction
instruction ADC $42,X,
$42.X.
which
which adds the contents
contents of the effective
effective address (base
(base address plus Index Register X)
X) to
the contents
contents of the Accumulator.
Accumulator. This instruction
instruction does the real
real work of the program.
The CLC
instruction simply
CLC instruction
simply clears the Carry flag so that it does not affect the summasumma­
tion. Note that each iteration
iteration of the loop adds in the contents
contents of a new effective
effective address
even though the instructions
instructions do not change.
The loop control
control section of the program consists of the instruction
instruction INX.
instruction
INX. This instruction
updates the Index register (by 1)
1) so that the next iteration
iteration adds the next number
number to the
sum. Note that (0041) - X tells you how many iterations
sum.
iterations are left to be done.
done.

BNE causes a branch if the Zero flag is 0. CPX
CPX sets the Zero flag to 1 if
The instruction
instruction BNE
Index Register X and the contents
contents of memory location 0041 are the same and to 0
O if
they are not. The offset is a twos complem
ent number
number and the count
count begins from the
complement
following
BNE instruction.
memory location immediately
immediately follow
ing the BNE
instruction. In this case,
case. the required
jumpp is from memory location 000B
So'the offset is:
OOOBto memory location 0003. So'the
is:
0003 =
-00
0B =
-OOOB

5-5
5-

03
+F5
F8
F8

If the Zero flag is one. the CPU
CPU executes the next instruction
(STA $40).
instruction in sequence (STA
Since CPX
BNE to affect
affect the Zero flag,
flag. BNE
BNE SUMD
SUMO
CPX $41 was the last instruction
instruction before BNE
SUMO if CPX $41 does not produce a zero result:
is.
causes a branch
branch to SUMD
result; that
that is.
SUMO if (X)
(X) - (0041)
(0041) * 0
,foO
SUMD

{

(PC) =
(PC)
{

(X) - (0041) = 00
(PC)+2 if (X)

The 2 is caused by the two-word
BNE instruction.
two-word BNE
instruction. A single instruction
instruction combining
combining the
Decrement
set.
Decrement and the Jump
Jump would
would be a useful addition
addition to the 6502 instruction
instruction set.
The order in which
which instructions
instructions are executed
executed is often very important.
important. INX must come
after
after ADC $42.X
$42,X or else the first
first number
number to be added to the sum will
ill be the contents
contents of
memory location
CPX $41 must
location 0043
0043 instead of the contents
contents of memory location
location 0042. CPX
come right
BNE SUMD,
SUMO. since otherwise
CPX
right before BNE
otherwise the Zero status setting
setting produced by CPX
could be changed by another
instruction.
another instruction.
CPX and CPY are the same as CMP except
CPX
except that the contents
contents of memory are subtracted
subtracted
from an Index register
Note. however,
however. that CPX
CPX and
register rather
rather than from the Accumulator.
ulator. Note,
CPY offer limited
(see Table 3-4).
3-4).
CPY
limited addressing
addressing options
options (see
Most
Most computer
computer loops count
count down rather than up so that the Zero flag can serve as an
exit
eliminating
exit condition.
condition, thus elim
inating the need for a Compare instruction.
instruction. This method is a bit
awkward
awkward for people although
although it is used occasionally
occasionally in launch countdowns
countdowns and in a few
other
other situations.
situations. Remember that
that the Zero flag is set to 1 if the result of an instruction
instruction is
O if the resultIt is not zero.
zero.
zero and to 0
(see the
We could easily revise the loop so that
that it works backward through
through the array (see
next flowchart).
following
versions.
flowchart). The follow
ing programs are revised versions.
Source Program:

SUMD

LOA
LDA
LOX
LDX
CLC
CLC
ACD
DEX
DEX
BNE
BNE
STA
BRK
BRK

#0
#0
$41
$41
$41,X
$41.X
SUMD
SUMO
$40
$40

;SUM== ZERO
ZERO
SUM
;INDEX
COUNT
INDEX = MAXIMUM
AXIMUM COUNT
;DO NOT INCLUDE
INCLUDE CARRY
CARRY
SUM
:SUM== SUM +
+ DATA
;DECREMENT
INDEX
DECREMENT INDEX
;BRANCH
BACK IF ALL ELEMENTS
ELEMENTS NOT
NOT SUMMED
SUMMED
BRANCH BACK
STORE SUM
;STORE

5-6
5-

Note that
that the addition
addition instruction
instruction is now ADC $41,X
,X instead of ADC $42,X; the number
in the Index register
register is one larger than before. Clearly, the net result of subtracting
subtracting one
from the base address and adding
zero. The reorganized object pro­
proadding one to the index is zero.
gram is:
is:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000BB

A9
00
A6
41
18
75
41
CA
DO
DO
FA
85
40
00

oooc
oooc

Instruction
Instruction
(Mnemonic)

SUMO
SUMD

LOA
LDA

#00

LOX
LDX

$41
$41

CLC
CLC
ADC

$41,X
$41,X

DEX
DEX
BNE
BNE

SUMO
SUMD

STA

$40

BRK
BRK

In most applications,
applications, the slight
slight time and memory differences
differences between one implementaimplementa­
tion of a loop and another
apanother do not matter
matter very much. You should therefore select the ap­
proach that is the clearest and easiest for you to use.
use. We will
ill discuss program design
15.
and efficiency
efficiency later in Chapters 13 and 15.
You may wish
wish to verify the hexadecimal
hexadecimal values for the relative offsets in the last two
programs. The final test of any calculations
calculations that
that you make is whether
hether the program runs
correctly.
reason. you must perform hexadecimal
frecorrectly. If. for whatever
whatever reason,
hexadecimal calculations
calculations fre­
quently,
Programquently. we suggest
suggest that
that you consider
consider a cal culator (like the Texas Instruments
Instruments Program­
mer)
that are available.
mer) or one of the numerous manual aids that

55-7

Flowchart (of reorganized summation program):
Start

Sum= 0
Index = 10041 I

Sum= Sum+
10041 +Index)

Index = Index - 1

10040) = Sum

End

5-8

16-Bit
-B it Sum of Data
Purpose: Calculate the sum of a series of numbers. The length of the series
series is in
series itself begins in memory location 0043.
memory location 0042 and the series
Store the sum in memory locations 0040 and 0041 (eight least significant
significant
bits in 0040).

Sample Problem:
(0042)
(0043)
(0043)
(0044)
(0045)

=
=
=
=

03
CB
C8
FA
96

CB +
+ FA ++ 96 = 025816
Result== C8
0258-|6
(0040) = 58
= 02
(0041) =
Flowchart:
Flowchart:
Start

Base= 0043
Index= 0
Suml = 0
SumU = 0

Suml = Suml +
(Base + Index)

SumU = SumU
+1

Index = Index + 1

10040) = Suml
10041) = SumU

End

5-9
5

Program:
Source Program:

SUMD
SUMO

COUNT
COUNT

LDA
ID
A
TAX
TAY
CLC
CLC
ADC
BCC
BCC
INY
INX
CPX
CPX
BNE
BNE
STA
STY
BRK
BRK

#00

$43,X
$43,X
COUNT
COUNT

ZERO
;SUM== ZERO
ZERO
;INDEX== ZERO
ZERO
;MSB'S OF SUM = ZERO
INCLUDE CARRY
CARRY
;DO NOT INCLUDE
;SUM== SUM++ DATA
CARRY TO MSB'S OF
;ADD CARRY
OF SUM

$42
SUMO
SUMD
$40
$41

;CONTINUE UNTIL ALL ELEMENTS
ELEMENTS SUMMED
;CONTINUE
;STORE LSB'S OF
OF SUM
;STORE
;STORE MSB'S OF
OF SUM
;STORE

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
000B
oooc
OOOC
000D
OOOE
000E
000F
OOOF
0010
0011
0012
0013

A9
00
AA
AB
A8
18
75
43
90
01
CB
C8
EB
E8
E4
E4
42
DO
DO
F5
85
40
84
41
00

Instruction
Instruction
(Mnemonic)

SUMO
SUMD

COUNT

LDA

#0

TAX
TAY
CLC
CLC
ADC

$43,X
$43,X

BCC
BCC

COUNT
COUNT

INY
INY
INX
CPX
CPX

$42

BNE
BNE

SUMO
SUMD

STA

$40

STY
STY

$41
$41

BRK
BRK

The structure
structure of this program is the same as the structure
structure of the last example. The most
significant
significant bits of the sum must now be initialized
initialized and stored. The processing section
consists of four instructions
(CLC; ADC $43,X;
BCC COUNT; and INY),
instructions (CLC;
$43,X; BCC
including a concon­
INY), including
dition jump.
dition

BCC COUNT causes a jumpp to memory location
BCC
location COUNT if Carry== 0. Thus, if there is no
carry from the 8-bit
-b it addition.
addition, the program jumps
ps around the statement
statement that increments
increments
the most significant
significant bits of the sum. The relative offset is
000A
OOOA
-0009
-00
09
0101
The relative offset
offset for BNE
BNE SUMD
SUMO is

0004 =
-OOOF
-000F

0004
-t-FFFl
+FFF1
F5
~

5-100
5-

\NY adds 1 to the contents
Y. which
INY
contents of Index Register Y,
hich is used here as a temporary
temporary
register to save the carries from the addition.
addition. We could also use a memory location
location to
carries. since the INC instruction
increment
hold the carries,
instruction can be used to directly
directly increm
ent the concon­
tents of a memory
memory location.
You might
ight wish to try reorganizing
reorganizing this program so that
that it decrements
decrements the index down
incrementing
to zero rather than increm
enting it. Which
hich version is faster
faster and shorter?

------ ..

Relative branches
LONG
branches are limited
ited to short distances
distances (7F16
1 g or + 127
27
forward.
CONDITIONAL
forward, 8 016
-| 6 orr -128 backward
backward from the end of the branch
branch inin­
CONDITIONAL
struction).
BRANCHES
struction). This limitation
itation is seldom important.
portant, since most propro­
However. if you need a conditional
gram branches
branches are short. However,
conditional
branch with
range. you can always invert
invert the condition
condition logic and branch
ith a greater
greater range,
around a JMP instruction.
FAR if Carry== 0, use the
instruction. For example.
example, to branch
branch to location
location FAR
sequence
8CS
BCS
JMP

NEXT
NEXT
FAR
FAR

NEXT
NEXT
following
NEXT is the address immediately
mediately follow
ing the last byte of the JMP instruction.
instruction. JMP
allows
allows only absolute
absolute (direct) and indirect
indirect addressing.

5-11
5-

Number of Negative
egative Elements
Purpose: Determine
1) in a
Purpose:
Determine the number
number of negative elements (most significant
significant bit 1)
block. The length of the block is in memory location 0041 and the block itself
starts in memory location 0042. Place the number
number of negative elements in
memory location 0040.
Sample Problem:

Result:
Result:

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)

=
=
=
=
=
=
=

06
68
F2
87
30
59
2A

(0040)
(0040)

=

02, since 0043 and 0044 contain
numbers with
1.
ith an MSB of 1.

Flowchart:
Start

Nneg = 0
Base= 0042
Index= 0

Nneg = Nneg + 1

Index = Index + 1

(0040) = Nneg

End

5-12
5-

Program:
Source Program:

SRNEG

CHCNT

LOX
LDX
LOY
LDY
LOA
LDA
BPL
BPL
\NY
INY
INX
CPX
CPX
BNE
BNE
STY
STY
BRK
BRK

#00
#00
$42.X
$42,X
CHCNT

;INDEX = ZERO
ZERO
;INDEX
;NUMBER OF
OF NEGATIVES
NEGATIVES== ZERO
ZERO
;NUMBER
NEXT ELEMENT
ELEMENT NEGATIVE?
NEGATIVE?
;IS NEXT
;YES. ADD 1 TO NUMBER
NUMBER OF
OF NEGATIVES
NEGATIVES
;YES,

$41
SRNEG
SRNEG
$40

;CONTINUE UNTIL ALL ELEMENTS
ELEMENTS EXAMINED
iCONTINUE
;SAVE NUMBER
NUMBER OF
OF NEGATIVES
NEGATIVES

Object Program:
Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
OOOB
000B
oooc
000C
000D
000E
OOOE
000F
OOOF
0010

A2
00
AO
00
B5
42
10
01
ca
C8
E8
ES
E4
E4
41
DO
DO
F6
F6
84
40
00

Instruction
Instruction
(Mnemonic)

SRNEG
SRNEG

CHCNT
CHCNT

LOX
LDX

#00

LOY
LDY

#0

LOA
LDA

$42.X
$42,X

BPL
BPL

CHCNT
CHCNT

INY
INX
CPX
CPX

$41

BNE
BNE

SRNEG
SRNEG

STY
STY

$40

BRK
BRK

LOA affects
(S) and Zero (Z)
(Z) status flags. Therefore,
Therefore. we can immediately
LDA
affects the Sign (S)
immediately check
see if a number
to see
number that
that has been loaded is negative
negative or zero.
zero.
BPL. Branch-on-Plus.
BPL,
Branch-on-Plus, causes a branch over the specified
specified number
number of locations
locations if the Sign
zero. A sign bit of zero may indicate
(or Negative) bit is zero.
indicate a positive
positive number
number or may just in­
indicate the value of the most significant
significant bit position;
position; the interpretation
interpretation depends on what
what
mean.
the numbers
numbers mean.
BPL is calculated
The offset for BPL
calculated from the first
first memory
memory location
location follow
ing the two-byte
two-byte
following
instruction.
instruction. Here the offset
offset is simply
simply from 0008
0008 to 0009,
0009. or one location
location (i.e.,
(i.e.. the INY
\NY in­
instruction
zero). The Negative
struction is skipped if the Negative
Negative bit is zero).
Negative bit will
ill be zero if the most
significant
LOA $42.X
significant bit of the data loaded from memory by the LDA
$42,X instruction
instruction is zero.
zero.
Remember that
that negative-signed
negative-signed numbers all have a most significant
significant bit (bit 7)
7) of 1.
1. All
negative numbers are actually
actually larger,
larger. in the unsigned
sense. than positive
unsigned sense,
positive numbers.

5-13
5-

M axim u m Value
Value
Maximum
Purpose: Find
Find the
the largest
largest element
element in
in aa block
block of
of data.
data. The
The length
length of
of the
the block
block isis in
in
Purpose:
memory location
location 0041
0041 and
and the
the block
block itself
itself begins
begins in
in memory
memory location
location 0042.
0042.
memory
Store the
the maximum
maximum in
in memory
memory location
location 0040.
0040. Assume
Assume that
that the
the numbers
numbers in
in
Store
the block
block are
are all
all 8
-b it unsigned
unsigned binary
binary numbers.
numbers.
8-bit
the
Sample Problem:
Problem:
Sample
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
Result:
Result:

(0040)
(0040)

05
05
67
67
79
79
15
15
E3
E3
72
72
= E3,
E3. since
since this
this is the
the largest
largest of
of
the
the five
five unsigned
unsigned numbers.

Flowchart:
Flowchart:
Start

Base= 0041
Index = 100411
Max= 0

Max = IBase+lndexl

lndeK= Index -1

10040) = Max

End

5-14
5 -1
4

Source Program:
Program:

MAXM
MAXM

NOCHG
NOCHG

LDX
LOX
LDA
LOA
CMP
BCS
BCS
LDA
LOA
DEX
DEX
BNE
BNE
STA
BRK
BRK

$41
#00
$41,X
$41,X
NOCHG
NOCHG
$41,X
$41,X

;GET
COUNT
ELEMENT COUNT
:GET ELEMENT
VALUE)
POSSIBLE VALUE)
:MAXIMUM
ZERO (MINIMUM POSSIBLE
;MAXIMUM= =ZERO
ELEMENT ABOVE MAXIMUM?
NEXT ELEMENT
:IS NEXT
;IS
MAXIMUM?
KEEPMAXIMUM
;NO, KEEP
;NO.
MAXIMUM
ELEMENT
REPLACE ,MAXIMUM
;YES, REPLACE
:YES,
.MAXIMUM WITH ELEMENT

MAXM
$40

EXAMINED
CONTINUE
ELEMENTS EXAMINED
;CONTINUE UNTIL ALL ELEMENTS
;SAVE MAXIMUM
MAXIMUM

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009

A6
41
41
A9
00
D5
41
BO
BO
02
85
B5
41
CA
DO
DO
F7
85
40
00

000A
000A
000B
0008
000C
oooc
000D
000E
OOOE
000F
000F

Instruction
Instruction
(Mnemonicl
(Mnemonic)

MAXM

NOCHG
NOCHG

LOX
LDX

$41
$41

LDA
LOA

#00

CMP
CMP

$41,X
$41,X

BCS
BCS

NOCHG
NOCHG

LDA
LOA

$41,X
$41,X

DEX
DEX
BNE
BNE

MAXM

STA

$40

BRK
BRK

The relative offset for BCS
is:
NOCHG is:
BCS NOCHG
000A
000A
-0008
-0008
02

is:
BNE MAXM is:
The relative offset for BNE
0004
0004
-000D
-000D

=

04
+F3
F7
F7

The first
first two instructions
instructions of this program form the initialization
initialization section.

unsigned binary
This program takes advantage
advantage of the fact that zero is the smallest 8-bit
-b it unsigned
case,
number. When
hen you set the register that contains
contains the maximum
maximum value -— in this case,
loop, then the
enter the loop,
you enter
the Accum
ulator — to the
the m
inimum possible value before
before you
minimum
Accumulatorill set the Accum
ulator to a larger value unless all the elements
the array
array
elements inin the
Accumulator
program will
are zeros.
properly if there are two elements in the array, but not if
zeros. The program works properly
there is only one or none at all. Why? How could you solve this problem?
The instruction
instruction CMP $41.X
$41,X sets the Carry flag as follows
follows where ELEMENT
con­
ELEMENT is the conAccumulator:
tents of the effective
effective address and MAX is the contents
contents of the Accum
ulator:
Carry = 0 if ELEMENT
ELEMENT >> MAX
MAX
Carry== 1 if ELEMENT
X
_:<::;MAX
ELEMENT< M A

5 -15

1, the program proceeds to
Remember that the carry is an inverted
inverted borrow. If Carry = 1,
NOCHG and does not change the maximum. If Carry== 0,
address NOCHG
0. the program replaces
the old maximum
aximum with
ith the current
current element
element by executing
executing the instruction
instruction LDA
LOA $41.X.
signed. because negative numbers will
The program does not work if the numbers are signed,
ill
appear to be larger than positive
positive numbers. This problem is somewhat
somewhat tricky
tricky because a
twos complem
complement
ent overflow
overflow could make the sign of the result incorrect. A further
further probprob­
lem is that
that the CMP instruction
instruction does not affect
affect the Overflow
Overflow flag. A program for signed
numbers would
SBC instruction
would therefore
therefore have to use the SBC
instruction and check both the Sign and
the Overflow
Overflow flags. The Carry flag would
would have to be set to 1 before the subtraction
subtraction
(remember that
that Carry is an inverted borrow and the SBC
SBC instruction
instruction inverts it before
subtracting
it}. and an addition
subtracting it),
addition would
would be required to
original value of the
to restore the original
maximum. Note how convenient
convenient it is in the example that CMP does not actually
actually change
the contents
contents of the Accumulator.
Accumulator.

5-16
5-

Justify a Binary Fraction
Fraction
Purpose: Shift
Shift the contents
contents of memory location 0040
0040 left until
until the most significant
significant bit
1. Store the result in memory location 0041 and the number
of the number
number is 1.
of left shifts required in memory location 0042. If the contents
contents of memory
location
zero, clear both 0041 and 0042.
location 0040
0040 are zero,
Note: The process is just
just like converting
converting a number
number to a scientific
scientific notation;
notation: for example:

3
0.0057 =
= 5.7 xX 170O'3

Sample Problems:
a.
a.
Result:
Result:
b.
Result:
Result:
c.
c.
Result:

d.
d.
Result:
Result:

(0040)
(0040)

=

22

(0041)
(0042)

=

=

88
02

(0040)

=

01
01

(0041)
(0042)
(0042)

=

=

80
07

(0040)
(0040)

=

CB
CB

(0041)
(0041)
(0042)
(0042)

=
=

CB
CB
00

(0040)
(0040)

=

00

(0041)
(0041)
(0042)
(0042)

=
=

00
00

Flowchart:
Flowchart:
Start

Nshft = 0
Numb = (0040)

Yes

Yes

Shift Numb

10041 I = Numb
(0042) = Nshft

left 1 bit

Nshft = Nshft + 1

End

55-17

Program:
Source Program:

CHKMS
CHKMS

DONE
DONE

LOY
LDY
LOA
LDA
BEO
BEQ
BM!
BMI
INY
!NY
ASL
JMP
STA
STY
STY
BRK
BRK

#00
$40
DONE
DONE
DONE
DONE
A
CHKMS
CHKMS
$41
$42

:NUMBER OF SHIFTS
SHIFTS =0
;NUMBER
:GET DATA
;GET
;DONE IF DATA IS ZERO
ZERO
;DONE
:DONE IF MSB IS ONE
ONE
;DONE
NUMBER OF SHIFTS
SHIFTS
;ADD 1 TO NUMBER
;SHIFT LEFT
LEFT ONE
ONE BIT
;SHIFT
:SAVE JUSTIFIED
JUSTIFIED DATA
;SAVE
:SAVE NUMBER
NUMBER OF SHIFTS
SHIFTS
;SAVE

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
OOOB
000B

AO
AO
00
A5
40
FO
FO
07
30
05
CB
C8
OA
4C
06
00
85
41
84
42
00

oooc
OOOC
000D
OOOE
000E
OOOF
000F
0010
0011

Instruction
Instruction
(Mnemonic)

CHKMS
CHKMS

DONE
DONE

LOY
LDY

#00

LOA
LDA

$40

BEO
BEQ

DONE
DONE

BMI

DONE
DONE

INY
ASL
JMP

A
CHKMS
CHKMS

STA

$41

STY
STY

$42

BRK
BRK

BMI DONE
location DONE
condition may
DONE causes a branch to location
DONE if the Sign bit is 1.
1. This condition
mean that the last result was a negative number.
number, or it may just
just mean that its most sigsig­
nificant
nificant bit was 1 -— the computer
puter only supplies the results:
results; the programmer
programmer must propro­
interpretation.
vide the interpretation.

Accumulator
ASL A shifts
shifts the contents
contents of the Accum
ulator left one bit and clears the least significant
significant
bit.
ProJMP is an unconditional
unconditional branch instruction
instruction that
that always places a new value in the Pro­
gram Counter. It only allows absolute (direct) or indirect
indirect addressing. The indirect
indirect mode
provides
xibility
provides fle xib
ility since the actual
actual destination
destination address can be stored in RAM. Note that
that
there is no relative addressing and no special page-zero modes.
modes.
The address in the JMP instruction
instruction is stored in two successive memory locations with
ith
address). This is the standard way in which
the least significant
significant bits first
first (at the lower address).
which
addresses. regardless of whether
the 6502 microprocessor
microprocessor expects to find addresses,
whether they are part
of instructions
instructions or are used indirectly.
indirectly. The same upside-down
upside-down method is used in the
8080, 8085.
8085, and Z80 microprocessors.
microprocessors, but the opposite
opposite approach
approach (most significant
significant bits
8080.
first) is used on the 6800
6800 microprocessor. Note that an address occupies
occupies two bytes of
memory, although
although there is a single byte of data located at that address.
memory.
address.

5-188
5-

We could
could reorganize this program
program so as to eliminate
eliminate the extraneous
extraneous JMP instruction.
instruction.
be:
One reorganized
reorganized version
version would
ould be:

CHKMS

DONE
DONE

LDY
LDA
BEO
BEQ
INY
ASL
BCC
BCC
ROR
ROR
DEY
DEY
STA
STY
BRK
BRK

#0
$40
DONE
DONE
A
CHKMS
A

$41
$41
$42

:NUMBER OF SHIFTS
SHIFTS== 0
:GET DATA
;DONE IF DATA
ZERO
DATA IS ZERO
:ADD 1 TO NUMBER OF
OF SHIFTS
SHIFTS
:SHIFT LEFT
LEFT ONE BIT
:CONTINUE IF MSB NOT ONE
ONE
:OTHERWISE,
ONCE
OTHERWISE. SHIFT BACK ONCE
:AND IGNORE
IGNORE EXTRA SHIFT
SHIFT
:SAVE JUSTIFIED
JUSTIFIED DATA
;SAVE NUMBER OF SHIFTS
SHIFTS

This version
1. Then it adjusts
version shifts
shifts the data until
until the Carry becomes 1.
adjusts the data and the
number
number of shifts
shifts back one since the last shift
shift was not really necessary. Show
Show that
that this
version is also correct. What
hat are its advantages
advantages and disadvantages
disadvantages as compared
compared to the
previous
previous program?
program? You might
ight wish to try some other
other organizations
organizations to see how they
compare
usage.
compare in execution
execution time and memory
memory usage.

5-199
5-

Post-Indexed (Indirect) Addressing
Addressing
flexibility
POST-INDEXED
We have already noted the additional
additional flexib
ility provided
provided by
POST-INDEXED
the indexed addressing mode.
mode. The same instructions
instructions can be
(INDIRECT)
used to process each element
element in an array or table. But even
ADDRESSING
flexibility
more flexib
ility is provided by the post-indexed
post-indexed addressing
MODE
mode in which
hich the instruction
instruction only specifies the address on
array. Now the same program
page zero that
that contains
contains the base address of the table or array.
can handle an array or table located anywhere
anywhere in memory. All that we have to do is
zero. Note that the startplace the starting
starting address in the appropriate
appropriate locations on page zero.
start­
memory. with
ing address occupies two bytes of memory,
ith the least significant
significant byte first (at the
lower address)
(six as compared to four for
address). Post-indexing
Post-indexing requires extra clock cycles (six
the zero-page indexed
indexed mode)
mode) but provides tremendous
tremendous additional
additional flexibility.
flexibility. Entire
Entire arar­
need not
required.
rays need
notbe
bemoved.
moved, nor
nor are
are repeated
repeated versions
versions of
of the
the same
same program
program required.
Post-indexed (indirect) addressing can only be used with
ith Index Register Y. So the maxmax­
imum value program with
ith post-indexed
post-indexed addressing is as follows.
follows, assuming that the
length of the array is in memory location
location 0041 and its starting
starting address is in memory
locations 0042 and 0043.
example.
For example,
(0041)
(0042)
(0043)
(0044)
(0045)
(0045)
(0046)
(0047)
(0048)

= 05
05
43 (LSBs
(LSBsofof starting
starting address
address minus
minus one)
one)
= 43
00 (MSBs
(MSBsofofstarting
starting address
address minus
minus one)
one)
= 00
= 67
67 (first
(first element
element inin array)
array)
= 79
79
= 15
15
= E3
E3
= 72
72

(40) = E3 since this is the largest
Result== (40)
of the 5 unsigned numbers.

Source Program:
Program:

MAXM

NOCHG
NOCHG

LDY
LOY
LDA
LOA
CMP
BCS
BCS
LDA
LOA
DEY
DEY
BNE
BNE
STA
BRK
BRK

$41
$41
#0
($42).Y
($42),
NOCHG
NOCHG
($42).Y
($42),Y

;GET
ELEMENT COUNT
COUNT
;GET ELEMENT
;MAXIMUM=
ZERO (MINIMUM POSSIBLE
POSSIBLEVALUE)
VALUE)
iM AXIM
UM = ZERO
;IS NEXT
MAXIMUM?
NEXT ELEMENT
ELEMENT ABOVE MAXIMUM?
;NO. KEEP
KEEP MAXIMUM
;NO,
MAXIMUM
;YES,
MAXIMUM WITH ELEMENT
ELEMENT
;YES. REPLACE
REPLACE MAXIMUM

MAXM
$40

;CONTINUE UNTIL ALL ELEMENTS
ELEMENTS EXAMINED
EXAMINED
;CONTINUE
;SAVE MAXIMUM
MAXIMUM

5 -20
0

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0004
0005
0006
0006
0007
0007
000B
0008
0009
OOOA
000A
000B
oooc
OOOC
OOOD
000D
OOOE
000E
OOOF
000F

A4
41
A9
00
D1
D1
42
BO
BO
02
B1
B1
42
88
DO
DO
F7
85
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

MAXM
MAXM

NOCHG
NOCHG

LDY

$41

LDA

#00

CMP

($42).Y
($42),

BCS
BCS

NOCHG
NOCHG

LDA

($42),Y

DEY
DEY
BNE
BNE

MAXM
MAXM

STA

$40

BRK
BRK

The indirect
indirect address (in memory
memory locations
locations 0042
0042 and 0043) is stored in the usual 6502
address).
fashion, with
ith the least significant
significant bits first
first (at the lower address).
We could use the same program
program to find the maximum
aximum element
element in an array of 5 entries
starting
starting in memory
memory address 25E1. Allll that
that we would
would have to do is change
change the indirect
indirect
address to 25E0
25EO before executing
is,
executing the program.
program, that is,

= E0
EO (LSBs
(LSBs of starting
one)
(0042) =
starting address minus one)
= 25 (MSBs
(MSBs of starting
one)
(0043) =
starting address minus one)
25E1 if the program used
How would
would you handle the array starting
starting in memory address 25E1
ordinary
(as in the earlier example)? Assume that
ordinary indexed addressing
addressing (as
that the program is in
ROM so that
that you cannot
change the addresses in the instructions.
instructions.
ROM
cannot change

5 -21

Pre-Indexed
Addressing
Pre-lndexed (Indirect) Addressing
The pre-indexed
pre-indexed addressing mode gives you a different
different kind of
PRE-INDEXED
PRE-INOEXED
flexibility.
flexibility. This method allows you to choose one address from
(INDIRECT)
addresses, rather than being limited
a table of addresses,
limited to a particular
particular
ADDRESSING
address. For example, rather than having memory
memory address.
MODE
location 0041 contain the length of the array in the maximum
aximum
problem, we could let it contain
contain the index of the address that contains
contains the length of the
array. The table of addresses must be located somewhere on page zero,
array.
start­
zero. perhaps starting at memory address 0060, that is
(0060)
(0060)) =
= 2F
2F}' • add
• w hich
h.Ich counter
#O
• storedd
ddress
in
counter #
0 is
(00
=
ress in
1s
(0061) = 000
0
(0062)
0 1 dd
(0062)) =
= 8
80}
. wh1c
• h counter
• stored
hich
counter #
#11 is
(00
=
address
ress in
In
1s
(0063) = 00 (
(0064)
5 ( dd
(0064)
=>A
A5}
• w hich
h.Ic h counter
#22 is
• storedd
ddress in
counter #
(006 5) ;=
Is
(0065)
00 a ress in

(

One problem is that addresses occupy two bytes of memory so that
that you must multiply
ultiply
the counter
counter number
number by two before applying
applying the pre-indexed
pre-indexed addressing mode.
mode. Note
that all addresses are stored in the usual 6502 manner, with
ith the least significant
significant bits
first. Pre-indexed addressing
addressing is not as useful as post-indexed
post-indexed addressing, but it does
come in handy occasionally.

5-22
5-

PROBLEMS

1)

Checksum of Data
Checksum

series is in
Purpose: Calculate
Calculate the checksum of a series of numbers. The length of the series
memory location
location 0041 and the series itself begins in memory location 0042.
Store the checksum
checksum in memory location 0040. The checksum is formed by
Exclusive-ORing all the numbers in the series together.
Note: Such checksums
checksums are often used in paper tape and cassette systems to ensure
that
that the data has been read correctly.
correctly. The calculated
calculated checksum is compared to
the one stored with
agree. the system
ith the data -— if the two checksums do not agree,
automatically
will
ill usually
usually either
either indicate
indicate an error to the operator or autom
atically read the data
again.

Sample Problem:

Result:

2)

(0041)
(0042)
(0043)
(0044)

03
= 03
28
= 28
55
= 55
26
= 26

(0040)

(0042)©EB(0043)
(0043)©EB(0044)
(0044)
= (0042)
EB
EB
= 28 ©
555
5 ©
226
6
0101000
= 00 1
0 1000
EB 0 1 0
1010101 1 0 1
©
11101
0 1111
10 1
E£)00100110
© 00
1 0 0 1 10
0 101
0 1 1101 111
= 58
5B

Sum of 16-Bit
-B it Data

series is in
Purpose: Calculate
Calculate the sum of a series of 16-bit
16-bit numbers. The length of the series
memory location
location 0042 and the series itself begins in memory location 0043.
Store the sum in memory locations 0040 and 0041 (eight most significant
significant
16-bit number
number occupies two memory locations,
ith the
bits in 0041).). Each 16-bit
locations. with
eight
address. Assume that
eight most significant
significant bits in the higher address.
that the sum can
be contained
contained in 16 bits.
Sample Problem:
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)

= 03
= Fl
F1
= 28
= 1A
= 30
= 89
= 48
4B

Result: 28F1
301A +
4B89 =A494
=A494
28F1 +
+ 301A
+ 4889
(0040) = 94
(0041) = A4

5-233
5-

3)

Number of Zero, Positive, and Negative
egative Numbers

zero. positive (most significant
Purpose: Determine
Determine the number
number of zero,
significant bit zero but entire
number
zero). and negative (most significant
1) elements in a block.
block.
number not zero),
significant bit 1)
The length of the block is in memory location 0043 and the block itself starts
in memory location 0044. Place the number of negative elements in memory
location
0041. and
location 0040.
0040, the number
number of zero elements in memory location 0041,
and
the number
number of positive elements in memory location 0042.
Sample Problem:
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)
(0048)
(0049)
(0049)

=
=
=
=
=
=
=

06
68
F2
F2
87
00
59
2A

Result: 2 negative. 1 zi
zero. and 3 positive. so
Result:
(0040) = 02
(0041) = 01
(0041)
(0042) = 03
(0042)

4)

Find M inimum
Find

Purpose: Find the smallest element
data. The length of the block is in
Purpose:
element in a block of data.
memory location 0041 and the block itself begins in memory location 0042.
inimum
Store the m inim
um in memory location 0040. Assume that the numbers in
the block are 8-bitit unsigned binary numbers.
numbers.

Sample Problem:
(0041)
(0041)
(0042)
(0042)
(0043)
(0044)
(0044)
(0045)
(0046)
(0046)
Result:
It:

5)

(0040)

05
67
79
15
E3
E3
72
=

15. since this is the smallest of the
15,
numbers.
five unsigned numbers.

Count 1 Bits

Purpose: Determine
are ones and place the
Purpose:
Determine how many bits in memory location 0040 are
result in memory location 0041.

Sample Problem:

Result:
Result:

(0040)

=

38=00111011
3B =
00111011

(0041)
(0041)

=

05

55-24

Chapter 6
CHARACTER-CODED
CHARACTER-CODED DATA
Microprocessors often handle character-coded data.
data, Not only do keyboards,
teletypewriters,
displays, and computer terminals exteletypew
riters, communications devices, displays,
ex­
pect or provide character-coded data, but many instruments, test
st systems, and
controllers also require data in this form. The most commonly used code is ASCII.
Baudot and EBCDIC are found less frequently.
frequently. We will
ill assume all of our character7-bitit ASCII with
coded data to be 7-b
ith the most significant bit zero (see Table 6-1).
Some principles to remember
handling ASCII-coded
remember in handling
ASCII-coded data
are:
1)

HANDLING
HANDLING
DATA IN
ASCII

The codes for the numbers and letters
letters form ordered subsub­
sequences. The codes for the decimal
decimal numbers are 3015
30^6
through
ASCII with
through 3915
39-|6 so that you can convert
convert between decimal
decimal and ASCII
ith a simple
additive
through 5A7i 6 so that
additive factor. The codes for the upper case letters are 417
115
q through
order.
you can do alphabetic
alphabetic ordering
ordering by sorting
sorting the data in increasing numerical
numerical order.

21 The computer draws no distinction between
charac2)
between printing and non-printing charac­
1/0 devices make that distinction.
ters. Only the I/O
distinction.
3)

ASCII printer.
An ASCII device will
ill handle only ASCII data. To print
rint a 7 on an ASCII
printer,
eend 3 716
the microprocessor
microprocessor must send
-|g to the printer;
printer; 0716
07-|g is the 'bell'
'bell' character.
Similarly, the microprocessor
microprocessor will
ill receive the character
character 9 from an ASCII
Similarly,
ASCII keyboard
915;
as 3 9
-|g; 0915
09-|6 is the 'tab' character.

4) Some
Some ASCII
ASCII devices
devices do
do not
not use
use the
the full
full character
character set.
set. For
For example,
example. control
control
characters and lower case letters may be ignored or printed as spaces or question
characters
marks.
marks.
Some wwidely
used ASCII
ASCII characters
characters are:
are:
5) Some
idely used
0A15e - line feed (LF)
(LF)
OAi
0D15
(CR)
0D-|6 -■ carriage return (CR)
20
ig - space
015

3F15 - ? (question mark)
mark)
3F-|6
7F
i0 - rubout
rubout or delete character
character
F15

6)

Each ASCII character occupies eight bits. This allows a large character
character set but is
wasteful when the data is limited
limited to a small subset such as the decimal
decimal numbers.
wasteful
byte. for example,
example. can hold only one ASCII-coded decimal
An 8-bit
-b it byte,
decimal digit.
digit, while
hile it
can hold twoo BCD-coded digits.

66-1

Table 6-1.
6-1. Hex-ASCII
Hex-ASCII
Table
Table
Table
D

0
~

,

D

,

0

2
3
4
6
6
7
8
9
A
B
C
D
E
F

NUL
SOH
STX
ETX
EOT
ENO
ACK
BEL
BS
HT
LF
VT
FF

CR

so

SI

DLE
DC1
DC2
DC3
DC4
NAK
SYN
ETB
CAN
EM
SUB
ESC
FS
GS
RS

us

2

3

4

SP

0

@

!

1

A
B
C
D
E
F
G
H
I

..
#
$

%
&
(

.)

2

3
4
5
6
7
8
9

J

+

<
=

-

>

I

?

6-2

K
L
M
N
0

6

7

p

'

Q

a
b

p
q

6

R

s
T
u

C

r
s

d

t

e

u

V

f

V

w

X

g
h

y

[

i
j
k

\

I

]

m
n

-

0

w
y

z

.

X

z

I
I
}

DEL

EXAMPLES

Length of a String of Characters
Length
Purpose: Determine
Determine the length
length of a string of ASCII characters
characters (seven bits with
ith most
significant
zero). The string
significant bit zero).
string starts in memory
memory location
location 0041;
0041; the end of
('CR', 0015).
the string
string is marked by a carriage return character
character CCR',
ODig). Place the
length
length of the string
string (excluding
(excluding the carriage return) into memory
memory location
0040.

Sample Problems:
a
Result:

b

Result:

(0041)

=

OD
0D

(0040)

=

00

since the first
first character
character is a carriage
carriage return.

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)

=
=
=
=
=
=
=

52
41
54
48
45
52
OD
OD

'R'
■R
'A'
T
'H'
'E'
'E'
'R'
CR
CR

(0040)

=

06

Flowchart:
Flowchart:
Start

Base= 0041
Length= 0

Yes

Length = Length

(0 040)
0 ) = Length

+1

C

6-3
6-

End
E
nd

)

Program:
Source Program:

CHKCR

DONE

LDX
LOX
LOA
LDA
CMP
BEO
BEQ
INX
JMP
STX
BRK
BRK

;STRING
;STRING LENGTH
LENGTH =
= ZERO
ZERO
:GET ASCII
ASCII CARRIAGE
CARRIAGE RETURN
RETURN TO COMPARE
COMPARE
;GET
:IS CHARACTER
CHARACTER A CARRIAGE
CARRIAGE RETURN?
RETURN?
;IS
:YES. DONE
DONE
;YES,
:NO. ADD 1 TO STRING
STRING LENGTH
LENGTH
;NO,

#00
# $0D
0D
$41.X
$41,X
DONE
DONE

CHKCR
CHKCR
$40

:SAVE STRING
STRING LENGTH
LENGTH
;SAVE

Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0004
0005
0006
0007
0008
0009
OOOA
000A
0008
000B
oooc
o ooc
000D
OOOE
000E

A2
00
A9
OD
OD
D5
41
FO
FO
04
E8
ES
4C
04
00
86
40
00

Instruction
Instruction
(Mnemonic)

CHKCR
CHKCR

DONE
DONE

LOX
LDX

#0

LOA
LDA

# $0D
0D

CMP

$41.X
$41,X

BEQ
BEO

DONE
DONE

INX
JMP

CHKCR
CHKCR

STX
STX

$40

BRK
BRK

'CR', is just
ASCII code (ODi
(0D15)
The carriage return character. 'CR',
just another
another ASCII
q as far as the comcom­
puter
puter is concerned. The fact that this character
character causes an output
output device to perform a
control
control function
function rather than print
print a symbol
symbol does not affect
affect the computer.
The Compare instruction.
instruction. CMP,
subtraction had been performed
CMP. sets the flags as if a subtraction
but leaves
leaves the carriage return character
Accumulator
character in the Accum
ulator for later comparisons. The
(Z) flag is affected
Zero (Z)
affected as follows:
follows:

=1
Z=

if the character
character in the string
string is a carriage return

=0
Z =

if it is not a carriage return

LOX #00 in­
inThe instruction
instruction INX adds 1 to the string
string length counter
counter in Index Register X. LDX
itializes this counter
counter to zero before the loop begins. Remember to initialize
initialize variables
loop.
before using them in a loop.
This loop does not terminate
inate because a counter
counter is decremented
decremented to zero or reaches a
maximum
maximum value. The computer
puter will
ill simply
simply continue
continue examining
examining characters
characters until
until it finds
a carriage return. It is good programming
programming practice
practice to place a maximum
maximum count
count in a loop
like this to avoid problems with
ith erroneous strings
strings that do not contain
contain a carriage return.
What
hat would
ould happen if the example program were used with
ith such a string?

6-4

Note that
that by rearranging
rearranging the logic and changing
changing the initial
initial conditions,
conditions, you can shorten
the program
proprogram and decrease its execution
execution time. If we adjust
adjust the flowchart
chart so that
that the pro­
gram increments
increments the string
string length
length before it checks for the carriage return, only one
flowchart
Jumpp instruction
instruction is necessary instead of two. The new flow
chart and program are as
follows:
follows:

Start

Base= 0041
Length= -1

Length = Length
+1

100401 = Length

End

Source Program:

CHKCR

LDX
LOX
LDA
LOA
INX
CMP
BNE
BNE
STX
BRK
BRK

#$FF
#$ 0D
D
$41,X
CHKCR
CHKCR
$40

:STRING
;STRING LENGTH
LENGTH =
= -1
:GET
;GET ASCII CARRIAGE
CARRIAGE RETURN
RETURN TO COMPARE
COMPARE
;ADD 1 TO STRING
STRING LENGTH
LENGTH
CHARACTER A CARRIAGE
CARRIAGE RETURN?
RETURN?
;IS CHARACTER
CHECK NEXT CHARACTER
CHARACTER
;NO, CHECK
;YES, SAVE STRING
STRING LENGTH
LENGTH
;YES.

This version is not only shorter
shorter and faster, but it also contains
contains no absolute
absolute destination
destination
addresses:
anywhere in memory. The earlier version concon­
addresses; thus it can easily be placed anywhere
tains a JMP instruction
instruction with
ith a specific
specific absolute
absolute address, while
hile this version has only
instructions with
ith relative
relative addresses.
branch instructions
addresses.

6-5
6-

Object Program:
Program:

MemoryAddress
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0001
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
000B

A2
A2
FF
FF
A9
A9
OD
OD
E8
EB
D5
D5
41
41
DO
DO
FB
FB
86
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LDX
LOX

#$FF

LDA
LOA

# $0D

CHKCR INX
INX
CHKCR
CMP
CMP

$41.X

BNE
BNE

CHKCR
CHKCR

STX
STX

$40

BRK
BRK

6 -6

Find First Non-Blank Charactet
Find
Character
(seven bits with
zero)
Purpose: Search a string
string of ASCII characters
characters (seven
ith most significant
significant bit zero)
for a non-blank
non-blank character. The string
string starts in memory location 0042. Place
the index of the first
first non-blank
non-blank character
character in memory location
location 0040. A blank
character
character is 2015
0 i6 in ASCII.
ASCII.

Sample Problems:
a.
Result:

b.

Result:

(0042)

37

(0040)

00. since memory location 0042 contains
00,
contains a
non-blank
non-blank character.

ASCII 7

(0042)
(0043)
(0044)
(0045)
(0046)

=
=
=
=
=

20
20
20
46
20

(0040)

=

03. since the three previous memory locations
all contain
blanks.
contain blanks.

SP
SP
SP
SP
SP
SP
'F
T'
SP
SP

Flowchart:
Flowchart:
Start

Base= 0042
Index= 0

No

Index = Index + 1

(00401 = Index

End

6-7
7

Program:
Source Program:

CHBLK
CHBLK

DONE
DONE

LDX
LOX
LDA
LOA
CMP
BNE
BNE
INX
JMP
STX

#00
#'
$42.X
$42,X
DONE
DONE
CHBLK
CHBLK
$40

;START WITH INDEX
INDEX =
= ZERO
ZERO
;GET ASCII
ASCII SPACE
SPACE FOR
FOR COMPARISON
COMPARISON
;GET
:IS CHARACTER
CHARACTER AN ASCII
ASCII SPACE?
SPACE?
;IS
;NO. DONE
DONE
;NO,
;YES. EXAMINE NEXT
NEXT CHARACTER
CHARACTER
;YES.
INDEX OF
OF FIRST
FIRST NON-BLANK
;SAVE INDEX
CHARACTER
; CHARACTER

BRK
BRK

(') or single quotation
ASCII character.
Note the use of an apostrophe
apostrophe 0
quotation mark before an ASCII

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0008
0009
000A
OOOA
0008
0006
oooc
000C
000D
OOOE
000E

A2
00
A9
20
D5
42
DO
DO
04
E8
EB
4C
04
00
86
40
00

Instruction
Instruction
(Mnemonic)

CHBLK
CHBLK

DONE
DONE

LOX
LDX

#0

LOA
LDA

#''

CMP

$42.X
$42,X

BNE
BNE

DONE
DONE

INX
JMP

CHBLK
CHBLK

STX

$40

BRK
BRK

Looking for spaces in strings
strings is a common
common task.
eliminated from
task. Spaces often are eliminated
strings
strings when they are used simply
simply to increase readability
readability or to fit particular
particular formats. It is
obviously
transmitit beginning.
obviously wasteful
wasteful to store and transm
beginning, ending.
ending, or extra spaces,
particularly
spaces. particularly
if you are paying for the comm
communications
capability and memory
memory required. Data and
unications capability
entry. however.
program entry,
however, are much simpler
simpler if extra spaces are tolerated.
tolerated. Microcom
Microcom-­
puters are often used in situations
situations like this to convert
convert data between
between forms that
that are easy
easy
for humans to use and forms that are efficiently
efficiently handled on computers
computers and comcom­
munications
unications lines.
lines.

6-8
6-

Again.
Again, if we alter
alter the initial
initial conditions
conditions so that
that the loop control
control section
section precedes the pro­
processing section.
section, we can reduce the number
number of bytes in the program
program and decrease the
loop's execution
execution time. The rearranged
rearranged flowchart
chart is:
is:
Start

Base= 0042
Index= -1

Index = Index + 1

(00401 = Index

End

Program:
Source Program:

CHBLK
CHBLK

LDX
LDA
INX
CMP
BEO
BEQ
STX

#$FF

#'
$42.X
$42,X
CHBLK
CHBLK
$40

:START WITH INDEX =
= -1
-1
:GET
SPACE FOR
FOR COMPARISON
COMPARISON
GET ASCII SPACE
:INCREMENT
INCREMENT INDEX
INDEX
:IS CHARACTER
CHARACTER AN ASCII SPACE?
SPACE?
:YES.
CHARACTER
YES, EXAMINE NEXT CHARACTER
:NO.
NO, SAVE INDEX OF FIRST
FIRST NON-BLANK
: CHARACTER
CHARACTER

BRK
BRK

Object
Program:
Object Program:
Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Memory
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
, 0003
0003
0004
0004
0005
0006
0007
0007
0008
0009
000A
OOOA
000B
0008

A2
FF
FF
A9
20
EB
E8
D5
42
FO
FO
FB
FB
86
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

CHBLK

LDX

#$FF

LDA

#''

INX
CMP

$42.X
$42,X

BEO
BEQ

CHBLK
CHBLK

STX

$40

BRK
BRK

6-9

Leading Zeros with
Blanks
Replace Leading
ith Blanks
Purpose: Edit a string of ASCII
ASCII decimal
zeros with
Purpose;
decimal characters by replacing
replacing all leading zeros
ith
blanks. The string starts in memory location 0041;
0041; assume that
that it consists
entirely
entirely of ASCII-coded decimal digits. The length
length of the string is in memory
location
location 0040.
Sample Problems:
a.
a.

(0040)
(0040)
(0041)

= 02
=
= 36

ASCII 6
ASCII

zero.
The program leaves the string unchanged.
unchanged, since the leading digitit is not zero.
b.

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

=
=
=
=

08
30
30
38

ASCII 0
ASCII
ASCII 0
ASCII
ASCII 8
ASCII

(0041)
(0041)
(0042)
(0042)

=
=

20
20

SP
SP
SP
SP

ASCII zeros
zeros have been replaced by ASCII
ASCII blanks.
blanks.
The twoo leading ASCII
Flowchart:
Flowchart:
Start

Count = (00401
lndex = 0

Base= 0041

(Base+lndex)

=

ASCII Space (20 151
Index = Index + 1

End

6-10
610

Source Program:

CHKZ
CHKZ

DONE
DONE

LOX
LDX
LOY
LDY
LDA
LOA
CMP
BNE
BNE
STY
INX
CPX
BNE
BNE
BRK
BRK

#00
#'
#
#'O
'0
$41.X
,X
DONE
DONE
$41.X
$41,X

;INDEX== ZERO
ZERO TO START
START
INDEX
:GET
SPACE FOR
FOR REPLACEMENT
REPLACEMENT
GET ASCII SPACE
:GET ASCII ZERO
ZERO FOR
FOR COMPARISON
COMPARISON
:IS LEADING DIGIT
DIGIT ZERO?
ZERO?
;NO, END REPLACEMENT
REPLACEMENT PROCESS
PROCESS
:IS LEADING DIGIT
DIGIT ZERO?
ZERO?

$40
CHKZ

NEXT DIGIT
DIGIT IF ANY
;EXAMINE NEXT

Single quotation
frontt of a character
ASCII
quotation mark in fron
character indicates
indicates that the operand is an ASCII
code.

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
000A
OOOB
000B

A2
00
AO
20
A9
30
D5
41
DO
DO
07
94
41
EB
E8
E4
40
DO
F5
00

oooc
oooc
000D
OOOE
000E
000F
OOOF
0010
0011

Instruction
Instruction
(Mnemonic)

CHKZ
CHKZ

DONE
DONE

LOX
LDX

#0

LOY
LDY

#''

LOA
LDA

#'O
'0

CMP
CMP

41,X
$4
1.X

BNE
BNE

DONE
DONE

STY
STY

$ 41.X
1.X

INX
CPX
CPX

$40

BNE
BNE

CHKZ
CHKZ

BRK
BRK

You will
ill frequently
frequently want
ant to edit
edit decimal
decimal strings
strings before they are printed
printed or displayed
displayed to
improve
their appearance. Common
include eliminating
zeros.
improve their
Common editing
editing tasks include
inating leading zeros,
justifying
markers. and rounding.
Clearly.
justifying numbers.
numbers, adding
adding signs or other
other identifying
identifying markers,
rounding. Clearly,
printed
printed numbers
numbers like 0006
0006 or $27.34382
$27.34382 can be confusing
confusing and annoying.
Here the loop has two exits
exits -— one if the processor finds a nonzero digitit and the other if
it has examined
examined the entire
entire string.

The instruction
hex) in a memory loca­
locainstruction STY $41.X
$41,X places an ASCII space character
character (20 hex)
tion that previously
zero. Note that STY has only a limited
previously contained
contained an ASCII zero.
limited number
number
of addressing
(see Table 3-4):
addressing modes (see
3-4); there are no indexing
indexing modes with
ith Register Y, no
pre-indexing.
zeropre-indexing, and no absolute
absolute indexing.
indexing. The only indexed addressing
addressing mode is the zeropage mode with
ith Index Register X.
All
is. the digits
3015 through
All digits
digits in the string
string are assumed to be ASCII; that is,
digits are 30-|6
916
Oto
ASCII is
39
1 0 rather
rather than the ordinary
ordinary decimal
decimal 0
to 9. The conversion
conversion from decimal
decimal to ASCII
simply
015
simply a matter
atter of adding
adding 3 0
ig to the decimal
decimal digit.

6 -11

You can place a single ASCII character
character in a 6502 assembly language program by pre·
pre­
ceding it with
apostrophe(').
ith an apostrophe
(’). You can place a string of ASCII characters
characters in program
memory by using the .TEXT
.TEXT (Store ASCII Text) pseudo-operation
assem·
pseudo-operation on the 6502 assem­
bier. A delim
delimiter
text: the usual form is:
is:
bler.
iter character
character (usually/)/) must surround the text;

Label

peration
O pe
ra tio n
Code
Code

Operand
Operand

EMSG
EMSG

.TEXT
.TEXT

/ERROR/
/ERROR/

zeros, to leave one zero in the event that
You may have to be careful,I. when blanking
blanking zeros,
that all
the digits
zero. How would
digits are zero.
would you do this?
Note that
ASCII digit
bits. as compared to four for a BCD digit.
that each ASCII
ig it requires eight
eight bits,
Therefore, ASCII is an expensive
transmitit numerical
numerical data.
data.
expensive format
at in which
hich to store or transm

6-12
612

Add Even Parity to ASCII Characters
ASCII characters. The length of the string
Purpose: Add even parity to a string of 7-bit
7-bit ASCII
is in memory location 0040 and the string itself begins in memory location
0041. Place even parity in the most significant
setsignificant bit of each character
character by set­
ting the most significant
significant bit to 1 if that makes the total number of 1 bits in
the word an even number.
Sample Problem:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0045)
(0045)
(0046)
(0046)
(0041)
Result: (0041)
(0042)
(0042)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

- 06
=
=
=
=
=
=

31
31
32
33
34
35
36

=

B1
B1
B2
33
B4
35
36

=
=
=
=
=

6-13

Flowchart:
Flowchart:
Start

Base= 0040
Index = (0040)

Bit Count= 0

Data = (Base +
Index)

Bit Count=
Bit Count + 1

Shift Data Left One
Bit Arithmetically

(LSB = 01

Set MSB of
(Base+lndex)
to 1

End

6-14

Program:
Source Program:
LDX
GTDATA LDY
GTDATA
LDA
CHBIT
BPL
INY
CHKZ
ASL
BNE
BNE
TYA
LSR
LSR
BCC
LDA
ORA
STA
NEXTE
DEX
NEXTE
DEX
BNE
BRK
BRK

sec

$40
#0
$40.X
$40.X
CHKZ

COUNT
INDEX = MAXIMUM
MAXIMUM COUNT
ZERO FOR
FOR DATA
BIT COUNT== ZERO
GET DATA
FROM BLOCK
BLOCK
GET
DATA FROM
;IS NEXT DATA BIT 1?
;YES.
YES, ADD 1 TO BIT COUNT
COUNT
;EXAMINE NEXT
NEXT BIT POSITION
POSITION
;UNLESS ALL BITS
BITS ARE
ARE ZEROS
ZEROS

A
CHBIT

;DID DATA
EVEN NUMBER
NUMBER OF
OF '1' BITS?
DATA HAVE EVEN

A
NEXTE
NEXTE
$40.X
$40,X
%10000000
#% 1
0000000
$40.X
$40,X

;NO.
SET PARITY BIT
BIT
NO, SET

GTDATA

;CONTINUE THROUGH
THROUGH DATA BLOCK
BLOCK

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000B
0008
OOOC
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018
0019
0019

A6
40
AO
00
85
B5
40
10
01
C8
CB
OA
DO
DO
FA
98
4A
90
06
B5
85
40
09
80
95
40
CA
DO
DO
E9
00

oooc

Instruction
Instruction
(Mnemonic!
(Mnemonic)
LOX
LDX

$40

GTDATA LDY
LOY

#0

LOA
LDA

$40.X
$40,
X

CHBIT

BPL
BPL

CHKZ
CHKZ

CHKZ
CHKZ

INY
ASL
BNE
BNE

A
CHBIT
CHBIT

TYA
LSR
LSR
BCC

sec

A
NEXTE
NEXTE

LDA

$40,
X
$40.X

ORA
ORA

#%10000000
10000000

STA

$40,
$40.XX

DEX
DEX
BNE
BNE

GTDATA

NEXTE
NEXTE

BRK
BRK

Parity is often
often added to ASCII characters
characters before they are transm
itted on noisy comcom­
transmitted
munications
unications lines; this provides
provides a simple
simple error-checking
error-checking facility.
facility. Parity detects
detects all
single-bit errors but does not allow
single-bit
allow for error correction;
correction; that is,
checking
is. you can tell by checking
the parity
parity of the data that
that an error has occurred.
occurred, but you cannot
cannot tell which
which bit was
received incorrectly.
incorrectly. All that
that the receiver
receiver can do is request
request retransmission.
retransmission.

6-15
6-

:

The procedure for calculating
calculating parity is to count
count the number
number of '1' bits in the data words.
even.
If that number
number is odd, the MSB of the data word is set to 1 to make the parity even.
ASL clears the least significant
significant bit of the number
number being shifted. Therefore.
Therefore, the result of
zero. regardless of the original
a series of ASL instructions
instructions will
ill eventually
eventually be zero,
original value of
the data (try it!). The bit counting
counting section of the example program not only does not
need a counter.
counter, but also stops examining
examining the data as soon as all remaining
remaining bits are
zeros. This procedure saves
saves execution
cases.
zeros.
execution time in many cases.

'1' by logically
The MSB of the data is set to T
logically ORing it with
ith a pattern that has a '1' in its
most significant
zeros elsewhere. Logically
significant bit and zeros
Logically ORing a bit with
ith one produces a
result of one regardless of the original
original value, while
hile logically
logically ORing a bit with
ith zero does
not change the original
original value.

5-16
5-

Pattern Match
atch
ASCII characters
see if they are the same.
same. The
Purpose: Compare twoo strings
strings of ASCII
characters to see
length
length of the strings
strings is in memory location
location 0041:
0041; one string starts in memory
location 0042 and the other in memory location 0052. If the two strings
location
match.
match, clear memory location 0040;
0040; otherwise.
otherwise, set memory location 0040 to
FF15 (all ones).
ones).
FF-ie
Sample Problems:
(0041)

a.

(0042)
(0043)
(0044)

Result:

b.

Result:

=

03

. 43
=

41
= 54

'C'
'A'
’A'
T

'C'
■c
'A'
T

(0052)
(0052)
(0053)
(0054)

=
=

(0040)

=

00,
00.

(0041)

=

03

(0042)
(0042)
(0043)
(0044)

-

52
41
54

'R'
■R
'A'
T

43
41
= 54

·c·
'C

43
41
= 54

=

(0052)
(0053)
(0054)

=
=

(0040)

=

since the two strings are the same.

'A'
'T
T

FF,
FF. since the first characters in the
strings
strings differ.

Note: The matching
matching process ends as soon as the CPU
difference -— the rest of
CPU finds a difference
the strings
strings need not be examined.

6-17

Flowchart:
Flowchart:
Start

Index= 0
Mark= FF16

Index = Index + 1

Mark= 0

(00401 = Mark

End

Source Program:
Program:

CHCAR
CHCAR

DONE
DONE

LDX
LOX
LDY
LOY
LDA
LOA
CMP
CMP
BNE
BNE
INX
INX
CPX
CPX
BNE
BNE
LDY
LOY
STY
STY
BRK
BRK

#0
#$FF
$42,X
$42.X
$52,X
$52.X
DONE
DONE

;START
FIRST ELEMENT
ELEMENTIN STRINGS
STRINGS
START WITH FIRST
MARKER
;MARKER FOR
FOR NO MATCH
;GET CHARACTER
CHARACTERFROM
FROM STRING
STRING 1
GET
;IS THERE
THEREA MATCH WITH STRING
STRING 2?
27
;NO.
DONE
NO, DONE

$41
$41
CHCAR
CHCAR
#0
$40

CHECK
;CHECK NEXT
NEXT PAIR
PAIR IF ANY LEFT
LEFT
;IF NONE
NONE LEFT,
LEFT. MARK
MARK MATCH
;SAVE MATCH MARKER
MARKER

6-18
618

Object Program:
Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
000B

A2
00
AO
A0
FF
FF
B5
42
D5
05
52
DO
DO
07
E8
EB
E4
41
DO
DO
F5
A0
AO
00
84
40
00

oooc
oooc
0000
00D
0
00E
OOOE
OOOF
000F
0010
0011
0012
0013

Instruction
Instruction
(Mnemonic)

CHCAR
CHCAR

DONE
DONE

LDX
LOX

#00

LDY
LOY

#$FF

LDA
LOA

$42.X
X

CMP

$52,X
$52.X

BNE
BNE

DONE
DONE

INX
CPX
CPX

$41

BNE
BNE

CHCAR
CHCAR

LOY
LDY

#00

STY
STY

$40

BRK
BRK

ASCII characters
Matching
atching strings
strings of ASCII
characters is an essential part of recognizing
recognizing names or comcom­
mands. identifying
identifying variables or operation codes in assemblers and compilers, finding
finding
files. and many other tasks.
tasks.
files,
Index Register X is used to access both string;,
strings -— only the base addresses are different.
different.
strings to be located anywhere
anywhere in memory,
although we would
would
This method allows the strings
memory. although
have to use the absolute indexed addressing modes if the strings
strings were not on page
zero.
post-indexed mode (with Index Register Y)
zero. We could also use the post-indexed
Y) if we had two
different
zero.
different base addresses stored somewhere on page zero.

Accumulator
The instruction
instruction CMP $52.X
$52,X compares the Accum
ulator to the contents
contents of the indexed
memory location. We could replace the LDY
LOY #0 instruction
INY. Why?
instruction with
ith INY.
Why? Compare
the time and memory requirements
requirements of the two alternatives.
alternatives. Which
hich version do you think
is clearer? The replacement
replacement would
would also allow
allow you to use a memory location
location for the
marker rather than a register
(why?).
register (why?).

6 -19
19

PROBLEMS
PROBLEMS
1)

Length of a T ele ty p
typewriter
Length
e w rite r Message

ASCII message.
message. All characters are 7-bit
ASCII
Purpose: Determine
Determine the length
length of an ASCII
7-bit ASCII
= 0. The string
message is embedded
with
ith MS8
MSB =
string of characters
characters in which
hich the message
starts in memory
ASCII STX
STX
memory location
location 0041. The message itself starts with
ith an ASCII
character
ETX (0315).
message
character (0215)
@ and ends with
ith ETX
6) Place the length of the message
ETX but including
(the number
number of characters
characters between
between the STX and the ETX
including
neither) into memory
memory location
location 0040.
Sample Problem:

Result:

2)

(0041)
(0042)
(0043)
(0044)
(0045)

= 40
40
= 02
02 STX
STX
'G'
= 47
47 'G'
·o·
= 4F
4F ’O’
= 03
03 ETX
ETX

(0040)

since there
there are
aretw
two
characters between
= 02, since
o characters
betweenthe
theSTX
STX
ETX in location 0045.
in location
location 0042 and ETX

Find Last Non-Blank Character
Find

ASCII characters
characters for
for the
the last non-blank
Purpose: Search a string of
of ASCII
non-blank character. The
string
location 0042
0042 and
and ends
ends wwith
string starts in memory
memory location
ith aa carriage
carriage return
return
character
(OD15). Place the index of the last non-blank
character (0D-|g).
non-blank character
character in memory
location
location 0040.
Sample Problems:
a.
Result:

b.

Result:

=

(0042)
(0043)

=

(0040)
(0040)

—

(0042)
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)

=
=
=
=
=
=

(0040)

=

37 ASCII 7
OD CR
CR
0D
00, since the last (and only) non-blank
non-blank character
character
is in memory location 0042.

41
20
48
41
54
20
20
= 0D
OD

'A'
SP
SP
'H'
'A'
T
SP
SP
SP
SP
CR
CR

04

6 -20
20

3)

Truncate
Decimal
Truncate Decim
al String to Integer
Integer Form

ASCII decimal characters by replacing
Purpose: Edit a string of ASCII
replacing all digits
digits to the right
right of
ASCII blanks (20-)
(2015).
locathe decimal
decimal point
point with
ith ASCII
q). The string
string starts in memory loca­
tion 0041 and is assumed to consist entirely
entirely of ASCII-coded decimal
decimal digits
digits
2E15).
The
and a possible decimal
decimal point
point ( 2 E
-|Th
e length
length of the string is in memory
location
location 0040.
0040- If no decimal point
point appears in the string.
string, assume that the
decimal
decimal point
point is implicitly
plicitly at the far right.
Sample Problems:

a.

Result:

b

Result:
Result:

4)

(0040)

=

04

(0041)
(0042)
(0043)
(0044)
(0044)

=
=
=
=

37
2E
38
31
31

ASCII 7
ASCII
ASCII.
ASCII
ASCII
ASCII 8
ASCII 1
ASCII

(0041)
(0042)
(0043)
(0044)

—

37
2E
20
20

ASCII
ASCII 7
ASCII.
ASCII
SP
SP
SP
SP

(0040)

=

03

(0041)
(0042)
(0043)

=
=

36
37
31

=
—

=

=

ASCII 6
ASCII
ASCII
ASCII 7
ASCII 1
ASCII

Unchanged.
nged, as number
number is assumed to be 671.

Check Even Parity in ASCII Characters

ASCII characters. The length
Purpose: Check even parity in a string of ASCII
length of the string is
in memory location 0041.
0041, and the string itself begins in memory location
0042. If the parity
correct. clear memory
parity of all the characters in the string is correct,
location
(all ones)
ones) into memory location 0040.
location 0040;
0040; otherwise.
otherwise, place FF15
1 q (all
Sample Problems:

a.

Result:
b

Result:

(0041)

=

03

(0042)
(0042)
(0043)
(0043)
(0044)

=

=

B1
B1
B2
33

(0040) =

00,

(0041)
(0041)

=

03

(0042)
(0043)
(0043)
(0044)
(0044)

=
=
=

B1
B1
B6
33

(0040)
(0040)

=

FF. since the character
FF,
character in memory location 0043
does not have even parity.

=

since all the characters have even parity.

66-21

5)

String Comparison

ASCII characters to see
see which
Purpose: Compare twoo strings of ASCII
which is larger {i.e
(i.e.,.. which
follows
follows the other in alphabetical
alphabetical ordering). The length of the strings is in
memory location 0041;
0041; one string starts in memory location 0042 and the
other in memory location 0052. If the string starting
starting in memory location
0042 is greater than or equal to the other string,
string. clear memory location
0040;
FF16 (all
{all ones).
ones).
0040; otherwise.
otherwise, set memory location 0040 to FF-|g
Sample Problems:

a.

Result:

b

Result:

c.

Result:

(0041)

03

(0042)
(0042)
(0043)
(0043)
(0044)
(0044)

43
41
54

·c·
'C'

(0052)
(0052)
(0053)
(0053)
(0054)
(0054)

42
51
54

'B'
'A'
T

(0040)
(0040)

00,

'larger· than BAT.
BAT.
since CAT is 'larger'

(0041)
(0041)

03

10042)
(0042)
10043)
(0043)
10044)
(0044)

43
41
54

'C'
■c
'A'
T

10052)
(0052)
10053)
(0053)
10054)
(0054)

43
41
54

'A'
T

(0040)
(0040)

00,.

equal.
since the two strings are equal.

(0041)
(0041)

03

(0042)
(0042)
(0043)
(0043)
(0044)
(0044)

43
41
54

'C'
'C
'A'
T

(0052)
(0052)
(0053)
(0053)
10054)
(0054)

43
55
54

'C'
·u·
'U'
T

10040) =
(0040)

FF. since CUT
CUT is 'larger'
'larger· than CAT.
CAT.
FF,

'A'
'T
T

·c·
'C'

6 -22
22

Chapter 7
CODE CONVERSION
CONVERSION
PeCode conversion is a continual problem in most microcomputer
icrocomputer applications. Pe­
ripherals provide data in ASCII,
codes. The system must
ripherals
ASCII, BCD, or various special codes.
convert the data into some standard form for processing.
processing. Output
Output devices may rere­
codes. Therefore, the system
quire data in ASCII.
ASCII, BCD, seven-segment,
seven-segment, or other codes.
processing is completed.
must convert
convert the results to a suitable form after
after the processing
There are several
several ways
ways to approach code conversion:
1)

2)

3)

Some conversions can easily be handled by algorithms involving arithmetic
etic or
logical functions. The program
program may. however.
however, have to handle some special cases
separately.
More complex conversions can be handled with
ith lookup tables. The lookup tata­
ble method
method requires little
little programming
programming and is easy to apply. However.
However, the table
large.
may occupy
occupy a large amount
amount of memory if the range of input
input values is large.
Hardware
Hardware is readily available for some conversion tasks. Typical
Typical examples
examples are
decoders
decoders for BCD to seven-segment
seven-segment conversion
conversion and Universal
Universal Asynchronous
Asynchronous
Receiver/Transmitters
(UARTs) for conversion
(ASCII) and serial
Receiver/Transmitters (UARTs)
conversion between
between parallel (ASCII)
(teletypewriterl
(teletypewriter) formats.

In most applications,
applications, the program
program should do as much as possible of the code conversion
conversion
work. This results in a savings in parts and board space as well
ell as in increased
reliability.
reliability. Furthermore.
Furthermore, most code conversions
conversions are easy to program
program and require little
little
execution time.
execution

7-1

EXAMPLES
Hex to ASCII
Purpose:

Convert
Convert the contents
contents of memory
memory location
location 0040
0040 to an ASCII character.
Memory location
digitit (the four most
Memory
location 0040
0040 contains
contains a single
single hexadecimal
hexadecimal dig
significant
zero). Store the ASCII character
significant bits are zero).
character in memory
memory location
0041.

Sample Problems:
a.
a.
Result:

b.
b.
Result:

(0040)
(0040)

oc
0C

(0041)

43

(0040)
(0040)

06

(0041)

36

·c·
'C'
'6'

Flowchart:
Flowchart:

(

Start

i

)

Data = 10040)

Data=
Data + ASCII A ASC\19 -1

Result=
Data+ ASCII Zero

10041) = Result

c__

E_nd
__

)

Source Program:
Program:

ASCZ

LDA
LOA
CMP
BCC
BCC
ADC
ADC
STA
BRK
BRK

$40
#10
10
ASCZ
# 'A-'9-2
-'9 -2
#'O
'0
$41

;GET
;GET DATA
LESS THAN 10?
;IS DATA LESS

;NO. ADD OFFSET
OFFSET FOR
FOR LETTERS
LETTERS (CARRY
(CARRY =
= 1)
.ADD
OFFSET FOR
;ADD OFFSET
FOR ASCII
;STORE ASCII DIGIT
;STORE
DIGIT

7-2
7-

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)
0000
0001
00
0002
0 0
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
0 00 0

Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

A5
A5

LDA
LOA

$40

40
C9

CMP
CMP

# 1 0

0A
90

BCC
BCC

ASCZ
ASCZ

ADC

# 'A-'9-2
-'9 -2

ADC

#■0

STA

$41
$41

02
69
06
69
30
85
41
00
0

#10

02

000B
000B
0 0 0
c
oooc

ASCZ
ASCZ

#'O

BRK
BAK

The basic idea of this program is to add ASCII zero (3015)
1 q) to all the hexadecimal digits.
This addition
ASCII correctly:
however. there is a break
break
addition converts
converts the decimal
decimal digits
digits to ASCII
correctly; however,
between ASCII
ASCII 9 (39-|
(3915)
15) which
g) and ASCII A (41 1 0
which must be considered. This break must
A. B,
B. C,
C. D,
D. E,
E. and F.
F. The first ADC instruction
acbe added to the non-decimal
non-decimal digits
digits A,
instruction ac­
complishes
complishes this by adding
adding the offset 'A-'9-2
'A-'9-2 to the contents
contents of the Accumulator.
Accumulator. Can
you explain
explain why
why the offset is 'A-'9-2?
'A-'9-2?
The problem here is that the letters do not follow
follow immediately
mediately after the decimal digits
digits in
ASCII.
occupied by the ASCII
1 0 >, =
ASCII. There is a gap occupied
ASCII codes for such characters as:: (3A15).
(3015).
@(4015).
gap. we must add a constant
(3D
1 g), and @
(40ig). To bridge this gap,
constant factor
factor determined
determined by
the distance
distance between
between the actual value of ASCII
1 0 and the value it would
would have if
ASCII A (4115)
(3A15). There is also an extra factor of 1 provided by the Carry
Carry flag.
there were no gap (3A-|g).
You can compare this situation
situation to the problem of walking
walking from one address to another
river.
on a street that
that is divided
divided into two discontinuous
discontinuous sections by a canyon or a river.

Remember that
BCC instructhat the ADC instruction
instruction always adds in the Carry bit. Afterr the BCC
instruc­
tion. we know
tion,
know that
that the Carry contains
contains one (otherwise a branch would
would have occurred).
Carry. As for the second
So we simply
ply reduce the additive
additive factor
factor by 1 to account
account for the Carry.
CMP instrucADC instruction.
instruction, the Carry will
ill be zero if the program branched after the CMP
instruc­
BCC instruction
used) or if the A ccum
ccumulator
hextion (since the BCC
instruction was used)
ulator contained
contained a valid hex­
adecimal digit
15) since the additive
7. Therefore,
Therefore. we do not
ig it (10 through
through 15)
additive factor
factor is only 7.
case.
have to worry
orry about
about the Carry in any reasonable case.
This routine could be used in a variety
example. monitor
variety of programs:
programs; for example,
onitor programs
must convert
ASCII in order to display the contents
convert hexadecimal
hexadecimal digits
digits to ASCII
contents of memory
locations in hexadecimal
ASCII printer
CRT display.
hexadecimal on an ASCII
printer or CRT
Another
nother (quicker) conversion
conversion method that requires no conditional
conditional jumps
ps at all is the
following
following program.
program, described
described by Allison.1
AllisonJ
SED
SEO
CLC
CLC
LDA
LOA
ADC
ADC
STA
CLD
CLO
BRK
BAK

$40
#$
90
$90
#$
40
$40
$41

ADDITIONS. DECIMAL
:MAKE ADDITIONS
DECIMAL
CLEAR CARRY
:CLEAR
CARRY TO START
START
:GET
DIGIT
GET HEXADECIMAL DIGIT
:DEVELOP
EXTRA 66 AND CARRY
CARRY
DEVELOP EXTRA
:ADD IN CARRY,
CARRY. ASCII
ASCII OFFSET
OFFSET
:STORE
DIGIT
STORE ASCII DIGIT
;CLEAR
MODE BEFORE
BEFOREENDING
ENDING
CLEAR DECIMAL MODE

7-3
7-

Try this program
program on some digits.
digits. Can you explain why it works? Note that you must be
careful
careful to clear
clear the decimal
decimal mode flag when
when you have completed
completed all decimal
decimal arithmetic.
arithmetic.
Otherwise,
Otherwise, you will
ill get decimal
decimal results in programs (including
(including the monitor) where they
are not wanted.
wanted.

Seven-Segment
Decimal
al to Seven-Segm
ent
Purpose:

Convert
Convert the contents
contents of memory
memory location
location 0041 to a seven-segment
seven-segment code in
memory
memory location
location 0042.
0042. If memory
memory location 0041 does not contain
contain a single
decimal
decimal digit.
digit, clear memory
memory location
location 0042.

Seven-segment
following
Seven-segment table: The follow
ing table can be used to convert
convert decimal
decimal numbers to
seven-segment
seven-segment code. The seven-segment
seven-segment code is organized with
ith the most significant
significant
e, d, c.
c, b, and a
bit
bit always
always zero followed
followed by the code (1 = on, 0 = off) for segments
segments g, f, e,
(see Figure 7-1 for the positions
(see
positions of the segments). The segment
segment names are standard but
the organization
organization that
that we have chosen is arbitrary.
arbitrary. In actual
actual applications,
applications, the hardware
determines
determines the assignment
assignment of data bits to segments.
Note that
that the table uses 7D for 6 rather
rather than the alternative
alternative 7C (top bar off) to avoid
confusion
(bottom bar off), for no particu­
particuconfusion with
ith lower
lower case b, and 6F for 9 rather than 67 (bottom
reason.
lar reason.

Digit
Digit

Code

0
1
2
3
4
5
6
7
8
B
9

3F
06
58
5B
4F
66
6D
7D
07
7F
6F

b

g

•
d

Figure 7-1. Seven-segment
Seven-segment Arrangement
Arrangement
Sample Problems:
a.
a.

(0041)
(0041)
Result:

b.
Result:

= 03
03

(0042)
(0042)

= 4F
4F

(0041)
(0041)

= 28
28

(0042)
(0042)

= 00
00

,,

7 -4

Flowchart:
Flowchart:
Start

Data - (0041 I

Yes

Result=

Result= O

(SSEG + Data)

100421• Result

End

Note that
(SSEG) and index
that the addition
addition of base address
address (SSEG)
index (OATA)
(DATA) produces
produces the address
address
that
that contains
contains the answer.
answer.

Source Program:

DONE

LOA
LDA
LDX
LOX
CPX
BCS
LDA
LOA

#0
$41
#100
DONE
SSEG.X

STA

$42

SSEG
SSEG

o

II

CM
m

BRK
BRK
·=$20
.BYTE
.BYTE

:GET ERROR
ERROR CODE TO BLANK DISPLAY
:GET DATA
DATA
:IS DATA
DATA A DECIMAL
DECIMAL DIGIT?
:NO.
KEEP ERROR
ERROR CODE
NO, KEEP
SEVEN-SEGMENT CODE FROM
;YES. GET
GET SEVEN-SEGMENT
; TABLE
SAVE SEVEN-SEGMENT
SEVEN-SEGMENT CODE OR ERROR
:SAVE
ERROR
: CODE

;SEVEN-SEGMENT CODE TABLE
:SEVEN-SEGMENT
$3F,$06.$5B.$4F,$66
$3F,$06.$5B.$4F.$66
$6D,$7D,$07,$7F.$6F
$6D.$7D.$07.$7F.$6F

7-5
7-

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0006
0007
0008
0009
000A
OOOA
0008
000B

oooc
oooc

A9
00
A6
41
E0
EO
0A
OA
BO
BO
02
85
B5
20
85
42
00

0020
0021
0022
0023
0024
0025
0026
0027
0028
0029

3F
06
5B
58
4F
66
60
6D
70
7D
07
7F
6F

Instruction
Instruction
(Mnemonic)
LDA
LOA

#0

LOX
LDX

$41

CPX
CPX

#100

BCS
BCS

DONE
DONE

LDA
LOA

SSEG,X
SSEG.X

DONE
DONE

STA

$42

SSEG
SSEG

■
BYTE
.BYTE

BRK
BAK

.BYTE
.BYTE

$3F
$06
$58
$5B
$4F
$66
$6D
$60
$70
$7D
$07
$7F
$6F

The program calculates
calculates the memory address of the desired code by adding
adding the index
(i.e.,.. the digit
table.
ig it to be displayed) to the base address of the seven-segment
seven-segment code table.
This procedure
explicit instructions
instructions are required for the
procedure is known
known as a table lookup. No explicit
addition.
automatically
modes.
addition, since it is performed
performed autom
atically in the indexed addressing modes.
.BYTE (define byte-length
conThe assembly language pseudo-operation
pseudo-operation .BYTE
byte-length data) places con­
stant
tables. headings,
headings. error
stant data in program memory. Such data may include
include tables,
messages,
ing messages,
at characters.
characters, thresholds,
messages. prim
priming
messages. format
thresholds. etc. The label attached to
.BYTE pseudo-operation
a .BYTE
pseudo-operation is assigned the value of the address into which
hich the first byte
of data is placed.
preTables are often used to perform code conversions
conversions that are more complex than the pre­
vious example. Such tables typically
typically contain
contain all the results organized according
according to the
input
zero.
input data:
data; e.g.... the first entry
entry is the code corresponding
corresponding to the number
number zero.
Seven-segment
letSeven-segment displays
displays provide recognizable forms of the decimal digits
digits and a few let­
ters and other
other characters. Calculator-type
Calculator-type seven-segment
seven-segment displays are inexpensive,
However. the seven-segment
easy to multiplex.
ultiplex, and use little
little power. However,
seven-segment coded digits
digits are
somewhat
read.
somewhat difficult
ifficu lt to read.
The assembler simply
.BYTE
simply places the data for the table in memory. Note that one .BYTE
pseudo-operation
pseudo-operation can fill
fill many memory locations. We have left some memory space
between
between the program and the table to allow for later additions
additions or corrections.
addressThe table can be placed anywhere
anywhere in memory, although
although the absolute indexed address­
zero. We could also use post-ining mode would
would have to be used if it was not on page zero.
dexing (with
Y) and have the base
base address saved in two memory loca­
loca(with Index Register Y)
tions on page zero.
zero. The same program could then be used with
base
ith any table since the base
ROM.
address would
would be specified
specified in RAM rather than in ROM.

7-6

ASCII to Decimal
Purpose: Convert the contents
Purpose:
contents of memory location 0040 from an ASCII
character to a
ASCII character
decimal digitit and store the result in memory location 0041. If the contents
contents of
memory location 0040 are not the ASCII
ASCII representation
representation of a decimal digit.
digit,
set the contents
contents of memory location 0041 to FFig.
FF15.

Sample Problems:
a.
a.
Result:

b.
Result:

(0040)
(0040) =

37
(ASCII 7)
37 (ASCII

(0041)
(0041) =

07
07

(0040)
(0040) =

(an
invalidcode,
code.
sinceit itis is
notanan
55
55 (an
invalid
since
not
ASCII decimal digit)
ASCII

(0041)
(0041) =

FF
FF

7)

Flowchart:
Flowchart:
Start

Data = 100401

Yes

Yes

Result=
Data -ASCII 0

Result = FF16

10041) = Result

End

7-7

Program:
Source Program:

DONE
DONE

LDX
LDA
SEC
SEC
SBC
SBC
BCC
BCC
CMP
BCS
BCS
TAX
STX
BRK
BAK

#$FF
$40
#'0
'0
DONE
DONE
#10
10
DONE
DONE
$41

:GET
ERRORMESSAGE
MESSAGE
GET ERROR
;GET
GET DATA
:IGNORE
CARRY IN SUBTRACTION
IGNORE CARRY
;IS DATA BELOW ASCII ZERO?
ZERO?
;YES.
DIGIT
YES. NOT A DIGIT
;IS DATA ABOVE ASCII NINE?
NINE?
;YES.
YES, NOT A DIGIT
;SAVE DIGIT IF VALID
;SAVE DIGIT OR ERROR
ERROR MARKER
MARKER

Object Program:
Object
Memory
Memory Address
Address
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
000A
0008
000B
oooc
oooc
000D
000D
000E
OOOE
000F
0010
0010

A2
FF
FF
A5
40
38
E9
30
90
05
C9
OA
0A
BO
BO
01
AA
86
41
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

DONE
DONE

LDX

#$FF

LDA

$40

SEC
SEC
SBC
SBC

#'0
'0

BCC
BCC

DONE
DONE

CMP

#10
10

BCS
BCS

DONE
DONE

TAX
STX
STX

$41

BAK
BRK

This program
program handles ASCII-coded
ASCII-coded characters
characters just
just like ordinary
ordinary numbers. Note that the
decimal
decimal digits
digits and the letters
letters form groups
groups of consecutive
consecutive codes. Strings
Strings of letters
letters (like
names) can be alphabetized
alphabetized by placing
placing their
their ASCII representations
representations in increasing
increasing
= ASCII A++ 1 for example).
numerical
(ASCII B =
numerical order (ASCII
Subtracting
(3015)
1g1t
Subtracting ASCII zero (30-|
q) from any ASCII decimal
decimal d ig
it gives the BCD representarepresenta­
tion of that
that digit.
digit.
The Carry must
11it is not to affect
SBC promust be set before a subtraction
subtraction if
affect the result
result since SBC
pro­
= (A)
(A) - (M)
(M) - (1
(1 - Carry) where
duces (A)
(A) =
where M is the contents
contents of the addressed memory
memory
location. Compare
hand. do not include
Compare instructions.
instructions, on the other
other hand,
include the Carry in their
their im-­
plied subtractions.
subtractions.
ASCII-to-decimal
ASCII-to-decimal conversion
conversion is necessary when
when decimal
decimal numbers
numbers are being entered
from an ASCII device
CRT terminal.
device like a teletypewriter
teletypewriter or CRT
terminal.
The basic idea of the program
11the character
Is between
program is to determine
determine if
character is
between ASCII 0 and
so. the character
ASCII 9, inclusive.
inclusive. If so.
character is an ASCII decimal
decimal digit
ig it since the digits
digits form a
sequence. It may then be converted
015
(ASCII 0):
converted to decimal
decimal simply
simply by subtracting
subtracting 3 0
i6 (ASCII
e.g.,.. ASCII 7 - ASCII 0 = 37 - 30 = 7.
7.
Note that
Is done with
(SBC #'0)
that one comparison
comparison is
ith an actual
actual subtraction
subtraction (SBC
'0 ) since the
subraction
subraction is necessary to convert
convert ASCII to decimal
decimal. The other
other comparison
comparison is done with
ith
Is now in the Accum
Accumulator
1f the
an implied
implied subtraction
subtraction (CMP #10)
#10) since the final
final result
result is
ulator if
original
original number
number was valid.

7-8
7-

BCD to Binary
Purpose: Convert
Convert two BCD digits
digits in memory locations
locations 0040
0040 and 0041 to a binary
number
BCD digit
number in memory location
location 0042. The most significant
significant BCD
digit is in
memory location 0040.
Sample Problems:
(0040)
(0041)

a.

(0042)
Result: (0042)

b.
Result:

=
=

02
09

= 1D
-] 6 == 29
-| o
1015
2910

(0040)
(0041)

= 07 07
= 01 01

(0042)

=

47
1 g = 71
•] q
715
7110

Note: We include
include no flowchart
chart because the program multiplies
ultiplies the most significant
significant
digitit by 10 simply
formula 10x =Bx+
2x. Multiplying
ply by using the formula
8x + 2x.
ultiplying by 2 requires
arithmetic
one arithm
etic left shift
shift and multiplying
ultiplying by 8 requires three such shifts.

Source Program:
LDA
ASL
STA
ASL
ASL
CLC
CLC
ADC
ADC
STA
BRK
BRK

$40
A
$42
A
A

;GET
DIGIT (MSD)
(MSD)
GET MOST SIGNIFICANT DIGIT
:MSD TIMES TWO
;SAVE MSD TIMES
TIMES TWO
;MSD TIMES FOUR
FOUR
:MSD TIMES
TIMES EIGHT
EIGHT

$42
$41
$42

:MSD TIMES
TIMES TEN
TEN (NO
(NO CARRY)
CARRY)
;ADD LEAST
LEAST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
;STORE BINARY
BINARY EQUIVALENT
STORE

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
000A
OOOA
000B
0008
oooc
000C
000D
OOOD
OOOE
000E

A5
40
OA
OA
85
42
OA
OA
OA
OA
18
65
42
65
41
85
42
00

Instruction
Instruction
(Mnemonic)
LDA

$40

ASL
STA

A
$42

ASL
ASL
CLC
CLC
ADC

A
A

ADC

$41
$41

STA

$42

BRK
BRK

7-9
7-

$42

BCD entries are converted
BCD
converted to binary in order to save on storage and to simplify
plify calculacalcula­
tions. However,
advantages of binary
However. the need for conversion may offset some of the advantages
storage and arithmetic.
arithmetic.
This program multiplies
ultiplies the BCD digit
ig it in memory location
location 0040
0040 by 10 using left shifts
2 Note that
Accumulator
2. This
and additions. 2
that ASL A multiplies
ultiplies the contents
contents of the Accum
ulator by 2,
Accumulator
allows you to multiply
ultiply the contents
contents of the Accum
ulator by small decimal
decimal numbers in a
few instructions.
instructions. How would
would you use this procedure to multiply
ultiply by 16? by 12? by 7?
BCD
about 20% more storage than do binary numbers. Representing 0
BCD numbers require about
1 =
to 999 requires 3 BCD
digits (12 bits) and 10 bits in binary (since 2^0
1000).
BCD digits
= 1024 =""1000).

7-100
7-

Convert Binary Number to ASCII String
ASCII
Purpose:
Purpose: Convert the 8-bitit binary number in memory location 0041 to eight ASCII
1) in memory locations 0042 through
ASCII 1)
ASCII 0 or ASCII
characters (either ASCII
In 0042).
significant bit is in
0049 (the most significant
Sample Problem:

(0041)
(0041)
Result:
Result:

=

11010010
=1 1 0 1
02
D2 =
00

31
31
(0042)
(0042)
(0043) = 31
31
(0043)
(0044) = 30
(0044)
(0045) = 31
31
(0045)
(0046) = 30
(0046)
(0047) = 30
(0047)
31
(0048) = 31
(0048)
(0049) = 30
(0049)

ASCII 1
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII

Flowchart:
Flowchart:
Start

Base= 0041
Index= B

(Base + Index) =
ASCII Zero
Shift Data Right
One Bit

(Base + Index) =
ASCII One
li.e , (Base + Index)

+ 1l

Index = Index - 1

End

7 -11

Program:
Source Program:

CONV

COUNT

LDA
LDX
LDY
STY
LSR
LSR
BCC
BCC
INC
DEX
BNE
BNE
BRK
BRK

$41
#88
#'O
'0
$41.X
$41.X
A
COUNT
$41.X
$41,X

;GET DATA
:NUMBER OF
OF BITS
BITS== 88
:GET ASCII ZERO
ZERO TO STORE
STORE IN STRING
STRING
;STORE
ZERO IN STRING
STRING
STORE ASCII ZERO
DATA ZERO?
;IS NEXT BIT OF DATA
ZERO?
;NO. MAKE STRING
STRING ELEMENT
ELEMENT ASCII ONE
ONE
;NO,
;COUNT BITS
BITS

CONV

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
000
B
OOOB
oooc
OOOC
000D
OOOD
OOOE
000E
000F
OOOF
0010
0010

A5
41
A2
08
AO
30
94
41
4A
90
02
F6
41
CA
DO
F6
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

CONV

COUNT

LDA

$41

LDX

#88

LDY

#'O
'0

STY

$41.X
,X

LSR
LSR
BCC
BCC

A
COUNT

INC
INC

$41.X
$41.X

DEX
DEX
BNE
BNE

CONV

BRK
BRK

The ASCII digits
O+
+ 1.1. The INX instruction
digits form a sequence
sequence so ASCII 1 = ASCII 0
instruction can be
increment
used to directly
directly increm
ent the contents
contents of a memory
memory location.
location. The savings
savings here are that
no explicit
explicit instructions
instructions are required
required to load the data from memory
memory or to store the result
(A. X,
X. and Y) disturbed.
disturbed. However,
However.
back into memory. Nor are any of the user registers
registers (A,
CPU must
the CPU
must actually
actually load the data from memory.
memory, save it in a temporary
temporary register.
register, increincre­
ment
it. and store the result
ment it,
result back into
into memory.
memory. All data processing
processing actually
actually takes place
inside
CPU.
inside the CPU.
Be careful
careful of the difference
difference between
between INX and an instruction
instruction like INC $41.X.
$41.X. The INC inin­
struction
struction adds one to the contents
contents of Index Register X; INC $41.X
,X adds one to the concon­
tents of the indexed
It has no effect
X.
indexed memory
memory location
location -— it
effect on Index Register X.

Binary-to-ASCII
Binary-to-ASCII conversion
conversion is necessary when
when numbers
numbers are printed
printed in binary
binary form on an
ASCII device.
The conversion
(3015).
conversion to ASCII simply
ply involves
involves adding
adding ASCII zero (30-|
6>.

7-12
7-

PROBLEMS

1)

ASCII
ASCII to Hex
Hex

Purpose: Convert
Convert the contents
memory location
location 0040 to a hexadecimal
hexadecimal digit
contents of memory
digit and
store the result
result in memory location
location 0041. Assume
Assume that memory location
0040
digitit (7 bits with
0040 contains
contains the ASCII representation
representation of a hexadecimal
hexadecimal dig
ith
MSB 0).
Sample Problems:
a.
a.

b.

(0040)
(0040)

=

ASCII C
43
43 ASCII
C

(0041)
Result: (0041)

=

oc
0C

(0040)
(0040)

=

ASCII 66
36 ASCII
36

(0041.) =
Result: (0041)

2)

06
06

Seven-Segment
Seven-Segm
ent to Decimal

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040
0040 from a seven-segment
seven-segment code
to a decimal
decimal number
number in memory location
location 0041. If memory
memory location
location 0040
0040 does
not contain
code. set memory
FF16
contain a valid seven-segment
seven-segment code,
memory location
location 0041 to FFi
g.
Use the seven-segment
Seven-Segment ex­
exseven-segment table given under the Decimal
Decimal to Seven-Segment
ample and try to match codes.
codes.
Sample Problems:
a.
a.

b.

3)

(0040)
(0040)

=

4F
4F

(0041)
Result: (0041)

=

03
03

(0040)
(0040)

=

28
28

(0041)
Result: (0041)

=

FF
FF

Decimal
al to ASCII

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040
0040 from a decimal
decimal digit
digit to an
ASCII character
character and store the result in memory
memory location
location 0041. If the number
number
in memory
memory location
location 0040 is not a decimal
decimal digit.
digit, set the contents
contents of memory
location
(2015).
location 0041 to an ASCII blank character
character (20-|g).
Sample Problems:
a.
a.

b.
b.

4)

(0040)
(0040)

= 07
07

(0041)
Result: (0041)

=

37
ASCII 77
37 ASCII

(0040)
(0040)

=

55
55

(0041)
Result: (0041)

=

ASCII SPACE
SPACE
20
20 ASCII

Binary to BCD

Purpose: Convert
Convert the contents
contents of memory
memory location
location 0040
0040 to two BCD digits
digits in memory
locations
igit.
locations 0041 and 0042
0042 (most significant
significant d ig
it in 0 041).'
4 1 ).'The number
number in
memory
less than 100.
100.
memory location
location 0040
0040 is unsigned
unsigned and less
Sample Problems:
a.
a.

b.
b.

(0040)
(0040)

=

(29decimal)
decimal)
1D (29
1D

(0041)
Result: (0041)
(0042)

=
=

02
02
09

(0040)
(0040)

=

47
(71decimal)
decimal)
47 (71

(0041)
Result: (0041)
(0042)

=
=

07
07
01

7-13
7-

6)
5)

ASCII String to Binary Number

Purpose: Convert the eight
eight ASCII
ASCII characters in memory locations
locations 0042 through
through 0049
to an 8-bitit binary number
number in memory location 0041 (the most significant
significant bit
ASCII characters
is in 0042). Clear memory location
location 0040
0040 if all the ASCII
characters are either
ASCII 1 or ASCII
ASCII 0 and set it to FF•)q
FF15 otherwise.
ASCII
Sample Problems:
(0042)
(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)

= 31
= 31
= 30
= 31
= 30
= 30
= 31
= 30

(0041)
(0040)

=
=

D2
00

a· except:
b. same as •'a'
(0045)

=

37

(0040)

=

FF
FF

a.

Result:

Result:
Result:

ASCII 1
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII
ASCII 0
ASCII
ASCII 1
ASCII
ASCII 0
ASCII

ASCII 7
ASCII

7-14
7-

REFERENCES
1.

D. R.
R. Allison,
Allison. "A Design Philosophy
Philosophy for Microcomputer
Architectures." Computer,
Computer.
icrocom puter Architectures,”
February 1977. pp.
pp. 35-41. This is an excellent
excellent article
article which
which we recommend
recommend highly.

2.

Other BCD-to-binary
BCD-to-binary conversion
conversion methods
methods are discussed in J.A. Tabb and M.L.
M.L.
Roginsky. "Microprocessor
Algorithmss Make BCD-Binary Conversions
Super-fast."
Roginsky,
icroprocessor Algorithm
Conversions.Super-fast,"
EON. January
January 5,
5. 1977,
1977. pp. 46-50
46-50 and in J.B. Peatman,
Peatman. Microcomputer-based
Microcomputer-based
EDN.
Design.
1977. pp. 400-406.
Design. (New York: McGraw-Hill.
McGraw-Hill, 1977,
400-406.

7-15
7-

Chapter 8
ARITHMETIC
PROBLEMS
ARITHMETIC PROBLEMS
arithmetic
Most
ost arithm
etic in microprocessor applications consists of multiple-word
ultiple-word binary
or decimal manipulations. A decimal correction (decimal adjust) or some other
arithmetic
means for performing decimal
decimal arithm
etic is frequently
frequently the only arithmetic
etic instrucinstruc­
tion provided besides basic addition and subtraction. You must implement
implement other
arithmetic
etic operations with
ith sequences of instructions.

Multiple-precision
ultiple-precision binary arithmetic
etic requires simple repetitions
repetitions of the basic
single-word
information
single-word instructions. The Carry bit transfers
transfers inform
ation between
between words. Add
arithmetic
with
ith Carry and Subtract
Subtract with
ith Carry use the information
information from the previous
previous arithm
etic
operations.
operations. You must
must be careful
careful to clear
clear the Carry before operating
operating on the first
first words
words
(obviously
(obviously there is no carry into or borrow
borrow from the least significant
significant bitsl.
bits).
Decimal
arithmetic
Decimal arithm
etic is a common
common enough
enough task for microprocessors
microprocessors that
that most have
special
special instructions
instructions for this purpose. These instructions
instructions may either
either perform
perform decimal
decimal
operations
operations directly
directly or correct
correct the results
results of binary
binary operations
operations to the proper
proper decimal
decimal
arithmetic
form. Decimal
Decimal arithm
etic is essential
essential in such applications
applications as point-of-sale
point-of-sale terminals.
terminals,
calculators.
calculators, check processors.
processors, order entry
entry systems.
systems, and banking
banking terminals.
terminals.
You can implement
plement multiplication
ultiplication and division
division as series of additions
additions and subtractions
subtractions
respectively.
respectively, much
much as they are done by hand. Double-word
Double-word operations
operations are necessary
since a multiplication
ultiplication produces
produces a result
result twice
twice as long as the operands.
operands, while
hile a division
division
similarly
ilarly contracts
contracts the length
length of the result. Multiplications
ultiplications and divisions
divisions are time-cone-con­
suming
arithmetic
suming when
when done in software
software because of the repeated arithm
etic and shift
shift operations
operations
that
that are necessary. Of course.
course, multiplying
ultiplying or dividing
dividing by a power
power of 2 is simple
simple because
such operations
operations can be implemented
implemented with
ith an appropriate
appropriate number
number of left or right
right
arithmetic
arithm
etic shifts.

8-1

EXAMPLES
Multiple-Precision
ultiple-Precision Binary Addition
Purpose: Add two multiple-word
ultiple-word binary numbers. The length of the numbers (in bytes)
bytes)
Is in
In memory location 0040.
is
0040, the numbers themselves start (most significant
significant
bits first) in memory locations
locations 0041 and 0051,
respectively, and the sum
0051. respectively.
replaces the number
number starting
starting in memory location 0041.
Sample Problem:

Result:

that is,
is.

(0040)

04

(0041)
(0042)
(0042)
(0043)
(0043)
(0044)

2F
5B
A7
C3

(0051)
(0052)
(0053)
(0054)

14
DF
DF
35
B8

(0041)
(0042)
(0043)
(0044)

44
3A
DD
7B

2F5BA7C3

+ 14DF35B8
443ADD7B
443ADD7B
Flowchart:
Flowchart:
Start

Index = (0040)
Carry= 0

(0040+1ndex) =
(0040+1ndex) +
(OOSO+lndex) +
(Carry)

Index = Index - 1

End

8-2

(This step also produces new Carry)

Program:
Source Program:

ADDW

LDX
CLC
CLC
LDA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BRK

$40

$40.X
$40,X
$50,X
$50.X
$40.X
$40,X

:INDEX== LENGTH
LENGTH OF
OF STRINGS
STRINGS
;INDEX
:CLEAR CARRY
;CLEAR
CARRY TO START
START
:GET BYTE
BYTE FROM
FROM STRING
STRING 1
;GET
:ADD BYTE
BYTE FROM
FROM STRING
STRING 2
;ADD
:STORE RESULT
RESULT IN STRING
;STORE
STRING 1

ADDW
ADDW

;CONTINUE UNTIL ALL BYTES
BYTES ADDED
CONTINUE

Object
Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
000B
OOOB
oooc
OOOC

A6
40
18
B5
B5
40
75
50
95
40
CA
DO
DO
F7
F7
00

Instruction
Instruction
(Mnemonic)

ADDW
ADDW

LDX
LOX

$40

CLC
CLC
LDA
LOA

$40,X
$40,X

ADC

$50.X
$50,X

STA

$40.XX
$40,

DEX
DEX
BNE
BNE

ADDW
ADDW

BRK
BRK

The relative address for BNE
BNE ADDW is:
is:
0003 =
-OOOC
-000C

03
+F4
F7F7

Is used to clear the Carry bit since there is no carry involved
The instruction
instruction CLC is
involved in the
addition
addition of the least significant
significant bytes.
Carry. includes
The instruction
instruction ADC. Add with
ith Carry,
includes the Carry from the previous
previous words in the
addition.
Is the only InstructIon
In the loop that affects
addition. ADC is
instruction in
affects the Carry
Carry.In particular.
Inparticular,
increment
(DEC. DEX,
DEX. DEY,
DEY. INC,
INC. INX,
INX. INY)
note that increm
ent and decrement
decrement instructions
instructions (DEC,
!NY) do not
affect
Carry.
affect the Carry.
adThis program uses the same index with
ith two different
different base ad­
dresses to handle the two strings. The strings can be located anyany­
where in memory. Furthermore.
Furthermore, there would
would be no d ifficu
lty in
ifficulty
In
storing
In a third string.
storing the result in

DECIMAL
DECIMAL
ACCURACY
IN BINARY

This procedure
procedure can add binary numbers of any length. Note that ten binary bits corres­
corres210 = 1024 =
:::::1000. So.
So. you can calculate
pond to three decimal
decimal digits
digits since 2^0
calculate the num-­
ber of bits required to give a certain accuracy
accuracy in decimal
decimal digits. For example.
example, twelve
decimal
decimal digitit accuracy
accuracy requires:

f

1
12 x ^

8-3
8-

=40
4 0 bits

Decimal Addition
Purpose: Add two multi-byte
(BCD) numbers. The length of the numbers (in
(in
Purpose:
ulti-byte decimal (BCD)
bytes) is in memory location 0040, the numbers themselves start (most
(most sig­
significant
nificant bits first) in memory locations 0041 and 0051, respectively, and the
sum replaces the number starting
starting in memory location 0041.

Sample Problem:

Result:
Result:

is.
that is,

(0040)
(0040)

=

04

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)

=

=
=
=

36
70
19
19
B5
85

(0051)
(0051)
(0052)
(0052)
(0053)
(0053)
(0054)
(0054)

=
=
=
=

12
66
34
59

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)

=
=
=
=

49
36
54
44

36701985
36701985
+12663459
+12663459
49365444
49365444

Flowchart:
Flowchart:
Start

Set Decimal Mode
Index = (0040)
Carry= 0

(0040+1ndex) =
(0040+1ndex) +
(0050+1ndex) +
(Carry)

Index = Index - l

Clear Decimal Mode

End

8-4
8-

(This step also produces new Carry)

Program:
Source Program:

ADDW
ADDW

SED
SED
LOX
LDX
CLC
LOA
LDA
ADC
STA
DEX
DEX
BNE
BNE
CLD
CLO
BRK
BRK

$40
$40,X
$40.X
$50,X
$50.X
$40.X
$40,X

ADDW
ADDW

;MAKE ALL ARITHMETIC DECIMAL
;INDEX== LENGTH
LENGTH OF STRINGS
STRINGS
INDEX
:CLEAR CARRY
CARRY TO START
:GET TWO DIGITS FROM STRING
STRING 1
;ADD TWO DIGITS FROM
FROM STRING
STRING 2
:STORE
RESULT IN STRING
STORE RESULT
STRING 1
:CONTINUE UNTIL ALL DIGITS ADDED
CONTINUE
:RETURN TO BINARY MODE
:RETURN

Object
Object Program:
Memory Address
Address
Memory
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
000A
OOOA
OOOB
000B
oooc
oooc
000D
000D
000E
OOOE

F8
F8
A6
40
18
B5
40
75
50
95
40
CA
DO
DO
F7
D8
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

ADDW
ADDW

SED
SED
LOX
LDX

$40

CLC
CLC
LOA
LDA

$40.X
$40.X

ADC

$50.X
$50,X

STA

$40.X
$40,X

DEX
DEX
BNE
BNE

ADDW
ADDW

CLD
CLO
BRK
BRK

The Decimal mode automatically
automatically takes care of the following
situations in which binary and BCD addition differ:
1)
1)

The sum of two digits
digits is between
between 10 and 15 inclusive.
inclusive. In this
case. six must
case,
must be added to the sum to give the right
right result.
result, 1.e
i.e.,..

+ 1000

0101

(5)
(5)
(8)
(8

1101

(D)
(D)

+

6502
6502
DECIMAL
DECIMAL
MODE

+ 0110
0110
0001 0011
2)

(BCD 13,
13. which
(BCD
which is correct)

d1g1tsis 16 or more. In this case,
case. the result
The sum of two
two digits
result is a proper
proper BCD digit
ig it but
six less than it should
should be, i.e.,..
(8)
1000 (8
(9)
+
+ 1001 (9)
0001 0001
+
0110
+ 0110

11)
(BCD 11)

0001 0111

(BCD 17,
17. which
(BCD
hich is correct)

s1tuat1ons. However.
Six must be added in both
both situations.
However, case 1 can be recognized
recognized by the fact
that
that the sum is not a BCD digit.
digit, 1
i.e.... it is between
between 10 and 15 (or A and F hexadecimal).
hexadecimal).
1g1t
1sone
Case 2 can only be recognized
recognized by the fact that the carry from the d ig
it addition
addition is
since the result
result is a valid BCD number.

8-5

When the Decimal Mode flag is set, all arithem
arithemtic
tic is carried out in the decimal
additions. regardless of which address­
addressform. This includes subtractions as welll as additions,
ing mode is employed.
ing
However,
proDECIMAL
However, the Increment
Increment and Decrement
Decrement instructions pro­
DECIMAL
duce binary results even when the Decimal Mode flag is
duce
MODE
DEC. DEX,
DEX. DEY,
DEY. INC,
INC. INX,
INX. and INY can only be used
LIMITATIONS
set. Thus DEC,
LIMITATIONS
to maintain
maintain binary
binary counters.
counters. For example.
example, to increment
increment a
decimal
decimal counter
counter in memory
memory location
location 0040.
0040, you must
must use the sequence:
sequence:

SED
SED
LDA
CLC
CLC
ADC
STA
CLD

$40
#1
$40

;MAKE ARITHMETIC DECIMAL
;GET COUNTER
COUNTER
;GET
;KEEP CARRY
CARRY FROM
FROM AFFECTING
AFFECTING ADDITION
;KEEP
;INCREMENT COUNTER
COUNTER (DECIMAL)
(DECIMAL)
INCREMENT
;RETURN TO BINARY MODE
;RETURN

The SED,
SED. CLC,
CLC. and CLD instructions
instructions may not be necessary if other
other parts of the program
program
set the status
status flags appropriately.
appropriately.
Subtractions
Subtractions in the decimal
decimal mode produce
produce correct
correct BCD results
results with
ith the Carry being an
inverted
Accumulator
03. the addressed memory
inverted borrow. For example.
example, if the Accum
ulator contains
contains 03,
memory
location
27. and the Carry contains
SBC instruction
location contains
contains 27,
contains 1. after
after the execution
execution of an SBC
instruction
Accumulator
mode. a Carry
the Accum
ulator will
ill contain
contain 76 and the Carry will
ill be 0. As in the binary
binary mode,
of zero means that
that a borrow
borrow has been generated.

The Sign bit is not meaningful after
after additions and subtractions when
when the Decimal
Mode flag is set. It reflects
reflects the result
result of the binary
binary operation.
operation, not of the decimal
decimal operaopera­
(03-27). the Sign bit will
(as it
tion. In the most recently
recently mentioned
mentioned situation
situation (03-27),
ill be set (as
would
(76) has a most
would be if the numbers
numbers were binary) even though
though the decimal
decimal result
result (76)
significant
zero.
significant bit of zero.
This procedure
(BCD) numbers
procedure can add decimal
decimal (BCD)
numbers of any length.
Here four binary
binary bits are required
required for each decimal
decimal digit.
digit, so
twelve-digit
elve-digit accuracy
accuracy requires

ACCURACY IN
BINARY AND BCD

4=48
12 x 4
= 48 bits
as opposed to 40 bits in the binary
binary case
case. This is six 8-bit
-b it words
words instead of five.

The program
program for decimal
decimal addition
addition is the same as that
that for binary
binary addition
addition except
except for the
surrounding CLD and SED
instructions. Thus a single sequence
sequence of instructions
instructions can propro­
surrounding
SED instructions.
duce twoo entirely
entirely different
different results depending
depending on the value of a flag that
that is not even
mentioned
mentioned explicitly.
explicitly. Can you suggest
suggest some problems
problems this might
ight create in connecting
connecting
programs
programs written
ritten at different
different times
times or by different
different people?
people?

8-6

8 -Bit
it Binary Multiplication
ultiplication
Purpose: Multiply
Purpose:
ultiply the 8-bit
-b it unsigned
unsigned number
number in memory
memory location
location 0040
0040 by the 8-bit
8-bit
unsigned
unsigned number
number in memory location
location 0041. Place the eight
eight least significant
significant
bits of the result
result into
into memory
memory location
location 0042
0042 and the eight
eight most significant
significant
bits into memory
memory location
location 0043.
Sample Problems:
a.
a.

(0040)
(0040)
(0041)

= 03
03
= 05
05

(0042)
Result: (0042)
(0043)

= OF
OF
= 00
00

or in decimal
decimal 3 xx 55 = 15
b.

(0040)
(0040)
(0041)

6F
= 6F
61
= 61

(0042)
Result: (0042)
(0043)

OF
= OF
= 2A
2A

767
or 111 x 997 == 10.
10.767
You can perform
perform multiplication
ultiplication on a computer
puter in the same way that
that you do long
multiplication
ultiplication by hand. Since the numbers
numbers are binary.
binary, the only problem
problem is whether
whether to
O or 1;
1. multiplying
multiply
ultiply by 0
ultiplying by zero obviously
obviously gives zero as a result.
result, while
hile multiplyultiply­
So. each
ing by one produces
produces the same number
number that
that you started with
ith (the multiplicand).
Itiplicand). So,
multiplication
step inina binary
binary m
ultiplicationcan
canbebereduced
reducedtotothe
thefollowing
followingoperation.
operation.

If the current
current bit in the multiplier
ultiplier is 1. add the multiplicand
ultiplicand
to the partial
partial product.
product.

MULTIPLICATION
MULTIPLICATION
ALGORITHM_____
ALGORITHM

The only remaining
remaining problem
problem is to ensure that you line everything
everything up correctly
correctly each
following
time. The follow
ing operations
operations perform this task
task.

1)
1)
2)

Shift
Shift the multiplier
ultiplier left one bit so that the bit to be examined
examined is placed in the Carry.
Shift
Shift the product
product left one bit so that
that the next addition
addition is lined up correctly.
correctly.

The complete
complete process for binary
binary multiplication
ultiplication is as follows:
follows:
Step 1 - Initialization
Initialization
Product=
Product = 0
Counter== 8
Counter
Step 2 - Shift
Shift Product
Product so as to line up properly
properly
Product
(LSB = 0)
Product = 2 x Product
Product (LSB
Step 3 - Shift
Shift Multiplier
ultiplier so bit goes to Carry
Multiplier=
ultiplier = 2 x Multiplier
ultiplier
Step 4 - Add Multiplicand
ultiplicand to Product
Product if Carry is 1
1. Product
Product== Product
Product++ Multiplicand
If Carry== 1,
ultiplicand
Step 5 - Decrement
Decrement Counter
Counter and check for zero
Counter== Counter
Counter
Counter - 1
If Counter
Counter i=O
¥=0 go to Step 2

8-7

b. where
In the case of Sample Problem b,
where the multiplier is 6115 and the multiplicand
6Fi
q the process works as follows:
follows:
6F15
Initialization:
Initialization:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter

0000
61
61
6F
08

After
fter first
iteration of steps 2-5:
first iteration
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
ultiplier
Carry from Multiplier

0000
C2
6F
07
0

After
After second iteration:
iteration:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from Multiplier
ultiplier

006F
84
6F
06
1

After third iteration:
iteration:
After

Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from Multiplier
ultiplier

014D
08
6F
05
1

After fourth
fourth iteration:
iteration:
After

Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
ultiplier
Carry from Multiplier

029A
029A
10
6F
04
0

After
fter fifth
fifth iteration:
iteration:
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from Multiplier
ultiplier

0534
20
6F
03
0

After sixth iteration:
iteration:
After
Product
Product
Mult1pl1er
ultiplier
Multiplicand
lt1plicand
Counter
Counter
ultiplier
Carry from Multiplier

0A68
0A68
40
6F
02
0

After
iteration:
seventh iteration:
After seventh
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
ultiplier
Carry from Multiplier

14D0
80
6F
01
01
0

8-8

is

iteration:
After
fter eighth
eighth iteration
Product
Product
Multiplier
ultiplier
Multiplicand
ultiplicand
Counter
Counter
Carry from Multiplier
ultiplier

2AOF
2A0F
00
6F
00
1

Flowchart:
Flowchart:
Start

Product= 0

Count= 8
Multiplicand-(0040)
Multiplier - 10041)

Product=2 x Product
(Shift left 1 bit)
Multiplier= 2 x
Multiplier
(Shift left 1 bit)

Product = Product
+ Multiplicand

Count = Count ~ 1

10042 and 00431 Product

End

8 -9

Program:
Source Program:

SHIFT

CHCNT

LOA
LDA
STA
LOX
LDX
ASL
AOL
ROL
ASL
BCC
CLC
ADC
BCC
INC
DEX
BNE
STA
BAK
BRK

#00
$43
#B
8
A
$43
$41
CHCNT
$40
CHCNT
$43

SHIFT
$42

;LSB'S OF PRODUCT== ZERO
ZERO
;MSB'S
ZERO
MSB'S OF PRODUCT== ZERO
;NUMBER OF BITS IN MULTIPLIER== 88
;SHIFT PRODUCT LEFT
LEFT ONE BIT
;SHIFT MULTIPLIER LEFT
LEFT
;NO ADDITION
ZERO
ADDITION IF NEXT BIT IS ZERO
;ADD
ADD MULTIPLICAND
MULTIPLICAND TO PRODUCT

;WITH
WITH CARRY IF NECESSARY
NECESSARY
;LOOP UNTIL 8 BITS ARE MULTIPLIED
STORE LSB'S OF PRODUCT
STORE

Object
Program:
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
000A
0008
000B
oooc
000C
0000
000D
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018
0019
0019

A9
00
85
43
A2
08
OA
26
43
06
41
90
07
18
65
40
90
02
E6
E6
43
CA
DO
DO
EF
EF
85
42
00

Instruction
Instruction
(Mnemonicl
(Mnemonic)

SHIFT

CHCNT

LOA
LDA

#00

STA

$43

LOX
LDX

#88

ASL
AOL
ROL

A
$43

ASL

$41

BCC
BCC

CHCNT

CLC
ADC

$40

BCC
BCC

CHCNT

INC

$43

DEX
BNE

SHIFT

STA

$42

BRK
BAK

8-100
8-

Besides its obvious use in calculators
terminals. multiplication
calculators and point-of-sale
point-of-sale terminals,
ultiplication is a key
part of almost
speed at which
almost all signal processing and control
control algorithms.
algorithms. The speed
which
CPU in process conmultiplications
ultiplications can be performed
performed determines
determines the usefulness of a CPU
con­
trol. signal detection.
trol,
detection, and signal analysis.
This algorithm
algorithm takes between
between 170 and 280 clock cycles to multiply
ultiply on a 6502
microprocessor. The precise time depends on the number
number of 1 bits in the multiplier.
multiplier.
Other algorithm
algorithmss may be able to reduce the average execution
execution time somewhat.
somewhat, but 250
clock cycles will
ill still
still be a typical
typical execution
execution time for a software
software multiplication.
ultiplication. Some
microprocessors
ZB000) have hardware multiplication
microprocessors (such as the 9900.
9900, 8086.
8086, and Z8000)
ultiplication inin­
structions
structions that
that are somewhat
somewhat faster but
but maximum
maximum speed requires the addition
addition of exterexter­
nal hardware.

8-11

8 -Bit
it Binary Division
Purpose: Divide the 16-bit
Purpose:
16-bit unsigned
unsigned number
number in memory locations 0040
0040 and 0041
(most significant
unsigned number
significant bits in 0041) by the 8-bit
-b it unsigned
number in memory
memory localoca­
1) the most significant
tion 0042. The numbers are normalized so that 1)
significant bits of
both the dividend
dividend and the divisor
divisor are zero and 2) the number
number in memory
location
location 0042
0042 is greater
greater than the number
number in memory
memory location 0041.Thus.
0041.Thus, the
quotient
quotient is an 8-bit
-b it number. Store the quotient
quotient in memory location
location 0043 and
the remainder
remainder in location 0044.
Sample Problems:

a.(0040)
a.

=

40 (64(0040)
decimal)
(0041) =
(0042) =
Result

b.(0040)

=

=

40 (64 decimal)
00
08
(0043) = 08
(0044) = 00
ie.
i.S„ 6 4/8
/8 = 8

(0040)decimal)
6D (12.909 decimal)
6D (12,909
(0041) = 32
(71 decimal)
(0042) = 47 (71
Result

=

= B5 (181
(181 decimal)
(0043) =
(0044) = 3A (58 decimal)
i.e.,.. 12.909/71
= 181
181 with
12,909/71 =
ith a remainder
remainder of 58

You can perform division
division on the computer
puter just
just like you would
would perDIVISION
DIVISION
form division
paper. i.e..
subtractions.
division with
ith pen and paper,
., using trial subtractions.
ALGORITHM
ALGORITHM
Since the numbers are binary.
binary, the only question
question is whether
whether the bit
”
1. i.e.,.. whether
in the quotient
quotient is 0 or 1,
whether the divisor
divisor can be subtracted
subtracted from what
hat is left of
Each step in a binary division
following
the dividend.
dividend. Each
division can be reduced to the follow
ing operation:
If the divisor
divisor can be subtracted
subtracted from the eight
most significant
significant bits of the dividend
dividend without
ithout
a borrow.
borrow, the corresponding
corresponding bit in the quoquo­
tient
tient is 1; otherwise
otherwise it is 0.
The only remaining
remaining problem is to line up the dividend
dividend and quotient
quotient properly. You can
do this by shifting
shifting the dividend
dividend and quotient
quotient logically
logically left one bit before each trial
subtraction. The dividend
dividend and quotient
quotient can share a 16-bitit register.
register, since the procedure
subtraction
11determines
clears one bit of the dividend
dividend at the same time as it
determines one bit of the quotient.
quotient.
The complete
complete process for binary division
division is:
Step 1 - Initialization:
Initialization:
Quotient== 0
Quotient
Counter== 8
Step 2 - Shift Dividend
Dividend and Quotient
Quotient so as to line up properly:
properly:
X Dividend
Dividend
Dividend = 2 x
Quotient
Quotient = 2 x Quotient
Quotient
Step 3 - Perform trial Subtraction.
Subtraction. If no Borrow add 1 to Quotient:
Quotient:
If 8 MSBs of Dividend
Dividend >
> Divisor then
D1v1dend- Divisor
D1v1sor
MSBs of Dividend
Dividend = MSBs of Dividend
Quotient = Quotient
Quotient +
Quotient
+1

zero·
Step 4 - Decrement
Decrement counter
counter and check for zero:
Counter== Counter - 1
if Counter -..00., go to Step 2
Remainder = 8 MSBs
MSBs of Dividend

8-12
8-12

4715.
In the
the case
case of
of sample
sample problem
problem b.
b, where
where the
the dividend
dividend is
is 326D15
326D-|6 and
and the
the divisor
divisor is
is47-|g,
the process
process works
works as
as follows:
follows:
the
Initialization:
Initialization:
Dividend
Dividend
Divisor
Divisor
Quotient
uotient
Counter
Counter

326D
47
47
00
00
00
00

After
fter first
first iteration
iteration of Steps 2 - 4:
(Note that
that the dividend
dividend is shifted
shifted prior
prior to the trial subtraction)
subtraction)
Dividend 1DDA
ODA
Dividend
Divisor
47
Quotient
01
Quotient
07
Counter
Counter

After second iteration of Steps 2 - 4:
3BB4
Dividend
Dividend 38B4
47
Divisor
Quotient
02
Quotient
06
Counter
Counter
After
fter third
third iteration:
iteration:

D1v1dend 3068
Dividend
47
Divisor
Divisor
Quotient
05
uotient
Counter
Counter
05
After
fter fourth
fourth iteration:
iteration:

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

19D0
47
OB
0B
04

Dividend
Dividend
Divisor
Divisor
Quotient
uotient
Counter
Counter

33A0
33AO
47
16
03

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

2040
47
2D
02

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

4080
47
5A
01

Dividend
Dividend
Divisor
Quotient
Quotient
Counter
Counter

3AOO
3AOO
47
B5
00

After
fter fifth
fifth iteration:
iteration:

After sixth iteration:
iteration:
After

After seventh iteration:
iteration:
i:
After

After
fter eighth
eighth iteration:
iteration:

remainder is 3A
So the quotient is B5 and the remainder

8-13
813

MSBs of dividend
The MSBs
dividend and divisor
divisor are assumed to be zero; this simplifies
plifies calculations
calculations
(the shift prior to the trial subtraction
subtraction would otherwise place the MSB of the dividend
dividend in
Carry). Problems that are not in this form must be simplified
the Carry).
plified by removing parts of
For example:
the quotient
quotient that
that would
would overflow
overflow an B-bit
8-bit word. For
1024 = 400 (Hex)
(Hex) =
3
3

+ 100 (Hex)
(Hex)

100 +

3

necessary.
The last problem is now in the proper form. An extra division
division may be necessary.
Flowchart:
Flowchart:
Start

Dividend = (0040
and 0041)
Divisor= (00421
Count= 8
Quotient= 0

Dividend = 2 x
Dividend

Quotient = 2 x
Quotient

(Shift both left 1 bit)

8 MS8s of
Olv~dend= 8 MSBs
of Dividend • Divisor
Quotient=
~
Quotient+ 1

Count = Count - 1

(0043) = Quotient
(0044) = 8 MS8s of
Dividend

End

814
8-14

Program:
Source Program:

DIVID

CHCNT

LOX
LDX
LOA
LDA
STA
LOA
LDA
ASL
ROL
ROL
CMP
BCC
BCC
SBC
SBC
INC
DEX
DEX
BNE
BNE
STA
BRK
BRK

#88
$40
$43
$41
$43
A
$42
CHCNT
$42
$43
DIVID
$44

;NUMBER OF BITS IN DIVISOR== 8
;START WITH LSB'S OF DIVIDEND

;GET MSB'S OF DIVIDEND
DIVIDEND, QUOTIENT LEFT
LEFT 1 BIT
;SHIFT DIVIDEND.
;CAN DIVISOR
DIVISOR BE
BE SUBTRACTED?
SUBTRACTED?
,NO, GO TO NEXT STEP
STEP
;YES,
(CARRY== 1)
1)
YES, SUBTRACT DIVISOR (CARRY
;AND INCREMENT
INCREMENT QUOTIENT BY 1
;LOOP UNTIL ALL 8 BITS HANDLED
;STORE REMAINDER
REMAINDER
;STORE

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
000A
OOOB
000B
oooc
oooc
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018

A2
08
A5
40
85
43
A5
41
06
43
2A
C5
42
90
04
E5
E5
42
E6
43
CA
DO
DO
F2
85
44
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)

DIVID

CHCNT

LOX
LDX

#88

LOA
LDA

$40

STA

$43

LOA
LDA

$41

ASL

$43

ROL
ROL
CMP

A
$42

BCC
BCC

CHCNT

SBC
SBC

$42

INC

$43

DEX
DEX
BNE
BNE

DIVID

STA

$44

BRK
BRK

Division
communications
Division is used in calculators,
calculators, terminals,
terminals, comm
unications error checking,
checking, control
control
algorithms, and many other
other applications.
applications.
algorithms,
algorithm takes between
between 150 and 230 microseconds
microseconds to divide
divide on a 6502
6502 with
ith a 1
The algorithm
MHz clock. The precise time depends
depends on the number
number of 1 bits in the quotient.
quotient. Other
Other
algorithms
algorithms can reduce the average time somewhat.
somewhat, but
but 200 microseconds
microseconds will
ill still
still be
typical
typical for a software
software division.
division.

The instructions
ROL A together
arithmetic
instructions ASL $43 and ROL
together provide
provide a 16-bit
16-bit arithm
etic left shift
shift of
the dividend
ROL.instruction
dividend (MSBs in A). The ROL
instruction picks up the bit which
which the ASL instrucinstruc­
tion left in the Carry.

8-15
8-

necessary, since there is no simple
An 8-bitit subtraction
subtraction is necessary,
simple way to perform
perform a 16-bit
16-bit
subtraction
subtraction or comparison,
comparison.
Memory
Accumulator
Memory location
location 0043
0043 and the Accum
ulator hold both the dividend
dividend and the quotient
quotient
(MS8s in Accumulator!,
In memory
(MSBs
Accumulator). The quotient
quotient simply
simply replaces the dividend
dividend in
memory location
0043
0043 as the dividend
dividend is shifted
shifted left arithmetically.
arithmetically.
We do not have to worry
SBC instruction,
'1' since
worry about
about the Carry in the SBC
instruction. It must be 'V
otherwise
branch, Remember that a Carry value of '1' has no
otherwise 8CC
BCC would
would have caused a branch.
effect
SBC instruction
s,nce the Carry is
Is an inverted
effect on the result of an SBC
instruction since
inverted borrow,
borrow.
llowing
utine
ffers
provement
In tim
tImIng
previous
example
The fo llo
w in g ro u
tin e o ffe
rs an im p ro
ve m e n t in
in g over
over the pre
vio u s exam
ple
ithout
creasing
emory
rforms
w ith
o u t in crea
sin g m em
ory usage.
usage. It also
also p e rfo
rm s error
rro r checking.
checking.
DIV

DIVID
DIVID

CHCNT

DONE

LDX
LDA
STA
LDA
CMP
CMP
BCS
AOL
ROL
AOL
ROL
CMP
sec
BCC
SBC
DEX
BNE
AOL
ROL
STA
ATS
RTS

#8
S40
$
$43
S43
$41
S42
$
DONE
S43
$
A
S42
$
CHCNT
$42

DIVID
DIVID
S43
$4
$44
$

:NUMBER
DIVISOR== 8
NUMBER OF BITS IN DIVISOR
:START WITH LSB'S
LSB’S OF DIVIDEND
DIVIDEND
:GET MSB'S
MSB'S OF DIVIDEND
DIVIDEND
:SHOULD
SHOULD BE LESS THAN DIVISOR
:IF NOT, ERROR
ERROR EXIT (CARRY== 1)
:SHIFTDIVIDEND,
SHIFTDIVIDEND, QUOTIENT
QUOTIENT LEFT 1 BIT
:(AND NEW ANSWER
ANSWER BIT -— SEE DEX BELOW)
BELOW)
:CAN DIVISOR
DIVISOR BE SUBTRACTED?
SUBTRACTED?
:NO, GO TO NEXT STEP (CARRY== 0)
:YES,
YES, SUBTRACT
SUBTRACT DIVISOR
DIVISOR (CARRY== 1)
:NOTE CARRY' ' NEW ANSWER
ANSWER BIT
:LOOP UNTIL ALL 8 BITS HANDLED
HANDLED
:SHIFT IN THE LAST ANSWER
ANSWER BIT
:STORE REMAINDER
HERE)
REMAINDER (CARRY== 0 HERE)
;QUIT (CARRY 0, NORMAL,
ERROR)
NORMAL, CARRY l,
1, ERROR)

8-166
8-

Self-Checking Numbers
Double Add Double Mod 10
Purpose: Calculate
Calculate a checksum
digitit from a string
digits. The length
length of the
checksum dig
string of BCD digits.
string
string of digits
digits (number
(number of words) is in memory
memory location
location 0041;
0041; the string
string of
digits
digits (2 BCD digits
digits to a word) starts in memory
memory location
location 0042. Calculate
Calculate the
checksum
checksum digit
ig it by the Double
Double Add Double
Double Mod 10 technique
technique1 and store it in
memory
location 0040.
memory location
The Double
Double Add
Add Double
Double Mod
Mod 10
10 technique
technique works
works as
asfollows:
follows:
1) Clear
Clear the
the checksum
checksum to
to start.
start.
1)
Multiply
the leading
leading d ig
digit by
by two
two and
and add
add the
the result
result to
to the
the
2) M
ultiply the
checksum.
checksum.

SELF-CHECKING
NUMBERS
NUMBERS

Add the
the next
next d ig
digit to
to the
the checksum.
checksum.
3) Add
4) Continue
Continue the
the alternating
alternating process
process until
until you
you have
have used
used all
all the
thedigits.
digits.
The least
least significant
digit of
of the
the checksum
checksum is
is the
the self-checking
5) The
significant d ig
self-checking digit.
digit.
Self-checking digits
digits are commonly
identification numbers
credit cards, inSelf-checking
commonly added to identification
numbers on credit
in­
ventory
ventory tags, luggage.
luggage, parcels, etc., when
when they are handled
handled by computerized
computerized systems.
They may also be used in routing
messages, identifying
routing messages,
identifying files, and other
other applications.
applications.
The purpose
purpose of the digits
digits is to minimize
minimize entry
entry errors such as transposing
transposing digits
digits (69 inin­
stead of 96), shifting
digits (7260 instead of 3726), missing
shifting digits
missing digits
digits by one (65 instead of
automatically
64), etc. You can check
check the self-checking
self-checking number
number autom
atically for correctness
correctness upon
entry
entry and can eliminate
eliminate many errors immediately.
immediately.
The analysis of self-checking
self-checking methods
methods is quite
quite complex.
complex. For example.
example, a plain checksum
checksum
+ 9 = 9 ++ 4). The Double
will
ill not find transposition
transposition errors (4 +
Double Add Double
Double algorithm
algorithm will
ill
+ 9 = 177 ^/c2 xx99 ++ 4); but willill miss some errors,
errors.
find simple
simple transposition
transposition errors (22 x 44 +
such as transpositions
transpositions across even numbers
numbers of digits
digits (367 instead of 763). However,
this method
method will
ill find many common
common errors! The value of a method
method depends
depends on what
what erer­
rors it will
probability of particular
particular errors in an application.
application.
ill detect
detect and on the probability
For example.
example, if the string
string of digits
digits is

549321
the result
result will
ill be:
Checksum
Checksum
Self-checking
Self-checking digit
ig it

=
=

5 xx 22 +
0
+ 4 ++ 9 xx22 ++ 3 ++ 2 xx22 ++ 1 == 440
0 (least significant
significant digit
ig it of a checksum)
checksum)

Note that
that an erroneous
erroneous entry
entry like 543921 would
would produce
produce a different
different self-checking
self-checking digit
digit
(4), but erroneous
(4),
erroneous entries
entries like 049321
049321 or 945321 would
would not be detected
detected.

Sample Problems:
a.
a.

(0041)
(0041)
= 03 03
(0042) = 36
(0043) = 68
(0044) = 51
Result: Checksum
Checksum= = 3 xx 22 +
+ 6 ++ 6 xx 22 ++ 8 ++ 5 xx22 ++ 1 = 4433
(0040) = 03

b.

(0041)
(0041)
= 04 04
(0042) = 50
(0043) = 29
(0044) = 16
(0045) = 83
Result: Checksum
+ 0 ++ 2 xx 22 ++ 9 ++ 1 x 22 ++ 6 ++ 8 xx 22 ++ 3 = 50
Checksum= = 5 xx 22 +
= 00
(0040) =
8 -17
7

Flowchart:
Flowchart:

c

Start

D

Checksum== 0

Basa=- 0041
Base
Index = (0 0411)

MSD = (Base
(Base
+lndex)/16
lndex)/16
LSD== (Base+lndexl
(Base+lndex)
1111
AND 0 0 0 0
0001111
(binary)
(binary)
Checksum==
Checksum
Checksum+Checksum
2 x MSD + LSD

Index = Index -1

(0 0401
0 ) = Checksum

01111
AND 0 0 0 0
1111
(binary)
(binary)

End

8 -18

Source Program:

CHKDG
CHKDG

SED
SED
LOX
LDX
LOY
LDY
LOA
LDA
LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA
CLC
CLC
ADC
STY
STY
ADC
STA
STA
LDA
LOA
AND
CLC
CLC
ADC
TAY
DEX
DEX
BNE
BNE
AND
STA
CLO
CLD
BRK
BRK

$41
$41
#0
$41.X
$41,X
A
A
A
A
$40
$40
$40
$40
$40
$41.X
$41,X
001111
#% 000
0 1 111

;MAKE ALL ARITHIMETIC
ARITHIMETIC DECIMAL
DECIMAL
:INDEX== LENGTH
LENGTH OF
OF STRING
STRING
INDEX
:CHECKSUM= ZERO
ZERO
CHECKSUM
:GET
NEXT 2 DIGITS
DIGITS OF
OF DATA
GET NEXT
:SHIFT
OFF LEAST
LEAST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
SHIFT OFF

:CLEAR
CARRY FROM
FROM SHIFTING
SHIFTING
CLEAR CARRY
:DOUBLE MOST
MOST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
DOUBLE
:DOUBLING A DIGIT
DIGIT NEVER
NEVER PRODUCES
PRODUCESA
DOUBLING
CARRY
CARRY
;ADD DOUBLED
DOUBLED MSD TO CHECKSUM
CHECKSUM
;GET
LEAST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
GET LEAST
; (MASK
(MASK OFF
OFF MSD)
MSD)
:ADD LSD
LSD TO CHECKSUM
CHECKSUM

$40

CHKDG
CHKDG
001111
#% 000
0 1 111
$40

:CONTINUEUNTIL
UNTIL ALL DIGITS
DIGITS SUMMED
SUMMED
CONTINUE
:SAVE LSD
LSD OF
OF SELF-CHECKING
SELF-CHECKINGDIGIT
DIGIT
;SAVE
;RETURNTO BINARY
BINARY MODE
MODE
;RETURN

8-19
8-19

Object
Object Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
000BB
oooc
OOOC
000D
OOOE
000E
OOOF
000F
0010
0011
0012
0013
0014
0014
0015
0016
0017
0018
0019
001A
001A
0018B
OOlC
001C
0010D
001E
01E
001F
01F
0020
0021
0022
0023
0024
0025
0026

F8
F8
A6
41
AO
AO
00
B5
B5
41
41
4A
4A
4A
4A
85
40
18
65
40
84
40
65
40
85
40
B5
B5
41
41
29
OF
OF
18
65
40
A8
AB
CA
DO
DO
E4
E4
29
OF
OF
85
40
D8
00

Instruction
Instruction
(Mnemonic)

CHKDG
CHKDG

SED
SEO
LOX
LDX

$41
$41

LOY
LDY

#00

LOA
LDA

$41.X
$41,X

LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR
STA

A
A
A
A
$40

CLC
CLC
ADC

$40

STY
STY

$40

ADC

$40

STA

$40

LOA
LDA

$41.X
,X

AND

00001111
#% 00
00
1

CLC
CLC
ADC

$40

TAY
DEX
DEX
BNE
BNE

CHKDG
CHKDG

AND

#% 00
00
1
00001111

STA

$40

CLD
CLO
BRK
BRK

The digits
digits are removed by shifting
shifting and masking. Four logical right
right shifts are needed to
separate out the most significant
significant digit.

All arithm
arithmetic
etic is performed
performed in the decimal
decimal mode
mode. Remember,
Remember. however,
however. that DEX
DEX still
produces a binary
binary result.
There is no problem with
ith the Carry from doubling
doubling a decimal
decimal digitit since the result can
18. You may be able to eliminate
CLC instruction
never be larger than 18.
eliminate the final CLC
instruction if the
numbers to be summed are known
known to be too small to ever produce
produce a Carry.
Carry.

8-20

Accumulator
You can double
double a decimal
decimal number
number in the Accum
ulator by
adding
mode. A typical
adding it to itself
itself in the decimal
decimal mode.
typical sequence is as
follows
follows (using memory location
location 0040
0040 for temporary
temporary storage):
SED
SEO
STA
CLC
CLC
ADC
CLO
CLD

:MAKE ARITHMETIC
ARITHMETIC DECIMAL
;MAKE

DOUBLING AND
HALVING
DECIMAL
DECIMAL
NUMBERS

$40
$40

;KEEP
:KEEP CARRY
CARRY FROM
FROM AFFECTING
AFFECTING ADDITION
:DOUBLE NUMBER
NUMBER
;DOUBLE
:RETURN TO BINARY
BINARY MODE
MODE
:RETURN

You may not need the SED,
instructions if other parts of the program set
SED. CLC,
CLC. and CLD
CLO instructions
the Carry and Decimal Mode flags appropriately.
appropriately. Note that you cannot
cannot use ASL A to
double a decimal
decimal number
number because that
that instruction
instruction produces a binary result even if the
double
Decimal Mode flag is set.
set.
You divide
divide a decimal
decimal number
number by 2 simply
simply by shifting
shifting it right logically
logically and then
subtracting
(since 10 BCD
BCD is 16 binary). The following
subtracting 3 from any digit
ig it that
that is 8 or larger (since
following
program divides
divides a decimal
decimal number
number in memory location 0040 by 2 and places the result
in memory location
location 0041.
LDA
LOA
LSR
LSR
TAX
AND
CMP
sec
BCC
TXA
SBC
SBC

DONE
DONE

TAX
STX
BRK
BRK

$40
A

;GET
:GET DECIMAL NUMBER
NUMBER
;DIVIDE
:DIVIDE BY 2 IN BINARY
BINARY

00001111
#% 00
00
1
#88
DONE
DONE

;IS
MORE?1
:IS LEAST
LEAST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT 8 OR
OR MORE

#33

:YES, SUBTRACT
SUBTRACT 3 FOR
FOR DECIMAL
;YES,
CORRECTION
: CORRECTION

$41

:STORE NUMBER
NUMBER DIVIDED
DIVIDED BY 2
;STORE

There is no problem
SBC instruction
problem with
ith the Carry in the SBC
instruction since that instruction
instruction is only
executed if the Carry is set.
set. Remember that
SBC subtracts
that SBC
subtracts off the complemented
complemented Carry
C) so a Carry of 1 does not affect
It.
(1 - C)
affect the result.
28. 30,
30. and 37. Do you underTry the division
division method
method by hand on the decimal
decimal numbers 28,
under­
stand why
data.
hy it works? You may also wish to try the program on the same data.
whether the numbers are binary
Rounding is simple regardless of whether
or decimal. A binary number
follows:
number can be rounded as follows:

-----

BINARY
ROUNDING

If the most significant
1.
significant bit to be dropped is 1.
add 1 to the remaining
remaining bits. Otherwise.
Otherwise, leave
leave
the remaining
remaining bits alone.
This rule works
O and 10 in binary,
binary. much as 5 is halfway
works because 1 is halfway
halfway between
between 0
decimal== 0.1 binary).
in decimal
decimal (note that 0.5 decimal
So. the follow
following
So.
ing program will
ill round a 16-bit
16-bit number in memory locations 0040 and
(MSBs in 0041) to an 8-bit
0041 (MSBs
-b it number
number in memory location 0041.

DONE
DONE

LDA
LOA
BPL
BPL
INC
BRK
BRK

$40
DONE
DONE
$41

:IS MSB OF EXTRA
EXTRA BYTE
BYTE 1?
;IS
:YES. ROUND
ROUND MSB’S
MSB'S UP
UP
:YES,

8-21

If the number is longer than 16 bits, the rounding
rounding must ripple through
through all the bytes as
needed. Note that we could use BIT $40 instead of LDA
needed.
instruction
LOA $40 since the BIT
BIT instruction
sets the Sign flag according
according to the most significant
significant bit of the addressed memory loca­
localeaves the Accum
Accumulator
tion. This approach leaves
ulator as it was although
although it does change the
flags.
status flags.

ifficult
Decimal rounding
rounding is a bit more d iffic
u lt because the crossover
point is now BCD
BCD 50 and the rounding
rounding must produce a decimal
is:
result. The rule is:

DECIMAL
DECIMAL
ROUNDING

If the most significant
significant digitit is to be dropped
more, add 1 to the remaining
is 5 or more,
remaining digits.
The following
following program will
ill round a 4-digit
-digit BCD
BCD number in memory locations 0040 and
(MSDs in 0041) to a tw o-digit
BCD number
0041 (MSDs
-d ig it BCD
number in memory locatlon
location 0041.

DONE
DONE

LDA
CMP
CMP
BCC
BCC
SEO
SED
LOA
LDA
ADC
STA
CLD
CLO
BRK
BRK

$40
# $50
50
DONE
DONE

;IS BYTE
BYTE TO BE
:IS
BE DROPPED
DROPPED50 OR
OR MORE?
MORE?

;YES. ROUND
ROUND MSD'S
UP BY 1 IN DECIMAL
DECIMAL
;YES,
MSD’S UP
$41
$41
#0
$41

CARRY (KNOWN
(KNOWN TO BE
BE SET)
SET)
;ADD IN CARRY
;RETURNTO BINARY
:RETURN
BINARY MODE
MODE

Remember that you cannot use the INC instruction
instruction to add 1 because that instruction
instruction always produces a binary result. The instruction
instruction A DC#O
C # 0 will
ill add 1 to the Accum
ulator
Accumulator
since the Carry must be 1 for the instruction
instruction to be executed (otherwise the BCC
BCC instrucinstruc­
usual. we must be careful
tion would
would have forced a branch). As usual,
careful to set and clear the
numbers. the rounding
Decimal Mode flag appropriately.
appropriately. For longer numbers,
rounding must ripple
needed.
through more significant
significant digits
digits as needed.

8-22

PROBLEMS
1) Multiple-Precision
ultiple-Precision Binary Subtraction
Subtraction
Purpose: Subtract
Subtract one multiple-word
ultiple-word number
number from another. The length
length of the numnum­
bers is in memory
numbers themselves
themselves start (most signifi­
signifimemory location
location 0040, the numbers
cant bits first) in memory
memory locations
locations 0041 and 0051,
0051, respectively,
respectively, and the
difference
difference replaces the number
number starting
starting in memory
memory location
location 0041. Subtract
Subtract
the number
number starting
starting in 0051 from the one starting
starting in 0041.
Sample Problem:

Result:

(0040)

=

04

(0041)
(0042)
(0043)
(0044)

=

2F
5B
A7
C3

=
=
=

(0051)
(0052)
(0053)
(0054)

=
=
=

14
OF
DF
35
B8

(0041)
(0042)
(0043)
(0044)

=
=
=
=

1A
7C
72
OB
OB

-

2F5BA7C3
14DF35B8

=

that is.

1A7C720B
A7C720B

2)

Decimal
al Subtraction
Subtraction

(BCD) number
Purpose: Subtract
Subtract one multiple-word
ultiple-word decimal
decimal (BCD)
number from another. The length
of the numbers
numbers is in memory location
location 0040,
0040, the numbers
numbers themselves
themselves start
(most significant
significant digits
digits first) in memory locations
locations 0041 and 0051.
0051, respecrespec­
difference replaces the number
number starting
starting in memory location
location
tively, and the difference
Subtract the number
number starting
starting in 0051 from the one starting
starting in 0041.
0041. Subtract
Sample Problem:

Result:

(0040)

=

04

(0041)
(0042)
(0043)
(0044)

=

=
=
=

36
70
19
85

(0051)
(0052)
(0053)
(0054)

=
=
=
=

12
66
34
59

(0041)
(0041)
(0042)
(0043)
(0044)

=
=
=
=

24
03
85
26

-

36701985
36701985
12663459
12663459
24038526
24038526

that is.

8-233
8-

3)

8-Bit
-B it by 1 6-Bit
-B it Binary Multiplication
ultiplication

Purpose: Multiply
ultiply the 16-bit
16-bit unsigned
unsigned number
number in memory locations 0040 and 0041
(most significant
locasignificant bits in 0041) by the 8-bitit unsigned number
number in memory loca­
tion 0042. Store the result in memory locations 0043 through
through 0045. with
ith the
most significant
significant bits in memory location 0045.
Sample Problems:
a.

(0040)
(0041)
(0042)

03
00
05

(0043)
Result: (0043)
(0044)
(0045)

= OF
OF
= 00
00
= 00
00

that is.
that
is.

b

Result:

x5=15
3x
5 = 15
(0040)
(0041)
(0042)

6F
(29.295 decimal)
72 (29,295
61 (97 decimal)

(0043)
(0043)
(0044)
(0045)

OF
OF
5C
2B
28

29,295
29.295 Xx 97 = 2,841,615
2,841.615

that is.
is.

4)

Signed Binary Division

Purpose: Divide the 16-bit
16-bit signed number
number in memory locations
locations 0040 and 0041 (most
(most
significant
significant bits in 0041)
0041) by the 8-bit
8-bit signed number
number in memory location
Thenumbers
numbersare
arenormalized
normalized so
sothat
thatthe
themagnitude
magnitudeofofmemory
memorylocaloca­
0042. The
tion 0042 is greater
greater than the magnitude
magnitude of memory location 0041. Store the
quotient
posiquotient (signed) in memory
memory location
location 0043 and the remainder
remainder (always posi­
tive) in memory location
0044.
location 0044
Sample Problems:
a.
a.

Result:

b.

Result:

co

(0040)
(0041)
(0042)
(0042)

=
=
=

CO
FF (-64)
(-64)
FF
08

(0043)
(0044)

=
=

(-8) quotient
F8 (-8)
quotient
00 (0)
(0) remainder
remainder

(0040)
(0041)
(0042)

=

=
=

93
ED (-4717)
(71 decimal)
47 (71

(0043)
(0044)

=
=

BO (-67 decimal)
BD
28 (+40
(+40 decimal)

Hint: Determine
division. and adDetermine the sign of the result.
result, perform an unsigned division,
ad­
just the quotient
quotient and remainder
remainder properly.
just

824
8-24

Self-Checking Numbers
NumbersAligned
Aligned 1,1,3,3, 77M od
Mod 10
10
5) Self-Checking
Purpose: Calculate
Calculate a checksum
checksum digit
ig it from a string of BCD digits. The length of the
string
of digits
digits (number
(number of
ofwords)
words) is
location 0041;
0041: the string
string of
is in
in memory location
string of
of
digits
BCD digits
to aa word)
word)starts
starts in
Calculate the
the
digits (2 BCD
digits to
in memory
memory location
location 0042.
0042.Calculate
checksum
1, 3.
3, 7 Mod 10 method and store it in memory
checksum digit
ig it by the Aligned
Aligned 1,
location
location 0040.
The Aligned
1, 3, 7 Mod 10 technique
Aligned 1.
technique works as follows:
1)
1)
2)
3)
4)
5)

6)

Clear the checksum
checksum to start.
Add the leading digit
ig it to the checksum.
Multiply
ultiply the next digit
ig it by 3 and add the result to the checksum.
digitit by 7 and add the result to the checksum.
Multiply
ultiply the next dig
Continue
Continue the process (Steps 2-4) until
until you have used all the digits.
The self-checking
self-checking digit
ig it is the least significant
significant digitit of the checksum.

For example,
string of digits
digits is:
example. if the string
is:
549321
the result will
ill be:
Checksum = 5 +
+ 3 xX 44 ++ 7 xX99 ++ 3 ++ 3 xX22 ++ 7 xX 11==9 6
96
Self-checking digit
ig it = 6
Self-checking

Sample Problems:
a.

(0041) = 03
(0041)
03
(0042) = 36
(0043) = 68
(0044) = 51
Result: Checksum== 3 +
3
+ 3 xx66 ++ 7 xx66 ++ 8 ++ 3 xx55 ++ 7 xx11 = 993
(0040) = 03
03

b.

(0041) = 0404
(0041)
(0042) = 50
(0043) = 29
(0044) = 16
(0045) = 83
Checksum== 5 +
+ 3 xx 00 ++ 7 xx22 ++ 9 ++ 3 xx11 ++ 7 xx 66 ++ 8
Result: Checksum
+ 3 Xx 3 = 90
80
+
(0040) == 00
00

+ 1 and 3 = 2 xx11 ++ 1,
1, so the formula
Hint:
in t: Note
Note that
a t 7 = 2 xx 33 +
ula
Mi
Mi-1 + 1 can be used to calculate
Mj = 2 x Mj_i
calculate the next multiplying
ultiplying factor.

8-255
8-

REFERENCES
1.
1.

R. Herr,
Herr. "Self-Checking
Systems." Computer
J. R.
"Self-Checking Number
Number Systems,”
Computer Design,
Design. June 1974,
1974. pp.
pp.
85-91.

2.

Other methods for implementing
implementing multiplication.
division. and other arithm
arithmetic
tasks
ultiplication, division,
etic tasks
are discussed in:
S. Davis,
Davis. "Digital
Gets a Boost from Bipolar LSI
LSI Multipliers."
EON.
S.
ig ita l Processing Gets
ultipliers," EDN.
November 5,
5. 1978,
1978. pp. 38-43.
-D. Wainland.
ultiplying
icrocomputer."
A. Kolodzinski and D.
Wainland, "M u
ltip lyin g with a M icrocom
puter," Electronic
Design. January 18,
18. 1978,
1978. pp. 78-83.
Design,
B. Parasuraman
ardware
ltipl1cat1on
Techniques
B.
Parasuraman "H ardw
are M u ltip
lic a tio
Techniques for Microprocessor
icroprocessor
Systems," Computer
Computer Design,
1977. pp. 75-82.
Design. April 1977,
T. F.
F. Tao et al.,
al.. "Applications
T.
pplications of Microprocessors
Microprocessors in Control Problems."
Problems," 1977 Joint
Automatic
CA.. June 22-24.
1977.
Autom
atic Control Conference Proceedings. San Francisco. CA„
22-24, 1977,
S. Waser "State-of-the-art
rithmetic
S.
"State-of-the-art in High-Speed A rithm
etic Integrated
Integrated Circuits."
Circuits," Computer Design,
Design. July 1978,
1978. pp.
pp. 67-75.
S. Waser "Dedicated
ICs Speed Up Processing in Fast
"Dedicated Multiplier
ultiplier ICs
Computer
Fast Computer
Systems."
Design. September
13. 1978,
1978. pp. 98-103.
Systems," Electronic Design,
September 13,
S. Waser
"Medium-Speed
Multipliers
S.
Waser and
and A.
A. Peterson.
Peterson, "M edium
-Speed M
ultipliers Trim
Trim Cost.
Cost, Shrink
Shrink BandBand­
width
Transmission." Electronic
Design. February 1,
1. 1979,
1979. pp.
pp. 58-65.
th in Speech Transmission,"
Electronic Design,
J. Weissberger
We1ssberger and T.
T. Toal,
Toal. "Tough
Tasks Are Child's
A. J.
"Tough Mathematical
Mathematical Tasks
Child’s Play for
Number Cruncher."
Electronics. February 17.
17. 1977. pp. 102-107.
Cruncher," Electronics,

8-266
8-

Chapter 9
TABLES AND LISTS
Tables and lists
lists are twoo of the
the basic
basic data structures
structures used with
ith all computers.
computers. We
Tables
have
arithmetic.
have already
already seen tables
tables used
used to perform
perform code
code conversions
conversions and arithm
etic. Tables
Tables
also be used to identify
identify or respond
respond to commands
commands and instructions,
instructions, linearize
linearize
may also
data, provide
provide access
access to files
files or records,
records, define
define the
the meaning
meaning of keys
keys or switches,
switches,
choose among
among alternate
alternate programs.
programs. Lists
Lists are usually
usually less structured
structured than tata­
and choose
bles. Lists
Lists may record
record tasks
tasks that
that the processor
processor must
must perform,
perform, messages
messages or data
that the
the processor
processor must
must record,
record, or conditions
conditions that
that have
have changed
changed or should
should be
that
monitored.
monitored. Tables
Tables are a simple
simple way
way of making
making decisions
decisions or solving
solving problems,
problems, since
since
computations or logical
logical functions
functions are necessary.
necessary. The task,
task, then,
then, reduces
reduces to
no computations
organizing
organizing the
the table
table so that
that the
the proper
proper entry
entry is easy to find.
find. Lists
Lists allow
allow the
the execuexecu­
tion of sequences
sequences of tasks,
tasks, the preparation
preparation of sets
sets of results,
results, and the
the construction
construction
tion
of
of interrelated
interrelated data files
files (or data
data bases). Problems
Problems include
include how
how to add elements
elements to
a list
list and remove
elements from
from it.
remove elements

9-1

EXAMPLES
List
Add
Entry to List
Add Entry
presalready pres­
not already
is not
to a list if itit is
Purpose:: Add
0040 to
location 0040
of memory location
contents of
the contents
Add the
Purpose
list
the list
and the
0041
ent
in
the
list.
The
length
of
the
list
is
in
memory
location
0041
and
in
Is
the
length
The
list.
the
in
ent
itself
in memory location 0042.
begins in
itself begins
s:
Sample Problems:
a.
a.

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)

=
=
=
=
=
=

6B
6B
04
37
61
61
38
1D
10

(0041)
(0041)
(0046)

=
=

05
6B

is
list is
the list
of the
length of
The length
The
list. since it is not already present. The
to the list,
added to
is added
(6B) is
entry (6B)
The entry
1.
ted by 1.
incremented
b.
b.

(0040) = 6B
(0040)
(0041) = 04
(0041)
(0042) = 37
(0042)
(0043) = 6B
(0044) = 38
(0045) = 1D
10
locamemory loca­
(in memory
Is already in the list (in
Result:
(6B) is
change. since the entry (6B)
No change,
Result: No
tion 0043).

9-2

Flowchart:
Flowchart:
Start

Entry = (0040)
Length = (0041 I
Index = Length

Index = Index .1

Length= Length+ 1
(0041 + Length) =
Entry

End

Source Program:

SRLST

DONE

LDA
LOA
LOX
LDX
CMP
SEO
BEQ
DEX
BNE
INC
LOX
LDX
STA
BRK
BRK

$40
$41
$41
$41.X
DONE
SRLST
$41
$41
$41
$41
$41,X

;GET ENTRY
:INDEX
;INDEX = LENGTH OF LIST
:IS ENTRY = ELEMENT IN LIST?
;IS
:YES. DONE
:YES,
:NO.
;NO, GO ON TO NEXT ELEMENT
;ADD 1 TO LIST LENGTH
;ADD
;ADD
;ADD ENTRY TO LIST

9-3

Object Program:
Program:
Memory Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0005
0006
0007
0008
0009

A5
40
A6
41
D5
41

SRLST
SRLST

FO
FO
09
CA
DO
DO
F9
E6
41
A6
41
95
41
00

OOOA
000A
0008
000B

oooc
oooc

OOOD
000D
000E
OOOE
OOOF
000F
0010
0011

Instruction
Instruction
(Mnemonic)

DONE
DONE

LOA
LDA

$40

LOX
LDX

$41

CMP
CMP

$41.X
$41,X

SEO
BEQ

DONE
DONE

DEX
DEX
BNE
BNE

SRLST
SRLST

INC
INC

$41
$41

LDX
LOX

$41
$41

STA

$41,
$41.XX

BRK
BRK

I

Clearly, this method of adding
adding elements is very inefficient
inefficient if the list
I HASHING
HASHING! I
is long. We could improve
improve the procedure
procedure by limiting
iting the search to
part of the list or by ordering
using the entry to
ordering the list. We
We could limit the search by using
get
ashing",
get a starting point in the list. This method is called "h ash
ing ", and is much like
selecting
selecting a starting
starting page in a dictionary
dictionary or directory
directory on the basis of the first letter
letter in an
numerical value. The search could then end when the
entry. We could order the list by numerical
list values went
smaller. depending
ent beyond the entry
entry (larger or smaller,
depending on the ordering techtech­
nique used).
used). A new entry would
would have to be inserted properly.
properly, and all the other entries
would
would have to be moved down
down in the list.

tables. One table could provide a starting
The program could be restructured
restructured to use twoo tables.
starting
point
based on the most or
point in the other
other table; for example.
example, the search point could be based
least significant
significant 4-bit
-b it digit
ig it in the entry.
The program does not work if the length
happens?). We could
length of the list is zero (what happens?).
avoid this problem by checking
checking the length initially.
initially. The initialization
initialization procedure would
be;
then be:

ADELM

LOX
LDX
SEO
BEQ

$41
$41
ADELM
ADELM

;INDEX
;INDEX== LENGTH
LENGTHOF
OF LIST
LIST
;ADD ENTRY
ENTRYTO
TO LIST
LIST IF
IF LENGTH
LENGTHIS
IS ZERO
ZERO
;ADD

INC

$41

LIST LENGTH
LENGTH
;ADD 1 TO LIST

Unlike many other
processors. the 6502's
other processors,
6502's Zero flag is affected by Load instructions.
instructions.
If each entry
pattern-matching
necesentry were longer than one word.
word, a pattern-m
atching program would
would be neces­
is.
sary. The program
program would
would have to proceed to the next entry if a match failed; that is,
skip over the last part of the current
current entry
entry once a mismatch
ismatch was found.

9-4
4

Check an Ordered List
Purpose:

see if that
orCheck the contents
contents of memory location
location 0041 to see
that value is in an or­
dered list. The length
length of the list is in memory
memory location
location 0042;
0042; the list itself
begins
begins in memory
memory location
location 0043
0043 and consists
consists of unsigned
unsigned binary
binary numbers
list. clear
in increasing
increasing order. If the contents
contents of location
location 0041 are in the list,
memory location
FF15.
location 0040;
0040; otherwise,
otherwise, set memory
memory location
location 0040
0040 to FF-|
q

Sample Problems:
a.

Result:
b.

Result:

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)

=.
=
=
=
=
=

68
6B
04
37
55
70
7D
A1

(0040)

=

FF, since 6B is not in the list.
FF,

(0041)
(0042)
(0043)
(0044)
(0045)
(0046)

68
6B
04
- 37
= 55
= 68
6B
= A1

(0040)

=

00, since 68 is in the list.

9-5

Flowchart:
Flowchart:
Start

Entry = 10041)
Length = 10042)
Mark = 0
Index =

Length

Index = Index -1

Mark =FF 15

10040) = Mark

End

The searching
ts a bit different
searching process is
different here since the elements
elements are ordered. Once we
find an element
element smaller
smaller than the entry
entry (remember
(remember that we are moving
moving backward
backward
through
fashion). the search is over,
through the list in the usual 6502 fashion),
subsequent ele­
over. since subsequent
elements will
ill be even smaller. You may want
want to try an example
example to convince
convince yourself
yourself that
the procedure
procedure works. Note trat
that an element
element smaller
smaller than the entry is indicated
indicated by a comcom­
parison that does not produ~e
is. Carry== 1).
1).
produce a borrow
borrow (that is.
As in the previous
previous problem.
problem, a table or other
other method that could
SEARCHING
SEARCHING
choose a good starting
starting point
point would
would speed up the search. One
METHODS
METHODS
method would
would be to start
start in the middle and determine
determine which
half of the list the entry was
was in, then divide the half into halves, etc. This method
is called a binary search, since it divides the remaining part of the list in
in half each
time.1

9-6

Source Program:

SRLST
SRLST

NOTIN
DONE

LOA
LDA
LDX
LOX
LOY
LDY
CMP
BEO
BEQ
BCS
DEX
BNE
BNE
LOY
LDY
STY
BAK
BRK

$41
$42
#00
$42.X
$42,X
DONE
NOTIN

GET ENTRY
ENTRY
GET
LENGTH OF LIST
INDEX = LENGTH
MARK = ZERO
ZERO FOR
FOR ELEMENT IN LIST
:IS ENTRY EQUAL TO ELEMENT?
ELEMENT?
:YES. SEARCH
SEARCH COMPLETED
;ENTRY NOT IN LIST IF GREATER
GREATER THAN ELEMENT
ELEMENT

SRLST
SRLST
#$FF
#$FF
$40
$40

:MARK
FF FOR
FOR NOT IN LIST
;MARK = FF
:SAVE
;SAVE MARK

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
000A
OOOB
000B
oooc
OOOC
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013

A5
41
A6
42
AO
00
05
D5
42
FO
FO
07
BO
BO
03
CA
DO
F7
AO
FF
84
40
00

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LOA
LDA

$41

LOX
LDX

$42

LOY
LDY

#00

CMP

$42.X
$42,X

BEO
BEQ

DONE
DONE

BCS
BCS

NOTIN

DEX
DEX
BNE
BNE

SRLST
SRLST

NOTIN

LDY
LOY

#$FF
#$FF

DONE
DONE

STY

$40

SRLST
SRLST

BRK
BAK

This
This algorithm
algorithm is a bit
bit slower
slower than the one in the example
example given under
under "Add
dd Entry to
List" because
because of the extra conditional
conditional jumpp (BCS
execution time
List"
(BCS NOTIN).
NOTIN). The average execution
for this simple
simple search technique
technique increases linearly
linearly with
ith the length
length of the list while
hile the
average
average execution
execution timee for a binary
binary search increases
increases logarithmically.
logarithmically. For example.
example, if the
length of the list is doubled.
doubled, the simple
simple technique
technique takes twice
ice as long on the average
length
while
hile the binary
binary search method
method only
only requires
requires one extra iteration.
iteration.

9-7

Remove Element
ent from Queue
Purpose:
Purpose:

Memory
head of the
Memory locations
locations 0042 and 0043 contain
contain the address of the head
queue
(head) of a
queue (MSBs in 0043). Place the address of the first
first element
element (head)
queue into
into memory
memory locations
locations 0040
0040 and 0041 (MSBs
queue
(MSBs in 0041) and update
Each element
the queue
queue to remove the element. Each
element in the queue is two bytes
long and contains
contains the address of the next two-byte
two-byte element
element in the queue.
The last element
element in the queue
queue contains
contains zero to indicate
indicate that
that there is no next
element.

Queues are used to store data in the order in which it will
ill be used,
used, or tasks in the
strucorder in which they will
ill be executed.
executed. The queue is a first-in, first-out
first-out data struc­
elements are removed from the queue in the same order in which they
ture; i.e., elements
were
were entered. Operating
Operating systems place tasks in queues so that they will
ill be executed
in the proper
1/0 drivers
transmitproper order. I/O
drivers transfer
transfer data to or from queues so that it will
ill be transm
it­
ted or handled in the proper
proper order. Buffers may be queued
queued so that the next available
one can easily be found
released can easily be added to the available
found and those that are released
ing, or I/O
storage. Queues may also be used to link requests for storage,
storage. timing.
1/0 so that
they can be satisfied in the correct
correct order.
In real applications.
applications, each element
element in the queue will
ill typically
typically contain
contain a large amount
amount of
information
information or storage space besides the address required to link the element
element to the
next one.
one.

Sample Problems:

a.
a.

Result:

b.
b.
Result:

(0042)
(0043)
(0046)
(0047)
(0040)
(004D)
(004EI
(004E)

6~}
element in queue
6~}address of second element

(00401
(0040)
(0041)
(0042)
(0043)

element removed from quei
6~}address of element
queue
6~}
J- address of new first element
element in queue

(0042)
(0043)

empty queue
~~} empty

(00401
(0040)
(0041)

element available from queue
~~} no element

q® j- address of first element
element in queue

~~} end of queue

qq

9-8

Flowchart:
Flowchart:

c

Start

D

=

Pointer = (0 0
10042
and 0 043)
43)
10040 and 0 041
(0 0
4 1 )I =
Pointer

(00421 = (Pointerl
(00431 = (Pointer+ 1I

End

Source Program:

DONE

LOA
LDA
STA
LOA
LDA
STA
ORA
BEO
BEQ
LDY
LOY
LDA
LOA
STA
INY
LDA
LOA
STA
BRK
BRK

$42
$40
$43
$41
$41
$42
DONE
#0
($40) Y
($40).
$42

;REMOVE HEAD
HEAD OF
OFQUEUE
QUEUE
;REMOVE

;ISQUEUE
QUEUEEMPTY?
EMPTY?
;IS
;YES.DONE
DONE
;YES,
;NO.MOVE
MOVE NEXT
NEXTELEMENT
ELEMENTTO
TOHEAD
HEADOF
OFQUEUE
QUEUE
;NO.

($40).Y
($40),Y
$43

9-9
9-9

Object
Program:
Object Program:

!

Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
0008
000B

A5
42
85
40
A5
43
85
41
05
42
FO
F0
OB
0B
AO
A0
00
B1
B1
40
85
42
C8
CB
B1
B1
40
85
43
00

oooc
oooc
0000
000D
OOOE
000E
OOOF
000F
0010
0011
0012
0013
0014
0015
0016
0017

Instruction
Instruction
(Mnemonic)

DONE
DONE

LOA
LDA

$42

STA

$40

LOA
LDA

$43

STA

$41
$41

ORA
ORA

$42

SEO
BEQ

DONE
DONE

LOY
LDY

#00

LOA
LDA

($40).Y

STA

$42

INY
LOA
LDA

($40).Y
($40),

STA

$43

BRK
BRK

Queuing can handle lists that are not in sequential
Each element
sequential memory locations. Each
element in
the queue must contain
contain the address of the next element. Such lists allow
allow you to handle
order. change variables,
variables. or fill in definitions
Exdata or tasks in the proper order,
definitions in a program. Ex­
tra storage is required but elements
elements can easily be added to the queue or deleted from it.
Post-indexing.
Post-indexing, or indirect
indirect indexed addressing.
addressing, is very handy here since it allows us to
use the contents
contents of memory locations 0040
0040 and 0041 as a pointer. Those locations con­
contain the address of the head of the queue which,
which. in turn,
turn. contains
contains the address of the
locations in which
hich the address of the element
element is stored must
next element. The memory locations
zero. since they are used with
be on page zero,
ith the post-indexed
post-indexed addressing mode. All other
addresses can be anywhere
anywhere in memory. The post-indexed
post-indexed mode could also be used later
to transfer data to or from the element
element that has just
just been removed from the queue.
addresses on page zero.
zero. Furthermore.
Remember that post-indexing
post-indexing is only available for addresses
Furthermore,
only Index Register Y can be used in this mode.
mode.
Note the use of the sequence
LDA
LOA
ORA

$43
$43
$42
$42

zero. Try to
to determine
determine if the 16-bit
16-bit number
number in memory locations 0042
0042 and 0043 is zero.
devise some other sequences that could handle this problem
problem -— it obviously
obviously occurs
whenever
whenever you use a 16-bit
16-bit counter
counter rather than the 8-bitit counter
counter that we have used in
most of the examples.
One problem with
ith the 6502 instruction
instruction set is that there are no instructions
instructions that
specifically
data) from one place to another
specifically move 16-bit
16-bit addresses (or data)
another or that perform
other 16-bit
course. such instructions
16-bit operations. Of course,
instructions would
ould have to operate eight
eight bits at
a time,
time. but some InstructIon
saved. Most other
instruction fetch and decode cycles could be saved.
instructions.
microprocessors have such instructions.
9 -10
10

It may be useful to maintain pointers to both ends of the queue rather than just to
head.2,33 The data structure may then be used in either
manits head.2'
either a first-in.
first-in, first-out
u t man­
ner or in a last-in, first-o
first-out
u t manner, depending on whether
hether new elements
elements are adad­
ded to the head or to the tail. How would
would you change the example
example program
program so that
locations 0044
0044 and 0045
0045 contain
contain the address of the last element
element (taill
(tail) of the
memory locations
queue?
elements in the queue.
queue, the program clears memory
memory locations
locations 0040
0040 and
If there are no elements
0041. A program
program that
that requested
requested an element
element from the queue would
would have to check those
memory
memory locations
locations to see if its request
request had been satisfied. Can you suggest
suggest other
other ways
to provide
provide this information?
information?

9 -11

8-Bit
it Sort
Purpose: Sort an array of unsigned binary numbers into descending order.
order. The length
Purpose:
of the array is in memory location 0040 and the array itself begins in memo­
memory location 0041.
Sample Problem:

Result:

(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0046)
(0046)

= 06
= 2A
= B5
= 60
= 3F
= D1
D1
= 19

(0041)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

=
=
=
=
=

D1
D1
B5
60
3F
2A
19

A simple sorting technique
technique works as follows:

1)
Step 1)

INTER.
Clear a flag INTER.

Step 2)

SIMPLE
SORTING
ALGORITHM
ALGORITHM

Examine each consecutive
consecutive pair of numbers in the array.
array. If
any are out of order,
order. exchange them and set INTER.
INTER.
INTER = 1 after the entire array has
has been examined, return to Step 1.
1.
Step 3) If INTER

INTER will
order. Therefore,
Therefore. if IN­
ININTER
ill be set if any consecutive
consecutive pair of numbers is out of order.
TER
through the entire array,
TER = 0 at the end of a pass through
array, the array is in proper order.
order.
following
case. Let us assume that we
The technique
technique operates as shown in the follow
ing simple case.
want
order: the array has
has four elements -— 12,
12, 03, 15,
15,
want to sort an array into descending
descending order;
style.
08. We will
ill work backwards through
through the array in normal 6502 processing style.
1st Iteration:
Step 1)
11 INTER
INTER = 0

Step 2)

Final order of the array is:
is:
15
12
03
08
15) is exchanged and so is the third pair (12.15)
since the second pair (03,15)
(12,15).
INTER= 1.
1.
INTER

2nd Iteration:
1)
Step 1)

INTER== 00
INTER

Step 2)
2)

Final order of the array is:
is:
15
12

08
03
since the first pair (08.03)
INTER= 1.
1.
(08,03) is exchanged. INTER

9-12
9-

3rd Iteration:
1)
Step 1)

INTER== 00
INTER

Step 2)

The elements are already in order; no exchanges are necessary,
necessary. and
INTER remains zero.
zero.
INTER

Note that
that one extra iteration
iteration is always performed to ensure that
that the elements are in the
order. Clearly,
Clearly. there is a large potential
provement
proper order.
potential for im provem
ent in this method and new
sorting techniques
techniques are an important
area of current
portant area
current research.
research.®6

Flowchart:
Flowchart:
Start

Inter= 0
Index = {0040) -1
Base = 0041

Temp= (Base+
Index -1)
{Basa+lndex -1) =
{Base+lndex)
{Base+lndex) =
Temp
Inter= 1

Index = Index -1

No

No

End

9-13

n
Source Program:
Program:
SORT
SORT

PASS

COUNT

LDY
LOY
LOX
LDX
DEX
LOA
LDA
CMP
BCS
LOY
LDY
PHA
LOA
LDA
STA
PLA
STA
DEX
BNE
DEY
BEO
BEQ
BRK
BAK

#00
$40

$40.X
$40,X
$4
1.X
41.X
COUNT
#1

;INTERCHANGE FLAG =
= ZERO
ZERO
;GET LENGTH OF ARRAY
:ADJUST
ADJUST ARRAY LENGTH TO NUMBER OF PAIRS
PAIRS
;IS PAIR OF ELEMENTS IN ORDER?
ORDER?
:YES.
YES, TRY NEXT PAIR
:NO.
SET INTERCHANGE FLAG
NO, SET
:INTERCHANGE ELEMENTS USING THE STACK

$41.X
$41,X
$40.X
$40,X
41,X
$4
1.X
:CHECK FOR
FOR COMPLETED PASS
PASS
SORT
SORT

:WERE ALL ELEMENTS IN ORDER?
ORDER?
:NO.
NO, GO THROUGH ARRAY AGAIN

Object Program:
Object
Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006
0006
0007
0007
0008
0008
0009
0009
OOOA
OOOA
000B
0008
oooc
OOOC
000D
0000
OOOE
000E
OOOF
000F
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018
0019
0019
001A
01A
0 018
1B

AO
00
A6
40
CA
85
B5
40
D5
05
41
BO
BO
OA
AO
01
48
85
B5
41
95
40
68
95
41
CA
DO
DO
ED
ED
88
FO
FO
E5
E5
00

SORT
SORT

PASS

COUNT

LOY
LDY

#00

LOX
LDX

$40

DEX
LDA
LOA

$40,
$40.XX

CMP

$41.X
,X

BCS
BCS

COUNT

LOY
LDY

#1

PHA
LDA
LOA

$41,X
$41.X

STA

$40,X
$40.X

PLA
STA

$41,X
$41.X

DEX
DEX
BNE
BNE

PASS

DEY
DEY
BEO
BEQ

SORT
SORT

BRK
BAK

9 -14
4

i

Instruction
Instruction
(Mnemonic)
(Mnemonic)

The case where
prowhere twoo elements
elements in the array are equal is very important. The pro­
since that interchange would
gram should not perform an interchange in that
that case since
be performed in every
pass. The result would be that
pass would set the Inevery pass.
that every
every pass
In­
terchange flag, thus producing an endless loop.
loop. The program compares the elements
in the specified
specified order so that
that the Carry flag is set if the elements are already arranged
correctly.
correctly. Remember that
that comparing
comparing twoo equal values sets the Carry flag since that flag
is an inverted borrow
borrow after
after subtractions
subtractions or comparisons.
The 6502 Conditional
Conditional Branch instructions
instructions can be limiting.
iting, and are particularly
particularly limiting
iting
CMP, we have only BCC
BCC -— branch if
in this program. Following
Following an instruction
instruction like CMP,
(M) >
(A)
BCS -— branch if (M) :5:
(A). The 6502 has no Branch instructions
(M
)>(A
) -— and BCS
<(A).
instructions for the
(A)
:5:(A).
is, (M)~
cases where the equality
equality condition
condition is on the other side, that
that is,
>(A
) and (M)<(A).
Therefore, we must
must be careful
careful of the order of operations.

pass, we must be careful to reinitialize
InBefore starting
starting each sorting
sorting pass,
reinitialize the Index and the In­
terchange
terchange flag.
The program must
must reduce the Counter
Counter by 1 initially,
initially, since the number
number of consecutive
consecutive
less than the number
has no successor).
successor).
pairs is one less
number of elements
elements (the last element
element has

This program does not work properly
array.
properly if there are fewer than two elements in the array.
How could you handle this degenerate
case?
degenerate case?
OTHER SORTING
There are many sorting
algorithmss that
sorting algorithm
that vary widely
widely in efficienefficien­
METHODS
METHODS
cy. References 1, 4. and 5 describe some of these.
cy. References 1, 4, and 5 describe some of these.

The Stack is easy to use for temporary
temporary storage
storage inin this
program since the
thePHA
PHA (Push
(Push Acthis program
Ac­
cumulator
Accumulator
PLA (PullAccum
Accumulator
cum
ulator or Store Accum
ulator in Stack)
Stack) and
and PLA
ulator or
or Load AcAc­
cumulator
Stack) instructions
cum
ulator from Stack)
instructions are each only one byte long. The address is in the
Stack Pointer
Pointer (extended with
ith 01 as its page number). If you wish.
wish, you can substitute
substitute a
fixed memory location.
is:
location, such as 003F. The interchange
interchange then is:
STA

$3F

LDA
STA
LDA
STA

41.X
$4
1.X
$40,X
$40,X
$3F
$41,X
$41.X

;INTERCHANGE ELEMENTS
ELEMENTS USING
USING TEMPORARY
TEMPORARY
INTERCHANGE
STORAGE
; STORAGE

See Chapter
Chapter 10 for a further
further discussion
discussion of the 6502 RAM Stack.
Stack.

9-15

Using an Ordered Jump Table
Purpose:

Use the contents
Use
contents of memory location
location 0042 as an index to a jumpp table startstart­
ing in memory
Each entry in the jumpp table contains
memory location
location 0043. Each
contains a 16-bit
16-bit
address with
first byte. The program
transfer control
control to
ith LSBs in the first
program should transfer
is. if the index is 6,
6. the prothe address with
ith the appropriate
appropriate index; that
that is,
pro­
gram should jumpp to address entry
entry #66 in the table. Assume
Assume that
that the table
has fewer
fewer than 128 entries.

Sample Problem:
Prablem:

Result:

(0042)

=

02

(0043)
(0044)
(0045)
(0046)
(0047)
(0048)
(0049)
(004A)

=

6g}

(PC)
(PC)

=

=
=
=
=
=
=
=

index for jump table

4C
j- zeroth element
element in jumpp table
00
50
j- first
first element
element in jumpp table
00
54
j- second element
element in jum
jumpp table
00
58
| third
third element
element in jumpp table
00

6~}

66}

6~
}

0054. since that is entry #2 (starting from zero) in the
00!
jumpp table. The next instruction
instruction to be executed
executed will
ill be
address.
the one located at that
that address.

Flowchart:
Flowchart:
Start

Index - (0042) x 2

(0040) - (0043
+Index)

(0041 I - 10044
+Index)

IPCI (0041110040)

The last box results in a transfer
transfer of control
control to the address obtained
obtained from the table.

Source Program:
LDA
LOA
ASL
TAX
LDA
LOA
STA
LOA
LDA
STA
JMP

$42
A

;GET INDEX
INDEX
;GET
;DOUBLE INDEX
INDEX FOR
FOR 2-BYTE TABLE
;DOUBLE

$43,X
$43.X
$40
$44,X
$44.X
$41
($40)
($40)

;GET LSB'S OF
OF JUMP ADDRESS
ADDRESS
;GET
;GET MSB'S OF
OF JUMP ADDRESS
ADDRESS
;GET
;TRANSFER CONTROL
CONTROL TO DESTINATION
DESTINATION
TRANSFER

9-16
-1 6

Object Program:
Program:
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
(Hex)
(Hex)

0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
OOOB
000B
oooc
oooc
0000
000D
OOOE
000E

A5
42
OA
0A
AA
B5
B5
43
85
40
B5
44
85
41
41
6C
40
00

Instruction
Instruction
(Mnemonic)
LDA
LOA

$42

ASL
TAX
LDA
LOA

A

STA

$40

LOA
LDA

$44,X
X

STA
STA

$41
$41

JMP

($40)
($40)

$43,X
$43,X

Jump tables are very useful in situations where
where one of several
several routines must be
selected
selected for execution.
execution. Such situations arise in decoding commands (entered, for
example,
choosing alternative
example, from a control keyboard).
keyboard), selecting test
st programs, choosing
alternative
methods, or selecting an I/O
1/0 configuration.
The jump table replaces a series of conditional jump operations. The program that
accesses the jumpp table could be used to access
access several different
accesses
different tables merely by
mode. in which
using the post-indexed,
post-indexed, or indirect
indirect indexed, addressing mode,
which the starting
starting ad­
adzero.
dress of the table is placed in RAM on page zero.
The data must be multiplied
ultiplied by 2 to give the correct
correct index since each entry in the jump
table occupies two bytes.
bytes.

($40) uses
uses indirect
The instruction
instruction JMP ($40)
indirect addressing: the destination
destination is the address
address
stored at the specified location rather than the specified
specified location itself. JMP is the only
6502 instruction
uses indirect
instruction that uses
indirect addressing. Note that there is no page-zero mode
and that the address is stored in the usual 6502 fashion with
ith the least significant
significant bits
first.
used in describing
The terminology
inology used
describing Jump
Jump or Branch instructions
instructions is JUMP
JUMP AND
often quite confusing.
confusing. A Jump
Jump instruction
instruction that is described as BRANCH
using direct
direct addressing actually
actually loads the specified address into TERMINOLOGY
TERMINOLOGY
the Program Counter:
Counter; this works more like immediate
mediate addressing
than like direct
direct addressing as applied to other instructions
instructions such as Load or Store.
Store. A
Jump instruction
instruction using indirect
indirect addressing works like other instructions
instructions using direct
direct
addressing.
No ending operation
operation (such as a BRK
instruction) is necessary since JMP ($40)
BAK instruction)
($40) transfers
control
control to the address obtained
obtained from the jumpp table.

References 7 and 8 contain
References
contain additional
additional examples of the use of jump tables.
tables. The program
(why?). How could you
assumes that the jumpp table contains
contains fewer than 128 entries (why?).
change the program to allow longer tables?

9 -17
7

PROBLEMS
PROBLEMS
1)

From a List
Remove an Entry From

Purpose:

Remove the contents
present.
Remove
contents of memory location 0040 from a list if it is present.
The length
length of the list is in memory
memory location 0041 and the list itself begins in
memory location 0042. Move the entries below the one removed up one
position
1.
position and reduce the length of the list by 1.

Sample Problems:
Sam
(0040)

a.

=

6B

entry to be removed from list

(0041)

=

04

length of list

(0042)
(0043)
(0044)
(0045)

=
=
=
=

37 first
first element in list
61
2B
28
1D

Result: No change.
change, since the entry
Result:
entry is not in the list.
b

Result:
Result:

(0040)

=

6B

entry to be removed from list

(0041)

=

04

length of list

(0042)
(0042)
(0043)
(0044)
(0045)

=
=
=
=

37 first element
element in list
6B
2B
28
1D

(0041)

=

03

(0042)
(0043)
(0044)

=
=
=

37
28 other
other elements
elements in list moved iup one position
1D

length of list reduced by 1

The entry is removed from the list and the ones below it are moved up one position. The
length
1.
length of the list is reduced by 1.

9 -18
18

2)

Add an Entry to an Ordered List

Purpose:
Purpose:

Place the contents
are
Place
contents of memory location 0040 into an ordered list if they are
not already there. The length
length of the list is in memory
memory location
location 0041. The list
itself begins in memory location
itself
location 0042
0042 and consists of unsigned
unsigned binary num-­
Place the new entry in the correct
bers in increasing
increasing order. Place
correct position
position in the
list. adjust the elements
list,
elements below it down, and increase the length
length of the list by
1..

Sample Problems:
a.

Result:

b.

(0040)

=

6B

entry to be added to list

(0041)
(0041)

=

04

length of list

(0042)
(0043)
(0044)
(0045)

=
=
=
=

37
55
7D
A1
A1

first element
element in list

(0041)

=

05

length
length of list increased by 1

(0044)
(0045)

=

6B
7D

entry placed in list
other elements in the list moved down one
position
position

(0046)

=

A1

(0040)
(0040)

=

6B

(0041)

=

04

length
length of list

(0042)
(0043)
(0044)
(0045)

=
=
=
=

37
55
6B
A1
A1

first
first element
element in list

entry to be added to list

Result: No change, since the entry is already in the list.

3)

Add an Element
ent to a Queue

Purpose:

Add the address in memory locations
locations 0040
0040 and 0041 (MSBs
(MSBs in 0041) to a
queue. The address of the first element
element of the queue is in memory
memory locations
0042 and 0043
(MSBs in 0043). Each
Each element
0043 (MSBs
element in the queue contains
contains either
the address of the next element
element in the queue or zero if there is no next ele­
element; all addresses are 16 bits long with
ith the least significant
significant bits in the first
byte of the element. The new element
element goes at the end (tail)
(taill of the queue: its
address will
ill be in the element
element that
that was at the end of the queue and it will
ill
contain
contain zero to indicate
indicate that it is now the end of the queue.

Sample Problem:

Result:

(0040)
(0041)
(0042)
(0043)

=
=
=
=

4D
4D}| new element
element to be added to queue
00
46
pointer to head of queue
pointer
00 }

(0046)
(0047)

=

00
^ last element
element in queue
00

(0046)
(0046)
(0047)

=

=

6~
}
gg}

=

4D l old last element points to
00 }f ' new last element
element

(004D) =
(004D)
(004E) =
(004E)

00
j- new last element
element in queue
00

gg}

How would
would you add an element
element to the queue if memory
memory locations
locations 0044 and 0045 concon­
tained the address of the tail of the queue (the last element)?
9 -19

4)

1 6-Bit
it Sort

Purpose:

an array of unsigned 16-bit binary numbers into descending order.
order. The
Sort an
length of the array is in memory location 0040 and the array itself begins in
memory location 0041. Each
Each 16-bit
16-bit number is stored with
ith the least signifisignifi­
cant bits in the first byte.

Sample Problem:

(0040)
(0040)

=

03

length of list

(0041)
(0041)
(0042)
(0042)

=
=

D1
D1
19

LSBs of first element in list
LSBs
MSBs of first element in list

(0043)
(0043)
(0044)
(0044)

=

60
3F

(0045)
(0045)
(0046)
(0046)
Result:

=

=
=

2A
B5
B5

(0041)
(0041)
(0042)
(0042)

=

(0043)
(0043)
(0044)
(0044)

=

60
3F

(0045) =
(0045)
(0046)
(0046) =

D1
D1
19

=

2A
B5

LSBs of first element in sorted list
LSBs
MSBs of first element in sorted list
MSBs

19D1.
The numbers are B52A, 3F60, and 19D1.

5)

Using a Jump Table with
ith a Key

Purpose:

Use the contents of memory location 0040 as
as the key to a jump table startUse
start­
ing in memory location 0041. Each
Each entry in the jumpp table contains
contains an B-bit
8-bit
key value followed
followed by a 16-bit
16-bit address (MSBs
(MSBs in second byte) to which
hich the
program should transfer control if the key is equal to that key value.
value.

Sample Problem:

Result:

(0040)
(0040)

=

38

search
key value for search

(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

=
=
=

32
4A
00

key value for first entry
LSBs of jump address for first entry
LSBs
MSBs of jump address for first entry

(0044)
(0044)
(0045)
(0045)
(0046)
(0046)

=
=
=

35
4E
00

(0047)
(0047)
(0048)
(0048)
(0049)
(0049)
(PC)
(PC)

=
=
=
=

38
52
00
0052, since that address corresponds
to key value 38.
38.

9-20
9-

REFERENCES
1.
1.

D. Knuth.
Knuth, The Art of Computer
Ill: Sorting and Searching
D.
Computer Programming. Volume III:
(Reading. Mass.:
Mass.: Addison-Wesley.
(Reading.
Addison-Wesley. 1978.
1978).
D. Knuth. "A lg o
lgorithms,"
1977. pp.
pp. 63-80.
D.
rithm s," Scientific
Scientific American. April
pril 1977,

2.
2.

K. J. Thurber
P. C.
C. Patton, Data Structures
(LexK.
Thurber and P.
Structures and Computer
puter Architecture
Architecture (Lex­
ington. Mass.:
Mass.: Lexington
Books, 1977.
ington,
Lexington Books,
1977).

3.
3.

E. Teja,
Teja. "Data Structures
Part 1,”
1," EDN.
EDN, March 5,
5. 1979,
1979. pp.
J. Hemenway and E.
Structures - Part
pp.
89-92.
-

4.

B. W. Kernighan and P.
P. J. Plauger,
Plauger, The Elements of Programming Style (New
B.
1978).
York: McGraw-Hill,
McGraw-Hill, 1978).

5.

K. A. Schember and J. R.
R. Rumsey,
Rumsey. "Minimal
TechK.
inim al Storage Sorting and Searching Tech­
niques for RAM Applications,"
Computer. June 1977, pp.
Applications," Computer,
pp. 92-100.

6.

"Sorting
DPS," Datamation.
1978. pp.
pp. 200-203.
"Sorting 30 Times Faster with
ith DPS,”
Datamation, February 1978,

7.

L. A. Leventhal,
Leventhal. "Cut
Processor's Computation
L.
u t Your Processor's
Computation Time," Electronic Design,
Design,
August
pp. 82-89.
August 16, 1977, pp.

8.

8. Peatman,
Peatman. Microcomputer-Based
1977).
J. B.
Microcomputer-Based Design (New York: McGraw-Hill.
McGraw-Hill, 1977),
Chapter 7.

9-21

Chapter 10
SUBROUTINES
None of the examples
examples thatt we have shown so far is typically
typically a program all by it-­
self. Most
ost real programs perform a series of tasks, many of which
hich may be the
same or may be common to several
programs. We need a way
several different
different programs.
ay to formuformu­
late these tasks once and make the formulations conveniently
conveniently available both in
different
programs.
different parts of the current
current program and in other
other programs.
The standard method is to write
rite subroutines that
that perform parpar­
SUBROUTINE
SUBROUTINE
ticular
LIBRARY
ticular tasks. The resulting sequences of instructions can be
written
ritte n once, tested
tested once, and then used repeatedly.
repeatedly. They
They can
form a subroutine library that
that provides documented
documented solutions to common probprob­
lems.
lems.
SUBROUTINE
SUBROUTINE
Most
o st microprocessors
icroprocessors have special
special in structions
ction s for
transferring control to subroutines and restoring control to
INSTRUCTIONS
INSTRUCTIONS
the main program. We often
often refer to the special
special instruction
instruction
that
that transfers
transfers control
control to a subroutine
subroutine as Call. Jump-to-Subroutine.
Jump-to-Subroutine, Jump
Jump and Mark
Place. or Jump
Place,
Jump and Link. The special
special instruction
instruction that
that restores control
control to the main propro­
gram is usually
usually called Return. On the 6502
6502 microprocessor.
microprocessor, the Jump-to-Subroutine
Jump-to-Subroutine
(JSR) instruction
(JSR)
instruction saves the old value of the Program Counter
Counter in the RAM Stack before
placing
placing the starting
starting address of the subroutine
subroutine into the Program
Program Counter;
Counter; the Return(RTS) instruction
from-Subroutine
-Subroutine (RTS)
instruction gets the old value from the Stack and puts it back in
effect is to transfer
transfer program
program control.
control, first
first to the subroutine
subroutine
the Program Counter. The effect
and then back to the main program.
program. Clearly the subroutine
subroutine may itself
itself transfer
transfer control
control to
on.
a subroutine.
subroutine, and so on.

In order to be really useful, a subroutine must be general. A routine
routine that
that can perform
perform
only a specialized
task. such as looking
specialized task,
looking for a particular
particular letter
letter in an input
input string
string of fixed
length.
other hand,
hand. the subroutine
letlength, will
ill not be very useful. If.
If, on the other
subroutine can look for any let­
ter in strings
strings of any length.
length, it will
ill be far more helpful.
helpful. We
We call the data or addresses
that
"parameters."
that the subroutine allowss to vary "param
eters." An important
portant part of writing
riting
subroutines is deciding
deciding which
hich variables
variables should
should be parameters.
subroutines
PASSING
One problem
problem is transferring
transferring the parameters
parameters to the subroutine;
subroutine; this
process is called passing parameters. The simplest
PARAMETERS
simplest method
method is for
program to place the parameters
parameters into registers. Then the
the main program
subroutine
subroutine can simply
ply assume that
that the parameters
parameters are there. Of course.
course, this technique
technique
may. however.
is limited
limited by the number
number of registers
registers that
that are available. The parameters
parameters may,
however,
be addresses as well
well as data. For example.
example, a sorting
sorting routine
routine could
could begin with
ith Index
Register X containing
locontaining the address on page zero at which
which the length
length of the array is lo­
cated.

6502 microprocessor is limited by the fact
fact that
that it has no address-length
address-length (16The 6502
bitl
such
bit) registers in which
hich to pass address-length
address-length parameters. However,
However, such
parameters
parameters can easily be passed by reserving locations on page zero; these localoca­
tions effective
additional registers. A further
further advantage
advantage of this approach
effectivelyly act as additional
is that
that addresses on page zero can be accessed using the post-indexed
post-indexed (indirect
pre-indexed (indexed
(indexed indirect) addressing modes, as well
e l as the
indexed) and pre-indexed
addressing.
short page-zero
page-zero forms of direct
direct and indexed addressing.

10-1
10

Another
Another approach is to use the Stack. The main program can place the parameters in
the Stack and the subroutine
subroutine can retrieve them. The advantages of this method are that
the Stack is usually fairly large (up to one page)
page) and that data in the Stack is not lost
lost
even if the Stack is used again. The disadvantages
disadvantages are that few 6502 instructions
instructions use
use
Stack. and the Jump-to-Subroutine
the Stack,
p-to-Subroutine instruction
instruction stores the return address at the top
of the Stack.
Stack.
Still another
another approach is to assign an area
area of memory for parameters. The main program
can place the address of the area on page zero and the subroutine
subroutine can retrieve the data
However. this approach is awkward if the
using the post-indexed
post-indexed addressing mode. However,
parameters are themselves
addresses.
themselves addresses.

I

I

Sometimes a subroutine
subroutine must have special characteristics.
characteristics. A
| RELOCATION |
in
subroutine is relocatable
relocatable if it can be placed anywhere
anywhere in
easily. regardless of the placement
memory. You can use such a subroutine
subroutine easily,
placement of other
programs or the arrangement
arrangement of the memory. A strictly relocatable program can use
use
program.
no absolute addresses; all addresses must be relative to the start of the program.
A relocating
relocating loader is necessary to place the program in memory properly; the loader
will
ill start the program after other programs and will
ill add the starting
starting address or reloca­
relocation constant
constant to all addresses in the program.

A subroutine is reentrant
reentrant if it can be interrupted
interrupted and called by
REENTRANT
the interrupting program and still give the correct results for
SUBROUTINE
SUBROUTINE
programs. Reentrancy is
both the interrupting
interrupting and interrupted
interrupted programs.
is
important
portant for standard subroutines
subroutines in an interrupt-based
interrupt-based system. Otherwise
Otherwise the interinter­
rupt service routines
errors.
routines cannot
cannot use the standard subroutines
subroutines w ithout
o u t causing errors.
Microprocessor
reentrant. since the Call instruction
Microprocessor subroutines
subroutines are easy to make reentrant,
instruction uses
uses
1sautom
automatically
the Stack and that procedure is
atically reentrant. The only remaining
remaining requirerequire­
ment is that
that the subroutine
subroutine use the registers and Stack rather than fixed memory loca­
locations for temporary
temporary storage. This is a bit awkward.
awkward, but usually can be done if necessary.
necessary.
A subroutine is recursive if it calls itself. Such a subroutine
subroutine clearly must also be re­
reentrant. However,
However. recursive subroutines
subroutines are uncommon
uncommon in microprocessor
microprocessor applications.
applications.
Most
ost programs consist of a main program and several subroutines. This is advan­
advantageous because you can use proven routines and debug and test
st the other
subroutines separately.
separately. You must, however,
however, be careful to use
use the subroutines pro­
properly and remember
remember their
their exact
exact effects
effects on registers, memory locations,
locations. and flags.
flags.

SUBROUTINE
CUMENTATION
SUBROUTINE D O C U M E
N TA TIO N
Subroutine listings must provide enough information so
so
that
that users need not examine
examine the subroutine's
subroutine's internal
structure. Among
are:
Among the necessary specifications
specifications are:
• A description
description of the purpose of the subroutine
subroutine
• A list of input
input and output
output parameters
• Registers and memory locations
locations used
•- A sample case
If these guidelines
guidelines are followed.
followed, the subroutine
subroutine will be easy to use.
use.

1 0-2

DOCUMENTING
DOCUMENTING
SUBROUTINES
SUBROUTINES

EXAMPLES
It is important
following
area of memory for the
portant to note that the follow
ing examples all reserve an area
Stack. If the monitor
icrocomputer
area, you may use
RAM Stack.
onitor in your m icrocom
puter establishes such an area,
use
area, remember to save
save and
it instead. If you wish to try establishing
establishing your own Stack area,
restore the monitor's
onitor's Stack Pointer in order to produce a proper return at the
\he end of
your main program.
save the monitor
To save
onitor Stack Pointer, use the instruction
instruction sequence
TSX
TSX
STX

TEMP
TEMP

To restore the monitor
onitor Stack Pointer, use the sequence
LOX
LDX
TXS
TXS

TEMP
TEMP

Note that the Stack Pointer can only be loaded or stored via Register X.
X. Remember that
the 6502 always keeps
keeps its Stack on page 1 of memory so that the real
real Stack address is
ss. where ss is the contents
01 ss,
contents of the 8-bitit Stack Pointer register.

Stack. You may have to conWe have used address 01FF16
1 g as the starting
starting point
point for the Stack.
con­
sistently
sistently replace that
that address with
ith one more suitable
suitable for your configuration.
configuration. You should
consult your m icrocom
icrocomputer's
changes.
consult
puter's User's Manual to determine
determine the required changes.
The basic sequence for initializing
initializing the Stack
Stack Pointer
Pointer is
is thus
thus

LOX
LDX
TXS

#$FF
#$FF

;PLACE
PAGE 1
;PLACE STACK AT TOP
TOP OF PAGE

1 0-3

Hex to ASCII
Accumulator
Purpose: Convert
Convert the contents
contents of the Accum
ulator from a hexadecimal
hexadecimal digit
ig it to an
ASCII character.
character. Assume
Assume that
that the original
original contents
contents of the Accum
ulator form
Accumulator
a valid hex digit.
digit.

Sample Problems:
a.
a.
Result:

b.
b.
Result:

oc

(A) =
(A)

0C

(A) =
(A)

43

(A) =
(A)

06

(A) =
(A)

36

ASCII C

ASCII 6

Flowchart:
Flowchart:
Start

(Al= (A)+ASCII A.
ASCII 9 • 1

(A)=(A) + ASCII 0

End

The calling
program starts the Stack at memory
calling program
memory location
location 01 FF,
FF. gets the data from
memory
0040. calls the conversion
memory location
location 0040,
conversion subroutine.
subroutine, and stores the result
result in memory
memory
location
location 0041.
*=00
LOX
LDX
TXS
LDA
LOA
JSR
JSR
STA
BRK
BRK

#$FF

:PLACE STACK AT END OF PAGE
;PLACE
PAGE 1

$40
ASDEC
$41
$41

:GET
GET HEXADECIMAL DATA
;CONVERT DATA
DATA TO ASCII
:STORE
STORE RESULT
RESULT

The subroutine
subroutine converts
converts the hexadecimal
hexadecimal data to ASCII.
ASCII.
ASDEC

ASCZ

*=$200
'= $
CMP
BCC
BCC
ADC
ADC
RTS
RTS

# 100
ASCZ
'A-'9-2
# 'A
-'9 -2
#'0’0

;IS
DIGIT?
:IS DATA A DECIMAL DIGIT?
OFFSET FOR
FOR LETTERS
LETTERS
;NO. ADD OFFSET
:CONVERT TO ASCII BY ADDING ASCII ZERO
;CONVERT

10-4

Documentation:
Subroutine Documentation:
ASDEC
SUBROUTINE ASDEC
:SUBROUTINE
PURPOSE:
CONVERTS A HEXADECIMAL
:PURPOSE: ASDEC CONVERTS
DIGIT IN THE ACCUMULATOR TO AN
: ASCII DIGIT IN THE ACCUMULATOR

HEX DIGIT IN A
;INITIAL CONDITIONS: HEX
CHARACTER IN A
:FINAL CONDITIONS: ASCII CHARACTER
REGISTERS
USED: A
:REGISTERSUSED:

CASE
:SAMPLE CASE
INITIAL CONDITIONS: 6 IN ACCUMULATOR
(HEX 36)
FINAL CONDITIONS:
CONDITIONS: ASCII 6 (HEX
IN ACCUMULATOR

Object Program:
Object
Memory Address
Memory
(Hex)
(Hex)
1)

Calling
Calling program
program
0000
0000
0001
0002
0003
0004
0004
0005
0006
0006
0007
0007
0008
0008
0009
000A
OOOA

2)
2)

Instruction
Instruction
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

A2
FF
FF
9A
A5
40
20
20
00
85
41
00

LDX
LOX

#$FF

TXS
LDA
LOA

$40

JSR
JSR

ASDEC
ASDEC

STA

$41
$41

BRK
BRK

Subroutine
Subroutine

0020
0020
0021
0022
0022
0023
0023
0024
0024
0025
0025
0026
0027
0027
0028
0028

C9
OA
90
02
69
06
69
30
60

ASDEC
ASDEC

ASCZ

CMP

#100

BCC
BCC

ASCZ

ADC

# 'A
-'9 -2
'A-'9-2

ADC

#'O
'0

RTS
RTS

RememThe instructions
instructions LDX
#$FF and TXS start
start the Stack at memory location
location 01FF.
FF. Remem­
LOX #$FF
addresses) and that the 6502 Stack
that the Stack grows
grows downward
downward (toward lower addresses)
ber that
Pointer always
always contains
contains the address on page one of the next empty
empty location
location (rather than
Pointer
filled one as on some other
other microprocessors).
the last filled

10
10-5

The Jump-to-Subroutine
p-to-Subroutine instruction
instruction places the subroutine
subroutine starting
starting address (0020) in
the Program Counter
Counter and saves the old Program Counter
Counter (the address of the last byte of
JSR instruction)
is:
the JSR
instruction) in the Stack. The procedure is:

STEP 1 -— Save MSBs of old Program Counter
Stack. decrement
STEP
Counter in Stack,
decrement Stack Pointer.
STEP 2 -— Save.LSBs
Save,LSBs of old Program Counter in Stack,
Stack. decrement
STEP
decrement Stack Pointer.
Note that the Stack Pointer is decremented
decremented after the data is stored.
The MSBs of the Program Counter
Counter are stored first.
first, but those bits end up at the higher
address (in the usual 6502 fashion) since the Stack is growing
growing down.
The result in the example is:

(01FF)
(01FF) = 00
(01FE)
FE) = 07
(S) =
(S)

FD

The value which
which the Jump-to-Subroutine
p-to-Subroutine instruction
instruction saves is the Program Counter
JSR instruction
before the last byte of the JSR
instruction has been fetched. This value is therefore one
address. The Return-from-Subroutine
(RTS) instruction
less than the proper return address.
Return-from-Subroutine (RTS)
instruction
Stack. adds one (because of the odd 6502 offset
retrieves the top twoo entries from the Stack,
just
is:
just mentioned).
mentioned), and places the result back in the Program Counter. The procedure is:

STEP 1 -— Increment
Stack. place result into LSBs
LSBs of
STEP
Increment Stack Pointer.
Pointer, load eight
eight bits from Stack,
Program Counter.
STEP2 -— Increment
Pointer. load eight
STEP
ent Stack Pointer,
eight bits from Stack, place result into MSBs of
Program Counter.
STEP 3 -— Increment
STEP
Increment Program Counter
Counter before actually
actually fetching
fetching an instruction.
instruction.
loaded.
Here the Stack Pointer is incremented
incremented before the data is loaded.
is:
The result in the example is:
(PC) =
(PC)
=
(S) =
(S)

(00FF)(00FE)+
+1
(00FFM00FE)
0008
FF
FF

This subroutine
Accumulator
subroutine has a single parameter and produces a single result. The Accum
ulator
is the obvious place to put both.
The calling
calling program consists of three steps: placing the data in the Accumulator,
Accumulator, callcall­
ing the subroutine.
subroutine, and storing the result in memory. The overall initialization
initialization must also
place the Stack in the appropriate
appropriate area of memory.
The subroutine
subroutine is reentrant
reentrant since it uses no.data memory; it is relocatable
relocatable since the adad­
dress ASCZ is only used in a Conditional
Conditional Branch instruction
instruction with
ith relative addressing.
Note that the Jump-to-Subroutine
p-to-Subroutine instruction
instruction results in the execution
execution of four or five inin­
structions
structions taking 13 or 14 clock cycles. A subroutine
subroutine call can take a long time even
though it appears to be a single instruction
instruction in the program.
though

parameters. remember
If you plan to use the Stack for passing parameters,
remember that
that Jump-to-Subroutine
Jump-to-Subroutine
saves the return address at the top of the Stack. You can move the Stack Pointer to In­
Indata. but you must remember
dex Register X to get access to the data,
remember to provide the proper
offsets. You can also gain access to the data by using two extra PLA instructions
instructions to
address. but you must then remember
move the Stack Pointer past the return address,
remember to adjust
the Stack Pointer back to its original
original value before returning.
returning.

10-6
10

Length of a String of Characters
Purpose: Determine the length of a string of ASCII
ASCII characters. The starting
Purpose:
starting address of
the string is in memory locations 0040 and 0041. The end of the string is
(CR. 0D-|6).
OD15). Place the length of the
marked by a carriage return character
character (CR.
string (excluding
(excluding carriage return) in the Accumulator.
Accumulator.
Sample Problems:

(0040) =
(0040)
(0041) =
(0041)

a.

(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)
(0048)
(0048)
(0049)
(0049)
Result:
Result:
b.

Result:

43
00

= 52
= 41
= 54
= 48
= 45
= 52
OD
= 0D

(A) =
(A)

06

(0040) =
(0040)
(0041) =
(0041)

43
00

(0043) =

OD
0D

(A) =
(A)

00

starting address of string
starting

'R'
'R'
'A'

·r
T
'H'
H
'E'
'E'
'R'
■R
CR
CR

starting address of string
stai

Flowchart:
Flowchart:
Start

Base =(0040 and
0041)
Index= -1

1ndex= Index + 1

End

10-7

Source Program:

The calling
FF. stores the starting
calling program
program starts
starts the Stack at memory
memory location
location 01 FF,
starting adad­
dress of the string
string in memory
memory locations
locations 0040
0040 and 0041.
0041, calls the string
string length
subroutine.
subroutine, and stores the result
result in memory
memory location
location 0042.
0042, Memory
Memory locations
locations 0040
0040 and
0041 are used as if they were extra registers.
'=00
LDX
LOX
TXS
LDA
LOA
STA
LDA
LOA
STA
JSR
STA
BRK
BRK

#$FF
#$FF

;PLACE STACK AT END OF PAGE
PAGE 1
:PLACE

#$
43
$43
$40
#00
$41
STLEN
STLEN
$42

;SAVE
ADDRESS OF
OF STRING
STRING
.SAVE STARTING ADDRESS

;DETERMINE LENGTH
LENGTH OF STRING
STRING
DETERMINE
;STORE STRING
STRING LENGTH
LENGTH
;STORE

The subroutine
subroutine determines
determines the length
length of the string
string of ASCII characters
characters and places the
length
length in the Accumulator.
Accumulator.
STLEN
STLEN
CHKCR
CHKCR

'=$20
•=
$20
LDY
LOY
LDA
LOA
INY
CMP
BNE
BNE
TYA
RTS
RTS

#$FF
#$FF
#$
0D
#$0D

($40).Y
($40),
CHKCR
CHKCR

; STRING
STRING LENGTH
LENGTH = -1
;GET
CARRIAGE RETURN
RETURN TO COMPARE
COMPARE
GET ASCII CARRIAGE
:ADD 1 TO STRING
STRING LENGTH
LENGTH
;IS NEXT CHARACTER
CHARACTER A CARRIAGE
CARRIAGE RETURN?
RETURN?
;NO.
KEEP LOOKING
LOOKING
NO, KEEP
;SAVE STRING
STRING LENGTH
LENGTH IN ACCUMULATOR
ACCUMULATOR

Documentation:
Subroutine Documentation:
:SUBROUTINE
STLEN
SUBROUTINE STLEN
;PURPOSE:
STLEN DETERMINES
DETERMINES THE LENGTH
LENGTH OF AN ASCII STRING
STRING
PURPOSE: STLEN
; (NUMBER
(NUMBER OF CHARACTERS
CHARACTERS BEFORE
BEFOREA CARRIAGE
CARRIAGE RETURN)
RETURN)
INITIAL CONDITIONS: STARTING ADDRESS
;INITIAL
ADDRESS OF
OF STRING
STRING IN MEMORY
; LOCATIONS 0040
0040 AND 0041

;FINAL CONDITIONS: NUMBER OF CHARACTERS
CHARACTERS IN A
;REGISTERSUSED:
USED: A,
A. Y. ALL FLAGS EXCEPT
EXCEPT OVERFLOW
OVERFLOW
REGISTERS
;MEMORY LOCATIONS USED: 0040
0040. , 0041
;SAMPLE CASE:
CASE:
0043 IN MEMORY LOCATIONS 0040
0040 AND 0041
INITIAL CONDITIONS: 0043
(0043) = =
35.35,
(0044)
= =
46.46,
(0045)
= =
ODOD
(0044)
(0045)
FINAL CONDITIONS: (A)
(A) = 02

10-8
10

Object
Program:
Object Program:

Memory
Memory Address
(Hex)
(Hex)
1)
1)

Calling program
0000
0001
0002
0003
0004
0004
0005
0006
0007
0007
0008
0009
000A
OOOA
0008
000B

oooc
OOOC
0000
000D
00
0E
OOOE
OOOF
000F
0010

2)

Memory Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

A2
FF
FF
9A
A9
43
85
40
A9
00
85
41
20
20
00
85
42
00

LOX
LDX

#$FF

TXS
LOA
LDA

# $43
43

STA
STA

$40

LOA
LDA

#0

STA
STA

$41
$41

JSR
JSR

STLEN
STLEN

STA

$42

BRK
BRK

Subroutine
Subroutine

0020
0021
0022
0023
0024
0025
0026
0027
0028
0029
002A

AO
FF
FF
A9
OD
OD
CB
C8
01
D1
40
DO
DO
FB
98
60

STLEN
STLEN

CHKCR
CHKCR

LDY
LOY

#$FF

LDA
LOA

# $00
0D

INY
INY
CMP
CMP

($40).Y
($40),

BNE
BNE

CHKCR
CHKCR

TYA
RTS
RTS

Pointer. placing the
The calling program consists of four steps: initializing
initializing the Stack Pointer,
starting
starting address of the string
string in memory locations 0040 and 0041.
0041, calling the
subroutine.
subroutine, and storing the result.
addresses 0040 and 0041.
The subroutine
subroutine is not reentrant.
reentrant, since it uses fixed memory addresses
However. if these locations are considered as extra registers and their contents
auHowever,
contents are au­
tomatically
atically saved and restored with
ith the user registers,
subroutine can be used
registers. the subroutine
used in a
reentrant
sizes use registers that are actually
reentrant manner. Many computers
computers of all sizes
actually located in
management more complex but does not
memory; this approach makes memory management
change the basic procedures.
The subroutine
subroutine changes Index Register Y as well
well as the Accumulator.
ulator. The programmer
lost: the subroutine
must be aware that data stored in Index Register Y will be lost;
subroutine docudocu­
used.
mentation
entation must describe what
hat registers are used.

10-9
10

One way to preserve register contents
contents during
during a subroutine
subroutine is to save them in the Stack
and then restore them before returning.
returning. This approach makes life easier for the user of
Stack). To save
the routine.
routine, but costs extra time and memory (in the program
program and in the Stack).
and restore Index Register Y, you would
would have to add the sequence

TYA
PHA

:SAVE OLD
OLD CONTENTS
CONTENTSOF
OF YY
;SAVE

to the beginning
beginning of the program and
PLA
TAY

;RESTOREOLD
OLD CONTENTS
CONTENTSOF
OFYY
;RESTORE

to the end of the program.

This subroutine
single input
input parameter,
parameter. which
which is
isananaddress.
address.The
The
easiest way to
subroutinehas aa single
easiest
to
pass this
twoo memory
pagezero.
zero.The
The 6502
pass
this parameter
parameter is through
through tw
memory locations
locations on page
6502 has no
no
address-length
passed.
address-length registers in which
which this parameter could be passed.
ASCII carriage return.
If the terminating
inating character
character were not always an ASCII
return, we could make
that character
character into another
another parameter. Now the calling
calling program would
would have to place
Accumulator
the terminating
inating character
character in the Accum
ulator and the starting
starting address of the string in
memory locations
locations 0040
0040 and 0041 before calling
calling the subroutine.
subroutine.
One way to pass parameters that are fixed for a particular
particular call is to place their
their values in
program memory
memory immediately
mediately after the Jump-to-Subroutine
p-to-Subroutine instruction.1
instruction.^ You can use
(saved at the top of the Stack) to access the data.
the old Program Counter
Counter (saved
data, but you
must adjust
parameters)
adjust the return address (increase it by the number
number of bytes used for parameters)
pass the
before transferring
transferring control
control back to the main program. For example.
example, we could pass
value of the terminating
inating character
character this way. The main program would
ould contain
contain the
pseudo-operation
.BYTE'. immediately
JSR instruction.
pseudo-operation .BYTE',
immediately after the JSR
instruction. The subroutine
subroutine could
place the return address in memory
memory locations 0050
0050 and 0051 and access the various
parameters using post-indexing.
address,
post-indexing. The following
following sequence could save the return address,
remembering
remembering that
that the Stack is always on page 1 of memory and that the Stack Pointer
always contains
contains the address of the next available location.
TSX
LDA
STA
LDA
STA

$0101,X
$0101,X
$50
$50
$0102,X
$0102,X
$51
$51

:GET STACK
STACK POINTER
POINTER
;GET
;GET
RETURN ADDRESS
;GET MSB'S OF RETURN
ADDRESS
;GET
OFRETURN
RETURN
ADDRESS
;GET LSB'SOF
ADDRESS

Be careful of the fact that
that the return address is actually
actually the address of the last (third)
JSR instruction,
JSR instruction
byte of the JSR
instruction, not the address immediately
immediately after the JSR
instruction as it
1.
is on most other microprocessors. The actual return address must also be offset by 1,
since RTS
RTS will
automatically
ill autom
atically add 1 to it.

Accumulator
Stack) and PLA (Load
(Load Accum
Accumulator
The instructions
instructions PHA (Store Accum
ulator in Stack)
ulator from
Accumulator
Stack) transfer eight
eight bits of data between the Accum
ulator and the RAM Stack. Index
Registers X and Y can only be saved and restored via the Accum
ulator. As in the JumpJumpAccumulator.
to-Subroutine
to-Subroutine instruction,
instruction, the Stack Pointer is decremented
decremented after data is stored in the
Stack and incremented
incremented before data is loaded from it. Remember that the RAM Stack
grows downward
addresses).
downward (to lower addresses).

1 0-10
10

M axim
u m Value
aximum
Purpose:
element in a block of unsigned
unsigned binary
binary numbers. The length
Purpose: Find the largest element
starting address of the block is in
of the block is in Index Register Y and the starting
0040 and 0041. The maximum
aximum value is returned in the AcAc­
memory locations 0040
cumulator.

Sample Problem:
(Y) = 05
(0040)
(0040) = 43
(0041) = 00
(0041)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)
(0046)
(0046)
(0047)
(0047)
Result:
(A)
(Al
Result:

length of block
length
starting address of block
starting

67
= 79
= 15
= E3
E3
= 72
= E3,
E3. since this is the largest of five unsigned numbers

Flowchart:

(

StartT ~ )
Z

Base
4 and
and
10040
Base = (0 0
0 041)
1)
Index
Index== (Y)
Max
Max== 0

Index :z: Index -1

Max = (Base + Index)

End

1011
10-11

Program:
Source Program:
The calling
calling program
program starts the Stack at memory
memory location
location 01 FF,
starting address
FF. sets the starting
of the block to 0043.
0043, gets the block length
length from memory
memory location
location 0030.
0030, calls the max­
maximum subroutine.
subroutine, and stores the maximum
aximum in memory location
location 0042.
*=00
LDX
LOX
TXS
LOA
LDA
STA
LDA
LOA
STA
LDY
LOY
JSR
JSR
STA
BRK
BRK

#$FF

:PLACE STACK AT END
;PLACE
END OF
OF PAGE
PAGE 1

# $43
43
$40
#00
$41
$30
MAXM
MAXM
$42

STARTING ADDRESS
ADDRESS OF
OF BLOCK
BLOCK
;SAVE STARTING

:GET LENGTH
:GET
LENGTH OF
OF BLOCK
BLOCK
:FIND MAXIMUM
;FIND
MAXIMUM VALUE
;SAVE MAXIMUM
:SAVE
MAXIMUM VALUE

The subroutine
subroutine determines
determines the maximum
aximum value in the block.

MAXM
CMPE
CMPE

NOCHG
NOCHG

*=$20
$20
LDA
LOA
DEY
DEY
PHP
PHP
CMP
CMP
BCS
BCS
LOA
LDA
PLP
PLP
BNE
BNE
RTS
RTS

#0

($40).Y
($40),Y
NOCHG
NOCHG
($40).Y
($40),Y
CMPE
CMPE

:MAXIMUM=
ZERO (MINIMUM POSSIBLE
POSSIBLE VALUE)
M
AXIMUM = ZERO
VALUE)
:DECREMENT
DECREMENT INDEX
INDEX
:SAVE STATUS
STATUS
;IS NEXT
NEXT ELEMENT
ELEMENT ABOVE MAXIMUM?
MAXIMUM?
NO, KEEP
MAXIMUM
:NO.
KEEP MAXIMUM
:YES.
REPLACE MAXIMUM
ELEMENT
YES, REPLACE
MAXIMUM WITH ELEMENT
:RESTORE
RESTORESTATUS
TUS
:CONTINUE
ELEMENTS EXAMINED
CONTINUE UNTIL ALL ELEMENTS

Subroutine Documentation:
Documentation:
SUBROUTINE
MAXM
:SUBROUTINE MAXM

:PURPOSE MAXM
DETERMINES THE
THE MAXIMUM
BLOCK
iPURPOSE:
MAXM DETERMINES
MAXIMUM VALUE IN A BLOCK
UNSIGNED BINARY NUMBERS
NUMBERS
;: OF UNSIGNED
CONDITIONS: STARTING
STARTING ADDRESS
ADDRESS OF
OF BLOCK
:INITIAL CONDITIONS:
BLOCK IN MEMORY
MEMORY
LOCATIONS 0040
LENGTH OF
OF BLOCK
: LOCATIONS
0040 AND 0041.
0041, LENGTH
BLOCK IN Y
;FINAL CONDITIONS: MAXIMUM
:FINAL
MAXIMUM VALUE IN A
:REGISTERSUSED:
USED: A,
A. Y,
Y. ALL FLAGS
FLAGS EXCEPT
EXCEPT OVERFLOW
OVERFLOW
REGISTERS
:MEMORY LOCATIONS
LOCATION·s USED:
USED: 0040, 0041
;MEMORY
:SAMPLE CASE:
CASE:
MEMORY LOCATIONS
: INITIAL CONDITIONS
CONDITIONS: 0043 IN MEMORY
LOCATIONS 0040 AND 0041
(Y) = 03,
03. (0043) = 35,
35. (0044) = 46. (0045) = 0D
OD
;
(Y)
(A) = 446
: FINAL CONDITIONS: (A)
6
This subroutine
subroutine has two parameters
parameters -— an address and a number. Memory
Memory locations
locations
0040 and 0041 are used to pass the address,
address. and Index Register Y is used to pass the
number. The result is a single number
number that
that is returned
returned in the Accumulator.
Accumulator.
The calling
calling program must place the starting
starting address of the block in memory locations
0040 and 0041 and the length
length of the block in Index Register Y before transferring
transferring concon­
trol to the subroutine.
subroutine.

10-122
10

1 1
UT

765432 4

HE

2

1 0 ^

--------Bit No.

| Z |C | ^

1B I C

Processor Status

A

*

.._
I-" ___
'-----...................

Carry

Zero
Result
Zero Result
Disable
■ Interrupt Disable

.._ -------------------------Decimal
_____
DecimalMode
Mode
'--------

Break Command
— Break

.._-------(Not
used)
------------------------- (Not used)
.._ ________------------------------- Overflow
Overflow
'----------Negative------------------------- Negative Result
Result (Sign)
(Sign)

Figure 10-1. The 6502
6502 Status
Status Register
The subroutine
subroutine returns
returns control
control with
ith zero in Index Register Y. It is not reentrant
reentrant unless
memory locations
locations 0040
0040 and 0041 are treated as extra registers. It is relocatable
relocatable since
the addresses are relative
temporary storage.
relative and the Stack is used for temporary

Note the use of the instructions
PHP and PLP
PLP which
instructions PHP
hich save and restore the Status
register. This register
register is organized as shown
shown in Figure 10-1. We could reorganize the
program and change
initial conditions
change the initial
conditions so as to eliminate
inate the need for these instrucinstruc­
tions (see
(see Chapter
5). The key here would
Chapter 5).
would be to provide
provide the address one before the start
of the array as a parameter. This is easy to do with
ith most assemblers since they allow
allow
simple
arithmetic
(see Chapter
3).
simple arithm
etic expressions
expressions (such as START-1) in the operand field (see
Chapter 3).
However.
necessary.
However, the user of the subroutine
subroutine must be warned
warned that this offset is necessary.

10-13
10-

Object
Program:
Object Program:

Memory
Address
M
emory Address
(Hex)
(Hex)

MemoryContents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

1) Calling
CallingProgram
Program
1)
0000
0001
0001
0002
0002
0003
0004
0005
0005
0006
0007
0007
0008
0009
OOOA
000A
0008
000B
OOOC
000D
000D
OOOE
000E
OOOF
0 00F
0010
0011
0011
0012
0012

oooc

A2
A2
FF
FF
9A
A9
A9
43
85
40
A9
A9
00
85
41
41
A4
30
20
20
00
85
42
00

LOX
LDX

#$FF
#$FF

TXS
TXS
LDA
LOA

# $43

STA
STA

$40

LOA
LDA

#0

STA
STA

$41
$41

LOY
LDY

$30

JSR
JSR

MAXM
MAXM

STA
STA

$42

8RK
BRK

2) Subroutine
Subroutine
2)
0020
0020
0021
0021
0022
0022
0023
0024
0025
0026
0026
0027
0027
0028
0029
0029
002A
002B
0028
002C
002C
002D
002D

A9
A9
00
88
08
D1
D1
40
BO
80
02
B1
81
40
28
DO
DO
F5
F5
60

1010-14

MAXM LDA
LOA
MAXM

#0

DEY
DEY
PHP
PHP
CMP
CMP

($40).Y
($40),
Y

BCS
8CS

NOCHG
NOCHG

LDA
LOA

($40),Y
($40).Y

PLP
NOCHG
NOCHG PLP
BNE
BNE

CMPE
CMPE

CMPE
CMPE

RTS
RTS

Pattern M atch
tc h 2
2
ASCII characters to see
see if they are the same.
same. The
Purpose: Compare two strings of ASCII
length
Y. The starting
length of the strings is in Index Register Y.
starting address of one string
is in memory locations 0042 and 0043; the starting
starting address of the other is in
memory locations 0044 and 0045. If the two strings match, clear the AcAc­
cumulator;
Accumulator
FF15.
cumulator; otherwise, set the Accum
ulator to FF 1
q.
Sample Problems:
(Y) =
(Y)

a.
a.

(0042)
(0043)
(0043)

(0044)
(0044)
(0045)
(0045)

Result:
b.
b.

03

length of strings

#1
6~}
starting address of string #2
6~}starting
46>

q q J starting
starting address of string

(0046) = 43
(0047) = 41
(0048) = 54

·c·
'C'
'A'
T

(0050) =
(0051) =
(0051)
(0052) =

'C'
'A'
'T
T

43
41
54

(A) =
(A)

are the same
same
00, since the strings are

(Y) =
(Y)

03

length of strings

6~}
(0044)
6~}starting address of string #2
(0045) = S } startin9 addreSS of Strin9 # 2

(0042) =
(0043) =

Result:

46
| starting
starting address of string #1
00

(0046)
(0047)
(0048)

= 52
52 'R'
-R'
= 41
41 'A'
’A'
= 54
54 T
T

(0050)
(0051)
(0052)

= 43
43 'C'
‘C
= 41
41 'A'
'T
= 54
54 T

(A) =
(A)

FF, since the first characters differ
FF,

10-15
10
-15

Flowchart:
Start

Basel =
(0042 and 0043)
Base2 =
(0044 and 0045)
Index - (YI
Mark - FF

Index = Index -1

Mark= Zero

End

10-16

Program:
Source Program:
FF, sets the two starting
adThe calling
calling program
program starts the Stack at memory
memory location
location 01 FF,
starting ad­
dresses to 0046
0046 and 0050
0050 respectively.
respectively, gets the string
string length
length from memory
memory location
location
0041.
0041, calls the pattern
pattern match
match subroutine.
subroutine, and places the resultIt in memory
memory location
location
0040.
•=O
*=
0
LDX
TXS
LDA
STA
LDA
STA
LDA
STA
LDA
STA
LDY
JSR
STA
BRK
BRK

#$FF

END OF PAGE
PAGE 1
;PLACE STACK AT END

# $46
46
$42
#00
$43
# $50
50
$44
#0
$45
$41
PMTCH
$40

;SAVE STARTING
STARTING ADDRESS
ADDRESS OF STRING
STRING 1

;SAVE STARTING
ADDRESS OF STRING
STRING 2
STARTING ADDRESS

;GET
LENGTH OF
OF STRINGS
STRINGS
GET LENGTH
;CHECK
FOR MATCH
CHECK FOR
;SAVE MATCH INDICATOR

The subroutine
subroutine determines
same.
determines if the two strings
strings are the same.
PMTCH
CMPE
CMPE

DONE
DONE

·=$20
*=
$20
LDX
DEY
DEY
LDA
CMP
BNE
BNE
TYA
BNE
BNE
LDX
TXA
RTS
RTS

#$FF

:MARK== FF
FF (HEX)
(HEX) FOR
FOR NO MATCH
;MARK

($42).Y
($42),
($44).Y
($44),Y
DONE
DONE

;GET CHARACTER
FROM STRING
;GET
CHARACTER FROM
STRING 1
THERE A MATCH WITH STRING
STRING 2?
;IS THERE
;NO, DONE —
DONE-STRINGS
;NO.
STRINGS DO NOT MATCH
;RESTORESTATUS FROM
FROM INDEX
INDEX
;RESTORE

CMPE
CMPE
#00

ZERO. STRINGS
STRINGS MATCH
;MARK== ZERO.

1 0 -17
7

Subroutine Documentation:

;SUBROUTINE
SUBROUTINE PMTCH
;PURPOSE
DETERMINES IF TWO STRINGS
PURPOSE: PMTCH DETERMINES
STRINGS MATCH
;INITIAL CONDITIONS: STARTING
STARTING ADDRESSES
ADDRESSES OF STRINGS
STRINGS
; IN MEMORY LOCATIONS 0042
0042 AND 0043.
0043, 0044
0044 AND 0045
; LENGTH
LENGTH OF STRINGS
STRINGS IN INDEX REGISTER
REGISTERY
;FINAL CONDITIONS: ZERO
ZERO IN A IF STRINGS
STRINGS MATCH.
; FF
FF IN A OTHERWISE
OTHERWISE
.REGISTERSUSED:
USED: A,
A. X,
X. Y,
Y. ALL FLAGS EXCEPT
REGISTERS
EXCEPT OVERFLOW
;MEMORY LOCATIONS USED:
0042, 0043.
0043, 0044,
0044, 0045
0045
USED: 0042.
;SAMPLE CASE:
CASE:
INITIAL CONDITIONS: 0046
0046 IN 0042 AND 0043.
0043, 0050
0050
IN 0044
0044 AND 0045.
(Y) = 02
0045, (Y)
(0046) == 36,
36. (0047)
(0047) == 39
39
(0051)
(0050) = 36,
=36,
(0051)
=39
= 39
(A)== 0 SINCE
SINCE THE STRINGS
FINAL CONDITIONS: (A)
STRINGS MATCH

10-188
10

Object Program:
Object
Program:

Memory Address
Address
Memory
(Hex)
(Hex)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

1) Calling
Calling program
program
1)
0000
0001
0001
0002
0003
0004
0005
0006
0007
0008
0009
O00A
000A
0008
000B
OOOC
000D
000E
000E
000F
000F
0010
0011
0011
0012
0013
0014
0015
0016
0017
0018
0019
001A

oooc

2)
2)

A2
A2
FF
FF
9A
A9
A9
46
85
42
A9
A9
00
85
43
A9
A9
50
85
44
A9
A9
00
85
45
A4
41
41
20
20
00
85
40
00

LDX
LDX

#$FF

TXS
TXS
LDA
LDA

# $46

STA
STA

$42

LDA
LDA

#0

STA
STA

$43

LDA
LDA

# $50

STA
STA

$44

LDA
LDA

#0

STA
STA

$45

LDY
LDY

$41
$41

JSR
JSR

PMTCH
PMTCH

STA
STA

$40

BRK
BRK

Subroutine
Subroutine
0020
0021
0021
0022
0023
0024
0025
0026
0027
0028
0029
002A
002B
002C
002D
002E
002E
002F
002F

A2
A2
FF
FF
88
B1
B1
42
D1
D1
44
DO
DO
05
98
DO
DO
F6
F6
A2
A2
00
BA
8A
60

10
10-199

PMTCH
PMTCH LDX
LDX

CMPE
CMPE

DONE
DONE

#$FF

DEY
DEY
LDA
LDA

($42),Y
($42),Y

CMP
CMP

($44),Y
($44),Y

BNE
BNE

DONE
DONE

TYA
TYA
BNE
BNE

CMPE
CMPE

LDX
LDX

#0

TXA
TXA
RTS
RTS

ones. changes all the flags except Overflow. You
This subroutine.
subroutine, like the preceding
preceding ones,
should generally
generally assume that
that a subroutine
subroutine call changes the flags unless it is specifically
specifically
stated otherwise. If the main program needs the old flag values (for later checking), it
must save them in the Stack before calling
calling the subroutine.
subroutine. This is accomplished
accomplished with
PHP instruction.
the PHP
instruction.
ariu rour memory locations on page zero.
zero. There are
This subroutine
subroutine uses all the registers anu
three parameters -— twoo starting
starting addresses and the length of the strings.
The instruction
instruction TYA has no purpose other than to set the Zero flag according to the
contents
need for that instruction
contents of Index Register Y. We could eliminate
inate the need
instruction by
reorganizing
reorganizing the subroutine.
subroutine. One alternative
alternative would be to change the parameters so that
is. both string addresses
the addresses were both offset by 1 (that is,
would actually
actually refer
addresses would
Remember. however,
however. that the
to the byte immediately
immediately preceding
preceding the character
character string). Remember,
user should be able to supply
supply parameters to the subroutine
subroutine in the simplest
simplest and most ob­
obvious form possible. The user should not have to offset addresses
addresses by one or make other
adjustments
adjustments for the convenience
convenience of the subroutine:
subroutine; such practices result in numerous,
numerous.
annoying programming
errors. The program should make such rote adjustments
programming errors.
adjustments unless
time or memory
memory constraints
constraints are critical.
Another
nother alternative
alternative would
would be to decrement
decrement the index by 1 initially
initially to avoid the problem
of accessing beyond the end of the string. The end of the loop would
would then decrement
decrement
the index and branch back as long as the result was positive, i.e
i.e.,..
DEY
DEY
BPL
BPL

CMPE
CMPE

This approach
less than 130 bytes long.
approach would
would work as long as the string was less
long. The
limitation
itation occurs because the 6502 Sign flag is set if the result is an unsigned number
greater than 127 (decimal).
(decimal).

10-20
10-20

Multiple-Precision
uitiple-Precision Addition
Purpose: Add two multiple-byte
Purpose:
ultiple-byte binary numbers. The length of the numbers (in bytes)
bytes)
is in Index Register Y, the starting
starting addresses of the numbers are in memory
locations 0042 and 0043
0043 and in 0044
0044 and 0045,
0045. and the starting
starting address of
the result is in memory locations 0046
0046 and 0047. All the numbers begin with
the most significant
significant bits.
Sample Problem:
(Y) =
(Y)

04

length of numbers in bytes

6~}
(0044)
6g}starting address of second number
(0045) =
(0042)
(0042)
(0043)
(0043)

=

(0044)
(0045)

48)
starting
starting address of first nun
number
0 0)
4C)
starting address of second
001

starting
starting address of result
= 0~g}
01
(0048)
(0048) = 2F MSBs of first number
number

Result:

(0046)
(0047)
(0047)

50)

(0049) =
(004A) =
(004B) =
(004B)

5B
A7
C3

LSBs of first number
LSBs

(004C)
(004C)
(004D)
(004D)
(004E)
(004E)
(004F)
(004F)

=
=
=
=

14 MSBs of second number
number
DF
35
LSBs of second number
B8 LSBs

(0050)
(0051)
(0052)
(0052)
(0053)
(0053)

=
=
=

44 MSBs of result
3A
DD
7B LSBs
LSBs of result

that is.
is.

2F5BA7C3
+
+ 14DF35B8

=

443ADD7B
443ADD7B

10-21

Flowchart:
Start

Index= IYI
Basel =
10042 end 00431
Base2 =

(0044 and 00451
Bese3 =
(0046 and 004 71
Carry= 0

Index = Index - 1

(Base3+Indexl =
(Basel +Index) +
(Base2+Indexl +
(Carry)

End

10-22
10-22

This step also produces new Carry

Program:
Source Program:
The calling
calling program
program starts the Stack at memory
memory location
location 01 FF,
starting adad­
FF, sets the starting
dresses of the various
various numbers
numbers to 0048, 004C, and 0050,
0050, respectively,
respectively, gets the length
length
of the numbers
numbers from memory
memory location
location 0040,
0040, and calls the multiple-precision
ultiple-precision addition
addition
subroutine.
subroutine.
*=00
LDX
LOX
TXS
LOA
LDA
STA
LOA
LDA
STA
LOA
LDA
STA
LOA
LDA
STA
STA
STA
LOY
LDY
JSR
JSR
BRK
BRK

#$FF

:PLACE STACK AT END OF PAGE
;PLACE
PAGE 1

# $48
48
$42
#$4C
#$4C
$44
# $50
50
$46
#00
$43
$45
$47
$40
MPADD

:SAVE STARTING
STARTING ADDRESS
ADDRESS OF FIRST
FIRST NUMBER
NUMBER
OF SECOND
SECOND NUMBER
NUMBER
:SAVE STARTING ADDRESS OF
;SAVE STARTING
STARTING ADDRESS OF
OF RESULT
RESULT
:SAVE PAGE
PAGE NUMBER
NUMBER FOR
FOR ALL ADDRESSES
ADDRESSES
;SAVE

:GET LENGTH
LENGTH OF NUMBERS
NUMBERS IN BYTES
BYTES
;GET
;MULTIPLE-PRECISION ADDITION
;MULTIPLE-PRECISION

The subroutine
subroutine performs
performs multiple-precision
ultiple-precision binary
binary addition.
addition.

MPADD
ADDB

*=$20
*=$20
CLC
CLC
DEY
DEY
LOA
LDA
ADC
STA
TYA
BNE
BNE
RTS
RTS

:;CLEAR
CLEAR CARRY TO START

($42).Y
($42),Y
($44).Y
($44),
($46).Y
($46),
ADDB

;GET BYTE
BYTE FROM
FROM FIRST
FIRST NUMBER
;GET
NUMBER
BYTE FROM
FROM SECOND
SECOND NUMBER
:ADD BYTE
NUMBER
;STORE RESULT
RESULT
;STORE
:ALL BYTES
;ALL
BYTES ADDED?
;NO. CONTINUE
:NO.
CONTINUE

Subroutine Documentation:
Documentation:
;SUBROUTINE
SUBROUTINE MPADD
:PURPOSE: MPADD ADDS TWO MULTI-BYTE
Tl-BYTE BINARY NUMBERS
PURPOSE:
NUMBERS
:INITIAL CONDITIONS: STARTING ADDRESSES
ADDRESSES OF NUMBERS
NUMBERS (MSB'S)
(MSB'S)
, IN MEMORY LOCATIONS 0042
0042 AND 0043,
0043, 0044
0044 AND 0045
0045
; STARTING
STARTING ADDRESS
ADDRESS OF RESULT
RESULT IN MEMORY LOCATIONS 0046
0046 AND 0047
0047
: LENGTH
LENGTH OF NUMBERS
NUMBERS IN INDEX REGISTER
REGISTERY
:REGISTERSUSED:
REGISTERS
USED: A,
A. Y,
Y. ALL FLAGS
FLAGS
;MEMORY LOCATIONS USED:
0042, 0043,
0043, 0044,
0044, 0045,
0045, 0046,
0046, 0047
0047
USED: 0042.
;SAMPLE CASE:
CASE:
INITIAL CONDITIONS: 0048
0048 IN 0042
0042 AND 0043,
004C IN 0044
0044 AND 0045,
0045, 0050
0050 IN 0046
0046 AND 0047,
(Y) = 02, (0048) = A7,
A7. (0049) = C3,
(Y)
C3. (004C) = 35,
35. (004D) = B8
BB
FINAL CONDITIONS: (0050) = DD,
DD. (0051) = 7B

10-23
10-

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)
1)
1)

Instruction
Instruction
(Mnemonic)

Calling program
0000
0001
0002
0003
0004
0005
0006
0007
0008
0009
OOOA
000A
000B
OOOB
oooc
000C
000D
OOOE
000E
OOOF
0
00F
0010
0011
0012
0013
0014
0015
0016
0017
0018
0019
001A
001A
001BB
001C
001C

2)
2)

Memory
Memory Contents
(Hex)
(Hex)

A2
FF
FF
9A
A9
48
85
42
A9
4C
85
44
A9
50
85
46
A9
00
85
43
85
45
85
47
A4
40
20
20
00
00

LOX
LDX

#$FF

TXS
TXS
LOA
LDA

# $48
48

STA

$42

LDA
LOA

#$4C
#$4C

STA

$44

LOA
LDA

# $50
50

STA

$46

LOA
LDA

#00

STA

$43

STA

$45

STA

$47

LOY
LDY

$40

JSR
JSR

MPADD

BRK
BRK

Subroutine
Subroutine
0020
0021
0022
0023
0024
0025
0026
0027
0028
0029
002A
002B

18
88
B1
B1
42
71
71
44
91
91
46
98
DO
DO
F6
60

MPADD
ADDB

CLC
CLC
DEY
DEY
LDA
LOA

($42).Y
($42),Y

ADC

($44).Y
($44),

STA

($46).Y

TYA
BNE
BNE

ADDB

RTS
RTS

This subroutine
subroutine has four parameters -— three addresses and the length
length of the numbers.
Six memory locations on page zero and Index Register Y are used for passing
parameters.
parameters.
As with
ith the previous example, we could eliminate
eliminate the need for the TYA instruction
instruction by
reorganizing the program or by offsetting
offsetting the address parameters by 1.

1 0-24
4

PROBLEMS
Note that
that you are to write
rite both a calling
calling program for the sample problem and a properly
documented
documented subroutine.
subroutine.

1)

ASCII to Hex

Accumulator
Purpose: Convert
Convert the contents
contents of the Accum
ulator from the ASCII
representation of a
ASCII representation
hexadecimal
hexadecimal digit
ig it to the actual digit. Place the result in the Accumulator.
Accumulator.
Sample Problems:
(A)
(A) = 43

a.
a.
Result:

b.
Result:

2)
2)

(A) =
(A)

ASCII C
ASCII

0C
oc

(A) =
(A)

36

(A) =
(A)

06

ASCII 6
ASCII

typewriter
Length of a T ele ty p
e w rite r Message

Purpose: Determine
Purpose:
Determine the length
length of an ASCII-coded teletypewriter
teletypewriter message.
start­
message. The starting address of the string of characters
characters in which
hich the message is embedded
embedded is
in memory locations
locations 0042
0042 and 0043. The message itself starts with
ith an ASCII
ASCII
(0215) and ends with
ETX (03151.
STX character
character (02-|g)
ith ASCII ETX
1 6>- Place the length of
the message (the number
number of characters
characters between the STX and the ETX)
ETXI in the
Accumulator.
Accumulator.
Sample Problem:
(00421
(0042)
(00431
(0043)
(0044)
(00451
(0045)
(00461
(0046)
(0047)
(00481
(0048)
Result:

3)

|} starting
starting address of string
~~
00

44

=
=
=
=
=
=
=

49
02
47
4F
03

(Al =
(A)

02

STX
'G'
'O'
’O'
ETX
ETX

M inimum Value

Purpose: Find the smallest element
element in a block of unsigned
unsigned binary numbers. The length
of the block is in Index Register Y and the starting
starting address of the block is in
memory locations
locations 0040
0040 and 0041. The minimum
inimum value is returned in the AcAc­
cumulator.
cumulator.
Sample Problem:
(Y)
(YI =

05

length of block

(0040) _ 43
starting address of block
~~}^ starting
(0041)
(00411 = 0 0 !
(0043)
(00431
(0044)
(0045)
(0046)
(0047)

Result:

=
=
=
=
=

(A)
(A) =

67
79
15
E3
E3
73
15, since this is the smallest
smallest of the five
unsigned numbers

1 0-25
25

4)

String Comparison

which
(i.e.. which
larger (i.e..
is larger
which
Purpose: Compare
strings of ASCII characters
s to see w
hich is
Compare two strings
Purpose
the strings
of the
follows the
"alphabetical"
strings is
is in
in
tical" ordering). The length of
the other in "alphabe
follows
0042
locations
memory
string
Index
Register
Y.
the
starting
address
of
1
is
in
locations
0042
starting
Y,
Index Register
and
locations 0044
0044
starting address of string 2 is in memory locations
and the starting
0043, and
and 0043,
and
0045. If
string 1 is larger than or equal to string 2.
2, clear the
the Accumula
Accum ula­
If string
and 0045.
FF15.
tor to FF-|g.
ccumula
tor; otherwise, set the A ccum
ulator
Sample Problems:
a.

Result:
Result:
b.

Result:
Result:
C.

(Y)
(Y)

03

(0042)
(0042)
(0043)
(0043)

46

(0044)
(0044)
(0045)

4A

(0046)
(0046)
(0047)
(0047)
(0048)
(0048)

43
41
54

(004A)
(0048)
(004B)
(004C)
(004C)

42
41
41
54

6~}
j6i}
00

00

| starting
starting address of string
string #1
starting address of string
string #2
starting

'C'
'A'

T
'B'
'A·
'A'

T

(A)
(A)

'BAT'
than 'B
00. since 'CAT'
T is "larger··
"larger" than
T

(Y)
(Y)

03

length of strings

(0042)
(0042)
(0043)
(0043) =

46 i
J- starting
starting address of string #1
00

(0044)
(0044)
(0045)
(0045)

6~}
6i}
00

4A[
j- starting
starting address of string #2

(0046)
(0046)
(0047)
(0047)
(0048)
(0048)

43
41
41
54

·c·
JC
'A'
T

(004A)
(0048)
(004B)
(004C)
(004C)

43
41
54

'C'
'C'
'A'

T

(A)
(A)

same
00
strings are the same
00,, since the two strings

(Y)
(Y)

03

length of strings

(0044)
(0044)
(0045)
(0045)

6~}
6i}

(0046)
(0047)
(0047)
(0048)
(0048)

43
41
41
54

(004A)
(0048)
(004B)
(004C)
(004C)

43
55
54

(0042)
(0042)
(0043)
(0043)

Result:
Result:

length of strings
strings

(A)
(A)

46

00

4A

00

| starting
starting address of string #1
^ starting
starting address of string #2

·c·
'C
'A'
T
'C'
·u·
V

T

"larger" than 'CAT'
FF,
·cur is "larger"
FF, since 'CUT'

10-26
10-

5)

Decimal Subtraction
Subtraction

(BCD) number
Purpose: Subtract
Subtract one multiple-digit
ultiple-digit decimal
decimal (BCD)
number from another. The length
of the numbers (in bytes)
bytes) is in Index Register Y and the starting
addresses of
starting addresses
the numbers are in memory locations 0042 and 0043 and 0044 and 0045.
Subtract
Subtract the number
number with
ith the starting
starting address in 0044 and 0045 from the
one with
ith the starting
starting address in 0042 and 0043. The starting
starting address of the
result is in memory locations 0046 and 0047. All the numbers begin with the
Accumulamost significant
significant digits. The sign of the result is returned in the Accum
ula­
positive. FF-]
FF15
torr -— zero if the result is positive,
q if it is negative.

Sample Problem:
(Y) =
(Y)

04

length of numbers in bytes

6~
}
6g}

(0042)
(0043)
(0043)

= 48 > , t .
..
,
- 00 ) starting
startln9 address
address of
of minuend
minuend

(0044)
(0044)
= 4C )
starting address of subtrahend
(0045)
(0045) - 00 ) start'n9 address of subtrahend

Result:
Result:

(0046)
(0046)
(0047)
(0047)

= 50 »
.
,,
,
- ~~
00 }) starting
startlng address
address of
of difference
difference

(0048)
(0048)
(0049)
(004A)
(0048)
(004B)

= 36
= 70
19
= 19
= 85

most significant
significant digits
digits of minuend
minuend

(004C)
(004C)
(004D)
(004D)
(004E)
(004E)
(004F)
(004F)

12
= 12
= 66
= 34
= 59

most significant
significant digits
digits of subtrahend
subtrahend

(A) =
(A)
(0050)
(0051)
(0052)
(0053)
(0053)

00
= 24
= 03
= 85
= 26

that is,
is.
+
+

least significant
significant digits
digits of minuend
minuend

least significant
significant digits
digits of subtrahend
subtrahend
positive resultIt

most significant
significant digits
digits of difference
difference

least significant
significant digits
digits of difference
difference

36701985
36701985
12663459
12663459
24038526
24038526

10-27
10-

REFERENCES
REFERENCES
1.
1.

Other examples of this technique
technique (for the 8080 microprocessor) are in S.
S. Mazor and
C. Pitchford.
C.
Pitchford. "Develop
"Develop Cooperative
Cooperative Microprocessor
Microprocessor Subroutines,"
Subroutines," Electronic
7, 1978, pp. 116-118.
Design, June 7,

2.
2.

T. O'Donnell.
J. T.
O'Donnell, "6502
"6502 Routine Compares Character Strings,"
Strings," rnH,
EDN, August
ugust 5,
5. 1978,
1978.
p. 54.

10-28

Chapter 11
Chapter
INPUT/OUTPUT
INPUT/OUTPUT
There are twoo problems in the design of input/output
input/output sections:
sections: one is how to inin­
terface
terface peripherals to the computer
computer and transfer
transfer data, status, and control sigsig­
1/0 devices
nals; the other
other is how to address I/O
devices so that
that the CPU can select
select a particuparticu­
lar one for a data transfer.
transfer. Clearly.
first problem
problem is both
complex and more in­
inClearly, the first
both more complex
teresting. We
teresting
We will
ill therefore
therefore discuss the interfacing
interfacing of peripherals
peripherals here and leave adad­
dressing
dressing to a more hardware-oriented
hardware-oriented book.
1/0 device
In theory.
theory, the transfer
transfer of data to or from an I/O
device is similar
to the transfer
transfer of data to or from memory. In fact, we can concon­
1/0 device. The memory
is,
sider the memory
memory as just
st another
another I/O
memory is,
however.
however, special for the following
ing reasons:

1/0 AND
I/O
AND
MEMORY
MEMORY

1)
2)

It operates
operates at almost
almost the same speed as the processor.
It uses the same type of signals as the CPU. The only circuits usually needed
to interface
interface the memory
memory to the CPU are drivers, receivers,
receivers, and level
level translatransla­
tors.
3) It requires no special formats
formats or any control signals besides a Read/Write
Read/Write
pulse.
4) ItIt autom
automatically
latches data
data sent
sent to
to it.it.
atically latches
Its word
word length
length isisthe
the same
same as
as the
the computer's.
computer's.
5) Its
1/0 devices
Most
ost I/O
devices do not have such convenient
convenient features.
features. They
They may operate
operate at
speeds much
much slower
slower than the processor;
processor; for example.
example, a teletypewriter
teletypewriter can transfer
transfer only
10 characters
characters per second.
second, while
hile a slow processor
processor can transfer
transfer 10.000
10,000 characters
characters per
second. The range of speeds is also very wide
wide -— sensors may provide
provide one reading
per minute.
minute, while
hile video
video displays
displays or floppy
floppy disks may transfer
transfer 250,000
250,000 bits per second.
1/0 devices
Furthermore.
Furthermore, I/O
devices may require continuous signals (motors or thermometers!.
thermometers),
currents rather
rather than voltages
voltages (teletypewriters).
(teletypewriters), or voltages
voltages at far different
different levels
1/0 devices
than the signals used by the processor (gas-discharge
(gas-discharge displays). I/O
devices may also
require
require special
special formats.
formats, protocols.
protocols, or control
control signals. Their
Their word
word lengths
lengths may be much
shorter or much
much longer
longer than the word
word length
length of the computer.
computer. These variations
variations make
shorter
sections difficult
ifficu lt and mean that
that each peripheral presents
presents its own
the design of I/O
1/0 sections
interfacing problem.
special interfacing
We may, however,
however, provide a general description
description of devices
devices
and interfacing
interfacing methods. We may roughly separate
separate devices
devices
into three categories,
categories, based on their
their data rates:

I/O
1/0
CATEGORIES

Slow devices
devices that
that change
change state
state no
nomore
more than
than once
once per
per second.
second. Changing
Changing their
their
1) Slow
states typically
typically requires
requires milliseconds
milliseconds or longer. Such devices
devices include
include lighted
lighted disdis­
plays,
switches, relays, and many mechanical
mechanical sensors and actuators.
actuators.
plays. switches.

Medium-speed devices
devices that
that transfer
transfer data
data at
at rates
rates of
of 11to
to 10,000
10,000 bits
bits per
persec­
sec2) Medium-speed
ond. Such devices
devices include
include keyboards.
keyboards, printers.
printers, card readers,
paper tape readers
readers. paper
lines. and many
and punches.
punches, cassettes.
cassettes, ordinary
ordinary communications
communications lines,
many analog
analog data acac­
quisition systems.
quisition

3)

High-speed devices
devices that
that transfer
transfer data at rates of over
over 10,000
10,000 bits per second.
High-speed
Such devices
tapes. magnetic
devices include
include magnetic
agnetic tapes,
magnetic disks.
disks, high-speed
high-speed line printers.
printers,
high-speed comm
unications lines,
video displays.
displays.
high-speed
communications
lines. and video

11-1

The interfacing
interfacing of slow devices
devices is simple. Few
Few control sigsig­
INTERFACING
INTERFACING
nals are necessary unless the devices
devices are multiplexed,
ultiplexed, i.e....
SLOW DEVICES
several are handled from one port.
port, as shown
shown in Figures 11-11 to
11-4. Input data from slow devices need not be latched, since it remains stable for a
course. be latched. The only problems with
long time interval.
interval Output
Output data must, of course,
ith
input
One-shots.
input are transitions
transitions that
that occur
occur while
hile the computer
computer is reading the data. One-shots,
cross-coupled
cross-coupled latches.
latches, or software
software delay routines
routines can smooth the transitions.
transitions.
11-1 shows a demultiplexer
A single port can handle several
several slow devices. Figure 11-1
demultiplexer
that
counting output
output
that automatically
autom atically directs
directs the next output
output data to the next device by counting
operations. Figure 11-2 shows a control
control port that provides
provides select inputs
inputs to a
demultiplexer.
order. but an additional
demultiplexer. The data outputs
outputs here can come in any order,
additional output
output
instruction
instruction is necessary to change the state of the control
control port. Output
utput demultiplexers
demultiplexers
are commonly
commonly used to drive several displays
displays from the same output
output port. Figures 11-3
and 11-4 show the same alternatives
alternatives for an input
input multiplexer.
multiplexer.
Note the differences
differences between
between input
input and output
output with
ith slow devices:

1)I Input
Inputdata
data need
need not
not be
be latched,
latched, since
since the
the input
input device
device holds
holds the
thedata
data for
for an
anenor­
enormous length
length of time by computer
puter standards. Output
utput data must be latched.
latched, since
the output
CPU clock
output device will
ill not respond to data that is present
present for only a few CPU
cycles.
2) Input
Input transitions
transitions cause
cause problems
problems because
because of
oftheir
their duration;
duration; brief
brief output
output tran­
transitions cause no problems because the output devices
devices (or the observers)
react
react slowly.
slowly.
3) The
The major
major constraints
constraints on
oninput
input are
are reaction
reaction tim
time
andresponsiveness,
responsiveness, the
the ma­
mae and
jor constraints on output
output are response time and observability.
observability.

-------

Medium-speed
INTERFACING
Medium-speed devices
devices must be synchronized in some way
way
MEDIUM-SPEED
CPU cannot
MEDIUM-SPEED
to the processor clock. The CPU
cannot simply
simply treat these
devices as if they held their
DEVICES
their data forever
forever or could receive data
at any time. Instead.
CPU must
Instead, the CPU
must be able to determine
determine when
a device has new input
input data or is ready to receive output
output data. It must also have a way
of telling
has
telling a device that new output
output data is available or that the previous input
input data has
processor.
been accepted. Note that
that the peripheral
peripheral may be or contain
contain another
another processor.

I

I

The standard unclocked procedure is the handshake.
handshake. Here the
|HANDSHAK
HANDSHAKEe ]
indicates the availability
availability of data to the receiver and
sender indicates
receptransfers the data:
data; the receiver
receiver completes
completes the handshake by acknowledging
acknowledging the recep­
receiver may control
control the situation
situation by initially
initially requesting
requesting the data or
tion of the data. The receiver
by indicating
indicating its readiness to accept
accept data; the sender then sends the data and comcom­
handshake by indicating
indicating that data is
either case,
pletes the handshake
Is available. In either
case. the sender
knows that
that the transfer
transfer has been completed
completed successfully
successfully and the receiver knows when
new data is available.

11-2
11-2

..

Data Outputs 0

Data Bus

..

.

'

..)

Output

.

Port
Port

.

)

Data

Inputs
Inputs

..)

Data Outputs 1

.

Strobe

Port Selection
Selectionlogic
Port
Logic

£

-

OemultiJ>'exer
Demultiplexer

..

I

Data Outputs 2

.

)

Clock

Select
Select

Counter

-

Inputs
Inputs

..

Data Outputs 3

.

= >)

Counter controls
controls where the Demultiplexer
Demultiplexer sends
The Counter
sends the data.

Figure 11-1. An Output
utput Demultiplexer
ultiplexer Controlled
Controlled by a Counter
Counter

Data Outputs 0

Data

Data

Port
Port

Inputs
Inputs
Data Outputs 1

Data Bus
Demultiplexer
Demultiplexer
Data Outputs 2

i>
Control
Control

Select
Select

Port
Port

Inputs
Inputs

Data Outputs 3

£

sends control
control information
information to the Control
The CPU sends
Control Port;
Port: that port then determines
determines
where the Demultiplexer
Demultiplexer sends
sends the data.
data.

Figure 11
11-2. An Output
Demultiplexer
utput Dem
ultiplexer Controlled
Controlled by a Port

11-3
11

VV,.

.. Data Inputs 0

Data
Bus
ta Bus

c
(

A.

Input

,.

Port

.

c

—

Data

i
IC
" =3
.

I(

l
I

5

Data Inputs 1

.

Enable
Enable
Port Selection
Selection Logic

~
»

~ —

Outputs
Outputs

Multiplexer
Multiplexer

I

Data Inputs 2

1
K
C = 3

Oock

-

Counter

"

Select
Inputs

K==3
..Data Inputs 3

\

' ,.

The Counter controls
controls which input the Multiplexer
Multiplexer gates to the Input Port.

11-3. An Input
Figure 11
Input Multiplexer
ultiplexer Controlled
Controlled by a Counter
Counter

£

Input Data Bus
ln~ut
Bus

c

Data
Data

(

Port
Pon

c"
-

Data Inputs 0

K,. = *

Data

~

Outputs
Outputs

.. Data Inputs l1

/■ -------------- )<.
Multiplexer
Multiplexer

"

.

Data Inputs 22

V

5

.

..._

)

"

Output Data Bus
Output
Bus

Control

Select
Select

Port
Pon

""' Inputs

.

Data Inputs 3

I(

,. = >
IC

The control
control information
information which the CPU
output operation)
CPU sends to the Control Port (with an output
operat10n)
determines which
which input the Multiplexer
Multiplexer routes to the Data Port.
determines

Figure 11-4. An Input
Input Multiplexer
ultiplexer Controlled
Controlled by a Port

11-4
11-4

~

Figures 11-5 and 11-6 show typical
typical input
input and output
output operations
operations using the handshake
method. The procedure whereby
whereby the CPU checks the readiness of the peripheral
Clearly. polling
before transferring data is called "p olling",
g ". Clearly,
polling can occupy
occupy a large
amount
1/0 devices. There are several
amount of processor time if there are many I/O
several ways
ways of
providing the handshake signals.
signals. Among
are:
Among these are:

1/0 lines.
lines. The processor may handle these as
as additional
1/0
• Separate
Separate dedicated
dedicated I/O
additional I/O
ports or through
through special lines or interrupts.
interrupts. The 6502 microprocessor
microprocessor does not have
special serial I/O
1/0 lines,
lines. but such lines are available
available on the 6520 Peripheral Interface
Adapter (or PIA),
PIA). the 6522 Versatile
Versatile Interface
Interface Adapter
Adapter (or VIA),
VIA). and the 6532 Pe­
PeAdapter
ripheral Interface/Mem
Interface/Memory
ory (or Multifunction)
ultifunction) device.
1/0 lines.
lines. These may be single start
• Special patterns
patterns on the I/O
start and stop bits or entire
characters
characters or groups of characters. The patterns
patterns must be easy to distinguish
distinguish from
background
states.
background noise or inactive
inactive states.
We
1/0 line that
We often call a separate I/O
that indicates the availability
availability
of data or the occurrence of a transfer
transfer a "s trobe".
b e ". A strobe
may, for example.
example, clock data into a latch or fetch data from a buffer.

|tsTROBE!
STROBE |

Many peripherals
peripherals transfer
transfer data at regular intervals;
intervals; i.e.,.. synchronously.
synchronously. Here the only
problem
problem is starting
starting the process by lining
lining up to the first input
input or marking the first output.
output.
cases. the peripheral
obIn some cases,
peripheral provides a clock input
input from which
hich the processor can ob­
tain timing
ing information.
information.

Transmission errors are a problem with
ith medium-speed
medium-speed
devices. Several
such
Several methods can lessen the likelihood of such
errors; they include:

REDUCING
TRANSMISSION
TRANSMISSION
ERRORS
ERRORS

• Sampling input data at the center
center of the transmission
interval
is, keep away from the edges where
interval in order to avoid edge effects;
effects; that is,
the data is changing.
changing.
using majority logic such as best three
• Sampling each input several
several times and using
out of five.1
.1
• Generating
Generating and checking parity; an extra bit is used that makes the number
number of 1
bits in the correct
correct data even or odd.
• Using other
other error detecting
detecting and correcting codes such as checksums, LRC
LRC
(longitudinal
check). and CRC
(longitudinal redundancy
redundancy check),
redundancy check).2
CRC (cyclic redundancy
High-speed devices that transfer more than 10,000 bits per
INTERFACING
INTERFACING
second require special methods. The usual technique
technique is to
HIGH-SPEED
construct
construct a special-purpose
special-purpose controller
controller that transfers data
DEVICES
directly
directly between
between the memory and the I/O
1/0 device. This process
DIRECT
(OMA). The DMA
is called direct
direct memory access (DMA).
controller
OMA controller
MEMORY
MEMORY
must force the CPU
CPV off the busses,
busses, provide addresses and concon­
ACCESS
ACCESS
trol signals to the memory, and transfer
transfer the data. Such a concon­
troller
troller will
ill be fairly complex.
complex, typically
typically consisting
consisting of 50 to 100
LSI devices are now available. 3 The CPU
CPU must initially
chips, although
although LSI
initially load the Address
and Data Counters
Counters in the controller
controller so that the controller
controller will
ill know where to start and
how much to transfer.

1 1-5

Input
Acknowled~e
Data

Data Bus

1/0

CPU

Section

"

~

...

Penpheral

Data Ready

a)
al

Peripheral provides
Peripheral
computer I/O
provides data and Data
Data Ready
Ready signal
signal to computer
1/0 section.

Input
Acknowledge
Data Bus

CPU

Data

1/0

'./

Section

"

K'.
...

Peripheral

~ata Ready

bl
b)

CPU reads
reads Data Ready
Ready signal
signal from I/O
1/0 section lthis
CPU
(this may be a hardware interrupt connection).
connect10n).

Input

Acknowledge
Data Bus

CPU

Data
Section

~

-

~

1/0

I(

Peripheral

...
Data Ready

cl
c)

CPU
CPU reads data from I/O
1/0 section.

Input
Acknowledge
Data Bus

CPU

.

Data

1/0

)

Section

-

.

I(

Peripheral
~

Data Ready

-

di
d)

CPU sends
sends Input Acknowledge
signal to I/O
1/0 section,
section. which then
CPU
Acknowledge signal
Acknowledge signal
then provides Input Acknowledge
signal
to Peripheral
Peripheral (this
{this may be a hardware connection).
to

Figure 11-5. An Input Handshake
11-6

Output Ready

.

CPU

--

Data Bus

.

Data

1/0

IC

.)

Section

~

Peripheral

Peripheral Ready

a)

Peripheral provides Peripheral
Peripheral Ready
Ready signal
Peripheral
computer I/O
signal to computer
1/0 section.
sectK>n.

Output Ready
Data Bus

1/0

~

CPU

I(

.

.

Data

Section

Peripheral

PeripheralReady

--

b)

CPU reads Peripheral
Peripheral Ready
Ready signal
signal from I/O
1/0 section (this may be a hardware interrupt connection).
CPU
connec'tion).

Output Ready

Data Bus
CPU

.

1/0

~

Section

Data

--

.

)

Penpheral

Peripheral Ready

-

c)
cl

CPU
CPU sends
sends data to Peripheral.
Peripheral.

Output Ready
Data Bus

CPU

-

.

Data

1/0
Section

.,,

Peripheral Ready

d)
d)

CPU sends Output Ready
Ready signal
signal to Peripheral
CPU
Peripheral (this may be a hardware connection).
connection}.

11-6. An Output
Handshake
Figure 11-6.
utput Handshake
11-7

Peripheral

(DELAYS)
T IMING
IN G INTERVALS (DELAYS)
One problem that we will
ill face throughout
throughout the discussion
discussion of inin­
USES OF
t/output
pu t/ou
tp u t is the generation of timing intervals with
ith specific
TIMING
TIMING
lengths. Such intervals
intervals are necessary to debounce
debounce mechanical
mechanical
INTERVALS
switches
switches (i.e.,.. to smooth their
their irregular
irregular transitions).
transitions), to provide
pulses with
ith specified
specified lengths
lengths and frequencies
frequencies for displays.
displays, and to provide timing
ing for
devices that transfer data regularly
regularly (e.g.
(e.g., a teletypewriter
teletypewriter that sends or receives one bit
ms).
every 9.1 ms).
We can produce timing intervals in several
several ways:

1)
1)

2)

3)

METHODS
FOR
METHODS FOR
PRODUCING
In hardware with
ith one-shots or monostable multivibraultivibra­
TIMING
TIMING
tors. These devices produce
tors.
produce a single pulse of fixed duradura­
INTERVALS___
tion in response to a pulse input.
In a combination of hardware and software
are with a flexx­
ible programmable timer
er such as those that are included
included in the 6522 Versatile
Versatile InIn­
terface Adapter
Adapter (to be described later in this chapter). The 6522 timers can provide
timing
ing intervals
intervals of various lengths
lengths with
ith a variety
variety of starting
starting and ending
ending conditions.
conditions.
In software
are with
ith delay routines. These routines use the processor as a counter.
Is possible since the processor has a stable clock reference,
reference. but it clearly
This use is
underutilizes the processor. However,
However. delay routines require no additional
underutilizes
additional hardhard­
ware and often use processor time that would
would otherwise
otherwise be wasted.

choice among these three methods depends on your ap­
The choice
apCHOOSING
Is inexpensive
plication. The software
software method is
inexpensive but may overover­
A TIMING
TIMING
burden the processor.
processor. The programmable
programmable timers are relatively
relatively ex­
exMETHOD
METHOD
pensive but are easy to interface
interface and may be able to handle many
complex
tasks. The timers that are included
complex timing
ing tasks.
included in the 6522 Versatile
Versatile Interface
Adapter
Adapter and in the 6530 and 6532 Multifunction
ultifunction Devices are available
available at no additional
additional
cost as long as those parts are being used. These parts may be somewhat
somewhat more expenexpen­
sive than simpler
simpler devices, but may be justifiable
justifiable as complete
complete packages.
ith
packages. Such parts with
integral
integral timers are used in many board-level
board-level microcomputers,
microcomputers, including
including the KIM.
KIM, SYM,
VIM, and AIM-65.
VIM.
AIM-65. The use of one-shots
one-shots should be avoided whenever
whenever possible.

11-88
11

ROUTINES
DELAY ROUTINES
A simple
simple delay routine
routine works
works as follows:
follows:

Step 1 - Load a register
register with
ith a specified
specified value.
Step 2 - Decrement
Decrement the register.

BASIC
SOFTWARE
DELAY

zero. repeat Step 2.
Is not zero,
Step 3 - If the result of Step 2 is
depends upon
This routine does nothing except
except use time. The amount
amount of time used depends
execution time of the various
various instructions.
instructions The maximum length of the delay is
the execution
limited by the size of the register; however.
however, the entire
entire routine
routine can be placed inside a
on.
similar routine
routine that
that uses another
another register.
register, and so on.
similar

proBe careful -— the actual time used depends on the clock rate at which the pro­
such
cessor is running, the speed of memory accesses, and operating conditions such
loading which may affect
temperature, power
power supply voltage,
voltage, and circuit loading
affect the
as temperature,
speed at which
hich the processor executes
executes instructions.
TRANSPARENT
ing example
example uses Index
Index Registers X and Y to
TRANSPARENT
The following
DELAY
Is
provide delays as long as 255
255 ms. The choice
choice of registers is
DELAY
ROUTINE
Accumulator
arbitrary. You may find the use of the Accum
ulator or of
ROUTINE
arbitrary.
Remember. however.
memory locations
locations more convenient.
convenient. Remember,
however, that
memory
Accumulator
the 6502
6502 has no explicit
explicit Decrement
Decrement Accum
ulator instruction
instruction. We could produce
produce a
routine that
that does not change
change the contents
contents of any user registers. The sequence
routine
PHP
PHP
PHA
TXA
PHA
TYA
PHA

REGISTER
;SAVE STATUS REGISTER
:SAVE
;SAVE ACCUMULATOR
ACCUMULATOR
REGISTERX
;SAVE INDEX REGISTER
REGISTERY
:SAVE INDEX REGISTER
;SAVE

would save the contents
contents of all the registers initially
initially and the sequence
would
PLA
TAY
PLA
TAX
PLA
PLP
PLP

:RESTORE
REGISTERY
;RESTORE INDEX REGISTER
:RESTORE
REGISTERX
;RESTOREINDEX REGISTER
;RESTORE
ACCUMULATOR
;RESTOREACCUMULATOR
;RESTORE
REGISTER
:RESTORESTATUS REGISTER

would restore the registers
registers at the end of the routine. A subroutine that
that does not affect
affect
would
any registers or flags is said to be "transparent"
spa rent" to the calling program.
in­
program. The incourse. be included
struction sequences
sequences that
that save and restore the registers must.
must, of course,
included in
struction
the time budget.
budget.

11-9
11-9

PROGRAM
DELAY PROGRAM
Purpose: The program
program provides
provides a delay
delay of 1 ms times the contents
contents of Index Register
Register V.
Y.
Flowchart:
ch a rt:
Start

Count - MSCNT

Count = Count - 1

IY) = IY)-1

1

No

End
value of MSCNT
The value
SCNT depends on the speed
speed of the
the CPU and
and the
the m em ory cycle
cycle

Source Program:

DELAY
DLY1

LDX
DEX
BNE
DEY
BNE
RTS
RTS

#MSCNT
#MSCNT
DLY1

DELAY

:GET COUNT FOR
;GET
FOR 1 MS DELAY
;COUNT =
= COUNT - 1
;CONTINUE UNTIL COUNT =
= ZERO
ZERO
;DECREMENT NUMBER OF
OF REMAINING MS
:CONTINUE UNTIL NUMBER OF
OF MS = ZERO
ZERO

11-10

Object
Object Program: (starting in location 0030)
Memory
Memory Location
(Hex)
(Hex)

Memory Contents
Memory
(Hex)
(Hex)

0030
0031
0032
0032
0033
0033
0034
0035
0036
0037
0038

A2
MSCNT
MSCNT
CA
DO
DO
FD
88
DO
DO
F8
60

Instruction
Instruction
(Mnemonic)
DELAY
DELAY

LDX
LOX

#MSCNT
#MSCNT

DLY1
DLY1

DEX
DEX
BNE
BNE

DLY1
DLY1

DEY
DEY
BNE
BNE

DELAY
DELAY

RTS
RTS

Time Budget:
Number of Times Executed
Executed

Instruction
Instruction
LDX
LOX
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
RTS
RTS

(Y)
(Y)
(Y) x MSCNT
MSCNT
(Y)
(Y)
(Y) xx MSCNT
MSCNT
(Y)
(Y)
(Y)
(Y)
11

#MSCNT
#MSCNT

DLY1
DLY1
DELAY
DELAY

The total
speed, the
total time used should be (Y) x 1 ms. If the memory is operating
operating at full speed,
instructions
cycles.
instructions require the following
following numbers of clock cycles.
Ignoring
Ignoring Page Boundaries
LDX
#MSCNT
LOX #MSCNT
DEX or DEY
DEX
BNE
BNE
RTS
RTS

or 3
22 or
22
2. 3,
3. or
or 44
2.
66

22
22
22 or 3
66

3

The alternative
alternative times for
for LDX
whether a page
LOX #MSCNT
#MSCNT depend on
on whether
page boundary is
is
crossed. The alternative
BNE depend on whether
crossed.
alternative times for BNE
whether the branch does not occur
(2). occurs to an address on the same page (3),
(3). or occurs to an address on a different
(2).
different
(4). A page is a set of 256 contiguous
same
page (4).
contiguous memory locations which
which have the same
eight
addresses. We will
eight most significant
significant bits (or page number) in their addresses.
ill assume that the
routine is located so that no page boundaries
crossed. and we can use the rightmost
boundaries are crossed,
rightmost
column
purposes.
column of the last table for timing
ing purposes.

Ignoring
(JSR) and Return from Subroutine
(RTS) instructions
Ignoring the Jump-to-Subroutine
Jump-to-Subroutine (JSR)
Subroutine (RTS)
instructions
(which occur only once),
once). the program takes:
takes:
(Y) x (2 +
+ 5 x MSCNT - 11++55)
(Y)
1 --11 clock cycles
BNE instruction
less time during
The -1 's are caused by the fact that
that the BNE
instruction requires less
during the
final iteration
occurs.
iteration when the Counter
Counter has reached zero and no branch occurs.
So. to make the delay 1 ms,
ms.
So.
5 + 5 x MSCNT = Nc
Ne
is the number
number of clock cycles per millisecond. At the standard 1 MHz 6502
where Nc
Ne 1s
clock rate,
rate. Nc
Ne = 1000 so

5 x MSCNT =
= 995

= 199 (C7-]g)
(C715) at a 6502 clock rate of 1 MHz
MSCNT =

11-11

6502 DELAY
6502
LOOP
LOOP
CONSTANT
CONSTANT

PUT/OUTPUT
6 502
0 2 IN PU T/O
U TPU T CHIPS
chips. These devices
Most
ost 6502
6502 input/output
input/output sections are based on LSI interface chips.
combine latches, buffers, flip-flops, and other logic circuits needed for handshak­
handshaking and other simple interfacing
connections.
interfacing techniques. They contain many logic connections,
certain sets of which
which can be selected
selected according to the contents of programmable
registers. Thus the designer has the equivalent
equivalent of a Circuit Designer's Casebook
under his or her control. The initialization
apinitialization phase of the program places the ap­
propriate values in registers
inregisters to select
select the required logic connections. An in­
put/output
put/output section based on programmable LSI interface chips can handle many
different
different applications and changes or corrections can be made in software
are rather
than by rewiring.
We will
ill discuss the following
ing LSI interface chips that can be used with
ith the 6502
microprocessor:
microprocessor:

1)

The 6520
1/0 ports
6520 Peripheral Interface
Interface Adapter. This device contains
contains two 8-bitit I/O
and four
four individual
individual control
control lines:
lines; it is exactly
exactly the same as the 6820
6820 device used
with
ith 6800-based
6800-based microcomputers.4
microcomputers.4

The 6522
6522 Versatile
Versatile Interface
Interface Adapter.
Adapter. This
This device
device contains
contains tw
two
8-b1t
1/0 ports,
ports.
2) The
o 8 -b
it I/O
lines. twoo 16-bit
-b1t
four individual
individual control
control lines,
16-bit counter/timers.
counter/timers, and an 8 -b
it shift
shift register.
The 6530
6530 Peripheral
Peripheral Interface/M
Interface/Memory
or M
Multifunction
(Support) Device.
Device.
3) The
em ory or
ultifunction (Support)
This device
1/0 ports.
counter/timerer with
device contains
contains twoo 8-bit
-b it I/O
ports, an 8-bit
-b it counter/tim
ith a prescaler.
1024 bytes of ROM.
ROM. and 64 bytes of RAM.
4) The
The 6532
6532 Peripheral
Peripheral Interface/M
Interface/Memory
or M
Multifunction
(Support) Device.
Device.
em ory or
ultifunction (Support)
This device
1/0 ports,
ports. an 8-bit
counter/timerer with
prescaler.
device contains
contains twoo 8-bit
-b it I/O
8-bit counter/tim
ith a prescaler,
and 128 bytes of RAM.
The follow
following
PIA. the
ing acronyms
acronyms are often used in describing
describing these devices: the 6520
6520 PIA.
6522
RIOT (for flOM
RAM. J/0,
J/Q.and IiTimer combination)
6522 VIA.
VIA, and the 6530
6530 or 6532 RIOT
ROM or RAM,
combination).
1/0 examples later in this chapter
Our I/O
chapter will
ill all use the 6522 Versatile
Versatile Interface
Interface Adapter.
ProExamples of the use of the 6520
6520 device
device can be found in 6800 Assembly
Assembly Language Programming:5
gram
m ing;5 those examples
examples can easily be adapted to the 6502 microprocessor
microprocessor
(remember
(remember the comparisons
comparisons of the instruction
instruction sets in Tables 3-6 and 3-7).

11-12
11-12

THE 6 520
2 0 PERIPHERAL
PERIPHERAL INTERFACE
INTERFACE ADAPTER
diagram of a PIA. The device contains two
o nearly identical
identical 8Figure 11
11-7 is the block diagram
-A. A. which
B. which
bit ports —
hich is usually
usually an input
input port.
port, and B,
hich is usually
usually an output
output port.
Each port contains:

,• A Data or Peripheral register
register that
that holds either
either input or
output
output data. This register
register is latched
latched when
when used for output
output
unlatched when
when used for input.
but unlatched
• A Data Direction
Direction register. The bits in this register
register deterdeter­
hether the corresponding
corresponding data register
register bits (and
mine whether
(0) or outputs
pins) are inputs
inputs (0)
outputs (1).).

PIA
REGISTERS
AND CONTROL
LINES

,• A Control register
holds the status signals required for handshaking, and
register that
that holds
other bits that
that select
select logic connections within
ith in the PIA.
other
• Tw
Twoo control lines that
that are configured by the control registers. These lines can
11-5 and 11-6.
be used for the handshaking
handshaking signals shown
shown in Figures 11
The meanings
meanings of the bits in the Data Direction
Direction and Control
Control registers are related to the
underlying hardware
hardware and are entirely
entirely arbitrary
arbitrary as far as the assembly language
language propro­
underlying
grammer is concerned.
concerned. You must either
either memorize them or look them up in the apap­
grammer
propriate
(Tables 11-2 through
propriate tables (Tables
through 11-6)
11-6).

PIA
Each PIA occupies four memory addresses. The RS
RS (register
ADDRESSES
registers. as described
select) lines choose one of the four registers,
described in Table
11-1. Since there are six registers (two peripheral.
peripheral, two data direcdirec­
tion. and two control) in each PIA,
PIA. one further
tion,
further bit is needed for addressing. Bit 2 of each
control register
register determines
determines whether
whether the other address on that side refers to the Data
control
Direction register
register (0)
register (1).). This sharing
sharing of an external
external address
Direction
(0) or to the Peripheral register
means that:
1)
1)

A program
program must change
change the bit in the Control
Control register
register in order to use the register
that
addressed.
that is not currently
currently being addressed.

2)

The programmer
programmer must
must know the contents
contents of the Control
Control register
register in order to know
which register is being addressed. RESET
Control register
register and thus adad­
which
RESET clears the Control
dresses the Data Direction
Direction register.

Table 11-1. Addressing
Addressing 6520
6520 PIA Internal
Internal Registers
Control Register Bit

Address Lines
Lines

Register S elect

RS1
RS1

RSO
RSO

CRA-2

CRB-2

0
0

0
0

1
1

X

P e r ipheral R e gister A

0
0

0
0

0
0

X

Data D ir e
Direction
Register A
A
Da
c t io n R e g

0
0

1

X

X

C o ntroll R e gister A

1
1

0
0

X
X

1

P e r ipheral R e gister B

1

0
0

X
X

0
0

D ata D ir e c t io n is te r B
t1on,Reg1ster

1

1

X
X

X

C o ntrol
o l R e gister B

=

X = E ither 0
O or 1

11-13
13

\

iROA-1-----------------------~
DO
DO -

D
01 -

Control

Interrupt

Register A

Status

(CAA)
(CRA)

A
Control A

CAl
-CA1
►CA2
CA2

D2 02
D3
03 -

Data Bus
Bus

Data

Buffers
D4 04

(DBB)
(DBBI

D5 05

Direction
DlrectlOn
Register A

c

(DORA)
(DDRA)
Output
Output E
Bus

D6 06

21

D7 07

H

x>

Output
Output
Register A
Register
A
(ORA)
(ORA)

PAO
* PAO
* PA1
PAI

PA2
►PA2

Bus Input
Register
Register

Penpheral
Peripheral

(BIR)
(BIR)

Interface
Interface
A

►PA3
PA3
►PA4

PAS
►PA5
PAS
►PA6
►PA7
PA7

cso
cs,

Output
Output

►PBO
P80

B
Register 8

(ORB)
(ORB)

►PB1
PBI

CS2

►PB2
PB2

Chip

RSO
RSl
R/W

Select

Penpheral
Peripheral

a"d

Interface

R/W

B

►PB3
PB3
►PB4
PB4

Control
►PB5
PBS

Enable

-PB6
PBS

Reset

►PB7
PB7

21

Input E
Bus

c>

Data
Direction
Direction

Control
B
Register 8

Register B
B

(DDRB)
(DDRB)

(CAB)
(CRB)

Interrupt

■ CB1
CBI

Status

IROB ◄...,_---------------------1
IRQB

Control B
8

Figure 11-7. Block Diagram of the 6520 Peripheral Interface Adapter

11-14
11-

* CB2
CB2

PIA CONTROL REGISTER
REGISTER
PIA
CONTROL
CONTROL
REGISTER
BITS

Table 11-2 shows the organization
organization of the PIA Control
Control registers. We
may describe
describe the general purpose of each bit as follows:
follows:
Bit 7: status bit set by transitions
transitions on control
control line 1 and cleared by
Peripheral (Data)
(Data) register
reading the Peripheral
same as
as bit
bit 77 except
except set
set by
by transitions
transitions on
on control
control line
line 22
Bit 6: same
determines w
hether control
control line
line 22 isis an
an input
input (0)
(0) or
or output
output (1)
(1)
whether
Bit 5: determines

Control line
line 22 input:
input: determines
determines whether
whether bit
bit 66 isisset
set by
by high-to-low
high-to-low transitions
transitions
Bit 4: Control
(0)
-to-high transitions
transitions (1)
control line 2
(1) on control
(0) or low-to-high
(0) or a level
Is a pulse (0)
Control line 2 output:
output: determines
determines whether
whether control
control line 2 is
Control
(1)
(1
Control line
line 22 input:
input: ifif 1,
1. enables
enables interrupt
interrupt output
output from
from bit
bit 66
Bit 3: Control
(0 == handshake
cond1t1on for pulse (0
Control line 2 output:
output: determines
determines ending
ending condition
handshake
Control
acknowledgement lasting
lasting until
until next transition
transition on control
control line 1.. 1 == brief strobe
acknowledgement
lasting one clock
clock cycle) or value of level
lasting

(1)
(0) or Data register
Direction register
register (0)
register (1)
Bit 2: selects Data Direction

tranlow-to-high tran­
(0) or low-to-high
transitions (0)
determines whether
whether bit 7 is set by high-to-low
high-to-low transitions
Bit 1: determines
(1) on control
sitions
sitions (1)
control line 1
Bit 0: if
interrupt output
output from bit 7 of Control
Control register.
1. enables interrupt
1f 1,
Tables 11
through 11
describe the bits in more detail. Since Eis
is normally
normally tied to the
11-6 describe
11-3 through
02
interpret "E" pulse as "clock
"clock pulse."
clock. you can interpret
<1>2clock,
Organization of the PIA Control
Control Registers
Table 11-2. Organization
7
7

6

IR Q
IAOAl1

IR Q
IAOA2

7

6

IAOBl
IR Q
B1

IR Q
B2
IA0B2

5

I 4 I 3
4

3

CR
AA

D DAA
R

CA2 C o ntrol
ol

5

A c cess

I 4 I 3
4

CRB
CAB

ntrol
CB2 C o n
tr o l

1 1-15
-15

2

3

2
D DAB
R
A c cess

1

I 0
0

CA11 C o ntrol
ol

1

I 0
0

ntrol
CBl1 C o n
CB
tr o l

Table 11-3. Control
Control of 6520 PIA Interrupt
Interrupt Inputs
Inputs CA11 and CB
CB11
CRA-1
CR
A -1

CRA-0
CR

Interrupt
Inputt
In te
rru p t In p

Interrupt
lag
In te
r r u p t F la
g

(CRB-1)
(C R
B -1 )

(CRB-01
(C R B
-0)

CAl1 (C B
(CB1)
C
1)

RB-71
C RA-7 (C R B
-7 )

00

0

Active
i Ac
tiv e

1

Set h ig
high oon
S

1of CA11

[

(CB1)
(C B
1)
tiv e
1A ctive

1

0

[

1

Set h igh on 1 of CAT1

(CB1)
(C B
1)

MPU I n t e
Interrupt
MP
rru p t
Request
R eq
IROA
(IRQB)
IR
Q
(IRQ
B)
Disabledd —
-IRO
re-­
D is a
IRQ re
mains h ig
high
ma
Goes lo
low w h
whenn th
the
Go
interrupt
flag bbit C RA-7
in t e
r r u p t fla
(C R B
-7 ) g oes h igh
RB-71

11

1

0

| A ctive
tiv e

I

Set h ig
high on | of CA11
S
(CBll
(C
B 1)

I

1

11

\

f A ctive
e

f

Set h igh on J of CA11

(CBl)
(C
B1)

Disabledd -— IR
IRO
re-­
D is a
Q re
mains h ig
high
ma
Goes
low w h
when th
the
Go
s lo
interrupt
flag bbit C R
CRA-7
in t e
r r u p t fla
(C R B
-7 ) g oes h ig
h
ICRB-71
19h

N otes:

j

1
1

1
1.

indicates
111ve
s1t1on
| in d ic
a te s p o s it
iv e t r a n s
itio n ( lo
!low to h igh)

2.

icates
1 in d ic
a t e s n e gative
tiv e t r a n s
it io n ( high tto low)
trans1t1on

3.

The I n t e
Interrupt
flag bbit C R
CRA-7 is
1s c le a
cleared bby an M PU R ead
Th
r r u p t fla
d of the A D ata R e gister, a nd
1sc le ared by an M PU R ead
C RB-7 is
d of t h
the B D ata R e gister

]
44

If C R
CRA-0 (C R
(CR~s
low w h
whenn aan in t e
interrupt
occurs ( In te
!Interrupt
disabled) a n
and is
1sla
later b r o
brought
If
B -0 ) is lo
rru p t o cc
r r u p t d is a
ht
high, IR
IROA
(IROB)
occurs a ft
after C R
CRA-0 (C R B
(CRB-01
1sw r it
written
to aa " o n
··one··
h ig
Q
(IR Q
B) o c c
-0 ) is
t e n to
”

CB2
Table 11-4. Control
Control of 6520 PIA Interrupt
Interrupt Inputs
Inputs CA2 and CB2
CRA-5
CR

CRA-4
CR

(CRB-5)
(C R
B -5)

(C R B
-4) (C R B
RB-41
RB-31
-3 )

0

0

I

CRA-3
CR

0

Interrupt
Input
In te
rru p t In p

Interrupt
Flag
In te
r r u p t F la

CA2 (C B
(CB2)
C
2)

CRA-6 (C R
RB-6)
CR
B -6 )

tiv e
1A ctive

Set h igh on j of C A2

[

1

(CB21
(C
B2)
0

0

1

tiv e
I A ctive

[

l

Set h igh on | of C A2
(C
B2)
(CB21

MPU I n t e
Interrupt
MP
ru p t
R e quest
IROA
Q
(IRQ
B)
(IROBI
D is abled -— IRQ
IRO
r e mains h igh

G oes low w hen
n the
in t errupt
r r u p t flag bit C RA-6
(C R B
-6 ) g oes h igh
RB-61

1

0

0

1

f A ctive
tiv e

Set h igh on |J of C A2
(C B
2)
B21

11

0

1

1

| A ctive
tiv e

I

Set h igh on f of C A2

(CB21
(C
B2)

D is abled
d -— IRQ
IRO
re mains h igh

G oes low w hen the
in t e
r r u p t flag bit C RA-6
errupt
(C R B
-6 ) g oes h igh
B-61

N otes:

1
1.

jI in d ic
a t e s p o sitive
iv e t r a nsition
s itio n ( lo
1nd1cates
!low tto h igh)

2.

1in d icates
a t e s n e gative
tiv e t r a n s
itio n ( high tto low)
transition

3
3.

The I n t e
Interrupt
flag bbl!it C R
CRA-6 is
1s c le a
cleared bby aan M PU
Th
r r u p t fla
U R ead of the A D ata R e gister a nd C RB-6

4
4

If C R
CRA-3 (C R B
RB-31
If
-3 ) is
r u p t o c curs ( I n terrupt
u p t d is abled)
d ) a nd is
ht
1slow w hen an in t e rrrupt
1slater b r ought

1sc le ared by an M PU R e
is
ad of t he B D ata R e gister.
ead
h igh., IROA
Q
(IR Q
B ) o c curs a fterr C RA-3 (C RB-31
-3 ) is w r it
t e n to a " o ne··
e"
OB)
itten

11-166
11

\

Table 11
11-5. Control
Control of 6520
6520 PIA CB2 Output
utput Line
C B2
C RB-5

C RB-4

CRB-3
CR
C le ared

1
1

0

0
0

Set

Low oon th
the p o s
pos,t,ve
trans,t,on
of
Lo
it iv e t r a n s
itio n o

H,gh
whenn th
the in t e
interrupt
flag bbit
H
ig w h
r r u p t fla

llowing
t he f irstt E p ulse f o llo
w in g

C RB-7 is
tiv e t r ans,s i­
,s set by an a ctive

MPU W r
Write
MP
it e

"B""
"B

an

D ata R e gister

,on of the CB11 s ig
,gnal
t io

o p e ration
tio n

1

0

1

s,t,on
L ow on the p o s,t,ve
it iv t r a n s
itio n of

sItIve
H,gh
ig on the p o s
it iv e e dge of the

the f ir
firstt E
E pu
pulse a ft
afterr aan M P
MPU
th

f irstt " E"" p ulse f o l lo
w in g an " E""
lowing

··s··

1

1

0
0

Write
Data R e g
Registerr o p e
operaW
r it e “ B " D a
a­

pulse w h
which
occurred
while
the
pu
ic h o c c u
rre d w h
ile th

tIon.
tio

part w
was d e s e
deselected
pa
le c te d

L ow w hen C RB-3 g oes low as a

A lways
a y s low as long as C RB-3 is
,s

resultlt oof aan M P
MPU W r
Write
in C o
Con·­
re s
it e in

low

trol R e g
Register " B
"B''
tr

Write
r it e

Will
i l go h igh on an M PU
in

C o ntrol
r o l R e gisterr " B""

t hat c h a nges C RB-3 to " one"
e"

1

1

1
1

A lways
a y s h igh as long as C RB-3 is
Is

High w hen C RB-3 g oes h igh as

h igh. Will
i l be c le ared w hen
n an

a r e sultlt of an M PU Write
r it e into

MPU W
Write
Control
Registerr " B
"B""
MP
r it e C o n
tro l R e g

C o ntrol
tr o l R e gister " B""

r e sults
lts

,n
in

c le aring
in g

C RB-3

to

"" z e
zero "

Table 11
11-6. Control
Control of 6520
6520 PIA CA2 Output
utput Line
CA2
C RA-5

C RA-4

C RA-3
Set

C le ared
1

0
0

0
0

L ow on n e gative
a tiv e t r a n s
itio n of E
ns,t,on

High w h
whenn t h
the in t e
interrupt
flag bbit
H
r r u p t fla

a fterr an M PU R ead "A""

CRA-7 is
,s sset bby aan a c
act,ve
trans,CR
tiv e t r a
s i­

D ata

t,on oof th
the C
CA11 s ig
signal
t io

o p e ration.
tio

11

1

0

1

1

0
0

L ow on n e gative
tiv e t r a n s
itio n of E
nsItIon

High oon th
the n e g
negative
H
tiv e

afterr aan M P
MPU R e
Read
"A""
a ft
d "A

the f ir
firstt " E
"E"" p u
pulse w h
which
occurs
th
ic h o c c

Data
Da

edge oof
ed

oper
a tio n
ration

d u ring
in g a d e select
ct

L ow w hen
n C RA-3 g oes low as a

Always
low as
as lo
long aas C R
CRA-3 is
,s
A lw
a y s lo

r e sultlt of an M PU Write
it e to C on·­

low

Will
i l go h igh on an M PU

t rol R e gister "A""

Write
W r
it e

Control
Registerr " A
"A""
tto C o n
ro l R e g

that c h a n
changes C R
CRA-3 to
to " o
"one"
th
ne"
1

1

1

,s
A lways
a y s h igh as long as C RA-3 is

High w hen
n C RA-3 g oes h igh as

h igh. Will
i l be c le ared on an M PU

a r e sult of an M PU Write
it e to C on·­

Write
r it e

trol R e g
Register " A
"A""
tro

to C o ntrol
t r o l R e gisterr " A""

ero"
t hatt c lears C RA-3 to a " z e
ro "

1 1-17
17

CONFIGURING
CONFIGURING THE PIA
program must select
The program
select the logic connections in the PIA
using it. This selection (or configuration)
configuration) is usually
before using
part of the startup routine. The steps in the configuration
configuration are:

STEPS
STEPS IN
IN
CONFIGURING
CONFIGURING
AA PIA
PIA________

1) Address the Data Direction
Direction register by clearing bit 2 of the
1)
Reset signal clears all the internal
Control register. Since the Reset
internal registers, this step is
unnecessary in the overall startup
startup routine.
2)
2)

1/0 pins by loading the Data Direction
Establish the directions
directions of the I/O
Direction register.

3)

Select the required logic connections
connections in the PIA by loading the Control register. Set
bit 2 of the Control
Control register so as to address the Data register.

Step 1 can be performed as follows:

LOA
LDA
STA

#0
PIACR
PIACR

LDA
LOA
AND
STA

PIACR
PIACR
11111011
#% 1
1111011
PIACR
PIACR

:CLEAR PIA CONTROL
CONTROL REGISTER
REGISTER
;CLEAR

or
:SELECT DATA DIRECTION
DIRECTION REGISTER
REGISTER
;SELECT

1, Step 2 is simply
Once the program has performed Step 1.
ply a matter
atter of clearing each in­
input bit position
position and setting
setting each output
output bit position in the Data Direction
Direction Register.
Register.
are:
Some simple examples are:
1)
1)

LDA
LOA
STA

#0
PIADDR
PIADDR

LINES INPUTS
INPUTS
:ALL LINES

2)
2)

LDA
LOA
STA
STA

#$FF
PIADDR
PIADDR

LINES OUTPUTS
OUTPUTS
;ALL LINES

3)
3)

LDA
LOA
STA

#$F0
#$FO
PIADDR
PIADDR

LINES 4-7 OUTPUTS.
OUTPUTS, 0-3 INPUTS
INPUTS
;MAKE LINES

Step 3 is clearly the difficult
ifficu lt part of the configuration.
configuration, since it involves selecting the
PIA. Some points to remember are:
logic connections
connections in the PIA.
are:

1) Bits
Bits 66 and
and 77 of
of the
the Control
Control register
register are
are set
set by
by transitions
transitions on
on the
the control
control lines
lines and
and are
are
1)
cleared by reading the Data register. You cannot
cannot change these bits by writing
riting data
into the Control register.
--2)
2)

Bit 22 of
of the
the Control
Control register
register must
must be
be set
set to
to address
address the
the Data
Data register.
register.
Bit

3)

Bit 11 determines
determines w
which
pulse edge
edge w
will set
set bit
bit 7.
7. Bit
81111 is
is 0Ofor
for aa high-to-low
high-to-low transi­
transiBit
hich pulse
tion; bit 1 is 1 for a low-to-high
low-to-high transition.

.4)

Bit 0O is
is the
the interrupt
interrupt enable
enable for
for control
control line
line 1.
1. Remember
Remember that
that it1tmust
must be
be set
set to
to ena­
enaBit
ble interrupts,
interrupts, unlike the 6502 interrupt
interrupt bit. which
hich must be cleared to enable interinter­
rupts. Chapter 12 describes interrupts
interrupts in more detail.

5) Bit
Bit 55 must
must be
be set
set ifif control
control line
line 22 is
is to
5)
to be
be output.
output. Bits
Bits 33 and
and 44 then
then determine
determine how
how
control
control line 2 works. Remember that sides A and B differ, since side A can only pro­
produce a read strobe while
hile side B can only produce a write
rite strobe. Once the strobe
option has been selected, the strobes automatically
atically follow
follow each reading of Data
Data
B. You must configure
Register A or writing
riting of Data Register B.
configure each side of each PIA
in the startup
startup program.

11-18
11-18

..._

EXAMPLES OF PIA CONFIGURATION
1)
1)

A simple
simple input
input port
port with
ith no control
control lines (as needed for
for a
set of switches):
switches):
LOA
LDA
STA
STA
LOA
LDA
STA

#00
PIACR
PIACR
PIADDR
PIADDR
#%00000100
00000100
PIACR
PIACR

PIA
CONFIGURATION
CONFIGURATION
EXAMPLES
EXAMPLES

;CLEAR OUT CONTROL
CONTROL REGISTER
REGISTER
;CLEAR
:MAKE ALL LINES
LINES INPUTS
INPUTS
;MAKE
:SELECT DATA REGISTER
REGISTER
;SELECT

Bit 2 of the Control
seControl register
register must be set to address the Data register. The same se­
quence
quence can be used if a high-to-low
high-to-TOw transition
transition (negative
(negative transition)
transition) on control
control line 1
indicates
Ready.
indicates Data Ready or Peripheral
Peripheral Ready.
2)

A simple
simple output
output port with
ith no control
control lines (as
(as needed for a set of single LED
LED disdis­
plays):
LOA
LDA
STA
LOA
LDA
STA
LOA
LDA
STA

3)

#00
PIACR
PIACR
#$FF
PIADDR
#%00000100
00000100
PIACR
PIACR

:CLEAR OUT CONTROL
CONTROL REGISTER
REGISTER
;CLEAR
;MAKE ALL LINES
LINES OUTPUTS
OUTPUTS
:SELECT DATA REGISTER
REGISTER
;SELECT

An input
that indicates
READY with
input port with
ith a control
control input
input that
indicates DATA
DATA READY
ith a low-to-high
low-to-high
transition
transition (positive
(positive transition):
transition):
LOA
OUT
CONTROL REGISTER
LDA
##0
0 ;CLEAR OUT :CLEAR
CONTROL
REGISTER
PIACR
STA
PIACR
:MAKE ALL
ALL LINES
LINESINPUTS
INPUTS
PIADDR
STA
PIADDR
;MAKE
:MAKE DATA
DATA READY
READYACTIVE
ACTIVE LOW-TO-HIGH
LDA
#%
00000110
;MAKE
LOW-TO-HIGH
LOA
#%00000110
STA
PIACR
PIACR

READY or DATA AVAILABLE
The DATA READY
AVAILABLE line is tied to control
control line CA11 or CB11 Bit 1 of
the Control
1.
Control register is set so as to recognize low-to-high
low-to-high transitions
transitions on control
control line 1.
This configuration
configuration is suitable
suitable for most encoded keyboards.
4)

output port that
that produces
produces a brief strobe to indicate
indicate DATA
DATA READY
An output
READY or OUTPUT
OUTPUT
READY (this could
READY
could be used for multiplexing
ultiplexing displays
displays or for providing
providing a DATA
AVAILABLE
AVAILABLE signal
signal to a printer):

LOA
LDA
STA
LOA
LDA
STA
LOA
LDA
STA

#00
PIACR
PIACR
#$FF
PIADDR
PIADDR
#%00101100
00101100
PIACR
PIACR

;CLEAR
:CLEAR OUT CONTROL
CONTROL REGISTER
REGISTER
;MAKE ALL LINES
LINES OUTPUTS
OUTPUTS
;MAKE
:MAKE CONTROL
CONTROL LINE
LINE 2 A BRIEF
BRIEF STROBE
STROBE

control line 2 an output.
output, bit 4 = 0 to make it a pulse,
pulse. and bit 3 = 1 to
Bit 5 = 1 to make control
automatmake it a brief
brief active-low
active-low strobe (one clock period in duration).
duration). The strobe will
ill autom
at­
ically follow
follow each instruction
instruction that
that writes
writes data into the B side of the PIA; for example.
example, the
instruction
instruction
STA

PIADRB
PIADRB

will
ill both transfer
transfer data and cause a strobe. However,
ill produce
produce a strobe
However. the A side will
only after
after a read operation.
operation. The sequence
STA
LDA
LOA

PIADRA
PIADRA
PIADRA
PIADRA

;WRITE DATA
DATA
;WRITE
:PRODUCEAN
AN OUTPUT
OUTPUTSTROBE
STROBE
;PRODUCE

will
ill both transfer
transfer data and cause a strobe. The LDA
instruction is a "dum
m y read”
LOA instruction
"dummy
read";; it
has no effect
effect other than to cause the strobe (and waste some time). Other instructions
instructions
LOA could also be used —
-you
besides LDA
you should try to name some of them.

11-19
11-19

5)

An input
input port
port with
ith a handshake
handshake Input
Input Acknowledge
Acknowledge strobe that can be used to tell
a peripheral
peripheral that
that the previous
previous data has been accepted
accepted (and the computer
puter is ready
for more):
LOA
LDA
STA
STA
LOA
LDA

##0
0
PIACR
PIACR
PIADDR
PIADDR
#%00100100
#%
00100100

STA

PIACR
PIACR

;CLEAR OUT
OUT CONTROL
CONTROLREGISTER
REGISTER
;CLEAR
;MAKE ALL
ALL LINES
LINES INPUTS
INPUTS
;MAKE
:CONTROLLINE
LINE22== HANDSHAKE
HANDSHAKE
;CONTROL
ACKNOWLEDGE
: ACKNOWLEDGE

Bit 5 = 1 to make control
pulse. and bit 3 = 0 to
control line 2 an output.
output, bit 4 = 0 to make it a pulse,
acknowledgment
make it an active-low
active-low acknowledgm
ent that
that remains low until
until the next active transition
transition
acknowledgment
automatically
on control
control line 1. The acknowledgm
ent will
ill autom
atically follow
follow a read operation
operation on the
A side of the PIA:
PIA; for example.
example, the instruction
instruction
LOA
LDA

PIADRA
PIADRA

will
ill both read data and cause the acknowledgment
acknowledgment. However.
However, the B side will
ill produce
acknowledgment
an acknowledgm
ent only after
after a write
write operation. The sequence

LOA
LDA
STA

PIADRB
PIADRB
PIADRB
PIADRB

;READ DATA
DATA
:READ
:PRODUCEACKNOWLEDGMENT
ACKNOWLEDGMENT
;PRODUCE

"dummy
will
ill both read data and produce
produce an acknowledgment
acknowledgment. The STA instruction
instruction is a "dum
my
acknowledgment
write";
rite "; it has no other
other effect
effect than to cause the acknowledgm
ent (and waste some time).
Note that the order of the sequence is reversed from the previous example. This concon­
figuration
CRT terminals
figuration is suitable
suitable for many CRT
terminals that require a complete
complete handshake.
6)

An output
output port
port with
ith a latched
latched zero control
control bit (latched individual
individual output
output or level
output).
output). Such an output
output can be used to turn the peripheral
peripheral on or off or to control
control its
mode of operation.

LOA
LDA
STA
LOA
LDA
STA
LDA
LOA
STA

##0
0
PIACR
PIACR
#$FF
#$FF
PIADDR
PIADDR
#% 00
1 101 0
%00110100
PIACR
PIACR

;CLEAR OUT
OUT CONTROL
CONTROL REGISTER
REGISTER
;CLEAR
;MAKE ALL
ALL LINES
LINES OUTPUTS
OUTPUTS
;MAKE
;CONTROL
;CONTROL LINE
LINE 2 =
= LATCHED
LATCHED ZERO
ZERO LEVEL
LEVEL

Bit 5 = 1 to make control
bit. and
control line 2 an output.
output, bit 4 = 1 to make it a level or latched bit,
zero. This output
bit 3 = 0 to make the level zero.
output is not affected
affected by operations
operations on the Data
register:
register; its value can be changed
changed by changing
changing the value of bit 3 of the PIA Control
register,
register. i.e....
LDA
LOA
ORA
STA

PIACR
PIACR
#%00001000
00001000
PIACR
PIACR

LEVEL ONE
ONE
;MAKE LEVEL

LDA
LOA
AND
STA

PIACR
PIACR
%11110111
#% 1
1110111
PIACR
PIACR

;MAKE LEVEL
LEVEL ZERO
ZERO

You can use this configuration
configuration to produce
produce active-high
active-high strobes or to provide pulses with
ith
software-controlled
software-controlled lengths
lengths

11-20
11-20

USING THE PIA TO TRANSFER DATA
Once the PIA has been configured, you may use its data
registers like any other
other memory locations. The simplest
plest in·
in­
transfer are:
structions for data transfer

PIA INPUT/
INPUT/
OUTPUT

Load Accumulator,
Accumulator, which
which transfers
transfers eight
eight bits of data from the specified
specified input
input pins to
Accumulator.
the Accum
ulator, and
Store Accumulator,
Accumulator
Accumulator, which
hich transfers
transfers eight
eight bits of data from the Accum
ulator to the
specified
specified output
output pins.
You must be careful
careful in situations
situations where
where input
input and output
output ports do not behave like
memory
memory locations.
locations. For example.
example, it often
often makes no sense to write
write data into input
input ports or
read data from output
output ports. Be particularly
particularly careful
careful if the input
input port is not latched or if
Is not buffered.
the output
output port
port is

Other
1/0 in·
Other instructions that
that transfer
transfer data to or from memory can also serve as I/O
in­
structions. Typical
Typical examples
examples are:

Bit Test,
Test, which
hich sets the Zero flag as if the values of a set of input
input pins had been
logically
Accumulator.
logically ANDed
ANDed with
ith the contents
contents of the Accum
ulator. The Sign (Negative) flag is set to
the value of bit
bit 7 of the input
input port
port and the Overflow
Overflow flag is set to the value of bit 6 of the
input
input port. This instruction provides a simple way
way to test
st the PIA status flags; that
is. the instruction
instruction
BIT

PIACR
PIACR

1)
sets the Sign flag to the value of Control
Control register
register bit 7 (the status latch for control
control line 1)
Overflow flag to the value of Control
Control register
register bit 6 (the status latch for control
control
and the Overflow
line 2).
2).

Compare, which
had been
hich sets the flags as if the values of a set of input
input pins had
subtracted
subtracted from the contents
contents of the Accumulator.
Accumulator.

1/0 ports. Be particularly
Here also you must be aware of the physical
physical limitations
itations of the I/O
particularly
careful
careful of instructions
instructions like shifts. Increment.
Increment, and Decrement.
Decrement, which
which involve both read
and write
rite cycles.
We
Often. comWe cannot
cannot overemphasize
overemphasize the importance of careful documentation.
documentation. Often,
com­
concealed in instructions
instructions with
ith no obvious
obvious functions
functions. You must
1/0 transfers can be concealed
plex I/O
describe
describe the purposes of such instructions
instructions carefully.
carefully. For example.
example, one could easily be
tempted
dummy
tempted to remove the dum
m y read and write
rite operations
operations mentioned
mentioned earlier since they
accomplish anything.
anything.
do not appear to accomplish

Bitit 7 of the PIA Control register
register often
often serves as a status bit,
such as Data Ready or Peripheral
Ready. You can check its value
Peripheral Ready.
following
with
ith either
either of the follow
ing sequences:
LDA
BMI

PIACR
PIACR
DEVRDY
DEVRDY

;IS READY
READYFLAG
FLAG 1?
1?
;IS
;YES.
:YES. DEVICE
DEVICE READY
READY

BIT
BMI

PIACR
PIACR
DEVRDY

:IS READY
READYFLAG
FLAG 1?
17
;IS
:YES. DEVICE
DEVICE READY
READY
;YES.

PIA STATUS
STATUS
BITS

Note that
that you should not use the shift
shift instructions,
instructions, since they will
ill change the contents
contents
of the Control
following
Ready flag to go
Control register
register (why?). The follow
ing program
program will
ill waitit for the Ready
high:
WAITR

BIT
BPL

PIACR
PIACR
WAITR
WAITR

:ISREADY
READYFLAG
FLAG 11?
;IS
?
:NO.WAIT
WAIT
;NO,

How would
would you change
change these programs
programs so that they examine
examine bit 6 instead of bit 7?

11-21
11-21

The only way
ay to clear bit 7 (or bit 6) is to read the Data register. A dumm
dummyy read
read will
be necessary if a read operation
operation is not normally
normally part of the response
response to the bit being set.
set.
If the port is used for output.
output, the sequence
STA
LOA
LDA

PIADR
PIADR
PIADR
PIADR

;SEND DATA
DATA
;SEND
;CLEAR READ
;CLEAR
READ FLAG
FLAG

10b. Note that here the dumm
dummyy read
read is
1snecessary on either
PIA.
will
ill do the job.
either side of the PIA.
The Bit Test instruction
instruction can also clear the strobe w ithout
o u t changing
changing anything
anything except the
cases where the CPU
CPU is not ready for input
has
flags. Be particularly
particularly careful in cases
input data or has
no output
output data to send
send.

11-22
11-22

THE 6 522
2 2 VERSATILE INTERFACE ADAPTER
ADAPTER (VIA)
PeriphThe 6522
6522 Versatile
Versatile Interface
Interface Adapter
Adapter is an enhanced version of the 6520
6520 Periph­
7,8
eral Interface Adapter.6,
Adapter.®-?'®
(see the block
The 6522
6522 VIA
VIA contains the following (see
block diagram
diagram in
Figure 11-8):

6522
6522 VIA
FUNCTIONS

Each pin
pin can
can be
be individually
individually
Two 8-b
8-bit I/O
1/0 ports
ports (A
(A and
and B).
B).Each
1) Two
selected
selected to be either
either an input
input or an output.
output.

2) Four
Fourstatus
status and
and control
control lines
lines (two
(two associated
associated wwith
each port).
port).
ith each
Two 16-bit
16-bit counter/tim
counter/timers
can be
beused
used toto generate
generate or
orcount
count pulses.
pulses. These
These
3) Two
ers wwhich
hich can
timers
timers can produce
produce single
single pulses or a continuous
continuous series of pulses.
An 8-b
8-bit
register which
which can
can convert
convert data
data between
between serial
serial and
and parallel
parallel forms.
forms.
4) An
it SShift
hift register
Interrupt logic
logic(to
(tobe
bedescribed
described ininChapter
Chapter 12)
12)so
sothat
that I/O
1/0can
can proceed
proceed on
onan
aninter­
inter5) Interrupt
rupt-driven
basis.
rupt-driven basis.
Thus the Versatile
Versatile Interface
Interface Adapter
Adapter provides
provides the functions
functions of the PIA plus two 16-bit
16-bit
counter/timers
counter/tim
ers and an 8-bit
-b it Shift
Shift register. We will
ill describe
describe the use of the
1/0
counter/timers
counter/tim
ers later in this chapter.
chapter. The Shift
Shift register
register provides
provides a simple
simple serial I/O
capability
capability that
that is only occasionally
occasionally useful:
useful; we will
ill not discuss
discuss it any further.
further.

addresses. The RS
RS (register
Each VIA occupies sixteen
sixteen memory addresses.
select) lines choose the various
various internal
internal registers, as described
described in
Table 11-7 The way
ay that
that a VIA operates is determined
determined by the

VIA
ADDRESSES

contents of four registers.
1)

inData Direction Register A (DORA)
(DDRA) determines
determines whether
whether the pins on Port A are in­
puts (Os)
(Os) or outputs
(1s).
sl.
outputs (1

Data Direction
Direction Register
Register BB(DDRB)
(DDRB)determines
determines whether
whether the
the
2) Data
pins on Port B are inputs
(Os) or outputs
sl.
inputs (Os)
outputs (1s).

VIA
REGISTERS
REGISTERS
AND CONTROL
LINES

The Peripheral
Peripheral Control
Control register
register (PCR)
(PCR) determines
determines which
which
3) The
polarity
polarity of transition
transition (rising edge or falling
falling edge) is recognized
recognized
on the input
input status
status lines (CA
(CA11 and CB1)
other
1) and how the other
status lines (CA2 and CB2) operate. Figure 11-9 describes
status
describes the bit assignments
assignments in
the Peripheral
Peripheral Control
Control register:
register; as usual, the functions
functions and bit
bit positions
positions are arar­
bitrarily
bitrarily selected by the manufacturer
manufacturer. Note that
that the 6522
6522 Peripheral
Peripheral Control
Control
register
register does not contain
contain status
status bits (latches) like the 6520
6520 Control
Control register:
register; these
bits are located in the separate Interrupt
(see Figure 11-11).
Interrupt Flag register
register (see
4)

The Auxiliary
uxiliary Control register (ACR)
determines whether
whether the data ports are
(ACR) determines
latched and how the timers
timers and Shift
Shift register
register operate. These functions
functions are not prepre­
latched
sent in the 6520
PIA. Figure 11-10 describes
6520 PIA.
describes the bit assignments
assignments in Auxiliary
Auxiliary ConCon­
trol register.

Note that
that there is a data direction
direction register
register for each side but
but only one control
control register
register
6520, which
hich has a separate control
control register
register for each side). Ports A and Bare
are
(unlike the 6520,
virtually
virtually identical
identical. One important
portant difference
difference is that
that Port B can handle
handle Darlington
Darlington trantran­
relays. We will
sistors, which
which are used to drive solenoids
solenoids and relays.
ill use Port A for input
input and
Port B for output
output in our examples
examples later in this chapter.

11-23
11
23

~----------------------------Port A Registers

Flags
IIFRI

Latch

Input

Output
(ORAi

Enable

IIERI

Data

Bus

Function Control

Handshake Control

Peripheral

Port A

IPCRI
Auxiliary

J.ila------------

CAl

J.ila----------~► CA2

Port B

(ACRI

""

Port A

(PAI

(DORAi

Bus

I

Buffers

Data Dir.

Data
Buffers

IRQ

Interrupt Control

,I>,

Timer 1

Latch
(TIL-HI

-----+

R/W
CLK

cs,
CS2
RSO
RSl
RS2
RS3

Counter

(TIC-HI

I

Latch

Shift Register

J.iaa--+♦------~► CBl

(TIL-LI

(SRI

J.ila--+-------~► CB2

Counter

Port B Registers

ITIC-LI

Chip

Input Latch

Access

Timer 2

Control
Latch

Output

Buffers

IT2L-LI

(ORB)

(PB)

Counter

Counter

Data Dir.

(T2C-HI

(T2C-LI

(DDRBI

Figure 11-8. Block Diagram
Diagram of the 6522
6522 Versatile
Versatile lnterf;ice
Interface Adapter
Adapter

Port B

Internal Registers
6522 VIA Internal
Table 11-7. Addressing
Addressing 6522

Select Lines
Lines
Select
Label

...

Addressed Location

m
CM r— 0o
N
Cl)
<
n Cl)
U) Cl)
«0
<0 Cl)
IC
C
C IC
cc cc D
C
IC
I")

IC

DEV
DEV
DEV+1
DEV+2
DEV+2
DEV+3
DEV+3
DEV+4
DEV+4

0
0
0
0
0

0
0
0
0
1

0
0
1
1
0

0
1
0
1
0

DEV+5
DEV+5

0

1

0

1

DEV+6
DEV+6
DEV+7
DEV+7
DEV+8
DEV+8

0
0
1

1
1
0

1
1
0

0
1
0

DEV+9
DEV+9

1

0

0

1

DEV+A
DEV+A
DEV+B
DEV+C
DEV+D
DEV+E
DEV+F

1
1
1
1
1
1

0
0
1
1
1
1

1
1
0
0
1
1

0
1
0
1
0
1

Output
utput register
register for I/O
1/0 Port B
A. with
Output
utput register
register for I/O
ith handshaking
handshaking
1/0 Port A.
I/O
Direction register
register
1/0 Port B Data Direction
I/O
Direction register
register
1/0 Port A Data Direction
Read
Timer 1 Counter
Counter low-order
low-order byte
Read Timer
Write
rite to Timer
Timer 1 Latch
Latch low-order
low-order byte
Read
Timer 1 Counter
Counter high-order
high-order byte
Read Timer
Write
rite to Timer
Timer 1 Latch
Latch high-order
high-order byte and
initiate
initiate count
count
Timer 1 Latch
Latch low-order
low-order byte
Access Timer
Access Timer
Timer 1 Latch high-order
high-order byte
Read
low-order byte of Timer
Timer 2 and reset
Read low-order
Counter interrupt
interrupt
Counter
Write
rite to low-order
low-order byte of Timer
Timer 2 but
but do not
reset interrupt
interrupt
high-order byte of Timer
Timer 2; reset
Access high-order
Counter
Counter interrupt
interrupt on write
write
1/0 Shift
Serial I/O
Shift register
register
Auxiliary Control
Control register
register
Auxiliary
Peripheral
Peripheral Control
Control register
register
Interrupt
Interrupt Flag register
register
Interrupt
Interrupt Enable register
register
ithout
A. w ith
Output
utput register
register for I/O
o u t handshaking
handshaking
1/0 Port A,

11-255
11-

7654321

-B it Number

Peripheral Control register
-Peripheral

I

0 Request
interrupt on high-to-low}
high-to-low
Request interrupt
transition
transition of CA1l

On interrupt
interrupt request set

1 Request interrupt
interrupt on low-to-high
low-to-high

Interrupt
Flag register bit 1
Interrupt Flag

transition
transition of CA11
000
input mode
OClOCA2 input
001 CA2 independent
independent input mode

interrupt on
f Request interrupt
f high-to-low
high-to-low CA2 transition
transition

l

010 CA2 input mode

} Request
Request interrupt
interrupt on
low-to-high CA2 transition
transition
low-to-high
011 CA2 independent
independent input mode
100 CA2 output
CPU read or write
100
output low on CPU
write

On interrupt
interrupt

request set

Interrupt Flag
Flag
register bit 0

101 CA2 output
CPU read or write
101
output low pulse on CPU
write
110 Output
Output CA2 low
111
Output CA2,
111 Output
CA2. high
0 Request interrupt
interrupt on high-to-low}
high-to-low

\

transition of CB
CB11
transition
1 Request
interrupt on low-to-high
low-to-high
Reque~t interrupt
transit10n of CB
transition
CB11

On interrupt
interrupt request set

Interrupt
Flag register bit 4
Interrupt Flag

l Request
Request interrupt on

-0 0
0 CB2
OClO
CB2 input mode

CB2 independent input mode
001 CB2

r high-to-low
CB2 transition
high-to-low CB2
transition

010 CB2
C82 input mode
0111 CB2
C82 independent input mode

} Request
Request interrupt on
}
low-to-high
C82 transition
low-to-high CB2

On interrupt
request set
Interrupt Flag
register bit 3

100 CB2
CB2 output
CPU write
100
output low on CPU
write
101 CB2
CB2 output
CPU write
101
output low pulse on CPU
write
110 Output
CB2 low
110
Output CB2
111 Output
CB2 high
111
Output CB2

Figure 11-9. 6522 VIA Peripheral
Peripheral Control
Control Register Bit Assignments
Assignments

7

6

5 4

3 2

1

I I I I I I I I
I~

0 ....,_Bit

Bit Number
Auxiliary Control
Control register
register
Auxiliary

I~
>0
Disable input
input latch on Port A
O Disable
1 Enable input
input latch
latch on Port A
0 Disable
Disable input
input latch
latch on Port B
1 Enable input
input latch on Port B

~

000
0 0 Disable Shift
Shift register
register
001 Shift
Shift in at Counter
Counter 2 rate
010
1 0 Shift
Shift in at <t>2
clock rate
4>2 clock
011 Shift
Shift in at external clock
clock rate
1 00 Free-running
Free-running output
output at Counter
Counter 2 rate
101 Shift
Shift out at Counter
Counter 2 rate
1 110 Shift
Shift out at $
2 clock
clock rate
tl>2
111 Shift
Shift out at external clock
clock rate
0 Decrement
Decrement Counter
Counter 22 on
on $
2 clock,
tl>2
clock,ininone-shot
one-shotmode
mode
1 Decrement
Decrement Counter
Counter 22 on
on external
externalpulses
PB6
pulsesinput
inputvia
via PB6
0
via PB7^
0 Disable
Disable output
output via
PB7}
1 Enable output
output via PB7 1
0 One-shot
One-shot mode
mode
1 Free-running
Free-running mode
mode

>Counter
Counter 1 controls
controls
|

t

Figure 11-10. 6522 VIA Auxiliary
Auxiliary Control
Control Register Bit Assignments
Assignments

11-26

CONFIGURING
CONFIGURING THE VIA
The program must select
select the logic connections in the VIA
STEPS IN
using it. This selection
before using
selection (or configuration) is usually
CONFIGURING
CONFIGURING
part of the startup routine. The steps are to establish
establish the
A VIA
directions of the I/O
1/0 pins by loading the Data Direction
directions
Direction register
register
Conand to select the required
required logic connections
connections in the VIA by loading the Peripheral Con­
trol register and, if necessary,
necessary, the Auxiliary
Auxiliary Control
Control register.
1/0 pins
pins as follows:
You can establish the directions of the I/O
s:
1I) A '0
·o•
' in a bit in the Data Direction register
register makes the
corresponding pin an input. For example, a '0'
O' in bit 5 of
Data Direction
Direction Register A makes pin PA5 an input.

ESTABLISHING
ESTABLISHING
VIA
VIA PIN
DIRECTIONS
DIRECTIONS

21 A '•V1' in a bit in the Data Direction register
2)
register makes the
corresponding pin an output. For example, a '1' in bit 3 of Data Direction
corresponding
Direction Register
PB3 an output.
B makes pin PB3
output.
1/O pins are fixed after the initialization
The directions
directions of almost
almost all I/O
initialization since most input
input and
output
output lines transfer
transfer data in only one direction
direction (i.e
(i.e.,.. the microprocessor
microprocessor will
ill never fetch
keyboard).
data from a printer
printer or send data to a keyboard).
are:
Some simple examples of setting
setting directions
directions are:
1)
1)

LDA
STA

LINES INPUTS
INPUTS
#00
;ALL LINES
VIADDRA

2)
2)

LDA
STA

#$FF
;ALL LINES
LINES OUTPUTS
OUTPUTS
VIADDRB

3)
3)

LDA
STA

#$F00
;MAKE LINES
LINES 4-7 OUTPUTS,
OUTPUTS. 0-3 INPUTS
INPUTS
#$F
VIADDRB

You can mix inputs
inputs and outputs
directions of inoutputs on a single port by establishing
establishing the dii
dividual
dividual pins appropriately.
appropriately. Port B is buffered
buffered so that its contents
contents can be read correctly
correctly
even when it is being used for output;
output; Port A is not buffered
buffered so that its contents
contents can be
read correctly
correctly only if it is lightly
lightly loaded (or designated
designated as inputs).

Configuring the VIA is difficultlt because of its many funcfunc­
tions, Most
1/0 port functions are controlled by the
tions.
ost of the I/O
Peripheral Control register, and we shall discuss these first.
Some points to remember
remember are:

,------..
VIA
VIA PERIPHERAL
CONTROL
REGISTER
REGISTER

Reset clears
clearsall
allthe
the VIA
VIA registers,
registers, making
making all
all lines
lines inputs
inputs and
1) Reset
and disabling
disabling all
all inter­
interrupts. All edge detection
detection facilities
facilities are set to trigger
trigger on falling
falling edges (high-to-low
(high-to-low
transitions).
21 Bits
Bits 0-3
0-3 of
ofthe
the Peripheral
PeripheralControl
Control register
2)
register are
areused
usedto
to establish
establish the
the logic
logiccon­
connections for control lines CA11 and CA2; bits 4-7 have the same purposes for
CB1 and CB2.
control lines CB1
3) Control
Control lines
lines CA1
CA 1 and
and CB1
CB1 are
are always
always inputs.
inputs, The
The only
only choice
choice isis whether
whether the
the
corresponding
corresponding status latches (Interrupt
(Interrupt Flag register
register bits 1 and 4 —
see Figure
-see
11-11) are set on falling
falling edges (high-to-low,
(high-to-low, or negative, transitions)
transitions) or on rising
edges (low-to-high,
(low-to-high, or positive, transitions).
transitions). For CA1, bit 0 = 0 for falling edges and
1 for rising edges; for CB1, bit 4 = 0 for falling
falling edges and 1 for rising edges.
edges.
4) Control
Control lines
linesCA2
CA2 and
-8 and
andCB2
CB2 can
canbe
beeither
either inputs
inputs or
oroutputs
outputs (see
(seeTables
Tables 11
11-8
and
11-9). For CA2, bit 3 = 1 to make it an output
11-9).
output and 0 to make it an input.

1 1-27
27

C82
Table 11-8. Configurations
Configurations for 6522 VIA Control
Control Line CB2

PCR7

PCR6

PCR6
PCR5

Mode

0

0

0

Interrupt Input Mode -— Set CB2 Interrupt
Interrupt flag
Interrupt
(IFR3)
negative transition
transition of the CB2 input
input
(IFR3) on a negative
Pesignal. Clear IFR3
rite of the Pe­
IFR3 on a read or write
ripheral B Output
utput register.
ripheral

0

0

1

IFR3 on
-SetSet IFR3
Independent Interrupt
Interrupt Input
Input Mode —
Independent
a negative
negative transition
transition of the CB2 input
input signal.
ORB does not clear the Interriting ORB
Inter­
Reading or writing
rupt
rupt flag.

0

1

0

posiInput Mode -— Set CB2 Interrupt
Interrupt flag on a posi­
Input
tive transition
transition of the CB2 input
input signal. Clear the
ORB.
CB2 Interrupt
Interrupt flag on a read or write
rite of ORB.

0

1

1

posiIFR3 on a posi­
-SetSet IFR3
Independent Input
Input Mode —
Independent
tive transition
transition of the CB2 input
input signal. Reading or
writing
ritin g ORB
Interrupt
ORB does not clear the CB2 Interrupt
flag.

1

0

0

utput Mode -— Set CB2 low on a
Handshake Output
acReset CB2 high with
write
rite ORB
ith an ac­
ORB operation. Reset
tive
transition of the CB11 input
input signal.
tIve transition

1

0

1

Pulse Output
utput Mode -— Set CB2 low for one cycle
ORB operation.
following
follow
ing a write
write ORB

1

1

0

Manual Output
utput Mode -— The CB2 output
output is held
Manual
mode.
low in this mode.

1

1

1

Manual Output
utput Mode -— The CB2 output
output is held
Manual
mode.
In this mode.
high in

1 1-28
28

Table 11-9. Configurations
Configurations for 6522 VIA Control Line CA2

Mode

PCR3

PCR2

PCR1
PCR1

0

0

0

Input
-SetSet CA2 Interrupt
(IFRO)on a
Input Mode —
Interrupt flag (IFRO)
negative transition
transition of the input
input signal. Clear IFRO
!FRO
on a read or write
rite of the Peripheral A Output
utput
register.
register.

0

0

1

Independent
IFROon
Independent Interrupt
Interrupt Input
Input Mode -— Set IFRO
signal.
a negative transition
transition of the CA2 input
input signal.
Reading or writing
ritin g ORA does not clear the CA2
Interrupt
flag.
Interrupt flag.

0

1

0

Input
posiInput Mode -— Set CA2 Interrupt
Interrupt flag on a posi­
!FRO
tive transition
transition of the CA2 input
input signal. Clear IFRO
with
ith a read or write
rite of the Peripheral A Output
Output
register.
register.

0

1

1

Independent
!FROon
Independent Interrupt
Interrupt Input
Input Mode -— Set IFRO
a positive transition
transition of the CA2 input
input signal.
Reading or writing
ritin g ORA does not clear the CA2
Interrupt
flag.
Interrupt flag.

1

0

0

Handshake Output
utput Mode -— Set CA2 output
output low
on a read or write
rite of the Peripheral A Output
utput
Reset CA2 high with
register. Reset
ith an active transition
on CA1.

1

0

1

-CA2
for one cy­
cyPulse Oulput
utput Mode —
CA2 goes low for
read or write
cle following
ing a read
rite of the Peripheral A
Output
utput register.

1

1

0

Manual Output
utput Mode -— The CA2 output
output is held
low in this mode.
mode.

1

1

1

Manual Output
utput Mode -— The CA2 output
output is held
mode.
high in this mode.

1 1 -29
29

6

4

3

2

0

~- Bit Number

--IR_Q__ ,...T_1....,_T_2____ C_B_1
-.--C-B-2....,_S_R-.-C-A-1 __ C_A_2-.J.--IRQ

T1

T2

CB1

SR

CA1

2

3

4

5
6

6

7

Interrupt Flag register

- Interrupt Flag register

Cleared By

Active
Active transition
transition of the signal
on the CA2 pin.

Reading or writing
Reading
writing the A Port Output
register
(ORA) using address
address 0 001.
register (ORA)
01.

Active transition
transition of the
the signal
Active
1

CA2

Sat
e By

Bit No.
No.

0

CB2

on the CA11 pin.

writing the A Port Output
Output
Reading or writing
register
register (ORA), using
using address
address 0000 1l..

Completion
Completion of eight shifts.
shifts.

Reading or writing
~he Shift
Reading
writing the
register.

Active
Active transition
transition of the signal

Reading or writing
Reading
writing the 8
B Port

on the CB2 pin.

Output
Output register.
register.

Active
Active transition
transition of the signal
CB1 pin.
on the CB1

Reading or writing
Reading
writing the B Port
Output register.

Time-out"
e-out of Timer
er 2.

Reading
low-order counter or
Reading T2 low-order

writing
writing T2 high-order
high-order counter.
1.
Time-out
e-out of Timer
er 1.

Reading T1
T1 low-order
Reading
low-order counter or

Active
Active and enabled interrupt
interrupt
condition.
condition.

Action
Action which
which clear interrupt
interrupt
condition.
condition.

writing
writing T11 high-order
high-order latch

1. 3, and 4 are the I/O
1/0 handshake signals. Bit 7 (IRQ)
(IRQ) is 1 if any of the interrupts
Bits 0, 1,
interrupts is both active
and enabled (see
(see Chapter 12).
21.

11-11 The 6522 VIA Interrupt
Figure 11-11
Interrupt Flag Register

11-30
11
30

Further functions are as follows:
follows:

CA2 Input
Bit 2 = 1 to trigger
trigger on a rising edge, 0 to trigger
trigger on a falling
falling edge.
edge.
Bit 1 = 1to make Interrupt
O (the CA2 input
Interrupt Flag register bitit 0
input status latch) independent
independent
of operations
operations on I/O
operations on I/O
1/0 Port A,
A. 0 to have that bit cleared by operations
1/0 Port
A.
The independent
independent mode is useful when CA2 is being used for purposes (such as a real­
realtime clock) that
1/0 port. The
that are completely
completely unrelated to the data transfers through
through the I/O
regular mode is useful when
when CA2 is being used as a handshaking
handshaking signal which
hich must be
1/0 operation (see
(see Figures 11-5 and 11-6).
11-6).
cleared to prepare for the next I/O

CA2 Output
Bit 2 =
= 1 to make CA2 a level,
level. 0 to make it a pulse
pulse
If CA2 is a level,
level. bit 1 is its value

have
CA2
low
when
the CPU
transfers
to ordata
fromto or from
If CA2 is a pulse, bit
bit1 is Oto 1
is 0
to go
have
CA2
go low
when the
CPUdata
transfers
1: bit 1 is 1 to
Port A and remain low until
until an active transition
transition occurs on CA1;
to have
have
CPU transfers data to or from Port A.
CA2 go low for one clock cycle after the CPU
CB2 is handled exactly
exactly the same (using bits 7, 6, and 5 of the Peripheral Control
Control register
and bit 3 of the Interrupt
Interrupt Flag register) except
except that pulses are produced on CB2 only
after data is written
B. To produce a pulse after reading data,
data. you must use a
ritten into Port B.
"dummy
is:
"dum m y write",
rite ", that is:

:GET DATA
PORT B
LDA
FROM FROM
PORT B
VIAORB;GET DATA
LOAVIAORB
:PRODUCE
STROBE
PORT B
STAVIAORB
STROBE
FROM FROM
PORT B
VIAORB;PRODUCE

VIA
VIA INPUT
1/0 port function
The only I/O
function governed by the Auxiliary
Auxiliary Control
register (Figure 11-10) is input
O (for
LATCHES
LATCHES
input latching.
latching. Bit 0
(for Port
Port A)
A) or
or bit
bit 11
Bl must
(for port B)
must be set to latch the input
input data on
onthe
theactive
active transitransi­
tion on control
(as determined
register!. Note the
control line 1 (as
determined by the Peripheral Control register)
following
ing features
features of the latching function:
1)
1)

RESETdisables the input
PIA.
RESET
input latches. The 6522 VIA then operates like the 6520 PIA,
which
which has no input
input latches.

2)

For Port A, the data that
that is latched will
ill always be the data on the peripheral
peripheral pins.
Since Port A is not buffered, that data may not be the same as the data in the Outut­
put register when
output.
when the port is being used for output.

3)

B, the data that is latched is either
For Port B,
either the data on the peripheral
peripheral pins (for those
pins defined
defined as inputs) or the contents
contents of the Output
utput register (for those pins defined
as outputs!.
outputs).

Some simple examples
examples of activating
activating the input latches are:
LDA
LOA
STA

#%
00000001
#%00000001
VIAACR
VIAACR

:ACTIVATE
ON PORT
PORT A
iACTIVATE LATCH
LATCH ON

A

LDA
LOA
STA

#%
00000010
#%00000010
VIAACR
VIAACR

:ACTIVATE
ONPORT
PORT B
ACTIVATE LATCH
LATCH ON

B

LOA
LDA
STA

#%00000011
#%
00000011
VIAACR
VIAACR

:ACTIVATE
PORTS A AND
ACTIVATE LATCHES ON PORTS
AND B

Note that
that 6522 output
output ports are autom
atically latched, just
just like 6520 output
output ports.
automatically
ports.

11-31
11-

EXAMPLES OF VIA CONFIGURATION
1)

(as needed for
A simple input port with
ith no control lines (as
a set of switches):
switches):
LDA
LOA
STA
STA

#0
VIAPCR
VIAPCR
VIADDRA
VIADDRA

VIA
CONFIGURATION
CONFIGURATION
EXAMPLES
EXAMPLES

;MAKE
;MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
:MAKE PORT
LINESA LINES
INPUTSINPUTS
;MAKEAPORT

Remember
Remember that
that Reset clears all the internal
internal registers so that this sequence may not
even be necessary. The same sequence
sequence can be used if a high-to-low
high-to-low edge (falling
Ready.
edge) on control
control line CA11 indicates
indicates Data Ready or Peripheral Ready.

2)

(as needed for a set of single LED
LED disA simple output
output port with
ith no control lines (as
dis­
plays):
LDA
LOA
STA
LDA
LOA
STA

##0
VIAPCR
VIAPCR
#$FF
#$FF
VIADDRB
VIADDRB

;MAKE ALL CONTROL
.MAKE
CONTROLLINES
LINESINPUTS
INPUTS
;MAKE PORT
,MAKE
PORT B LINES OUTPUTS
OUTPUTS

3) An
An input
input port
port w
with an
an active
active low
low-to-high DA
TA READY
READY signal
signalattached
attached to
to CA
DATA
CA11
(as needed for an encoded
encoded keyboard):
LOA
LDA
STA
LOA
LDA
STA

##0
0
VIADDRA
VIADDRA
#1
#1
VIAPCR
VIAPCR

;:MAKE PORT
PORT A LINES
LINES INPUTS
INPUTS
;MAKE RISING
RISING EDGE
EDGE ACTIVE
:MAKE

Peripheral Control
Control register
register is set so as to recognize low-to-high
-to-high transitions
transitions
Bit 1 of the Peripheral
1. Such a transition
(see
on control
control line CA1.
transition will
ill set bit 1 of the Interrupt
Interrupt Flag register
register (see
Figure 11
11-10): reading the data from the port will
(see the table associated
ill clear that bit (see
11-11).). Input
O of the Auxiliary
Conwith
ith Figure 11
Input latching
latching can be provided
provided by setting
setting bit 0
Auxiliary Con­
trol register.

4) An
An output
output port
port that
that produces
produces aa brief
brief strobe
strobe to
to indicate
indicate DATA
DATA READY
READY or
orOUT­
OUTultiplexing displays
displays or for providing
providing a DATA
PUT READY (this could be used for multiplexing
AVAILABLE
AVAILABLE signal to a printer!:
printer):
LOA
LDA
STA
LOA
LDA
STA

#$FF
#$FF
VIADDRB
VIADDRB
#%10100000
#% 1
0100000
VIAPCR
VIAPCR

:MAKE PORT
PORT BLINES
LINES OUTPUTS
;MAKE
OUTPUTS

The brief
brief strobe
strobe on control
control line CB2 will
ill occur
occur after every output
output operation. Bit 7 of the
Peripheral
Oto
pulse.
Peripheral Control
Control register
register is 1 to make CB2 an output.
output, bit 6 is 0
to make CB2 a pulse,
and bit
bit 55 isis 11 to
to make
make CB2
CB2 aa brief
brief (one
lone clock
clock cycle)
cycle) pulse
pulse follow
following each
each output.
output.

ith aa handshake
5) An
An input
input port
port wwith
handshake Input
Input Acknowledge
Acknowledge strobe
strobe that
that can
canbe
beused
usedto
to
tell
tell a peripheral that
that the previous data has been accepted
accepted (and that the comcom­
puter
more)·
puter is ready for more):
LOA
LDA
STA
LOA
LDA

##0
0
VIADDRA
VIADDRA
#%00001000
#%
00001000

;MAKE
INPUTS
;MAKE PORT
PORT AALINES
LINES INPUTS
;CONTROL
HANDSHAKE
:CONTROL LINE
LINE 22 = HANDSHAKE
ACKNOWLEDGE
; ACKNOWLEDGE

control line CA2 will
ill occur
occur after
after every input
input or output
output operation. It will
ill re­
The strobe on control
remain low until
Conuntil the next active
active transition
transition on control
control line CA1. Bit 3 of the Peripheral Con­
trol register
Oto
Oto
register is 1 to make CA2 an output,
output, bit 2 is 0
to make CA2 a pulse, and bit 1 is 0
to
make CA2 an active-low
active-low acknowledgm
ent that lasts until
until the next active transition
transition on
acknowledgment
CA1. Note that
O of the Peripheral
that the active
active transition
transition on CA11 is a falling
falling edge since bit 0
Control
Is suitable
CRT terminals
Control register
register is 0. This configuration
configuration is
suitable for many CRT
terminals that require a
complete
complete handshake.

11-32
11
32

6)

An output
output port with
ith a latched
latched active-low
active-low control
control bitit (latched
(latched output
output or level
output).
output). Such
Such an output
output bit
bit can be used to turn
turn a peripheral
peripheral on or off
off or to control
control
its mode of operation.
operation.
LOA
LDA
STA
STA
LOA
LDA
STA
STA

#$FF
#$FF
VIADDRB
VIADDRB
#%11000000
#% 1
VIAPCR
VIAPCR

:MAKEPORT
PORT 8
LINESOUTPUTS
OUTPUTS
;MAKE
BLINES
:CONTROLLINE
LINE2 2 =
= LATCHED
;CONTROL
LATCHED ZERO
ZERO LEVEL
LEVEL

Bit
Bit 7 = 1 to make control
control line
line CB2 an output.
output, bit
bit 6 = 1 to make it a level or latched
latched bit.
bit,
and bit
zero. This bit
bit 5 = 0 to make the active
active level zero.
bit is not affected
affected by operations
operations on the
1/0 port
I/O
port or Output
utput register:
register; its value can be changed
changed by changing
changing bit
bit 5 of the Peripheral
Peripheral
Control
Control register.
register, i.e.,..
LDA
LDA
ORA
STA
LDA
LOA
AND
STA

VIAPCR
00100000
#% 00
100000
VIAPCR
VIAPCR
11011111
#% 1
1011111
VIAPCR

:MAKE
;MAKE LEVEL ONE

;MAKE
;MAKE LEVEL ZERO

You can use this configuration
configuration to produce
produce an active-high
active-high or active-low
active-low strobe or to propro­
vide pulses with
ith software-controlled
software-controlled lengths.

11-33

TRANSFER DATA
USING THE VIA TO TRANSFER
Once the VIA has been configured.
configured, you may use its data registers
VIA INPUT/
INPUT/
PIA). The common
like any other memory location (just as with
ith the PIA).
OUTPUT
data. status,
status. and control
ways to transfer data,
control are with
ith the instructions
instructions
Accumulator.
Load Accum
ulator, Store Accumulator.
ulator, Bit Test,
Output
Test. and Compare. Note that Output
Register A can be addressed in two ways —
- one with
handshaking (address
(address 1)
1) and one
ith handshaking
ithout
(address F).
F). The address w ith
ithout
w ith
o u t handshaking
handshaking (address
o u t handshaking
handshaking allows you to use
CA11 independently
1/0 Port A. That control
independently of the peripheral
peripheral attached
attached to I/O
control line could be
alarm. clock input.
used for an alarm,
input, control
control panel interface.
interface, or extra control
control input
input from
another peripheral. The Interrupt
Interrupt flag for that input
another
input can be cleared directly
directly by clearing
Flag register (see
(see Figure 11-11).). The alternate
the appropriate
appropriate bits in the Interrupt
Interrupt Flag
alternate ad­
ad•
dress for Output
utput Register A and the independent
independent modes for control
control lines CA2 and CB2
CB2
ithout
allow use of control
control lines w ith
o u t having to worry about the automatic
atic handshaking
features of the VIA.

1 1-34
34

REGISTER
VIA INTERRUPT
INTERRUPT FLAG REGISTER
(see Figure
VIA
We have mentioned
mentioned the VIA Interrupt
Interrupt Flag register (see
VIA INTERRUPT
Figure 11-11 exFLAG REGISTER
REGISTER
11-11) on severalI occasions. The table in Figure
ex­
FLAG
plains the meanings of the various bits (bit 7 is a general inin­
terrupt
enabled).
terrupt request bit that is 1 if any interrupt
interrupt is both active and enabled).

explicitly
Any of the flags in the Interrupt
Interrupt Flag register may be exp
licitly cleared by writing
riting
a logic 1 into the corresponding
corresponding bit position. This procedure
procedure is useful when the concon­
trol lines are being used independently
(as in the independent
independently of the data ports (as
independent input
input
remode described in Tables 11-8 and 11-9) or when no data transfers are actually
actually re­
quired in response to the flag being set.
set. Some examples of explicitly
xplicitly clearing the flags
are:
are:
LDA
STA

#%00000010
00000010
VIAIFR
VIAIFR

;CLEAR
CLEAR CA11 INTERRUPT
INTERRUPTFLAG
FLAG

LDA
STA

#%00001000
00001000
VIAIFR
VIAIFR

;CLEAR C82
INTERRUPTFLAG
FLAG
;CLEAR
CB2 INTERRUPT

LDA
STA

%11111111
#% 1
1111111
VIAIFR
VIAIFR

;CLEAR ALL INTERRUPT
INTERRUPTFLAGS
FLAGS
;CLEAR

The value written
ritten into bit 7 does not matter.
matter, since that flag cannot
cannot be explicitly
explicitly set or
CPU.
cleared from the CPU.

Flag register often serve as handshake status bits
Bits 0, 1, 3, and 4 of the VIA Interrupt
Interrupt Flag
Ready or Peripheral Ready.
Ready. You can check their
such as Data Ready
their values with
ith appropriate
appropriate
masking or shifting
shifting operations.
LDA
AND
BNE
BNE

VIAIFR
VIAIFR
#%00000010
00000010
DEVRDY
DEVRDY

FLAG SET?
SET?
;IS CA11 FLAG
;YES, DEVICE
DEVICE READY
READY
;YES.

LDA
AND
BNE
BNE

VIAIFR
VIAIFR
00010000
#% 00
0 10000
DEVRDY
DEVRDY

CB1 FLAG
FLAG SET?
SET?
;IS CB1
;YES. DEVICE
DEVICE READY
READY
;YES.

automatically
The flag is then autom
atically cleared by reading or writing
riting the appropriate
appropriate port or by
following
explicitly
xplicitly clearing
clearing the bit in the Interrupt
Interrupt Flag register. The follow
ing program will
ill wait
wait
for a Ready flag attached
attached to input
input CA11 to go high:
WAITR

LDA
LDA
AND
BEQ
BEG

VIAIFR
VIAIFR
#%
00000010
#%00000010
WAITR
WAITR

;ISCA1
CA1 FLAG
FLAG SET?
;IS
SET?
;NO,WAIT
WAIT
;NO,

1. or
How would
would you change these programs to handle Ready lines attached
attached to CA2, CB1,
CB2?
CB2?

that the flag will
ill remain set unless some operation clears it. If no operation is
Note that
actually required.
required, some dummy
m y operation (such as reading the port and discarding
discarding the
actually
cases where
data) will
ill be necessary simply
simply to clear the flag. Be particularly
particularly careful
careful in cases
CPU is not ready for data or has no output
the CPU
output data to send. Obviously, careful docudocu­
mentation
cases where the purposes of operations may be far from ob­
obmentation is essential in cases
vious.
vious.

11-35
11
35

ERS9,
VIA TIM E
R S 9' 10
As we noted earlier.
counter/timers.
earlier, the VIA contains
contains twoo 16-bit
16-bit counter/tim
ers.
These timers
timers are handled
handled as follows:
follows:

|!VIA
VIA TIMERS
TIMERS! |

They may
may be
be read
read or
orw ritte
written as
assix
six memory
memory locations,
locations, four
fourfor
fortim
timer
andtw
two
1) They
er 11and
o
(see Table
for timer
er 2 (see
Table 11-7).
Their modes
modes of
of operation
operation are
are controlled
controlled by
by bits
bits 5,
5, 6,
6, and
and 77 of
of the
the Auxiliary
Auxiliary
2) Their
Control register
register (see Figure 11-10).
11-10),
Their status
status may
may be
be determined
determined by
by examining
examining bits
bits 55 and
and 66 of
of the
the Interrupt
Interrupt
3) Their
(see Figure 11-11).).
Flag register
register (see
The timers can be used as follows:
follows:
1) To
To generate
generate aa single
single time
time interval.
interval. The
The tim
timer
must be
be loaded
loaded wwith
the number
number of
of
er must
ith the
clock
clock pulses that
that are required.
required.
To count
count pulses
pulses on
on pin
pin PB6
PB6 (timer
(timer 22 only).
only). The
The tim
timer
must be
be loaded
loaded wwith
the
2) To
er must
ith the
number
number of pulses to be counted.
counted. This use of PB6 takes precedence
precedence over its normal
1/0 pin.
use as an I/O
To generate
generate continuous
continuous tim
time
intervals (timer
(timer 11 only)
only) for
for use
use in
in real-time
real-time ap­
ap3) To
e intervals
plications. The timer
er must
must be loaded with
ith the number
number of clock pulses per interval.
4) To
To produce
produce aa single
single pulse
pulse or
oraa continuous
continuous series
series of
of pulses
pulses on
onpin
pin PB7
PB7 (timer
(timer 11
only). The timer
er must be loaded with
ith the number
number of clock pulses per interval. This
1/0 pin.
use of PB7 takes precedence
precedence over its normal use as an I/O

1 1-36
36

OPERATION OF 6522
OPERATION
6522 VIA TIMER
TIMER 2
Timer
Timer 2 is simpler than timer
er 1 and can be used only to generate
generate a single time inin­
terval
terval (the one-shot
one-shot mode) or to count pulses on pin PB6. Bit 5 of the Auxiliary
Auxiliary ConCon­
trol register
register selects the mode:
Bit 5 = 0 for one-shot
one-shot mode, 1 for pulse-counting
pulse-counting mode.
(see Table 11-7). The first
The 16-bit
16-bit timer
er occupies
occupies two memory
memory locations
locations (see
first address is
used to read or write
write the 8 least significant
significant bits;
bits: reading this address also clears the
timer
er 2 interrupt
interrupt flag (Figure 11-11).). The second address is used to read or write
rite the 8
most significant
insignificant bits; writing
ritin g into this address loads the counters,
counters, clears the timer
er 2 in­
terrupt
terrupt flag, and starts the timing
ing operation.
operation. The completion
completion of the operation
operation sets the
timer
er 2 interrupt
interrupt flag (bit 5 of the Interrupt
Interrupt Flag register
register as shown
shown in Figure 11-11).).

Examples of timer
er 2 operation are as follows:
s:
1)
1)

elapse.
Wait
a it for 1024 (040015)
(0400-|6> clock pulses to elapse.

WAITD
WAITD

LOA
LDA

#00

STA
STA
LOA
LDA
STA
LOA
LDA
BIT
BEO
BEQ
LDA
LOA
BAK
BRK

VIAACR
VIAT2L
#44
VIAT2H
#% 00
100000
%00100000
VIAIFR
VIAIFR
WAITD
WAITD
VIAT2L
VIAT2L

:PUT TIMER
TIMER 2 IN ONE-SHOT
ONE-SHOT MODE (BIT
(BIT
;PUT
;: 5 ==00)
)
PULSE LENGTH
LENGTH 0400
HEX
;MAKE PULSE
0400 HEX
;START TIMING INTERVAL
;GET MASK FOR
FOR TIMER 2 INTERRUPT
INTERRUPT FLAG
FLAG
;GET
TIMER 2 FLAG SET?
SET?
;IS TIMER
;NO, INTERVAL
INTERVAL NOT COMPLETED
COMPLETED
;NO,
;YES, CLEAR
CLEAR INTERRUPT
INTERRUPT FLAG
FLAG
;YES,

following
Note the follow
ing steps in the program:
a)
a)

Putting
Putting the timer
er in the one-shot
one-shot mode by clearing
clearing bit 5 of the Auxiliary
Auxiliary Control
Control
register.

b) Loading
Loading the
the tim
timer
the initial
initial count
count (0400-)
(040015)
required to
to give
give the
the correct
correct inter­
interb)
er wwith
ith the
g) required
val. Loading
Loading the MSBs of the timer
er also starts the timing
ing operation.

d
Waiting
for the
the interval
interval to
to be
be completed.
completed. AA tim
timeout sets
sets bit
bit 55 of
of the
the Interrupt
Interrupt Flag
c) W
aiting for
register.
d)

Clearing
Clearing the interrupt
interrupt flag so that it does not interfere
interfere with
ith other
other operations. The inin­
struction LDA
VIAT2L performs
performs this function.
function.
struction
LOA VIAT2L

Generate aa delay
delay of
of length
length given
given by
by 10
10 pulses
pulses on
on pin
pin PB6.
PB6.
2) Generate

WAITC

LDA
LOA
STA
LDA
LOA

#00
VIADDRB
#% 0 0
1 00000
00100000

STA
LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
BIT
BEQ
BEO
LDA
LOA
BRK
BAK

VIAACR
#10
10
VIAT2L
VIAT2L
#0
VIAT2H
#%00100000
% 0 0 100000
VIAIFR
VIAIFR
WAITC
VIAT2L
VIAT2L

;MAKE PORT
PORT B INPUTS
INPUTS
;PUT TIMER
TIMER 2 IN PULSE-COUNTING
PULSE-COUNTING MODE
(BIT 5 = 1)
(BIT
;MAKEPULSE
PULSE COUNT 10

;START PULSE
PULSE COUNTING
COUNTING
GET MASK FOR
INTERRUPT FLAG
;GET
FOR TIMER
TIMER 2 INTERRUPT
FLAG
;IS TIMER
TIMER 2 FLAG SET?
SET?
NO, COUNT
;NO.
COUNT NOT COMPLETE
COMPLETE
;YES,
CLEAR INTERRUPT
INTERRUPT FLAG
YES. CLEAR

This program
program is the same as the previous
previous example, except
except that the mode of timer
er 2
is different.
different. Here the input
input on pin PB6 could be a periodic
periodic clock line or a line that is
simply
simply pulsed with
ith each occurrence
occurrence of some external
external operation.
1 1-37
37

OPERATION OF 6622
OPERATION
6522 VIA TIMER 1
Timer 1 has four operating modes (see
(see Figure 11-10) which allow it to generate a
single time-interval
mode) or a continuous
continuous series of intervals (free-runsingle
e-interval (one-shot mode)
(free-run­
ning mode).
mode). Furthermore.
Furthermore, each loading operation can generate an output
output pulse on PB7
which
hich can be used to control
control external hardware. Bits 6 and 7 of the Auxiliary
Auxiliary Control
register determine
determine the mode of timer
er 2 as follows:
follows:
Bit 7 = 1 to generate output
PB7, 0 to disable such pulses (in the free-runoutput pulses on pin PB7,
free-run­
ning mode,
mode. PB7 is inverted each time the counter
zero).
counter reaches zero).
Bit 6 = 1 for free-running
mode. 0 for one-shot mode.
mode.
free-running mode,

Timer 1 occupies four memory addresses
addresses (see
(see Table 11-7). The first
first twoo addresses
are used to read or write
rite the counters. Writing
ritin g into the second address loads the councoun­
adters, clears the timer
er 1 Interrupt
Interrupt flag, and starts the timing
ing operation. The next two ad­
dresses are used to read from or write
ithout
dresses
rite into the latches w ith
o u t affecting
affecting the counters.
This allows the generation
mode. Writing
generation of complex
complex waveforms
waveforms in the free-running
free-running mode.
riting
into the most significant
significant bits of the latches also clears the timer
er 1 interrupt
interrupt flag.
Examples of timer 1 operation are as follows:
1)
1)

(100015)
Wait
ait for 4096
4096 (1000-|
q) clock
clock pulses to elapse before producing
producing an output
output on pin
PB7.
PB7.

WAITD

LOA
LDA

#0

STA
STA
LOA
LDA
STA
LOA
LDA
BIT
BEO
BEQ
LOA
LDA
BRK
BRK

VIAACR
VIAT1L
# $10
10
VIAT1CH
01000000
#% 0
1000000
VIAIFR
VIAIFR
WAITD
VIAT1L

TIMER 1 IN SINGLE
SINGLE PULSE,
PULSE.NO OUTPUT
OUTPUT
;PUT TIMER
MODE
: MODE
;PULSE LENGTH
LENGTH =
= 1000 HEX
HEX
:PULSE
;START TIMING INTERVAL
INTERVAL
;START
;GET MASK FOR
FOR TIMER
TIMER 1 INTERRUPT
INTERRUPTFLAG
FLAG
;GET
TIMER 1 FLAG
FLAG SET?
SET?
;IS TIMER
;NO. INTERVAL
INTERVAL NOT COMPLETED
COMPLETED
;NO.
;YES, CLEAR
CLEAR TIMER
TIMER 1 INTERRUPT
INTERRUPTFLAG
FLAG
:YES,

The only changes from the program for timer
er 2 are the different
different addresses used to load
the pulse length
length and the different
different bit position
position (bit 6 instead of bit 5) that is examined for
the interrupt
interrupt flag.
2)

an interrupt
Produce an
interrupt every 2048 (080015)
1 g) clock pulses and produce a continuous
continuous
half-width
pulses.
series of cycles on pin PB7 with
ith a half-w
idth of 2048 clock pulses.
LOA
LDA
STA
LOA
LDA

#$FF
#$FF
VIADDRB
VIADDRB
#%11000000
#%
11000000

STA
LOA
LDA
STA
LDA
LOA
STA
BRK
BRK

VIAACR
VIAACR
#0
#0
VIAT1L
VIAT1L
##8
8
VIAT1CH
VIA
TIC H

;MAKE PORT
PORT B
B LINES
LINES OUTPUTS
OUTPUTS
;MAKE
;PUT
;PUT TIMER
TIMER 11 IN
IN CONTINUOUS
CONTINUOUS MODE
MODE WITH
WITH
OUTPUT TO
TO PB7
PB7
:; OUTPUT

;MAKE PULSE
PULSE LENGTH
LENGTH 0800
0800 HEX
HEX
;MAKE

;START TIMING
TIMING INTERVALS
INTERVALS
:START

This routine
routine will
ill produce a continuous
continuous series of intervals that
that will
ill be marked by the setset­
ting of the timer
Flag register). The main program
er 1 Interrupt
Interrupt flag (bit 6 of the Interrupt
Interrupt Flag
can look for the occurrence
occurrence of each interval
interval (with the waiting
aiting routine
routine from Example 1).).
(see Chapter 12).
12).
or (more sensibly) the end of each interval
interval can produce an interrupt
interrupt (see
PB7 will
The level on PB7
ill be inverted
inverted at the end of each timer
er interval
interval (it will
ill go low when
the first
first interval
interval starts). Timer 1 will
ill run continuously
continuously with
ith the values in the latches auau­
zero.
tomatically
atically being reloaded into the counters
counters each time the counters
counters reach zero.

11-38
11
38

THE 6 5
530
532
FUNCTION SUPPORT DEVICES
3 0 AND 6 5
3 2 MUL Tl
LTIFU N C
6530 and 6532
6532 devices contain memory as welll as I/O
The 6530
1/0
ports. They
They are sometimes
sometimes referred to as combination
hips,
ultifunction
upport
evices,
ch
ip s , m u lt if
u n c t io n s u p
p o rt d e v
ic e s , or ROM
ROM
(RAM)/1O/TIMER
has:
(RAMl/IO/TIMER chips (RIOTs). The 6530
6530 device has:
•
•
•

6530
6530 AND 6532
6532
MULTIFUNCTION
MUL Tl
FUNCTION
DEVICES

1024
1024 bytes of ROM
64 bytes of RAM
Two
1/0 ports (A and B).
Bl. although
Two 8-bit
-b it I/O
although pins 5 through
through 7 of Port Bare
are often used for
chip
chip selects and an interrupt
interrupt output
output
One 8-bit
-b it timer
timer

Figure 11-12 is a block diagram
diagram of the 6530
6530 device and Table 11-10 describes its interinter­
nal addressing.
addressing. The 6532
6532 device
device has:
•
•

128 bytes
bytes of RAM
Two
1/0 ports (A and B),
B), although
Two 8-bit
-b it I/O
although pin 7 of Port A is often used as a strobe input
input
comparable
device.
comparable to pins CA11 or CB11 of a 6520
6520 or 6522 device,
One 8-bit
8-bit timer
timer

Figure 11-13 is a block diagram
11-11 describes its interdiagram of the 6532
6532 device and Table 11-11
inter­
nal addressing.
ROM.
addressing. Note that
that 6532
6532 devices contain
contain no ROM.

ing features
features of 6530
6530 and 6532
6532 devices should
The following
should be noted:
1) Neither
Neither contains
contains any
any dedicated
dedicated I/O
1/0 control
control lines,
lines, although
although pin
pin 77 of
of Port
Port AA on
on aa6532
6532
1)
device can be used for this purpose.
Both contain
contain aa single
single 8 -b
8-bit tim
timer
prescaler that
that allows
allows tim
timing
intervals wwith
2) Both
er wwith
ith aa prescaler
ing intervals
ith
1. 8,
8. 64.
multiplying
ultiplying factors
factors of 1,
64, or 1024 clock pulses. The timer can thus be used to
provide intervals
intervals far longer
longer than the basic 256 clock counts.
provide
3)

The end of the timing
ing interval
interval either
either causes an interrupt
interrupt or sets a flag which
which can be
read.
read.

The 6530
6530 and 6532 devices are used in such popular
popular single-board
single-board microcomputers
icrocomputers as
the KIM, VIM, SYM,
IM-65.11-14
SYM. and A IM
-65.11’ 14

11-39

~

h

~

£

SS

"'
u

.,__

,,

.....

1/0 Port A

,,,.,'

...
J

s

■15.

a o. cc d •c'lcc

0.

'.

'l

S3 S3

0

I ... |

--

l

h

•

i

t

I

1/0 Port
Pon B
I/O
Control

and
and
Select logic
logic

1/0 Port
Pon A
I/O
~

Oireclion
Data Direction

,.,.

I/O
1/0 Port
Pon B

Direction
Data Direction

register

§ .................o

register

~

Interval
Interval
Timer

L J
Data
Buffer
Buffer

64 Bytes

-

,,

j'

r

r

Data

1024
1024 Bytes

of

of

RAM
RAM

ROM
ROM

Figure 11-12. Block Diagram of the 6530 Multifunction
ultifunction Device

1 1-40
40

Internal Addressing
Addressing for the 6530
6530 Multifunction
ultifunction Device
Table 11-10. Internal
Pim
ary Select
elect
Pimary
Accessed locations
Locations
Accessed

RAM
AM

I/O
Tim er
1/0Timer

Selecr
elect*

Select•
elect*

\1

X

X

directly address one of 1024
1024 ROM bytes
AO
AO - A9 directly

0

\1

0

d1rectly address one of 64 RAM bytes
AS directly
AO - A5

RSO
RSO

Secondary
Secondary
Select
elect

0
0
0
0
0
0
0
0
0
0
0
0

0

!

0
0
0
0
0
0
0
0
0
0
0
0

Interpretation
Interpretation

A3

A2

A1
A1

AO
AO

1

X

0

0 Port A
Access I/O

X

0
0

0

1

\1

Access I/O
Dtreclion register
1/0 Port A Data Direction

\1
\1

0

Access
Port B
Access I/O0 Port

\1

Access I/O
D1rect1onregister
_!L£Port B Data Direction

\1

X

\1

X

0
0
0

1W
\W

0

\1

X

X

Disable IRQ
IRQ

1W
\W

\1

\1

X

X

Enable
IRQ
Enable IRQ

1W
\W

X

\1

0

0

1W
\W

X

0

\1

\W
1W

X

\1
\1

\1

0

Write to timer, then decrement every
every <t>2pulse
Wnte
pulses
<tl2 pulses
every 8 <t>2
Write to timer, then
decrement every
then decrement
Write
Write to timer,
<P2pulses
timer, then decrement every 64 <t>2
Wnte

1W
\W

X

1

1

\1

Write to timer.
timer, then
decrement every 1024
4>2pulses
1024 <t>2
then decrement
Write

1R
IA

X

1

X

0

Read
Read timer

\R
1R

X

\1

X

\1

Read
interrupt flag
Read interrupt

j

<P2

*• R AM s elect a nd I /
O s elect are 't r
u e ” if 1,
ls e '' if 0; true a nd false are fu n ctions
n s of y our
"false"
1, or ' f a
"true"
1/0

"true"
s p e c ific
a tio n . Y ou s p ecify the c o m bination
in a tio n of a d dress lines t hat c reate a "tru
e ” line c o n dition.
ification.

1.
re p resents " d
o n 't c are".
” . Bits may be 0 or 1.
"don·t
1R re p resents S elect d uring a re ad.
1
W re p resents S elect d uring a w rite..
lW
X

11-41

PAO
PAO

PA77

PBO
PBO

IRQ

1/0 Po,t A

P87
PB7

co
™1
^
(J UICE CC
ICC

1/0 Po,t
I/O
Port B

Interrupt Logic
Logic

Control
Control
and
and

1/0 Port A
I/O

1/0 Port B
I/O

Interval
Interval

Data Direction
D1rect10n
Data
Register
Register

i

Timer

’

Selec1Logic
Logic
Select

Owectt0n
Data Direction

Register
Register

Data

n

Data

Buffer
Buffer

AO

A6

T
128 Bytes
Bytes
128

00

07

of

RAM
RAM

Figure 11-13. Block Diagram of the 6532 Multifunction
ultifunction Device

Table 11-11

Internal Addressing
Addressing for the 6532 Multifunction
ultifunction Device
Internal
Secondary Select
elect
Secondary

Primary
ary Select
elect

\

RAM

I/O
Tim er
I/0Timer

Select

Select
elect

11
0

Interpretation
Interpretation
A4

A3

A2

A1
Al

AO
AO

0

X

X

X

X

X

AO - A6 directly
addressesone
AO
directly addresses
one of 128
128 RAM
RAM bytes
bytes

1

X

X
X

0

0

0

Access
AccessI/O
1/0 Port
Port A

0

1

X

X

0

0

1

Access
AccessI/O
1/0 Port
Port A Data
Data Direction
Directionregister
register

0

1

X

X
X

0

1

0

Access
AccessI/O
1/0 Port
Port B

0

X

X
X

0

1

1

Access
AccessI/O
1/0 Port
Port B
8 Data
Data Direction
Directionregister
register

0

1
1W
tW

1

0

1

X

X

Disable
DisableIRQ

0

1W
1W

1

1

1

X

X

Enable
EnableIRQ
iRa

iRo

0

1W

1

X

1

0

0

Write to timer, then decrement every <t>2
Write
4>2 pulse
pulse

0
0

1W
1W

1

X

1

0

1

Write to
pulses
to timer,
timer, then
then decrement
decrement every
every 8 <t»2
<1>2
pulses

0

1W
1W

1

X

1

1

0

Write to
pulses
to timer,
timer, then
then decrement
decrementevery
every 64 <l>2
<1>2
pulses

0

1W
1W

1

X

1

1

1

Write to timer, then decrement every 1024 4>2
Write
4>2 pulses
pulses

0

1R
lR

X

X

1

X

0

Read timer

0

1R
lR

X

X

1

X

1

Read interrupt flags

0

1W

,w

0

X

1

X

0

Request interrupt on high-to-low
high-to-low PA7 transition
transittOn

0

1W

0

X

1

X

1

Request interrupt
interrupt on low-to-high PA7 transition
Request
transition

0

1W
1W

0

X

1

0

X

Enable
EnabtePA7
PA7 interrupt
interruptrequest
request

0

1W
1W

0

X

1

1

X

OisabtePA
interruptrequest
Disable
PA7 interrupt
request

X
X

represents
"don't
represents
"don'tcare"
care”Bits
Bits
may
may
bebeO 0oror1.1.
lR
represents
access.
1Rrepresents
ReadRead
access.
1W lW
represents
WriteWrite
access.
represents
access.

1 1 -42
2

EXAMPLES
A Pushbutton
itch
Pushbutton S witch
Purpose:

To interface
interface a single
single pushbutton
pushbutton switch
switch to a 6502 microprocessor
microprocessor by means
Is a single mechanipushbutton is
Adapter. The pushbutton
Interface Adapter.
of a 6522 Versatile
Versatile Interface
echani­
pressed
'O') while
cal switch
switch that
that provides a contact
contact closure (logic level '0')
hile pressed

Figure 11-14 shows the circuitry
circuitry required to interface
interface the pushbutton.
pushbutton. It uses one bit of
hich acts as a buffer; no latch is needed since the pushbutton
pushbutton remains
a 6522 VIA, which
grounds the VIA input
button grounds
CPU clock cycles. Pressing the button
closed for many CPU
input bit. The
Is not being pressed
'1' if the button
pullup resistor ensures that
that the input
input bit is T
button is
pressed.
pullup

+55 vV
)

..

◄►
• ►

To CPU

6522
VIA

----1
)

P\Jshbutton

l

Pushbutton Circuit
Circuit
Figure 11-14. A Pushbutton

1 1-43
43

~

)
~

Programming Examples:
are:
We will
ill perform
perform two tasks with
ith this circuit.
circuit. They are:
a)
a)

Set a memory
memory location
location based on the state of the button.

b)
b)

Count
pressed.
Count the number
number of times that
that the button
button is pressed.

Task 1: Determine
witch
Closure
Determine S w
itch Closure

Purpose: Set memory location
location 0040
0040 to one if the button
button is not being pressed,
pressed. and to
pressed.
zero if it is being pressed.
Sample Cases:
1)
1)

Button
pressed)
Button open (i.e
(i.e.,.. not pressed)
Result== (0040) = 001
1

2)
2)

Button
pressed)
Button closed (ie
(i.e.,.. pressed)
Result== (0040) = 00

Flowchart:
Flowchart:
Start

100401= 0

Input and mask
pushbutton
data

10040) • I

End

Source Program:
Program:

DONE

LDA
STA
STA
STA
LDA
AND
BEQ
BEO
INC
BRK
BRK

#0
VIAPCR
VIADDRA
VIADDRA
$40
VIAORA
VIAORA
#MASK
ASK
DONE
$40

;MAKE
MAKE ALL CONTROL LINES INPUTS
:MAKE
MAKE PORT
PORT A LINES INPUTS
;MARKER== ZERO
MARKER
ZERO
;READ BUTTON POSITION
;IS BUTTON CLOSED (LOGIC
(LOGIC ZERO)?
ZERO)?
;YES.
DONE
YES, DONE
;NO.
NO, MARKER =1

11-44
11-44

Object Program:
Program:
Object
Memory Location
(Hex)
(Hex)

0000
0001
0002
00031
0003}
0004)
0005
0006)
0006}
00071
0008
0009
000A
OOOA
000B)
0008}

A9
00
8D

000D
OOOE
000E

29
MASK
FO
FO
02
E6
E6
40
00

oooct
oooc
OO
OF
OOF
0010
0011
0012
0013

Instruction
Instruction
(Mnemonic)

Memory Contents
(Hex)
(Hex)

LDA
LOA

#0

STA

VIAPCR
VIAPCR

STA
STA

VIADDRA

STA

$40

LDA
LOA

VIAORA
VIAORA

AND

#MASK
ASK

BEQ
BEO

DONE
DONE

INC
INC

$40

VIAPCR
VIAPCR
8D
VIADDRA
85
40
AD
VIAORA

DONE
DONE

BRK
BRK

Register
(Data Direction Register
The addresses
register). VIADDRA (Data
(Peripheral Control register).
VIAPCR (Peripheral
addresses VIAPCR
A),
A). and VIAORA (Output Register A) depend on how the VIA is connected in your
microcomputer. The VIA control
control lines are not used in this example; the contents of the
microcomputer.
prePeripheral Control register are thus irrelevant
irrelevant but we have
have cleared that register as a pre­
case) that the
(as is usually the case)
assumed (as
caution against spurious operations. We have assumed
zero.
VIA addresses
addresses are not on page zero.
MASK depends on the bit to which
hich the pushbutton
pushbutton is connected; it has a one
one in the
button position and zeros
elsewhere.
zeros elsewhere.
button

Mask
Mask

Button Position
(Bit Number)

Binary

Hex

0
1
2
3
4
5
6
7

00000001
00000010
00000010
00000100
00000100
00001000
00001000
00010000
00010000
00100000
00100000
01000000
01000000
10000000
10000000

01
01
02
04
08
10
20
40
80

11-45
11-45

port. the program
If the button
button is attached
attached to bit 6 or bit 7 of the VIA input
input port,
program can use a Bit
Test instruction
instruction to set the Overflow
Overflow or Sign bits and thereby
thereby determine
determine the button's
button's
example.
state. For example,
Bit 7
BIT
BPL
BPL

VIAORA
VIAORA
DONE
DONE

;IS BUTTON
BUTTON CLOSED
(LOGIC ZERO)?
;IS
CLOSED (LOGIC
ZERO)?
;YES. DONE
DONE
;YES,

Bit 6
BIT
BVC

VIAORA
VIAORA
DONE
DONE

;IS BUTTON
BUTTON CLOSED
(LOGIC ZERO)?
;IS
CLOSED (LOGIC
ZERO)?
;YES. DONE
DONE
:YES.

6.
Note the use of BVC or BVS to check the value of bit 6.
0. 6, or 7.
7. TheseWe could also use shift
shift instructions
instructions if the button
button is attached
attached to bits 0,
se­
quence
O is:
is:
quence for bit 0
LSR
LSR
BCC
BCC

VIAORA
VIAORA
DONE
DONE

;IS BUTTON
BUTTON CLOSED
:IS
CLOSED (LOGIC
(LOGIC ZERO)?
ZERO)?
;YES. DONE
DONE
;YES,

ROL can be used with
The instructions
instructions ASL or ROL
ith bits 6 or 7. Do the contents
contents of the VIA
Data register
register actually
actually change?
change? Explain your answer.

11-46

Task 2: Count S witch
itch Closures
Closures

Purpose: Count
Purpose:
Count the number
number of button
button closures by incrementing
Incrementing memory location 0040
after each closure.
Sample Case:
Pressing the button
button ten times after the start of the program should give

(0040) = 0A
Note: In order to count
count the number
number of times that the button
button has
SWITCH
has
BOUNCE
pressed. we must be sure that each closure causes a single
been pressed,
I BOUNCE
transition. However,
However. a mechanical
mechanical pushbutton
pushbutton does not produce a
single transition
transition for each closure,
closure. because the mechanical
mechanical contacts
contacts bounce back and
forth before settling
settling into their final positions. We can use
eliminate the
use hardware to eliminate
bounce or we can handle it in software.

DEBOUNCING
The program can debounce
debounce the pushbutton
pushbutton by waiting
aiting after it
DEBOUNCING
IN SOFTWARE
SOFTWARE
finds a closure. The required delay is called the debouncing
debouncing
IN
time and is part of the specifications
specifications of the pushbutton
pushbutton. It is
typically
typically a few milliseconds
milliseconds long. The program should not examine the pushbutton
pushbutton durdur­
ing this period because it might
ing
ight mistake the bounces for new closures.
closures. The program
may either
either enter a delay routine
routine like the one described previously or may simply per­
perform other
other tasks for the specified amount
amount of time.
time.
Even after
Even
after debouncing.
debouncing, the program must still wait for the present closure to end before
looking for a new closure. This procedure avoids double counting.
looking
counting. The following
following pro­
prouses a software delay of 10 ms to debounce the
gram uses
ant to try
the pushbutton.
pushbutton. You may want
varying the delay or eliminating
inating it entirely
entirely to see
what happens.
see what
happens. To run this program,
program.
you must also enter the delay subroutine
you
subroutine into memory starting
starting at location 0030.

Flowchart:
Start

Count= 0

Count = Count + 1

Debounce button
with 10 ms
wait

11-47

Source Program:
Program:
Source

CHKCL
CHKCL

':HKOP
CHKOP

LOA
LDA
STA
STA
STA
STA
STA
STA
LOA
LDA
AND
AND
BNE
BNE
INC
INC
LOY
LDY
JSR
JSR
LOA
LDA
AND
AND
BEO
BEQ
BNE
BNE

# 0#0
VIAPCR
VIAPCR
VIADDRA
VIADDRA
$40
$40
VIAORA
VIAORA
#MASK
#M A
SK
CHKCL
CHKCL
$40
$40
#100
#1
DELAY
DELAY
VIAORA
VIAORA
#MASK
#M
ASK
CHKOP
CHKOP
CHKCL
CHKCL

;MAKE
;MAKE ALL
ALLCONTROL
CONTROLLINES
LINESINPUTS
INPUTS
;MAKE
;MAKE PORT
PORTAALINES
LINESINPUTS
INPUTS
;COUNT
;COUNT ==ZERO
ZEROINITIALLY
INITIALLY
;IS
;ISBUTTON
BUTTON BEING
BEINGPRESSED?
PRESSED?
;N0.
AIT UNTIL
.NO.WWAIT
UNTIL ITITISIS
;YES.
;YES.ADD
ADD 11TO
TOCLOSURE
CLOSURECOUNT
COUNT
;W
;WAIT 10
10 MS
MS TO
TO DEBOUNCE
DEBOUNCE BUTTON
BUTTON

:IS
;IS BUTTON
BUTTON STILL
STILL BEING
BEINGPRESSED?
PRESSED?
;YES.W
; YES.
AIT FOR
WAIT
FORRELEASE
RELEASE
;NO,
:NO. LOOK
LOOK FOR
FORNEXT
NEXT CLOSURE
CLOSURE

11-48
11
-48

Object Program:
Object
Memory Location
Location
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
00031
0003}
0 004
041
0005
0005
0006)
0006}
0007)
0007
0008
0008
0009
0009
000A
OOOA
000B)
000B}
oooc
000C)
000D
0000
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018
0019)
0019}
001AA)
001BB
001C
001C
001D
0010
001E
01E
001F
01F
0020
0020

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)
A9
00
80
8D

LDA
LOA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

STA

$40

LOA
LDA

VIAORA

AND

#MASK

BNE
BNE

CHKCL
CHKCL

INC
INC

$40

LOY
LDY

#10
10

JSR
JSR

DELAY

LDA
LOA

VIAORA

AND

#MASK
#MASK

BEQ
BEO

CHKOP
CHKOP

BNE
BNE

CHKCL

VIAPCR
8D
80
VIADDRA
VIADDRA
85
40
AD

CHKCL

VIAORA
29
MASK
MASK
DO
DO
F9
E6
E6
40
AO
OA
OA
20
30
00
AD

CHKOP
CHKOP

VIAORA
29
MASK
MASK
FO
FO
F9
DO
DO
E9
E9

The three instructions
instructions beginning
beginning with
ith the label CHKOP
determine when
when the
CHKOP are used to determine
switch reopens.
switch
simple interface
interface. An addressable
addressable tn-state
tri-state
Clearly we do not really need a VIA for this simple
buffer would
ould do the job at far lower cost.
buffer

11
-49
1-49

A Toggle Switch
itch
Purpose: To interface
interface a single-pole.
single-pole, double-throw
double-throw (SPDT)
switch to a 6502
(SPOT) toggle switch
microprocessor.
microprocessor. The toggle is a mechanical
mechanical device that is
either in the nor­
Is either
normally closed (NC)
(NC) position
(NO) position.
position or the normally
normally open (NO)
Circuit
ircuit Diagram:
DEBOUNCING
Figure 11-15 shows the circuitry
circuitry required to interface
interface the
DEBOUNCING
switch.
WITH
switch. Like the pushbutton.
pushbutton, the switch
switch uses one bit of a 6522
WITH
CROSS-COUPLED
VIA that serves as an addressable buffer. Unlike the button.
button, the
CROSS-COUPLED
NANO
switch
switch may be left in either
either position.
position. Typical
Typical program tasks are
NAND GATES
to determine
determine the switch
switch position
position and to see if the position has
has
changed. Either a one-shot
one-shot with
ith a pulse length
length of a few milliseconds
illiseconds or a pair of crosscrosscoupled
NANO gates (see
(see Figure 11-16) can debounce
coupled NAND
debounce a mechanical
mechanical switch.
switch.

+5 V

To CPU
Debounce
C1rcu1t

6522
VIA

NO

Figure 11-15. An Interface
Interface for a Toggle Switch
Switch

+5 V

To 1/0 port (VIA)

Figure 11-16. A Oebounce
Debounce Circuit
Circuit Based
Cross-coupled NAND
Based on Cross-coupled
NANO Gates
Gates

11-50
11-50

posiresponse to a change in switch
The circuits
circuits will
ill produce
produce a single step or pulse in response
switch posi­
switch bounces before settling
settling into its new position.
tion even if the switch

Programming
Programming Examples:
are:
We will
ill perform two tasks involving
involving this circuit.
circuit. They are:
1)
1)

closed.
Set a memory
memory location to one when
when the switch
switch is closed.

2)
2)

changes.
Set a memory location to one when the state of the switch
switch changes.

witch
Task 1: Wait
ait for S w
itch to Close
Is closed and then is set to
Purpose:
Memory location
location 0040
0040 is zero until
until the switch
switch is
Purpose: Memory
one;
0040, waits for the switch
is. the processor clears memory location 0040.
one: that is.
one.
to be closed,
closed. and then sets memory location 0040 to one.
The switch
itch could be marked Run/Halt.
Run/Halt, since the processor will not proceed until
until the
switch
itch is closed.

Flowchart:
Start

10040) = 0

10040) = 1

End

Program:
Source Program:

WAITC

LDA
LOA
STA
STA
STA
LDA
LOA
AND
BNE
BNE
INC
INC
BRK
BAK

#0
VIAPCR
VIAPCR
VIADDRA
$40
VIAORA
#MASK
ASK
WAITC
$40

INPUTS
LINES INPUTS
CONTROL LINES
;MAKE ALL CONTROL
INPUTS
LINES INPUTS
PORT A LINES
;MAKE PORT
ZERO
;MARKER== ZERO
MARKER
READ SWITCH
POSITION
SWITCH POSITION
;READ
CLOSED ('O')?
;IS SWITCH CLOSED
CO')?
NO. WAIT
:NO.
YES. MARKER
ONE
MARKER = ONE
;YES.

1 1 -51

Object Program:
Object
Memory
Location
MemoryLocation
(Hex)
(Hex)
0000
0001
0001
0002
0003)
0003}
0004)
0005
0006)
0006}
0007)
0008
0009
000A
OOOA
OOOB)
000B}
OOOCi
000D
0000
000E
OOOE
000F
OOOF
0010
0011
0011
0012
0013

oooc

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Contents
MemoryContents
(Hex)
(Hex)

A9
A9
00
8D
80

LDA
LOA

#0

STA
STA

VIAPCR
VIAPCR

STA
STA

VIADDRA
VIADDRA

STA
STA

$40

LOA
LDA

VIAORA
VIAORA

AND
AND

#MASK
ASK

BNE
BNE

WAITC
WAITC

INC
INC

$40

VIAPCR
VIAPCR
8D
80
VIADDRA
VIADDRA
85
40
AD
AD

WAITC
WAITC

VIAORA
VIAORA
29
MASK
MASK
DO
DO
F9
F9
E6
E6
40
00

1 1-52
52

BRK
BRK

Switch
Task 2: Wait
ait for Sw
itch to Change

Purpose: Memory
Memory location
location 0040
0040 remains zero until
until the switch
switch position
position changes
changes and is
then set to 1;
1. ie.
i.e., the processor
processor waits
waits until
until the switch
itch changes
changes position.
position, then
sets memory
memory location
location 0040
0040 to 1.
Flowchart:
Flowchart:
Start

(0040)

=0

Old data

=

Sw,tch position

New data =
Switch pos1t1on

(0040) = 1

End

Source Program:
LDA
LOA
STA
STA
STA
LDA
LOA
AND
STA
WAITCH LDA
WAITCH
LOA
AND
CMP
BEQ
BEO
INC
BRK
BRK

#0
VIAPCR
VIADDRA
VIADDRA
$40
VIAORA
VIAORA
#MASK
ASK
$41
$41
VIAORA
VIAORA
#MASK
ASK
$41
WAITCH
WAITCH
$40

:MAKE ALL CONTROL LINES INPUTS
:MAKE PORT
PORT A LINES INPUTS
:MARKER = ZERO
ZERO
SWITCH POSITION
:GET OLD SWITCH

:GET NEW SWITCH
SWITCH POSITION
:ARE NEW AND
AND OLD POSITIONS THE SAME7
:YES.
YES, WAIT
AIT
NO, MARKER== ONE
;NO.

1 1-53
53

Object
Program:
Object Program:
Memory
Memory Location
Location
(Hex)
(Hex)
0000
0001
0002
0003)
0003}
0004
0004)
0005
0006)
0006}
0007
0007)
0008
0008
0009
OOOA
000A
000B)
000B}
oooc
000C1
000D
OOOE
OOOE
OOOF
OOOF
0010
0010
0011
0012)
0012}
0013
0013)
0014
0014
0015
0016
0016
0017
0018
0019
001A
001A
001BB
001C

Memory
Memory Contents
Contents
(Hex)
(Hex)
A9
00
8D

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LOA
LDA

#00

STA

VIAPCR

STA

VIADDRA

STA

$40

LOA
LDA

VIAORA

AND

#MASK
ASK

STA

$41

VIAPCR
8D

VIADDRA
VIADDRA
85
40
AD
VIAORA
29
MASK
85
41
AD

WAITCH
LOA
WAITCH LDA

VIAORA

AND

#MASK
ASK

CMP

$41

BEO
BEQ

WAITCH

INC
INC

$40

VIAORA
29
MASK
C5
41
FO
FO
F7
E6
E6
40
00

BRK
BRK

A Subtract
Subtract or Exclusive OR
instruction in the program. Either
OR could replace the Compare instruction
instructions would.
would, however.
however, change
change the contents
contents of the Accumulator.
Accumulator. The
of these instructions
Exclusive OR
would be useful if several switches
switches were attached
attached to the same VIA.
VIA, since
OR would
it would
would produce
produce a one bit for each switch
switch that
that changed
changed state. How would
would you rewrite
rewrite
this program so that
that it debounces
debounces the switch
switch in software?
software?

1 1-54
54

(Rotary, Selector, or Thumbwheel) Switch
A Multiple-Position
ultiple-Position (Rotary,
lead
Purpose: To interface
interface a multiple-position
ultipie-position switch
switch to a 6502
6502 microprocessor.
microprocessor. The lead
corresponding
corresponding to the switch
switch position
position is grounded.
grounded, while
hile the other leads are
high (logic ones)
ones).

Circuit
Circuit Diagram:
17 shows the circuitry
Figure 11-17
circuitry required to interface
interface an 8-position
8-position switch.
switch. The switch
switch
uses all eight
eight data bits of one port of a VIA. Typical
Typical tasks are to determine
determine the position
of the switch
itch and to check whether
whether or not that
that position
position has changed. Two special situasitua­
tions must
must be handled:
1) The
The sw
switch is
is temporarily
between positions
positions so
so that
thatnonoleads
leads are
1)
temporarily between
are grounded.
grounded.

The sw
switch has
has not
not yet
yet reached
reached its
its final
final position.
position.
2) The
The first
first of these situations
situations can be handled by waiting
aiting until
until the input
input is not all 'l's.
'Vs. i.e....
until
until a switch
itch lead is grounded.
grounded. We can handle the second situation
situation by examining
examining the
switch
switch again after
after a delay (such as 1 or 2 seconds) and only accepting
accepting the input
input when it
remains the same.
same. This delay will
ill not affect
affect the responsiveness of the system to the
switch.
switch. We can also use another
another switch
switch (i.e.,.. a Load switch)
switch) to tell the processor when
Id be read.
read.
the selector
selector switch
itch should

Programming Examples:
We will
ill perform
perform two tasks involving
involving the circuit
circuit of Figure 11-17. These are:

a) M
Monitor
the switch
switch until
until itit isisininaadefinite
definite position,
position. then
thendetermine
determine the
a)
onitor the
the position
position and
store its binary
memory location.
location.
binary value in a memory
b)

Wait
ait for the position
position of the switch
switch to change.
change, then store the new position
position in a
memory location.
memory

If the switch
switch is in a position.
position, the lead from that
that position
position is grounded
grounded through
through the comcom­
mon line. Pullup
Pullup resistors on the input
input lines avoid problems
problems caused by noise
noise.

7

PA 7

::: 6

t=
:::
5
4

::.

C~J

i=2
::: 1
-o

-

PA5
PA 5
PA 4
PA 3
PA 2
PA 1

To CPU

6522
VIA

~
-v

PAo

Common

Figure 11-17.
17. An Interface
Interface for a Multi-Position
ulti-Position Switch
Switch

1 1-55
55

l

witch
Task 1:: Determine
Determine S w
itch Position
Purpose: The program waits
Purpose:
aits for the switch
switch to be in a specific
specific position
position and then stores
the position
position number
number in memory
memory location
location 0040.
Table 11-12 contains
contains the data inputs
inputs corresponding
corresponding to the various switch
switch positions.
vs. Switch
Table 11-12. Data Input
Input vs.
Switch Position

Data Input
Sw
itch Position
witch
0
1
2
3
4
5
6
7

Binary

Hex
Hex

11111110
11111110
11111101
11111101
11111011
11111011
11110111
11101111
11011111
10111111
01111111
01111111

FE
FE
FD
FB
F7
EF
EF
OF
DF
BF
BF
7F

11 requires eight
eight bits to distinguish
distinguish among
This scheme
scheme is inefficient.
inefficient since it
eight
eight different
different positions.

USING
A TTL or MOS encoder
encoder could reduce the number
number of input
input bits
A TTL
needed. Figure 11-18 shows a circuit
circuit using the 74LS148
74LS148 TTL 8ENCODER
ENCODER
to-3 encoder.15
encoder.15 We
v\/e attach
attach the switch
switch outputs
outputs in inverse order,
since the 74LS148
74LS148 device
device has active-low
active-low inputs
inputs and outputs.
outputs. The
output of the encoder
encoder circuit
circuit is a 3-b,t
-b it representation
representation of the switch
switch position.
position. Many
output
switches
switches include
include encoders so that their outputs
outputs are coded.
coded, usually
usually as a BCD digitit (in
negative
negative logicl.
logic).

7
:::: 6

=

5

F4
-.:..::..3
2

i:::::
:::,

- T,io
-::- '213

14
15

:::::o

15
17

-

74LS148
8-to-3
Encoder

02

-

Oo

-

~,

PA2
::. PA1
PAo

To CPU

6522
VIA

µ

Common

-Figure 11-18. A Multiple-Position
ultiple-Position Switch
Switch with
ith an Encoder

11-56
11
56

The encoder
encoder produces
active-low outputs.
so. for example.
produces active-low
outputs, so.
example, switch
switch position
position 5,
which is
5. which
attached
2. produces
attached to input
input 2,
produces an output
output of 2 in negative
negative logic
logic (or 5 in positive
positive logic).
You may want
ant to verify
verify the double
double negative
negative for yourself.
yourself.
Flowchart:
Flowchart:
Start

Data Switch position

Position= 0

Shift data
right 1 bit

Yes

Position=

(0040) = Pos1t1on

Position + 1

End

Source Program:
LDA
LOA
STA
STA
CHKSW LDA
LOA
CMP
BEQ
BEO
LDX
LOX
CHKPOS ROR
ROR
BCC
INX
JMP
DONE
STX
BRK
BRK

#0
VIAPCR
VIADDRA
VIADDRA
VIAORA
VIAORA
#$FF
CHKSW
CHKSW
#0
A
DONE

CHKPOS
CHKPOS
$40

;MAKE
MAKE ALL CONTROL LINES INPUTS
:MAKE PORT
PORT A LINES INPUTS
;IS SWITCH
SWITCH IN A POSITION?
;NO.
NO, WAIT
AIT UNTIL IT IS
;SWITCH
SWITCH POSITION== ZERO
ZERO
;IS NEXT BIT GROUNDED POSITION?
;YES.
YES, SWITCH
SWITCH POSITION FOUND
;NO.
NO, INCREMENT SWITCH
SWITCH POSITION
;SAVE SWITCH
SWITCH POSITION

1 1-57
57

Program:
Object Program:
Memory Address
Memory
(Hex)
(Hex)
0000
00
0001
00
0002
0003)
0003}
0004 (
0004
0005
0 006}
06)
0007
0007)
0008
0008
00091
0009}
000A)
OOOA
000B
oooc
OOOC
000D
000E
OOOE
000F
OOOF
0010
00
00
0011
00
0012
0013
0014
0014
0015
0016
0017
0018
0019
0 0
1 A
001A
0000

Instruction
Instruction
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)
A9
00
8D
8

LOA
LDA

# 0

STA

VIAPCR
VIAPCR

STA

VIADDRA

LDA
LOA

VIAORA

CMP

#$FF

BEQ
BEO

CHKSW

LDX
LOX

#0

#0

00

VIAPCR
VIAPCR
8D

8 D

VIADDRA
CHKSW

AD
VIAORA
C9
FF
FF
FO
FO
F9
A2
0
00
6A
6
90
04
ES
8
4C
11
11
00
0
8
86
40
0
00

CHKPOS
ROR
CHKPOS ROR
BCC
BCC

DONE
DONE

# 0

A
DONE
DONE

INX
JMP

CHKPOS
CHKPOS

STX

$40

BRK
BRK

FF15.
faulty switch
itch or defective
defective VIA results in the input
input always being FF-|
0
Suppose that a faulty
How could you change
change the program
program so that it would
would detect
detect this error?
This program could easily be restructured
restructured to make it
shorter and faster -— and relocatrelocat­
11 shorter
CHKPOS: why is
BCS CHKPOS;
able as well. One option
option would
would be to replace JMP CHKPOS
ith BCS
CHKPOS with
this possible and what
hat improvements
improvements result'
result? Another
Another option
option would
would be to change the
initial conditions
conditions so that only one jumpp instruction
instruction was required. How would
would you
initial
increment
accomplish that? Hint: start with
ith FF-|g
ent X before
FF15 in Index Register X and increm
accomplish
shifting the Accumulator.
Accumulator.
shifting
This example
example assumes that the switch
switch is debounced
debounced in hardware
hardware How would
would you
program to debounce
debounce the switch
switch in software?
software?
change the program

1 1-58
58

Task 2: Wait
witch
ait For S w
itch Position To Change

Purpose: The program
program waits
waits for the switch
switch position
position to change
change and places
places the new
position
position (decoded)
(decoded) into
into memory
memory location
location 0040.
0040. The program
program waits
waits until
until the
ne-lv position.
switch
itch reaches
reaches its neOv
position.

Flowchart:
Flowchart:
Start

Old data=

Position = - 1

Switch position

Shift data right 1 bit

New data=

Position=
Position+ 1

Switch pos1t1on

10040) = Position

End

Source Program:
LDA
LOA
STA
STA
CHKFST LDA
LOA
CMP
BEQ
BEO
TAX
CHKSEC LDA
LOA
CMP
BEQ
BEO
CPX
BEO
BEQ
LDX
LOX
CHKPOS INX
ROR
ROR
BCS
STX
BRK
BRK

#00
VIAPCR
VIADDRA
VIADDRA
VIAORA
VIAORA
#$FF
#$FF
CHKFST
VIAORA
VIAORA
#$FF
#$FF
CHKSEC
CHKSEC
VIAORA
VIAORA
CHKSEC
CHKSEC
#$FF
#$FF
A
CHKPOS
$40

;MAKE
MAKE ALL CONTROL LINES INPUTS
:MAKE PORT
PORT A LINES INPUTS
;IS SWITCH
SWITCH IN A POSITION?
;NO,
NO. WAIT
AIT UNTIL IT IS
:SAVE OLD POSITION
:IS SWITCH IN A POSITION?
:NO,
NO. WAIT
AIT UNTIL IT IS
:IS POSITION SAME AS BEFORE?
BEFORE?
:YES,
FOR IT TO CHANGE
YES. WAIT
AIT FOR
:NO, START SWITCH
SWITCH POSITION AT -1
SWITCH POSITION = SWITCH
SWITCH POSITION +
+1
:SWITCH
;IS NEXT BIT GROUNDED?
,NO, KEEP
KEEP LOOKING
STORE SWITCH
SWITCH POSITION
:STORE

11-59
11-59

Object
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)

LOA
LDA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

LOA
LDA

VIAORA

CMP

#$FF
#$FF

BEO
BEQ

CHKFST
CHKFST

TAX
CHKSEC LDA
LOA
CHKSEC

VIAORA

A9
00
8D

0000
0000
0001
0002
0002
0003)
0003}
0004
0004)
0005
0005
0006)
0006}
0007
0007t
0008
0008
0009)
0009}
000A)
OOOA
000B
OOOB
oooc
000C
000D
OOOE
000E
OOOF
000F
0010
0010
0011)
0011}
0012
0012)
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018)
001B}
0019
0019)
001A
001A
001BB
001C
01C
001D
0010
001EE
001F
001F
0020
0020
0021
0022
0022
0023
0023
0024
0024

VIAPCR
8D

VIADDRA
VIADDRA
CHKFST

AD
VIAORA
C9
FF
FF
FO
FO
F9
AA
AD

VIAORA
C9
FF
FF
FO
FO
F9
EC
EC

CMP

#$FF
#$FF

BEO
BEQ

CHKSEC
CHKSEC

CPX
CPX

VIAORA

BEQ
BEO

CHKSEC
CHKSEC

LDX
LOX

#$FF
#$FF

VIAORA
FO
FO
F4
A2
FF
FF
E8
6A
BO
BO
FC
86
40
00

CHKPOS INX
ROR
ROR
BCS
STX

A
CHKPOS
CHKPOS

$40

BRK
BRK

An alternative
determining
alternative method
method for determ
ining if the switch
switch is in a position
position is:
CHKSW

INC
BEQ
BEO

VIAORA
VIAORA
CHKSW
CHKSW

Why
hy does this work?
work? What
hat happens
happens to the input
input data? Rewrite
Rewrite the program
program to use the
alternative method:
method; how much
much less memory
memory is required?
required?
alternative

11-60
11
60

LED
A Single LED
light-emitting
Purpose: To interface
interface a single light-em
itting diode to a 6502 microprocessor.
microprocessor. The LED
LED
can be attached
attached so that either
either a logic zero or a logic one turns it on.
on.
Circuit
Circuit Diagram:
F'igure 11-19 shows the circuitry
Figure
circuitry required to interface
interface an LED.
LED. The
LED
LED
LED lights
LED
lights when
when its anode is positive
positive with
ith respect to its cathode
cathode
CONTROL
CONTROL
(Figure 11-19a). Therefore,
Therefore. you can either
LED by groundeither light
light the LED
ground­
ing the cathode
cathode and having the computer
puter supply
supply a one to the anode (Figure 11-19b) or
by connecting
connecting the anode to +5 volts and having the computer
puter supply
supply a zero to the
cathode
11-19c).
cathode (Figure 11
-19 c). Controlling
Controlling the cathode
cathode is the most common
common approach. The
LED is brightest
LED
brightest when
when it operates from pulsed currents
currents of about
about 10 or 50 mA applied
applied a
LEDs have a very short turn-on
few hundred
hundred times per second. LEDs
turn-on time (in the microsecond
microsecond
range) so they are well
range)
well suited to multiplexing
ultiplexing (operating
(operating several from a single port). LED
LED
circuits usually
usually need peripheral
peripheral or transistor
transistor drivers
current-limiting
circuits
drivers and current-lim
iting resistors.
resistors. MOS
devices normally
LEDs directly
normally cannot
cannot drive LEDs
directly and make them bright
bright enough
enough for easy
viewing.
viewing.
However. the B port is normally
Note: The VIA has an output
output latch on each port. However,
normally used
for output.
capability. In particular,
particular. the B port outputs
output, since it has somewhat
somewhat more drive capability.
outputs
are capable of driving
driving Darlington
Darlington transistors
transistors (providing
(providing 3.0 mA m inim
um at 1.5 V).
inimum
V).
Darlington
Darlington transistors
transistors are high-gain
high-gain transistors
transistors capable of switching
switching large amounts
amounts of
current
speed: they are useful in driving
relays. and other devices.
current at high speed;
driving solenoids.
solenoids, relays,

1 1 -61

Anode
de
Cathode
Anodo^ ^ C a t h o

R

+svo
f5
V Q-

8

-W V -

and
50 mA and
current to 50
maximum current
should limit the maximum
a)
resistor R should
The resistor
circuitry. The
LEOcircuitry.
Basic LED
a) Basic
10 mA.
the average
average current to 10

l

From CPU

6522

Driver

VIA

MD

+5V
b)

LEO on.
CPU turns the LED
1· from the CPU
LED with positive logic. A logic •'1'
Interfacing an LED
+5V

R
From CPU
6 522

Driver
Driver

VIA

MD

c)
cl

·o·

01 the
drrver or
Interfacing an LED with
with negative
negative logic.
logic. A logic
logic '0 ' from
from the CPU turns
turns the LED on. The driver
Interfacing

CPU may invert the logic
logic levels.

LED
Interfacing an LED
Figure 11-19. Interfacing

1 1 -62
2

Task: Turn the Light On or Off

Purpose: The program
program turns
turns a single
single LED either
either on or off.
A.

Send a Logic
Logic One to the LED (turn a positive
positive display
display on or a negative
negative display
display off).

Source Program:
(form data initially)
initially)
LOA
LDA
STA
LOA
LDA
STA
LOA
LDA
STA
BRK
BRK

#0
VIAPCR
#$FF
#$FF
VIADDRB
#MASKP
#MASKP
VIAORB

:MAKE
LINES INPUTS
;MAKE ALL CONTROL LINES
:MAKE
PORT B LINES
LINES OUTPUTS
;MAKE PORT
:GET DATA
FOR LED
;GET
DATA FOR
:SEND DATA
LED
;SEND
DATA TO LED

The B side of the VIA is used because of the buffering.
buffering. The CPU can therefore
therefore read the
data from the output
output port.

(update
(update data)
LOA
LDA
ORA
STA
BRK
BRK

VIAORB
#MASKP
#MASKP
VIAORB

:GET OLD DATA
;GET
:TURN
ONON
LED
BITBIT
;TURN
LED
:SEND
;SEND DATA
DATA TO
TO LED
LED

MASKP has a one bit in the LED position
position and zeros elsewhere
elsewhere. Logically
Logically ORing with
ith
MASKP does not affect
other bit positions,
positions, which
values for other
affect the other
hich may contain
contain values
other
LEDs. Note that
LEDs.
that we can read the VIA Output
utput (Data) Register
Register even when
when the pins are
assigned
assigned as outputs.
outputs.

11-63

Object Program:
Program:
Memory
Memory Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

(form data initially)
initially)

B.
B.

0000
0000
0001
0002
0002
00031
0003}
0004
0004)
0005
0006
0007
0008)
0008}
0009
0009)
OOOA
000A
0008
000B
oooc
OOOC
000DI
0000}
OOOE
000E)
OOOF
000F
(update data)

A9
00
80
8D

00

BRK
BRK

0010
0010
0011}
0011)
0012
0012)
0013
0014
0014
0015
0016)
0016}
0017)
0017
0018

AD

LDA
LOA

VIAORB
VIAORB

ORA
ORA

#MASKP
#MASKP

STA
STA

VIAORB
VIAORB

LOA
LDA

#0

STA

VIAPCR
VIAPCR

LOA
LDA

#$FF

STA
STA

VIAODRB
VIADDRB

LOA
LDA

#MASKP
#MASKP

STA

VIAORB
VIAORB

VIAPCR
VIAPCR
A9
FF
FF
80
8D

VIADDRB
A9
MASKP
8D
80
VIAORB

VIAORB
09
MASKP
8D
80

VIAORB
VIAORB
00

BRK
BRK

LED (turn a positive display
Send a Logic Zero to the LED
display off or a negative
negative display on).
on).

The differences
differences are that MASKP must be replaced by its logical complement
complement MASKN
and ORA #MASKP
#MASKP must be replaced by AND #MASKN.
#MASKN. MASKN has
has a zero bit in the
the
LED position
LED
position and ones elsewhere. Logically
Logically ANDing
ANDing with
ith MASKN does not affect
affect the
the
other
other bit positions.

1 1-64
64

Seven-Segment
Seven-Segm
ent LED Display
Purpose: To interface
interface a seven-segment
seven-segment LED display to a 6502
6502 microprocessor.
microprocessor. The disdis­
play may be either
either common-anode
common-anode (negative logic) or common-cathode
common-cathode
(positive
(positive logic).
Circuit
Circuit Diagram:
Diagram:

COMMON-ANODE
COMMON-ANODE
Figure 11-20 shows the circuitry
circuitry required
required to interface
interface a
OR
seven-segment
one. two,
two.
OR
seven-segment display. Each segment
segment may have one,
COMMON-CATHODE
COMMON-CATHODE
or more LEDs
LEDs .attached
attached in the same way. There are two
DISPLAYS
DISPLAYS
ways of connecting
connecting the displays. One is tying
tying all the
cathodes
(see Figure 11-21a):
cathodes together
together to ground
ground (see
a); this is a
"common-cathode"
lights a segment. The other is
"com m on-cathode" display.
display, and a logic one at an anode lights
tying
(see Figure 11
11-21b);
bl: this is a
tying all the anodes together
together to a positive
positive voltage
voltage supply
supply (see
"common-anode"
"com m
on-anode" display.
display, and a logic zero at a cathode
cathode lights
lights a segment. So the common-cathode
mon-cathode display
display uses positive
positive logic and the common-anode
common-anode display
display negative
negative logic.
Either display
resistors
display requires
requires appropriate
appropriate drivers
drivers and resistors.
The Common
Common line from the display
display is tied either
either to ground or to +5 volts. The display
display
segments
customarily
segments are custom
arily labelled:
a

b

f

9
e

c

d
Note: The seven-segment
seven-segment display
display is widely
idely used because it contains
contains the smallest num-­
ber of separately
separately controlled
controlled segments
segments that
that can provide
provide recognizable
recognizable representations
representations of
all the decimal
(see Figure 11
11-22 and Table 11-13). Seven-segment
decimal digits
digits (see
Seven-segment displays
displays can
also produce
(see Table 11-14). Better representaproduce some letters and other
other characters
characters (see
representa­
16 Since
require a substantially
substantially larger number
number of segments
segments and more circu
itry.1®
tions require
circuitry.
seven-segment
seven-segment displays
displays are so popular.
popular, low-cost
low-cost seven-segment
seven-segment decoder/drivers
decoder/drivers have
become widely
idely available. The most popular
popular devices are the 7447 common-anode
common-anode driver
and the 7448 common-cathode
common-cathode driver:
river;17 these devices have Lamp Test inputs
inputs (that
turn all the segments
on) and blanking
segments on)
blanking inputs
inputs and outputs
outputs (for blanking
blanking leading or trailtrail­
ing zeros).
zerosl.

11-65
11-

De
Os
04

From CPU

~
---v

6522
VIA

MO

~

Di
o,

-

--

9

-

-

-

-

-

Oriva's

-

f
e

d

Dilplly

- b
C

Co

0

Common

..r-Ll

1)
+5V
PB7 may be used for a decimal point LED.

SV

(Common-

(Common-

Cathode)

Anode)

Figure 11-20. Interfacing a Seven-Segment Display

Table 11-13. Seven-Segment
Seven-Segment Representations of Decimal Numbers

Hexadecimal
Hexadecimal Representation
Representation
Number
0
1
2
3
4
5
6
7
8
B
9

Common-cathode

Common-anode

3F
3F
06
58
5B
4F
66
6D
60
70
7D
07
7F
67

40
79
24
30
19
12
12
02
78
00
18

Bit 7 is always zero and the others are g.
e, d. c.
g. f,I.e.
c. b,
b. and a in
In decreasing order of
significance.
significance.

11-66

a)

Common-cathode
Common-cathode

gO----------------- V A ( 0 ------------------------<W V- e

eO

W

r

d o ------------------------------- v w

-

co

-

w > -

b o --------------------- w v -

aO

W

r

b) Common-anode
Common-anode

+5V
5V

Q

g0

W

r

fO -------------------- v w eO

............

d o ------------------------------ v w

-

c o --------------------- w v -

bO--------------vw OO

V Ar

Figure 11-21. Seven-Segment
Seven-Segment Display
Display Organization
Organization

11-67

0: Segments
0:
Segments f, e,
e, d,
d. c.
C, b, a
I~ on

3: Segments g, d, c, b, a on
~
3:

a

a

ff

b
b

e

cC

b
b

9
c
C

d
d

d
d

1:
n
1: Segments c, b o~

4: Segments
4:
nts g,
g. f, c, b on
2!'

b
b

ff

b

lb
9
cC

cC

2: Segments g, e, d, b.
a on
b,12!!

5:
5: Segments
Segments g, f, d.
d, c, a on
~

a

a

ff

b
b

g
9

g
9

e

c
C

d

d

Figure 11-22
11-22. Seven-Segment
Seven-Segment Representations
Representations of Decimal
Decimal Digits
Digits

11-68
11-68

!!!.'
8:
e, d, c, b, a on
I, e.
g, f,
8: Segments g,

~
6: Segments
e, d, c, a on
Segments g, f, e.

a

a

b

fI

f

9g

9

e

e

C
c

c
C

d
d
Lamp Test.
as Lamp
This
same as
This is the same

d
d
Note that the alternate
j^ off may
representattOnwith..!.
alternate representation
be reserved
reserved for the lower case letter 'b'.

9:
2!:I
b, a on
c, b.
Segments g, f. c.
9: Segments

~
7: Segments
c. b, a on
Segments c,

a

a

f

b
b

b
b

9
c
C

c
C

also,
segment d on also.
has segment
An
altemate has
An alternate

Figure 11-22. Seven-Segment
Seven-Segment Representations
Representations of Decimal Digits (Continued)

Seven-Segment Representations of Letters and Symbols
Table 11-14. Seven-Segment

Lower-case Letters
Letters
Lower-case
and Special Characters

Letters
Upper-case Letters

Letter
Letter

A
C
E
F
H
I
J
L
0
pP
U
u
yY

Hexadecimal
Hexadecimal
Representation
Representation
Commoncathode

Commonanode

77
39
79
71
76
06
1E
1E
38
3F
73
3E
66

08
46
06
0E
OE
09
79
61
47
40
OC
oc
41
19

Character
Character

b
cC
d
h
n
0
0
r
u
-

?
?

1 1-69
69

Hexadecimal
Hexadecimal
Representation
Representation
Commoncathode

Commonanode
anode

7C
7C
58
5E
5E
74
54
5C
50
1C
1C
40
53

03
27
21
21
0B
OB
2B
28
23
2F
2F
63
3F
2C

Task 1:1: Display
Display aa Decimal
Decimal Digit
Digit
Task
Purpose: Display
Display the
the contents
contents of
of memory
memory location
location 0040
Purpose:
0040 on
onaaseven-segment
seven-segment display
display ifif
contains aa decimal
decimal d ig
digit. Otherwise,
Otherwise. blank
itit contains
blank the
the display.
display.
Sample Problems:
Problems:
Sample
(0040) ==05
05
a.a. (0040)
Result isis 55 on
on display
display
Result
(0040) == 66
66
b.b. (0040)
ResuIt isis aa blank
blank display
display
Result

Flowchart:
Flowchart:
Start

Code= Blank
Data = 10040)

Code = ISSEG +

Data)

Send code
to display

End

11
-70
11-70

Source Program:
Program:
Source

DISPLY

LDA
LOA
STA
STA
LDA
LOA
STA
STA
LDA
LOA
LDX
LOX
CPX
CPX
BCS
BCS
LDA
LOA

#
#00
VIAPCR
VIAPCR
#$FF
#$FF
VIADDRB
VIADDRB
#BLANK
#BLANK
$40
$40
#
10
#10
DSPLY
DSPLY
SSEG.X
SSEG,X

STA
BRK

VIAORB
VIAORB

;MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
:MAKE
MAKE PORT
PORT B
B LINES OUTPUTS
OUTPUTS
:MAKE
GET BLANK
BLANK CODE
CODE
:GET
GET DATA
DATA
:GET
IS DATA
DATA 10
10 OR
OR MORE?
MORE?
:IS
YES. DISPLAY
DISPLAY BLANKS
BLANKS
:YES,
SEVEN-SEGMENT
NO. CONVERT DATA
DATA TO SEVEN-SEGMENT
.NO.
: CODE
SEND CODE TO DISPLAY
:SEND

BLANK is
is 00
00 for
for a common-cathode
common-cathode display,
display, FF for
for a common-anode
common-anode display.
display. An alteralter­
BLANK
native procedure
procedure would
would be to put
put the blank
blank code
code at the end of the table
table and replace
replace all
native
improper
proper data
data values
values with
ith 10, i.e., the instructions
instructions after
after STA VIADDRB
VIADDRB are:

CNVRT

LDX
LOX
CPX
BCC
LDX
LOX
LDA
LOA

$40
#10
#10
CNVRT
#10
10
SSEG.X
SSEG,X

;GET
DATA
:GET DATA
;IS DATA
DATA 10 OR MORE?
MORE?
:IS
;YES.
REPLACE IT WITH 10
:YES. REPLACE
CODE
SEVEN-SEGMENT CODE
iCONVERT
DATA TO SEVEN-SEGMENT
:CONVERT DATA

Table SSEG
SSEG is either
common-cathode or common-anode
common-anode representation
representation of the
either the common-cathode
decimal digits
Table 11-13.
d1g1ts from Table
decimal

11-71
11-71

Object
Program:
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004
004)
0005
0005
0006
0006
0007
0007
0 008}
0 8)
0009
0009)
000A
000A
000B
OOOB
oooc
OOOC
000D
000E
000F
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015)
0015}
00161
0017
0017

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)
A9
00
8D

LDA

#00

STA

VIAPCR

LDA

#$FF
#$FF

STA

VIADDRB

LDA

#BLANK
#BLANK

LDX

$40

CPX
CPX

#10
10

BCS
BCS

DSPLY

LDA

SSEG.X
SSEG.X

STA

VIAORB

VIAPCR

A9
FF
FF
8D
VIADDRB
A9
BLANK
A6
40
E0
EO
0A
OA
BO
BO
02
B5
20
8D

DSPLY

VIAORB

BRK
BRK

00
SSEG
SSEG

0020-0029
0020-0029

(seven-segment
(seven-segment
code table)

displays may be multiplexed.
multiplexed, as shown
shown in Figure 11-23. A brief
brief strobe
strobe on concon­
Several displays
trol line CB2 clocks
RESET starts the
clocks the counter
counter and directs
directs data to the next display.
display. RESET
decimal
decimal counter
counter at 9 so that
that the first
first output
output operation
operation clears the counter
counter and directs
directs
data to the first
first display.
display.
ing program
program uses the delay routine
routine to pulse each of ten common-cathode
common-cathode
The follow
following
displays
ms.
displays for 1 ms.

11-722
11-

Task 2:
2: Display
Display Ten
Ten Decimal
Decimal Digits
Digits
Task
Purpose: Display
Display the
the contents
contents of
of memory
memory locations
locations 0040
0040 through
through 0049
0049 on
on ten
ten 7-seg7-seg­
Purpose:
with
ment displays
displays that
that are
are m
ultiplexed w
ith aa counter
counter and
and aa decoder.
decoder. The
The most
most
multiplexed
ment
significant d
ig it is
is in
in 0049.
0049.
digit
significant
Sample Problem:
Problem:
Sample
66
(0040)
(0040) = 66
3F
(0041)
(0041) = 3F
(0042) = 7F
7F
(0042)
7F
(0043)
(0043) = 7F
06
(0044) = 06
(0045) = 5B
(0046) = 07
(0047) = 4F
(004B) = 6D
(0048)
(0049) = 7D
B804
displays read 653721
6537218804
The displays
The cIrcuIt
circuit in
in Figure 11-23 uses the VIA handshake
handshake signal CB2 as a brief
brief output
output strobe
to indicate
occurrence of a data transfer.
1nd1catethe occurrence

Source Program:

SCAN
DSPLY

LDA
STA
LDA
STA
LDX
LDA
STA
JSR
JSR
DEX
DEX
BNE
BNE
BEQ
BEO

#$FF
#$FF
VIADDRB
#% 1
0100000
10100000
VIAPCR
VIAPCR
#10
10
$3F,X
$3F.X
VIAORB
VIAORB
DELAY

STROBE
READY STROBE
.PROVIDE DATA READY
;PROVIDE
;NUMBER OF DISPLAYS== 10
;NUMBER
DISPLAY
FOR DISPLAY
;GET DATA FOR
;GET
;SEND DATA TO DISPLAY
;SEND
;WAIT 1 MS

DSPLY
DSPLY
SCAN
SCAN

DISPLAYS
:COUNT DISPLAYS
;COUNT
SCAN
ANOTHER SCAN
;START ANOTHER
;START

OUTPUTS
LINES OUTPUTS
PORT B LINES
.MAKE PORT
;MAKE

pulse.
make it a pulse,
CB2 an output.
to make CB2
Peripheral Control register bit 7 = 1 to
output, bit 6 = 1 to make
DELAY
that subroutine
here that
have assumed here
make it a brief strobe. We have
and bit 3 = 1 to make
subroutine DELAY
has
ms wait.
transparent 1 ms
provide a transparent
to provide
modified to
has been modified

111-73
1-

Object Program:
Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)

;

0000
0000
0001
0002
0002
0003)
0003}
00041
0005
0005
0006
0006
0007
0007
00081
0008}
0009
0 9'
000A
000A
000B
0008
oooc
OOOC
000D
000E
000F)
000F}
00101
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)

LDA

#$FF
#$FF

STA

VIADDRB
VIADDR8

LDA

#% 1
0100000
10100000

STA

VIAPCR

SCAN

LDX

#10
10

DSPLY

LDA

$3F,X

STA

VIAORB
VIAOR8

JSR

DELAY

DEX
DEX
BNE
8NE

DSPLY

BEQ
SEO

SCAN

A9
FF
FF
8D
VIADDR8
VIADDRB
A9
AO
8D
VIAPCR

A2
0A
OA
85
B5
3F
·8D
VIAOR8
VIAORB
20
30
00
CA
DO
DO
F5
F0
FO
F1
F1

1 1-744

0D,, C.
significant, A
ID most significant.
and A (D
B, and
C, B.
least
significant) are the 4-bit output
ktast significant)

DO

actrlate
bits activate
from the counter.
Tilese 4 bits
counter. These
the correspondingly numbered output

hence the co,.
decoder.and hence
from the decoder,
cor

respondingly
respondingly numbered display.

D1

D2

D3

04

From CPU

6522
VIA
OS

06

D7

D8

09

9 88 77 66 55 4 4 3 32 2 1 0

D

Oock

7 490
Decade

7 4422

C

Counter

B

rR9
9

A

4 to 10
Decoder/Driver
Decoder/Driver

Reset

Interfacing Multiplexed
ultiplexed Seven-Segment
Seven-Segment Displays
Figure 11-23. Interfacing

1111-755

PROBLEMS

1))

An On-Off
n-O ff Pushbutton

Each closure of the pushbutton
Purpose: Each
pushbutton complements
complements (inverts) all the bits in memory
location 0040. The location
zero. The program should conlocation
location initially
initially contains
contains zero.
con­
tinuously
tinuously examine the pushbutton
pushbutton and complement
complement location
location 0040
0040 with
ith each
closure. You may wish to complement
complement a display
display output
output port instead, thus
making the results easier to see.
see.
Sample Case:
Location
Location 0040
0040 initially
initially contains
contains zero.
zero.
FF15,
The first pushbutton
pushbutton closure changes location
location 0040
0040 to FF
g, the second changes it
zero. the third back to FF
FF15,
back to zero,
q, etc. Assume that the pushbutton
pushbutton is debounced
debounced in
hardware. How would
would you include
include debouncing
debouncing in your program?

2)

ftware
Debouncing a S witch
itch in S o ftw
are

readings. taken a de­
dePurpose: Debounce
Debounce a mechanical
mechanical switch
switch by waiting
aiting until
until two readings,
bounce time apart,
apart. give the same result. Assume that the debounce
debounce time (in
ms) is in memory
ms)
memory location 0040 and store the switch
itch position
position in memory
location
location 0041.
Sample Problem:
(0040) = 03 causes the program to wait
ait 3 ms between
between readings.

3)

Control for a Rotary S witch
itch

Purpose: Another
nother switch
switch serves as a Load switch
switch for a four-position
four-position unencoded
unencoded rotary
switch.
CPU waits
zero), and then reads
reads
switch. The CPU
waits for the Load switch
switch to close (be zero),
the position
position of the rotary switch.
switch. This procedure
procedure allows the operator
operator to move
the rotary switch
CPU tries to read it. The pro­
switch to its final position
position before the CPU
program should place the position
position of the rotary switch
switch into memory location
0040. Debounce
Debounce the Load switch
switch in software.
Sample Problem:
Place rotary switch
itch in position
position 2. Close Load switch.
Result:

(0040) == 02

1111-76

4)

Record S witch
itch Positions on Lights

Purpose: A set of eight
eight switches
switches should have their
their positions
positions reflected
reflected on eight
eight LEDs.
LEDs.
That is to say,
say. if the switch
That
switch is closed (zero),
otherwise
(zero). the LED should be on,
on. otherwise
the LED should be off. Assume that
that the CPU output
output port
port is connected
connected to the
cathodes of the LEDs.
cathodes
LEDs.
Sample Problem:
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH
SWITCH

0
1
2
3
4
5
6
7

CLOSED
CLOSED
OPEN
OPEN
CLOSED
CLOSED
OPEN
OPEN
OPEN
OPEN
CLOSED
CLOSED
CLOSED
CLOSED
OPEN
OPEN

Result:
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED
LED

0 ON
1 OFF
OFF
2 ON
3 OFF
OFF
4 OFF
OFF
5 ON
ON
6 ON
7 OFF
OFF

How would
ould you change the program so that a switch
switch attached
attached to bit 7 of Port A of VIA
#2 determines
determines whether
whether the displays are active (i.e
(i.e.,.. if the control
control switch
itch is closed,
closed. the
displays attached
attached to Port B reflect the switches
switches attached
attached to Port A;
A: if the control
control switch
switch
is open,
open. the displays are always off)? A control
control switch
switch is useful when the displays may
distract
distract the operator, as in an airplane.
How would
would you change the program so that it makes the control
control switch an on-off
pushbutton:
is, each closure inverts the previous state of the displays? Assume
pushbutton; that is,
that the displays start in the active state and that the program examines and debounces
the pushbutton
the
pushbutton before sending data to the displays.

5)

Count on a Seven-Segm
ent Display
Seven-Segment

Purpose: The program should count
Purpose:
count from 0
to 9 continuously
Oto
continuously on a seven-segment
seven-segment dis­
display.
starting with zero.
play, starting
zero.
timing
for the displays and see
Hint: Try different
different tim
ing lengths for
hat happens.
see what
happens. When does
does
the count
count become visible? What
hat happens if the display is blanked part of the time?

11-77
11-77

MORE COMPLEX I/O
1/0 DEVICES
DEVICES
1/0 devices differ
More complex
complex I/O
differ from simple
simple keyboards,
switches, and displays in that:
keyboards. switches.
1)
1)

They transfer
transfer data at higher
higher rates
rates.

2)

They may have their own internal
internal clocks and timing.
timing.
They produce
information
produce status inform
ation and require control
control information.
information, as well as
as
transferring
transferring data.

3)

rates. you cannot
Because of their high data rates,
cannot handle these I/O
1/0 devices casually. If the
service. the system may miss input
processor does not provide
provide the appropriate
appropriate service,
input data or
produce
produce erroneous output
output data. You are therefore
therefore working
working under
under much more exacting
exacting
constraints
constraints than in dealing
dealing with
ith simpler
simpler devices. Interrupts
Interrupts are a convenient
convenient method for
handling
1/0 devices,
devices. as we shall see in Chapter
handling complex
complex I/O
Chapter 12,
12.
keyboards. teletypewriters,
Peripherals such as keyboards,
teletypewriters, cassettes,
cassettes.
SYNCHRONIZING
SYNCHRONIZING
WITH
1/0
and floppy
floppy disks produce their own internal
internal timing.
timing. These
WITH I/O
devices provide streams of data,
data. separated by specific
specific tim-­
DEVICES
ing intervals. The computer
puter must synchronize
synchronize the initial
initial in­
input or output
output operation
operation with
ith the peripheral
peripheral clock and then provide the proper interval
interval
between subsequent
subsequent operations. A simple delay loop like the one shown previously
previously can
produce the timing
ing interval. The synchronization
synchronization may require one or more of the follow
follow-­
ing procedures:
1) Looking
Looking for
for aa transition
transition on
on aaclock
clock or
orstrobe
strobe line
line provided
provided by
by the
the peripheral
peripheral for
1)
for tim
tim-­
Is to tie the strobe to a VIA control
ing purposes. The simplest
simplest method
method is
control line and wait
ait
Is set.
set.
u ntil
til the appropriate
appropriate bit of the VIA Interrupt
Interrupt Flag register
register is
2)
2)

Finding
Is stable. We would
Finding the center
center of the time interval
interval during
during which
hich the data is
would
prefer to determine
determine the value of the data at the center
center of the pulse rather than at
edges. where the data may be changing.
the edges,
changing. Finding the center
center requires a delay of
one-half
one-half of a transmission
transmission interval
interval (bit time) after the edge. Sampling
Sampling the data at
have little
the center
center also means that small timing
ing errors have
little effect
effect on the accuracy
accuracy of
the reception.
Recognizing aa special
special starting
starting code.
code This
This isiseasy
easy ifif the
the code
code isIsaasingle
single bit
3) Recognizing
bit or
or ifif we
we
have some timing
information The procedure
procedure is
Is more complex
complex if1f the code is long
ing information.
and could start at any time. Shifting
Shifting will
ill be necessary to determine
determine where the
transmitter
bits. characters.
transm
itter is starting
starting its bits,
characters, or messages (this is
Is often called a search
"framing").
for the correct
correct "fram
ing").
probab1l1ty of receiving
4) Sampling
Sampling the data several times. This reduces the probability
receiving data inin­
correctly
correctly from noisy lines. Ma1ority
ajority logic (such as best 3 out of 5 or 5 out of 8)
8) can
be used to decide on the actual data value.
value.
Reception is,
Is. of course,
course. much more d ifficu
1lf1cult
lt than transmission.
transmission, since the peripheral
peripheral concon­
trols the reception
reception and the computer
puter must interpret
interpret timing
ing inform
ation generated by
information
the peripheral. In transmission.
transmission, the computer
computer provides the proper timing
ing and formatting
atting
for a specific
specific peripheral.
Peripherals may require or provide other inform
ation besides
information
CONTROL
information
data and timing.
ing. We refer to other
other inform
ation transmitted
itted by
AND STATUS
information";
the computer
puter as "control
"control inform
ation"; it
It may select modes of
INFORMATION
INFORMATION
operation. start or stop processes,
processes. clock registers,
operation,
registers. enable
buffers.
buffers, choose formats
formats or protocols.
protocols, provide
provide operator
operator displays.
displays, count
count operations.
operations, or
identify
1nformat1on
identify the type and priority
priority of the operation. We refer to other
other inform
ation transmitted
transmitted
information";
by the peripheral
peripheral as "status
"status inform
ation"; it may indicate
indicate the mode of operation.
operation, the
readiness of devices,
devices. the presence of error conditions.
use. and
conditions, the format
at of protocol
protocol in use.
other states or conditions.
conditions.

1 1-78
78

The computer
data. This information
puter handles control
control and status information
ation just like data.
information
seldom changes.
changes, even though
though actual data may be transferred at a high rate. The control
information
words. or multiple
or status inform
ation may be single bits.
bits, digits.
digits, words,
ultiple words. Often single
port.
bits or short fields are combined
combined and handled by a single input
input or output
output port.
Combining
1/0
Combining status and control
control information
ation into bytes reduces the total number
number of I/O
port addresses required by the peripherals. However,
However. the combination
bination does mean that
individual
individual status input
input bits must
must be separately interpreted
interpreted and control
control output
output bits must
resetbe separately determined.
determined. The procedures
procedures for isolating status bits and setting or reset­
ting control
control bits are as follows:
follows:
Separating
Separating Out Status Bits

SEPARATING
STATUS
INFORMATION
INFORMATION

Step 1)

Read status data from the peripheral
Read
peripheral

Step 2)

Logical
has ones in bit
Logical AND with
ith a mask (the mask has
sitions
examined
pos
itio n s that
a t must
ust be exam
ined and zeros
elsewhere)
Shift the separated bits to the least significant
significant bit positions
Shift

Step 3)

BIT TEST
Is unnecessary
bit. since the Zero
Step 3 is
unnecessary if the field is a single bit,
INSTRUCTION
complement
flag will
ill contain
contain the complem
ent of that
that bit after Step 2 (try it!).
Is a
A Shift
Shift or Load instruction
instruction can replace Step 2 if the field is
single bit and occupies
occupies the least significant.
significant, most significant.
significant, or next to most significant
significant
bit position
0. 7,
7. or 6).
6). These positions
reserved for the most fre­
freposition (positions 0,
positions are often reserved
quently
sequently used status information.
information. You should try to write
write the required instruction
instruction se­
quences for the 6502 processor.
processor. Note,
Note. in particular.
particular, the use of the Bit Test instruction.
instruction.
This instruction
theAccum
Accumulator
and
instruction performs a logical AND between the contents
contents ofofthe
ulator and
save the result;
result: the
the flags are
are set
set as
the contents
contents of a memory location but does not save
as
follows:
follows:
result. 0 if it does not.
not.
Zero flag== 1 if the logical
logical AND produces a zero result,
Sign flag = bit 7 of the contents
contents of the memory location (independent
(independent of the value in
the Accumulator).
Accumulator).
Overflow
Overflow flag = bit 6 of the contents
contents of the memory location (independent
(independent of the value
in the Accumulator!.
Accumulator).

COMBINING
COMBINING
CONTROL
Read
Read prior
prior control
control information
information
INFORMATION
INFORMATION
Step 2) Logical
Logical AND
AND w
ith mask to clear
clear bits (mask has zeros
with
zeros
in bit positions
positions to be cleared.
cleared, ones elsewhere)
Step 3) Logical
(mask has ones in bit positions
set. zeros
zeros
Logical OR with
ith mask to set bits (mask
positions to be set,
elsewhere)
information
Step 4) Send
Send new
new control
control inform
ation to peripheral

Setting
Setting and Clearing Control
Control Bits
Step 1)

bit and
Here again the procedure
procedure is simpler
simpler if the field
field is a single bit
and occupies
occupies aa position
position at
at
either
either end of the byte.

1-79
11
-79

Some examples
examples of separating
separating and combining
bining status bits are:
1)
1)

is a
(Data) register
put (Data)
A 3-bit
3-bit field in bit
bit positions
positions 2 through
through 4 of a VIA Ouput
register is
a scaling
scaling
factor. Place that
that factor
factor into the Accumulator.
Accumulator.

PORT
INPUT PORT
FROM INPUT
READ STATUS DATA FROM
; READ
LDA

VIAOR
VIAOR

;READ STATUS DATA;READ STATUS DATA

RESULT
SHIFT RESULT
BITS AND SHIFT
OFF UNWANTED
UNWANTED BITS
; MASK OFF
AND
LSR
LSR
LSR
LSR
2)

#% 000
1 1 1 00
=IF%00011100
AA
AA

;MASK
FACTOR
SCALINGFACTOR
;MASK SCALING
NORMALIZE
TO TWICE
:SHIFT
TO NORMALIZE
;SHIFT TWICE

and 44
in bit positions 33 and
be placed in
The Accum
ulator contains
contains a 2-bit
2-bit field that must be
Accumulator
(Data) register.
of a VIA Output
Output (Data)
TEMP
$0040
TEMP== $0040
MASK== %11100111
11100111

POSITIONS
FIELD POSITIONS
; MOVE DATA TO FIELD
ASL
ASL
ASL
ASL
AND
STA

AA
AA
A
A
#
% 0 0 0 1 1000
=IF%00011000
TEMP
TEMP

;SHIFT DATA
DATA TO
TO BIT
BIT POSITIONS
POSITIONS 33 AND
AND 44
;SHIFT

BITS
OTHER BITS
OUT OTHER
;CLEAR OUT
;CLEAR

OTHER DATA
COMBINE
FIELD VALUE WITH OTHER
COMBINE NEW FIELD
LDA
AND
ORA
STA

VIOADR
VIOADR
HMASK
TEMP
TEMP
VIOAR
VIOAR

CHANGED
BE CHANGED
FIELD TO BE
;CLEAR
;CLEAR FIELD
;COMBINED
;COMBINED NEW DATA WITH OLD
COMBINED DATA
;OUTPUT COMBINED

and
Documentation is a serious problem
problem in handling
handling control
control and
G
Documentation
DOCUMENTING
DOCUMENTIN
status information.
meanings of status inputs
inputs or control
control
information. The meanings
STATUS AND
inoutputs are seldom obvious. The programmer
programmer should clearly in­
CONTROL
outputs
dicate the purposes of input
input and output
output operations
operations in the comcom­
dicate
TRANSFERS
TRANSFERS
EVEN
"CHOOSE EVEN
READER IS ON."
ments, e.g.,.. "CHECK IF READER
ON," "CHOOSE
instrucShift instruc
PARITY
ACTIVATE BIT RATE
RATE COUNTER."
COUNTER." The Logical and Shift
OPTION," or "ACTIVATE
PARITY OPTION,
debug.
ill otherwise
otherwise be very difficult
ifficu lt to remember.
remember, understand,
understand, or debug.
tions will

1 1-80
80

EXAMPLES
EXAMPLES
An Unencoded Keyboard
Recognize a key closure
closure from an unencoded
unencoded 3 xx 33 keyboard and place the
Purpose: Recognize
number
number of the key that
that was pressed into the Accumulator.
Accumulator.

Keyboards
(see Figure 11
11-24). Small numbers
Keyboards are just
just collections
collections of switches
switches (see
numbers of keys are
easiest to handle
1f each key is attached
handle if
attached separately
separately to a bit of an input
input port. Interfacing
Interfacing
the keyboard
keyboard is then the same as interfacing
interfacing a set of switches
switches.

MATRIX
MATRIX
Keyboards
Keyboards with
ith more than eight
eight keys require
require more than one input
input
KEYBOARD
port
port and therefore
therefore multibyte
ultibyte operations.
operations. This is particularly
particularly
wasteful
terwasteful if the keys are logically
logically separate.
separate, as in a calculator
calculator or ter­
minal keyboard
keyboard where
where the user will
ill only strike
strike one at a time. The number
number of input
input lines
minal
required
required may be reduced
reduced by connecting
connecting the keys into a matrix.
matrix, as shown
shown in Figure
11-25.
11-25. Now each key represents
represents a potential
potential connection
connection between
between a row and a column.
column.
+ m external
lines. where
Is the number
The keyboard
keyboard matrix
atrix requires
requires n +
external lines,
where n is
number of rows and
m is the number
sepanumber of columns.
columns. This compares
compares tonn x m external
external lines if each key is sepa­
rate. Table 11-15
11-15 compares
compares the number
number of keys required
required by typical
typical configurations.
configurations.

KEYBOARD
A program
program can determine
determine which
hich key has been pressed by using
SCAN
the external
external lines from the matrix.
matrix. The usual procedure
procedure is a
"keyboard
"keyboard scan."
scan." We ground
ground Row 0 and examine
examine the column
column
lines. If any lines are grounded.
pressed. causing
grounded, a key in that
that row has been pressed,
causing a row-torow-tocolumn
determining
column connection.
connection. We can determine
determine which
which key was pressed by determ
ining which
which
columnn line is grounded:
is. which
Is zero.
zero. If no column
Is
colum
grounded; that
that is,
hich bit
bit of the input
input port
port is
column line is
grounded.
grounded, we proceed
proceed to Row 1 and repeat
repeat the scan. Note that
that we can check to see if1f
grounding all the rows at once and examining
examining the
any keys at all have been pressed by grounding
columns.
columns.
The keyboard
keyboard scan requires
requires that
that the row lines be tied to an output
output port
port and the column
column
lines to an input
CPU can ground
input port. Figure 11-26 shows the arrangement.
arrangement- The CPU
ground a parpar­
ticular
ticular row by placing
placing a zero in the appropriate
appropriate bit of the output
output port and ones in the
other
other bits.
The CPU can determine
determine the state of a particular
particular column
column by examining
examining the appropriate
appropriate
bitit of the input
input port.

Table
Table 11-15. Comparison
Comparison Between
Between Independent
Independent Connections
Connections
atrix Connections
Connections for Keyboards
and Matrix

Keyboard Size

Number of Lines with
Number
Independent
Independent Connections

Number
Number of Lines with
ith
atrix
Ma
trix Connections

3 xX 33
4x4
x4
4x6
x6
5 xX 55
6 xX 66
6 xX 88
8x8
x8

9
16
24
25
36
48
64

6
8
10
10
12
14
16

11-81
1181

+5V

-----------------0

I

Key 1

J_
;;~-------

+5V

------------0

Key 2

f

J_

r

Key 3

J_

_______ ...
I,_______ o

Each key is a switch just like a pushbutton and grounds an input bit if it is pressed.

Figure 11-24. A Small Keyboard

Column
Colu
mn 0

J

Key 0 .

AowO

>
'

“ > < /

*

K 9v4' y

Z 5
Ksy 3 v

Rowl

Colu
mn 2
Column

Colu
Column 1

(

w
/>

Key 6 v

►

c/

i

)

^

Key 8

►

w
/

Row 2

Each
Each key
key now serves to
to connect a rov
nee, key
row to a column.
cotumn. For
For instance.
key 4 connects row 1 to column 1.
1.

--------------------Figure 11-25. A Keyboard Matrix
Matrix
11-82
11-82

Column 0

Cotumn 1

Cotumn2

Datallul
(from CPU)

VIA

Output

01 ..,______

--+--------+----IJ---+--Row

Port

VIA

Input

Port

Data Bus Ito CPU)

1/0 Arrangement
Figure 11-26. I/O
Arrangement for a Keyboard Scan

11-83

1

Task 1:1 : Determine
Determine Key
Key Closure
Closure
Task
Purpose: W
Wait
for aaKey
Key toto be
be Pressed.
Pressed.
Purpose:
ait for
The procedure
procedure isis as
as follows:
follows:
The
Ground all
all the
the rows
rows by
by clearing
clearing all
all the
the output
output bits.
bits.
1)1) Ground
2) Fetch
Fetch the
the column
column inputs
inputs by
by reading
reading the
the input
input port.
port.
2)

WAITING
WAITING
FOR
FORAA
KEY
KEY CLOSURE
CLOSURE

3) Return
Return to
to Step
Step 11 ifif all
all the
the column
column inputs
inputs are
are ones.
ones.
3)

Flowchart:
Flowchart:
Start

Ground all
keyboard rows

End

Source Program:
Program:

WAITK

LDA
STA
LDA
STA
STA
STA
LDA
LDA
AND
AND
CMP
CMP
BEO
BEQ
BRK
BRK

#$FF
VIADDRB
#00
VIAPCR
VIADDRA
VIADDRA
VIAORB
VIAORA
VIAORA
#%00000111
#% 0 0
0001 1
#%00000111
#% 000001 1
WAITK
WAITK

;MAKE PORT B LINES OUTPUTS
;MAKE
MAKE ALL CONTROL LINES INPUTS
MAKE PORT A LINES INPUTS
;MAKE
ALL KEYBOARD ROWS
;GROUND ALL
GET KEYBOARD COLUMN
COLUMN DATA
DATA
;GET
MASK COLUMN
COLUMN BITS
BITS
:MASK
ARE ANY
ANY COLUMNS
COLUMNS GROUNDED?
GROUNDED?
:ARE
NO, W
AIT UNTIL
UNTIL ONE
ONE IS
IS
:NO.
WAIT

11
-84
11-84

Object
Program:
Object Program:
Memory
Memory Address
(Hex)
(Hex)
0000
0001
0002
0003)
0003}
00041
0005
0006
0007
0008)
0008}
0009
0009)
000A
0008}
B)

oooc
000C)
000D
000EI
000E}
000F)
0010
0011)
0011}
00121
0013
0014
0015
0016
0017
0018
0019

Memory
Memory Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

A9
FF
FF
8D

LDA

#$FF

STA

VIADDRB

LDA

#00

STA

VIAPCR
VIAPCR

STA

VIADDRA

STA

VIAORB
VIAORB

LDA

VIAORA

AND

00000111
#% 00
000 1

CMP

00000111
#% 00
000 1

BEO
BEQ

WAITK

VIADDRB
A9
00
8D

VIAPCR
VIAPCR
8D
VIADDRA
8D

VIAORB
VIAORB
AD

WAITK

VIAORA
29
07
C9
07
F0
FO
F7
00

BRK
BAK

is the keyboard output
VIA Port 8
B Is
output port and Port A is the input
input port.
column bits eliminates
eliminates any problems
problems that could be caused by
Masking off all but the column
the states of the unused input
input lines
lines.
We could generalize the routine
routine by naming the output
output and masking
maskingpatterns:
patterns:
ALLG
OPEN
OPEN

=%11111000
=%
11111000
=%00000111
=%00000111

reThese names could then be used in the actual program;
program; a different
different keyboard would
would re­
quire only a change in the definitions
re-assembly.
definitions and a
and a
re-assembly.
Of course, one port of a VIA is all that isisreally
reallynecessary
necessaryfor
foraa33x 3 or
or44 x 4 keyboard.
Try rewriting
lIses only Port A.
riting the proqram
program so that it uses

11-85

Identify Key
Task 2: Identify
the Accumulator.
into the
the key into
of the
the number of
key closure by placing the
Purpose:
Accumulator.
Identify a key
Purpose: Identify
follows:
as follows:
is as
The procedure is
0.
zero in bit 0,
for a zero
-1. keyboard output
to -1.
1)
output port to all ones except for
key number to
Set key
1) Set
rows.
counter to number of rows.
and row counter
and
port
input port
the input
reading the
by reading
inputs by
column inputs
the column
Fetch the
2) Fetch
2)
Step 7.7.
to Step
proceed to
zero. proceed
are zero,
inputs are
column inputs
any column
3) IfIf any
3)
4)
4)

row.
Add the number of columns to the key number to reach next row.

posI lion.
oneposition.
leftone
zero bit left
the zero
shifting the
by shifting
port by
output port
the output
of the
5)
contents of
the contents
Update the
5) Update
scanned. otherbeenscanned,
not been
have not
rows have
any rows
Step 22 ifif any
to Step
Go to
6)
other­
counter Go
row counter.
Decrement row
6) Decrement
9.
to Step 9.
wise go to
bit.
one bit.
right one
inputs right
column inputs
Shift column
number. Shift
key number.
to key
Add 11 to
7) Add
7)
Step 7.7.
to Step
return to
Carry == 1,1. return
8) IfIf Carry
8)
program.
of program.
Endof
9) End
9)
Flowchart:
Flowchart:
Start

Key Number • - 1
Counter = Number
of rows
Keyboard output port
= 1 1111110 (binary)

Kev Number=
Key Number + 1
Shift column inputs

Update keyboard
output port by
shifting contents
left arithmetically

right 1 bit

Key Number=
Key Number+
Number of Columns
Counter=Counter -1
Yes

End

11
86
1-86

Source Program:
Program:
Source

FROW
FROW

FCOL
FCOL

LDA
LDA
STA
STA
STA
STA
LDA
LDA
STA
STA
TAX
TAX
LDA
LDA
STA
STA
LDY
LDY
LDA
LDA
AND
AND
CMP
CMP
BNE
BNE
TXA
TXA
CLC
CLC
ADC
ADC
TAX
TAX
ASL
ASL
DEY
DEY
BNE
BNE
BAK
BRK
INX
INX
LSR
LSR
BCS
BCS
BAK
BRK

# 0#0
VIAPCR
VIAPCR
VIADDRA
VIADDRA
#$FF
#$FF
VIADDRB
VIADDRB

#%11111110
#%
1 1111110
VIAORB
VIAORB
#3
#3
VIAORA
VIAORA
#%00000111
#%00000111
#%00000111
#% 000
0 11
FCOL
FCOL

;MAKE
;MAKEALL
ALLCONTROL
CONTROLLINES
LINESINPUTS
INPUTS
;MAKE
:MAKEPORT
PORTAALINES
LINESINPUTS
INPUTS
;MAKE
:MAKEPORT
PORTBBLINES
LINESOUTPUTS
OUTPUTS
;KEY
:KEYNUMBER
NUMBER= =-1 -1
:START
;STARTBY
BYGROUNDING
GROUNDINGROW
ROWZERO
ZERO
;COUNTER
:COUNTER==NUMBER
NUMBEROF
OFROWS
ROWS
;GET
:GETCOLUMN
COLUMN INPUTS
INPUTS
;ISOLATE
:ISOLATECOLUMN
COLUMNBITS
BITS
;ARE
:AREANY
ANY COLUMNS
COLUMNS GROUNDED?
GROUNDED?
;YES,
:YES.GO
GODETERMINE
DETERMINEWHICH
WHICH ONE
ONE
;NO.
:NO.MOVE
MOVEKEY
KEYNUMBER
NUMBERTO
TONEXT
NEXT ROW
ROW

#3
#3

;BY
:BY ADDING
ADDING NUMBER
NUMBEROF
OFCOLUMNS
COLUMNS

VIAORB
VIAORB
FROW
FROW

;UPDATE
:UPDATE SCAN
SCAN PATTEN
PATTENFOR
FORNEXT
NEXTROW
ROW
;HAVE
:HAVE ALL
ALL ROWS
ROWS BEEN
BEENSCANNED?
SCANNED?
;NO,
;NO. SCAN
SCAN NEXT
NEXT ONE
ONE

AA
FCOL
FCOL

;KEY
;KEY NUMBER
NUMBER ==KEY
KEYNUMBER
NUMBER ++ 11
;IS
.ISTHIS
THIS THE
THECOLUMN
COLUMN GROUNDED?
GROUNDED?
;NO,
;NO. EXAMINE
EXAMINE NEXT
NEXT ONE
ONE

11-87
1
1-87

Object
Program:
Object Program:

Memory
Address
Memory Address
(Hex)
(Hex)
0000
0001
0001
0002
0003)
0003}
0004)
0005
0005
0006)
0006}
0007)
0008
0009
OOOA
000A
000
B)
000B}

oooc

000C)
000D
OOOE
000E
OOOF
OOOF
0010
00111
0011}
0012)
0013
0014
0015
0016)
0016}
0017)
0018
0019
001A
001
0018B
001C
001D
0010
001E
001F
0020
0021
0021
0022
0023
0024)
0024}
0025)
0026
0027
0028
0029
002A
002B
002B
002C
002C
002D
0020
002E
002E

MemoryContents
Memory
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
A9
00
8D
VIAPCR
VIAPCR
8D

LOA
LDA

#0

STA
STA

VIAPCR
VIAPCR

LD
LD
STA
STA

A.00001111B
A,00001111B
VIADDRA
VIADDRA

LOA
LDA

#$FF

STA
STA

VIADDRB
VIADDRB

TAX
TAX
LOA
LDA

11111110
#% 1
1111110

STA
STA

VIAORB
VIAORB

LOY
LDY

#3

LOA
LDA

VIAORA
VIAORA

AND
AND

# % 0 0 000111
1 11

CMP
CMP

# % 0 0 000111
1 11

BNE
BNE

FCOL
FCOL

TXA
TXA
CLC
CLC
ADC
ADC

#3

TAX
TAX
ASL
ASL

VIAORB
VIAORB

DEY
DEY
BNE
BNE

FROW
FROW

BRK
BRK
INX
LSR
LSR
BCS
BCS

A
FCOL
FCOL

VIADDRA
VIADDRA
A9
A9
FF
FF
8D
VIADDRB
VIADDRB
AA
AA
A9
A9
FE
FE
8D
VIAORB
VIAORB
AO
AO
03
AD
AD

FROW
FROW

VIAORA
VIAORA
29
07
C9
C9
07
DO
DO
OC
8A
BA
18
18
69
03
AA
AA
OE
OE

oc

VIAORB
VIAORB
88
DO
DO
EC
EC
00
E8
E8
4A
BO
BO
FC
FC
00

FCOL
FCOL

BRK
BRK

11-88
11
88

CLC instruction
We have included
included a CLC
instruction for clarity.
clarity, but it is not actually
actually necessary. The only
BNE instruction
case in which
which the BNE
instruction does not cause a branch
branch is the one in which
hich the two
operands used in CMP are equal. In that
case. the Carry flag is always
that case,
always set to indicate
indicate
that no borrow
borrow has been generated.
generated. So we could replace the sequence
CLC
CLC
ADC

#3
#3

;BY ADDING
ADDING NUMBER
NUMBER OF
OF COLUMNS
COLUMNS
;BY

with
ith the single
single instruction
instruction
ADC

#2
#2

;BY ADDING
ADDING NUMBER
NUMBER OF
OF COLUMNS
COLUMNS (NOTE
(NOTE
;BY
; CARRY
CARRY== 1)
1)

Each time a row scan fails,
fails. we must add the number
Each
number of columns
columns to the key number
number to
move past the current
current row (try the procedure
procedure on the keyboard in Figurt
Figure 11-26).
What
hat is the result
result of the program
program if no keys are being pressed? Change the program
program so
that it starts the scan over again in that
that case.
case. We could insert
insert an extra INX instruction
instruction
that
BRK. What
before the first
first BRK.
a t would
would the final value be in Index Register X iiif no keys were
being pressed? Would
ould it be different
different from the case in which
hich the highest
highest numbered
numbered key
was being pressed? Note that
that the Zero flag could also be used to distinguish
distinguish the case
where
how7
where no keys were pressed. Can you explain
explain how?
An alternative
alternative is to use the bidirectional
bidirectional capability
capability of the VIA. The procedure
procedure would
would be:

1)
1)
2)
3)

Ground all the columns
columns and save the row inputs.
Ground all the rows and save the column
column inputs.
Use the row and column
column inputs
inputs together
together to determine
determine the key number
number from a table.

Try to write
write a program
program to implement
implement this procedure.
This program
program can be generalized
generalized by making the number
number of rows,
number of colcol­
rows. the number
umns. and the masking pattern
EQUATE (=) pseudoumns,
pattern into named parameters
parameters with
ith EQUATE
pseudo­
operations.

11-899
11-

An Encoded Keyboard18
Keyboard18
data. when
available. from an encoded keyboard that provides a
Purpose: Fetch data,
when it is available,
strobe along with
ith each data transfer.
An encoded keyboard provides a unique
unique code for each key.
key. It has internal
internal electronics
electronics
that perform the scanning
scanning and identification
identification procedure
procedure of the previous example. The
tradeoff
tradeoff is between the simpler
simpler software required by the encoded keyboard and the
lower cost of the unencoded
unencoded keyboard.
Encoded keyboards may use diode matrices.
matrices, TTL encoders.
encoders, or MOS encoders. The
ASCII. EBCDIC,
EBCDIC. or a custom code.
code. PROMs
PROMs are often part of the encoding
codes may be ASCII,
encoding
circuitry.
circuitry.
tha-n just
The encoding
encoding circuitry
circuitry may do more than
just encode key
^ROLLOVER]
!ROLLOVER!
closures. It may also debounce
closures.
debounce the keys and handle "rollover."
"rollover," the
problem of more than one key being struck at the same time. Common ways of
handling
handling rollover
rollover are: "2-key
"2-key rollover,"
rollover," whereby
whereby two keys (but not more) struck at the
closures. and "n-key
same time are resolved into separate closures,
"n-key rollover."
rollover," whereby
whereby any
number of keys struck at the same time are resolved into separate closures.
closures.
The encoded keyboard also provides a strobe with
ith each data transfer. The strobe sigsig­
11-27 shows the interface
nals that a new closure has occurred. Figure 11
interface between
between an enen­
coded keyboard and the 6502 microprocessor. The 6522
6522 Versatile
Versatile Interface
Interface Adapter
Adapter
provides input
B; these latches are enabled by setting
setting bit
input latching
latching on both Ports A and B:
O (for Port A) of the Auxiliary
(see Figure 11-10). In
B) or bit 0
I1 (for Port B)
Auxiliary Control
Control register
register (see
mode. the data on the input
this mode,
input pins is latched when the Interrupt
Interrupt flag is set and wil
not change until
until the Interrupt
Interrupt flag is cleared. Note that
that the latching
latching works somewhat
somewhat
differently
register are latched if the pin
differently on the B side.
side, where the contents
contents of the Output
utput register
is programmed
programmed as an output.

1. A transition
The keyboard strobe is tied to input
input CA1.
transition on the strobe line causes InterInter­
O of the Peripheral Control
(see Figure
rupt Flag Register bit 1 to go high. Bit 0
Control register (see
11-9) determines
O = 0)
0)
II
determines whether
whether the VIA recognizes high-to-low
high-to-low transitions
transitions on CA11 (bit 0
O = 1). Thus the VIA contains
or low-to-high
low-to-high transitions
transitions (bit 0
contains an edge-sensitive
edge-sensitive latched
status port as well as a data port. It also contains
contains an inverter
inverter that can be used to handle
strobes of either
either polarity. A VIA can replace many simple circuit
circuit elements;
elements: you can
make corrections
corrections in circuit
circuit logic by changing
changing the contents
contents of the Control
Control registers (in
software) rather than by rewiring
rewiring a breadboard. For example.
example, changing
changing the active edge
requires the changing
changing of a single program bit. whereas it might
ight require additional
additional parts
and rewiring
rewiring on a breadboard.

p~

Data Bus (
to CPU

I(

.
~ Keyboard Data Inputs

PA7

'

CA 1

-

6522

'

VIA

Keyboard Strobe

Figure 11-27. 1/0 Interface for an Encoded Keyboard

11-90
11
90

Task: Input from Keyboard

Purpose: Wait
for an active-low
a it tor
active-low strobe on VIA control
control line CA11 and then place the
the
data from Port A into the Accumulator.
ulator. Note that
that reading the data from the
(Data) register
Output
utput (Data)
register clears the status bit in the Interrupt
Interrupt Flag register
register (this
circuitry is part of the 6522 VIA).
circuitry
Flowchart:
Flowchart:
Start

Read Interrupt Flag
Register

Read Output
(Data) Register

End

The hardware
hardware must hold the control
control lines in
In a logic T
'1' state during
during reset to prevent
prevent the
accidental setting
accidental
setting of status flags. An initial
initial read of the Data (Output) registers in the
startup
startup routine
routine may be used to clear the status flags. As noted earlier,
earlier. you can also clear
bits in the 6522 Interrupt
Interrupt Flag register by writing
ritin g logic Ts
'1's into them.

Source Program:

KBWAIT

LDA
LOA
STA
STA
LDA
LOA
STA
LDA
LOA
BIT
BIT
BEQ
BEG
LDA
LOA
BAK
BRK

#0
VIAPCR
VIADDRA

CONTROL LINES
;MAKE ALL CONTROL
LINES INPUTS
INPUTS
PORT A LINES
;MAKE PORT
LINES INPUTS
INPUTS

#%00000001
VIAACR

#%00000010
#%00000010
VIAIFR
VIAIFR
KBWAIT
VIAORA

;ENABLE
ENABLE LATCHING ON PORT
PORT A
;GET
PATTERN FOR
FOR EXAMINING CA11 FLAG
GET PATTERN
FLAG
;IS THERE
THERE NEW KEYBOARD
KEYBOARD DATA?
DATA7
;NO.
NO. WAIT UNTIL THERE
THERE IS
;YES.
YES. FETCH
FETCH DATA

1 1 -91

Object
Program:
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003
0003} >
0004
0004)
0005
0005
0006)
0006}
0007
0007)
0008
0008
0009
0009
OOOA
000A
000
BI
OOOB}
oooc
000C)
000D
000D
OOOE
000E
OOOF
000F
0010)
0010}
0011
0011)
0012
0012
0013
0013
0014
0014
0015)
0015}
0016
0016)
0017
0017

Memory
Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
00
8D

LOA
LDA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

LOA
LDA

#%00000001
00000001

STA

VIAACR

LOA
LDA

#%00000010
00000010

BIT

VIAIFR

BEO
BEQ

KBWAIT
KBWAIT

LOA
LDA

VIAORA

VIAPCR
8D

VIADDRA
VIADDRA
A9
01
8D
VIAACR

A9
02
2C

KBWAIT
KBWAIT

VIAIFR

FO
FO
FB
FB
AD
VIAORA
00

BRK
BRK

(J of
To make the status
1, you must
status bit
bit respond to low-to-high
-to-high transitions
transitions on CA1,
must set bit 0
the Peripheral
Control register.
Peripheral Control

The other
O (for CA2),
CA2). 3 (for CB2l.
1I of the
other handshake
handshake status
status flags are bits 0
CB2). and 4 (for CB1)
Interrupt
Interrupt Flag register.
Show
(Data) register
Show that
that reading
reading the Output
utput (Data)
register clears the status
status flag. Hint: save the concon­
tents of the Interrupt
LOA VIAORA is exInterrupt Flag register
register in memory
memory before the instruction
instruction LDA
ex­
ecuted. What
LOA with
INC. ROL?
ROL? Note
hat happens
happens if you replace LDA
ith STA? How about
about CMP, INC,
that
(Data) register
that either
either reading
reading or writing
ritin g the Output
utput (Data)
register clears the status
status bit. What
hat haphap­
(see Table 11-7)?
11-7)7 What
happens if you read Port A from the non-handshaking
non-handshaking address (see
hat hap­
pens if you replace LDA
LOA VIAORA with
LOA VIAORB?7
ith LDA

1 1-92
92

Digital-to-Analog
onverter19-22
A Digital-to-A
nalog C onverter19
22
Purpose: Send data to an 8-bitit digital-to-analog
digital-to-anaiog converter,
converter, which
which has an active-low
active-low
latch enable.
Digital-to-analog
Digital-to-analog converters
converters produce
produce the continuous
continuous signals required by motors,
motors.
heaters, actuators,
actuators, and other electrical
electrical and mechanical
mechanical output
output devices. Typical
Typical converconver­
ters consist
consist of switches
switches and resistor ladders with
ith the appropriate
appropriate resistance values. You
must generally
generally provide a reference voltage
voltage and some other
other digital
digital and analog circuitry.
circuitry,
although
although complete
complete units are becoming
becoming available at low cost.
Figure 11-28 describes the 8-bit
Signetics NE5018 D/A converter,
-b it Signetics
converter, which
which contains
contains an
on-chip
Enable) input
on-chip 8-bit
-b it parallel data input
input latch. A low level on the LE (Latch Enable)
input gates
the input
input data into the latches.
latches, where it remains after
after LE goes high.
Figure 11-29 illustrates
illustrates the interfacing
interfacing of the device to a
D/A CONVERTER
6502 system. Note that the B side of the VIA autom
atically
automatically
INTERFACE
produces the active-low
active-low strobe required to latch the data
into the converter:
Ready signal. Remember that
converter; CB2 acts as an Output
utput Ready
that CB2 autom
at­
automatically goes low for one cycle follow
following
ing a write
write operation on
(Data)
on the B port
port O
Output (Data)
register ififCB2
(see Table 11-9). The Peripheral
Peripheral Control
register
CB2 is in the pulse output
output mode (see
Control
register
register bits are:
Bit 7 = 1 to make CB2 an output
output
Bit 6 = 0 to make CB2 a pulse
Bit 5 = 1 to make CB2 a brief Output
Ready strobe (one clock
utput Ready
clock cycle
cycle
in duration).
Note that the VIA contains
contains an output
output latch. The data therefore remains stable during
during
and after
after the conversion.
conversion. The converter
converter typically
typically requires only a few microseconds
microseconds to
produce
produce an analog output.
output. Thus, the converter
converter latch could be left enabled if the port
were not used for any other
other purpose.
In applications
applications where eight
eight bits of resolution
resolution are not enough,
enough, 10- to 16-bit
16-bit converters
converters
used. Additional
can be used.
Additional port logic is required to pass all the data bits; some converters
converters
provide part of this logic.
The VIA here serves both as a parallel data port and as a control
control port. CB2 is a pulse
that lasts one clock cycle after the data is latched into the VIA. This pulse is long
enough
ns) of the NE5018 converter.
enough to meet the requirements
requirements (typically
(typically 400 ns)

11-93
11
93

DB7
MSB

DBS

DB4

DB2

DBI

DBO

Digital
GND

LSB

latches and
Switch Drivers

Sum
Node

Vee
A
INT VAEF

VAEF
Out

1 1 -9 4
'

(0

"'

VOut

OAC Current
Output

Amp
Comp

VAEF
Adi

Analog

OAC Switches

VREF

-

GND

A

In

Bipolar

Offoet

Vee

All R values equal 5 k H and are thermally matched

Figure 11-28. Signetics
D/A Converter
Converter
S1gnet1es NE5018 D/A
Figure

Analog

Data Bus
Bus
from CPU

2i

L

)>
~

6522
VIA

PB7
PBo
PB0

-)
V

V

NE5018

Output

D/A
Converter

cb2

CB2

LE
i:e

I

_
_
_
_
_♦

f

Figure 11
11-29 Interface
Interface for an 8-bit
8-bit Digital-to-Analog
Digital-to-Analog Converter
Converter

11-95
11-95

--

Task: Output
Output to
to Converter
Converter
Task:
Purpose: Send
Send data
data from
from memory
memory location
location 0040
0040 toto the
Purpose:
the converter.
converter.
Flowchart:
Flowchart:

(
C

Start

)

Data
Data =- (0040)
(0040)

♦
Send
Senddata
data to
to
converter
converterand
and
1

latch
latchitit

(
C
E"
End

J

Source Program:
Program:
Source
LDA
LDA
STA
LDA
STA
LDA
STA
BAK
BRK

#$FF
VIADDRB
# % 10100000
0100000
VIAPCR
$40
VIAORB

;MAKE PORT
PORT B LINES
LINES OUTPUTS
OUTPUTS

:PROVIDE BRIEF
;PROVIDE
BRIEF LATCH ENABLE STROBE
STROBE
;GET
;GET DATA
;SEND DATA
:SEND
DATA TO DAC AND LATCH

11-96
11-96

Object
Object Program:
Program:
Memory
Memory Address
Address
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004
0004)
0005
0005
0006
0006
0007
0007
00081
0008}
0009
0009)
OOOA
000A
OOOB
0
00B
oooc
oooc
000D|
000D}
OOOE
000EI
OOOF
000F

Memory
Memory Contents
Contents
(Hex)
(Hex)
A9
FF
FF
8D

Instruction
Instruction
(Mnemonic)
(Mnemonic)
LOA
LDA

#$FF
#$FF

STA

VIADDRB

LOA
LDA

10100000
#% 1
0100000

STA

VIAPCR

LOA
LDA

$40

STA

VIAORB

VIADDRB
A9
AO
A0
8D
VIAPCR
A5
40
8D
VIAORB
00

BRK
BRK

The pulse for the Latch Enable input
input is produced
produced automatically
when data is stored in
autom atically when
B. Note,
Note. however.
Output
utput (Data) Register B.
however, that
that the pulse is a fairly
fairly brief
brief one. lasting
lasting only
one clock cycle;
cycle; this may be insufficient
insufficient for some applications.
applications.
acWee could use the level (manual) output
output from CB2 if the Latch
Latch Enable signal
signal were ac­
tive-high
tive-high or if the required
required length
length were greater. The program
program would
would then be.:
LOA
LDA
STA
LOA
LDA
STA
LDA
LOA
STA
LDA
STA
LDA
STA
BRK
BRK

#$FF
#$FF
VIADDRB
#%11000000
11000000
VIAPCR
$40
VIAORB
#% 1
1100000
%11100000
VIAPCR
#% 1
1000000
%11000000
VIAPCR

;MAKE PORT
PORT BE
BE LINES
LINES OUTPUTS
OUTPUTS
;MAKE LATCH ENABLE A LEVEL
:MAKE
LEVEL (LOW)
(LOW)
;GET DATA
;GET
PORT
;SEND DATA
DATA TO DAC OUTPUT PORT

:OPEN DAC LATCH (ENABLE
(ENABLE HIGH)
HIGH)
;OPEN
:LATCH DATA
(ENABLE LOW)
;LATCH
DATA (ENABLE

Here bit
Peripheral Control
register is set to make CB2 a level with
bit 6 of the Peripheral
Control register
ith a value given
by bit 5 of the Peripheral
Peripheral Control
Control register. This is referred to as the Manual
Manual Output
utput mode
in 6522
6522 literature
literature. Note how many more instructions
instructions are required
required to pulse the Latch
Enable than in the previous
previous example.
example, since no automatic
automatic pulse is provided.
provided. An inverter
inverter
gate could
invert the polarity
polarity of the strobe.
could also be used to invert
mode. CB2 is completely
In the Manual
Manual mode,
completely independent
independent of the parallel
parallel data port. It is
simply
simply a control
control output
output that
that is available
available for any purpose. The only problem
problem involved
involved in
using it is that
that you must
must not accidentally
accidentally change
change any of the other
other bits in the Peripheral
Control register,
register. since they may have unrelated
unrelated functions.
functions.
Control

11-97

Analog-to-Digital
Analog-to-D
igital Converter19-23
onverter19-23
Purpose: Fetch data from an 8-bit
Purpose:
-b it analog-to-digital
analog-to-digital converter
converter that requires a Start
Conversion pulse to start the conversion process and provides an End of
Conversion output
output to indicate
indicate the completion
completion of the process and the
availability
availability of valid data.
Analog-to-digital converters
converters handle the continuous
Analog-to-digital
continuous signals produced by various types
of sensors and transducers. The converter
converter produces the digital
digital input
input which
hich the comcom­
puter
requires.
puter requires.
One form of analog-to-digital
approximation
analog-to-digital converter
converter is the successive approxim
ation device.
device, which
which
makes a direct
direct 1-bit
1-bit comparison
comparison during
during each clock cycle. Such converters
converters are fast but
have little noise immunity.
immunity. Dual slope integrating
integrating converters
converters are another
another form of
analog-to-digital
noise.
analog-to-digital converter. These devices take longer but are more resistant
resistant to noise.
Other techniques.
used.
techniques, such as the incremental
incremental charge balancing
balancing technique.
technique, are also used.
Analog-to-digital
nalog-to-digital converters
converters usually require some external
external analog and digital
digital circuitry.
circuitry,
although
although complete
complete units are becoming
becoming available at low cost.
Figure 11-30 contains
contains a general description
description and a timing
ing diagram for the National
MM5357
M5357 8-bitit A/D converter. The device contains
contains output
output latches and tristate
tristate data outout­
puts. A pulse on the Start Conversion (STRT
(STRT CONV)
CONV) line starts conversion
conversion of the analog
input; after
after about
about 40 clock cycles (the converter
converter requires a TTL level clock with
ith a
input:
inimum
ns). the result will
m inim
um pulse width
id th of 400 ns),
ill go to the output
output latches and the End of
(EOC) output
Conversion (EOC)
output will
ill indicate
indicate this by going high. Data is read from the latches
by applying
applying a T
'V to the Output
utput Enable input. Figure 11-31 shows the connections
connections for
the device and some typical
typical applications
applications circuits.
circuits.

A/0
Figure 11-32 shows the interface
interface for the 6502 processor
A/D CONVERTER
and the 5357 A/D converter. Control
Control line CA2 is used in the
INTERFACE
Manual (Level)
(Level) Output
utput mode to provide a Start Conversion
End of Conversion signal is tied to control
pulse (active-high)
(active-high) of sufficient
sufficient length. The End
control
EOC going high will
line CA11 so that EOC
ill set bit 1 of the Interrupt
Interrupt Flag register. The imporimpor­
tant edge on the End of Conversion line is the low-to-high
edge. which
low-to-high edge,
which indicates
indicates the
completion
completion of the conversion. Note that we are using the 6522
6522 device to handle both
control
control input
input and control
control output.
output, since the converter
converter interface
interface involves a complete
complete
high. since we are not plachandshake. The Output
utput Enable pin on the converter
converter is tied high,
plac­
bus. Note (see
(see Figure 11-30) that
ing the data directly
directly on the processor's tri-state
tri-state data bus.
the converter
converter data outputs
complementary binary (all zeros
outputs are complementary
zeros is full-scale).

11-98

NATIONAL
ATIONAL

M5357
MM
5 3 5 7 8-bit
-b it /I
General Description
Description
an 8-bit
The M M5357
5 3 5 7 is an
8-bit monolithic
monolithic A/0
/D converter using P-channel ion-implanted
ion-implanted MOS technology.
technology. It contains
series resistors and analog switches,
a high input impedance comparator,
comparator, 2 56 series
switches, control logic and output
output latches.
Conversion is performed using a successive approximation
approximation technique where the unknown analog voltage is
compared to the resistor tie points using analog switches.
switches. When the appropriate
appropriate tie point
point voltage matches the

and the digital outputs contain an 8-bitit complementary
unknown voltage, conversion is complete
complete and
complementary binary word
corresponding
corresponding to the unknown. The binary output
output is tri-state
tri-state to permit bussing on common
common data lines.

Features
Features
■
■
■
■
■
■
■
■

Low cost
ranges
±55 V, 10 V input ranges
No missing codes
No
High input impedance
Ratiometric
Ratiometric conversion
Tri-state
Tri-state outputs
Contains output latches
TTL compatible
compatible

Key Specs
■

Resolution

■

Linearity
speed
Conversion speed
Input impedance
Supply voltages
range
Clock range

■
■
■
■

8 bits
±1/
2 LSB
1/2
LSB

40µs
40/xs

> 1 00 MO
>
ft
GNO
+55 V, -12 V, GND
kHz to 2.0 MHz
MHz
5.0 kHz

Timing
ing Diagram::

v-n

n

n

fl

j \Ua Ua UA a a a a a a a j

Clock +5 V — j

ovJ

Input
Input

0 V

V
Start + 5v-r7..
Conversion

Z T Y
V
ov-l

0

~1-------------------~

+ 55 V

EOC +

V \l-\44-------440
0 V

•

/11------<1..,
- 4 0 X (l1 / f ) -

— la—

--------------·,--------------.!

Output ++ 5 V Output
Enable
Enable

ov---------~~---•1

0 V -

+ 55 V -

Data +

V -

ov

-s -

(Tri-state)

~i~~•J.- - - ~•,----M
-J?-

0 V Enable___
Enable
Delay
Delay
Data
complementary binary (full scale is "Os"
"Os" output).
Data is complementary

□

r

Disable _

Delay
Delay

Description and Timing
Timing Diagram
Diagram for the National
National 5357 A/D
Figure 11-30. General Description
Converter
Converter

11-99
1199

Connection Diagram
Diagram
Connection

2-4 .
2-“

1B

2-3
-3 -

2

17
17

2-22 .

3

16
16

IMSBI 2·' 11 (MSB)

4

R Network
Network -

5
6
7
8
9

STAT C ONV
STRT
VOutput Enable
EnableVGG"
VG
E OC-

Voo
- V
DD
2-5
-2-5

- 2·6
2-6

M M5357
357

1R
15
10

A/D

14

Converter

1^

+VAEF
"+
REF
-2 7
2-7
ILS81
- 2 ‘-8 (LSB)

11
11

VIN
-V |
Clock
"Clock

10

" vVss

Typical
Typical Application
Application

+55 V-

15 M

2·1
2
'1
22-2

+ V REF

10

MSB

2
-6
2-3

-5 V

R NET

22-4

Digital

GG
MM5357
Vq
g MM
57
VIN
,N
A
/D
A/D

22"-b5

Output

O

GND
GND

O

vss
>

+55 V

-12 V

12
Analog Input
11
Clock
6*

Conversion
Start Conversion

Output Enable
Enable

7*

CK

2
2·-b6

2-1

Converter 2-7
Converter

/

SC
SC

2-B
2-8

LSB
■ LSB

OE
OE

EOC

End of Conversion
Conversion
• End

+ 5 V < V iN < -5 V

Figure 11-31. Connection
Connection Diagram and Typical
Typical Application
Application for the National
National 5357
A/O
/D Converter

Data
Data Bus
Bus

Analog

to CPU
CPU

c

,

.

....

6 522
22

PA
p
a7

VIA

N --------------------PA
q
PA(J

National

Input
Input

5 357
AID
/D
Converter
STRT
STAT

CA1
,

CA2

EOC
EOC

CONV
CONV

Figure 11-32. Interface
Interface for an 8-b,tit Analog-to-Digital
Analog-to-Digital Converter
Converter

1 1 -100
100

Task: Input from Converter

Conversion to go low and then
process. Wait
Purpose:
Start the conversion
conversion process,
ait for End of Conversion
Purpose: Start
high, and then read the data and store it in memory
memory location
location 0040.
0040.
high.
F lo wchart:
Start

Pulse Start
Conversion
Line

Read data from
Data Input port

(00401 = Data

End

port. and a control
that here the VIA serves as a parallel
parallel data port.
port, a status
status port,
control port.
Note that
Source
Program:
Source Program:

WTEOC

LDA
LOA
STA
LDA
LOA
STA

#00
VIADDRA
VIADDRA
#%00001101
#%00001101
VIAPCR

LDA
LOA
STA
LDA
LOA
STA
LDA
LOA
AND
BNE
BNE
LDA
LOA
EOR
EOR
STA
BRK
BRK

#% 00
0 0 111
00001111
VIAPCR
#%00001101
#%00001101
VIAPCR
VIAIFR
#%00000010
00000010
WTEOC
VIAORA
VIAORA
#% 1
%111111111
$40
$40

PORT A LINES INPUTS
;MAKE PORT
;BRING
EOC
LOW. ENABLE EOC
;BRING START CONV LOW,
; LOW TO HIGH
HIGH
;PULSE
HIGH
;PULSE START CONVERSION HIGH
iPULSE
;PULSE START CONVERSION LOW
;IS CONVERSION
COMPLETE-?
CONVERSION COMPLETE?
;NO. WAIT
WAIT
;YES,
DATA FROM
CONVERTER
FROM CONVERTER
FETCH DATA
;YES. FETCH
TRUE VALUE
iCOMPLEMENT DATA
DATA FOR
FOR TRUE
;COMPLEMENT
CONVERTER DATA
;SAVE CONVERTER

1 1 -101

Object
Program:
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004
0004)
0005
0005
0006
0006
0007
0007
0008)
0008}
0009
0009)
OOOA
000A
0008
000B
oooc
000C
000D)
000D}
OOOE
000E)
OOOF
OOOF
0010
0010
0011
0012)
0012}
0013
0013)
0014
0014
0015)
0015}
0016
0016)
0017
0017
0018
0018
0019
0019
001A
01A
0018B
001C)
001C}
' 0010D)
001E
001E
001F
001F
0020
0020
0021
0022
0022

tviemory
Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

A9
00
8D

LOA
LDA

#00

STA

VIADDRA
VIADDRA

LOA
LDA

00001101
#% 00
0 1 101

STA

VIAPCR

LOA
LDA

#%0000111111
#%00001

STA

VIAPCR

LOA
LDA

00001101
#% 00
0 0 101

STA

VIAPCR

LOA
LDA

VIAIFR

AND

#%00000010
00000010

BNE
BNE

WTEOC

LDA
LOA

VIAORA
VIAORA

EOR
EOR

#%11111111
% 1 1111111

STA

$40

VIADDRA
VIADDRA
A9
OD
OD
8D
VIAPCR
A9
OF
OF
8D
VIAPCR

A9
OD
OD
8D
VIAPCR
AD

WTEOC

VIAIFR
29
02
DO
DO
F9
AD

VIAORA
49
FF
FF
85
40
00

BRK
BRK

The VIA Peripheral
Peripheral Control
Control register
register bits are:
output
= 1 to make CA2 an output
Bit 3 =
(Manual Output
utput mode)
Bit 2 = 1 to make CA2 a level (Manual
Bit 1 = value
value of level on CA2
Status flag on a low-to-high
low-to-high transition
transition on CA11
Bit 0
O = 1to set Status
that VIAs
VIAs can be addressed
addressed using
using the Postindexed
Postindexed mode. The starting
starting address of
Note that
(VIAORB) is placed
the VIA (VIAORB)
placed in two memory
memory locations
locations on page zero: all VIA registers
registers can
then be reached with
ith appropriate
appropriate offsets
offsets in Index Register
Register Y.

11-102
11102

eletypewriter
A T ele ty
p e w rite r (TTY)
Purpose: Transfer
Transfer data to and from a standard 10-character-per10-character-persecond serial teleypewriter.
teleypewriter.

TTY
INTERFACE

The common
common teletypewriter
teletypewriter transfers data in an asynchronous
asynchronous
mode. The procedure
serial mode.
procedure is as follows:
follows:
1)
1)

state.
The line is normally
normally in the one state.

2)
2)

(zero bit) precedes each character.
A Start bit (zero

STANDARD
STANDARD
TTY

3)

The character
character is usually
usually 7-bit
7-bit ASCII with
ith the least significant
significant
transmitted
bit transm
itted first.

CHARACTER
FORMAT
FORMAT

4)

The most significant
significant bit is a Parity bit. which
which may be even,
one.
odd, or fixed at zero or one.

5)

Two stop bits (logic one)
one) follow
follow each character.

Figure 11-33 shows the format. Note that each character
character requires the transmission
transmission of
eleven bits, of which
hich only seven contain
contain information.
information. Since the data rate is ten characcharac­
11, or 110 Baud.
Baud. Each bit therefore
ters per second, the bit rate is 10 x 11,
therefore has a width
th of
1/110 of a second, or 9.1
9.1 milliseconds.
milliseconds. This w idth
th is an average: the teletypewriter
teletypewriter
does not maintain
maintain it to any high level of accuracy.

One stat __

_

Zero state

'1'

~

·o·

'1'

·o·

·o·

·o·

'1'

'O'

'-------.....,,,,,,------"'"-::~~

Brt

7 Data Bits

..._

Parity

Stop

Stop

Bit

Bit

Bit

O,aroctor is ASCII 'E' with odd parity (45 hex).

Remember that the ttan11miuion order is Start bit
l"O'l.bit o,bit 1,bit 2, bit 3, bit 4, bit 5, bit 6, Parity
bit, Stop bit ('1'), Stop bit l'1'1.

Figure 11-33. Teletypewriter Data Format
letypewriter
For a te le typ
e w rite r to communicate
communicate properly with
ith a computer, the following
ing pro­
procedures are necessary.
Receive (flowcharted
(flowcharted in Figure 11-34):
TTY
RECEIVE
RECEIVE
Step 1)
1) Look
Look for
for aa Start
Start bit
bit (a
(a logic
logic zero)
zero) on
on the
the data
data line.
line
MODE
2) Center the reception
Step 2)
reception by waiting
aiting one-half
one-half bit time, or 4,55
4.55
milliseconds.
milliseconds.
3) Fetch
Fetch the
the data
data bits,
bits, wwaiting
one bit
bit time
time before
before each
each one.
one.Assemble
Assemblethe
Step 3)
aiting one
thedata
data
bits into a word by first shifting
shifting the bit to the
circularly shifting
shifting
the Carry
Carry and
and then
then circularly
Carry. Remember that the least significant
the data with
ith the Carry.
significant bit is received
first.
Step 4)

Generate the received Parity and check it against
against the transm
itted Parity. If
transmitted
they do not match, indicate
indicate a "Parity
"Parity error."

Step 5)

Fetch the Stop bits (waiting
(waiting one bit time between
between inputs). If they are not corcor­
rect (if both Stop bits are not one),
one). indicate
"framing
indicate a "fram
ing error."

11-103
1103

Start

Get input data
(i.e., is parity =
received parity ?)

Parity
error

Wait one-half

Count = 2

bit time

Count

8

Data

0

Wait one bit time

Wait one bit time

Get input data

Get input data
Carry = Input data
Shift data right
with Carry

Framing

Count = Count-1

error

Count = Count - 1

Generate
received parity

End

Figure 11-34. Flowchart
Flowchart for Receive Procedure
Procedure

1,
_, 04
11-104

Task 1.
1. Read
Read Data
Data
Task
Purpose: Fetch
Fetch data
data from
from aa teletypewriter
through bit
Purpose:
teletypewriter through
bit 77 of
of aa VIA
VIA data
data port
port and
and place
place
the data
data into
into memory
memory location
location 0060.
the
0060. For
For procedure,
procedure. see
see Figure
Figure 11-34.
11-34
Source Program:
Program:
Source
(Assume that
that the
the serial
serial port
port is
Is bit
bit 77 of
of the
the VIA
VIA and
and that
(Assume
that no
no parity
parity or
or fram
framing check
check is
Is
necessary)
necessary)
LOA
LDA
STA
STA
STA
STA
LOA
LDA
WAITS
BMI
BMI
JSR
JSR
LOA
LDA
TTYRCV JSR
JSR
TTYRCV
ROL
ROL
ROR
ROR
BCC
BCC
STA
BRK
BRK

#0
VIAPCR
VIAPCR
VIADDRA
VIADDRA
VIAORA
WAITS
DLY2
#%10000000
10000000
DELAY
PIADRA
A
TTYRCV
$60

:MAKE ALL
ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
.MAKE PORT
PORT A
A LINES
LINES INPUTS
INPUTS
.IS THERE
BIT?
THERE A
A START
START BIP
.NO.
WAIT
NO. WAIT
,YES.
YES. DELAY HALF
HALF BIT
BIT TIME
TIME TO
TO CENTER
CENTER
.COUNT WITH
WITH BIT
BIT IN
IN MSB
MSB
.WAIT 11 BIT
W
BIT TIME
TIME
GET DATA BIT
.GET
BIT
.ADD DATA BIT
BIT TO
TO DATA WORD
.CONTINUE
IF COUNT
CONTINUE IF
COUNT BIT
BIT NOT
NOT IN
IN CARRY
CARRY

(Delay program)

DLY2
DELAY
DLY1
DLY

LOY
LDY
BNE
BNE
LOY
LDY
LOX
LDX
DEX
DEX
BNE
DEY
DEY
BNE
RTS
RTS

#5
DLY1
DLY1
#10
10
#$B44
#$B

.COUNT FOR
FOR 4.55
55 MS
.COUNT FOR
FOR 9.11 MS
:GET
FOR 0.91 MS
GET COUNT FOR

DLY
DLY1

Remember
O of the data is
Is received
Remember that
that bit
bit 0
received first.

11-105
11-105

Object Program:
Program:

MemoryAddress
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0001
0002
0002
0003
0003})
0004)
0005
0005
0006)
0006}
0007)
0008
0008
0009)
0009}
000A
OOOA)
000B
0008
OOOC
000D
OOOD
000E
000F
000F
0010
0011
0011
0012
0012
0013
0013
0014
0014
0015
0015
0
016)
0016}
0017)
0018
0018
0019
0019
001A
0
0 018
B

oooc

:

MemoryContents
Contents
Memory
(Hex)
(Hex)
A9
A9
00
8D

LDA
LDA

#0

STA
STA

VIAPCR
VIAPCR

STA
STA

VIADDRA
VIADDRA

VIAPCR
VIAPCR
8D
VIADDRA
VIADDRA

AD
AD

WAITS LDA
WAITS
LDA

VIAORA
VIAORA

VIAORA
VIAORA
30
FB
FB
20
30
00
A9
A9
80
20
34
00
2E
2E

BMI
BMI

WAITS
WAITS

JSR
JSR

DLY2
DLY2

LDA
LDA

#%10000000
#% 1
0000000

TTYRCVJSR
TTYRCV
JSR

DELAY
DELAY

ROL
ROL

VIAORA
VIAORA

ROR
ROR
BCC

sec

A
TTYRCV
TTYRCV

STA
STA

$60
$60

VIAORA
VIAORA

001D
0010

6A
90
F7
F7
85
85
60
00

0030
0030
0031
0031
0032
0032
0033
0033
0034
0034
0035
0035
0036
0036
0037
0037
0038
0038
0039
0039
003A
0038
003B
003C
003C
003D
003D
003E
003E

AO
AO
05
05
DO
DO
02
AO
AO
0A
OA
A2
A2
84
B4
CA
CA
DO
DO
FD
FD
88
DO
DO
F8
F8
60

001C
001
c

Instruction
Instruction
(Mnemonic)
(Mnemonic)

BRK
BRK

DLY2
DLY2

LDY
LDY

#5

BNE
BNE

DLY1
DLY1

DELAY
DELAY LDY
LDY

# 10

DLY1
DLY1

LDX
LDX

#$84
B

DLY
DLY

DEX
DEX
BNE
BNE

DLY
DLY

DEY
DEY
BNE
BNE

DLY1
DLY1

RTS
RTS

1 1-106
06

assumes that the Stack can
can be used
This program assumes
subroutine calls,
i.e.,.. that the
used for subroutine
calls. i.e
the
monitor
has already initialized
initialized the
the Stack Pointer.
Pointer. Otherwise
Otherwise you will
onitor has
ill have
have to initialize
the Stack Pointer as
as shown in Chapter 10.
the
10.
for the delay routine were calculated
The constants for
calculated just as shown earlier in this chapter.
chapter.
You might
ight try determining
ining them for yourself. The delays do not have
have to
to be
be highly accu­
accurate because the reception is centered,
centered. the messages
messages are
rate
are short,
short. the bit rate
rate is
is low,
low. and
and
highly accurate itself.
the teletypewriter
teletypewriter is not highly
itself.
How would you extend this program to check parity?

,1 ,1 -_,1 007

Task 2:
2: W r
Writee D a
Data
Ta
Purpose: Transmit
Transmit data to a teletypewriter
teletypewriter through
through bit 0 of a VIA Output
utput (Data)
(Data)
register. The data is in memory location 0060.
Transmit
Transmit (flowcharted
(flowcharted in Figure 11-35)
1) Transmit
Transmit aa Start
Start bit
bit (i.e..
(i.e . aa logic
logic zero).
zero)
Step 1)
Transmit the
the seven
seven data
data bits,
bits. starting
starting with
Step 2) Transmit
ith the least
significant
significant bit.

TTY
TRANSMIT
TRANSMIT
MODE

Generate and
and transm
transmit the
the Parity
Step 3) Generate
Parity bit.
bit.
Transmit tw
two Stop
Stop bits
bits (i.e.,
(i.e.. logic
logic ones).
ones).
Step 4) Transmit
The transmission
transmission routine
routine must wait
it one bit time between each operation.

=

start

t

Get output data

Shift data left

circuiertywith Carry
Count; 11

Send data to
Output Port

Shilt data right
circu4artywith Carry
Carry ; 1 (stop bit)

Weit l bit time

Count = Count . 1

End

Figure 11-35. Flowchart
Flowchart for Transmit
Transmit Procedure

11-108
11108

Source Program
(Assume that
that parity
parity need not be generated)
generated)
(Assume

TBIT

LDA
LOA
STA
STA
LDA
LOA
STA
LDA
LOA
LDX
LOX
JSR
SEC
SEC
ROR
ROR
ROL
ROL
DEX
BNE
BNE
BRK
BRK

#00
VIAPCR
VIAORB
#$FF
#$FF
VIADDRB
VIADDRB
$60
$60
#11
#11
DELAY

LINES INPUTS
;MAKE ALL CONTROL LINES
;FORM START BIT
OUTPUTS
LINES OUTPUTS
PORT B LINES
;MAKE PORT
;GET
GET DATA
CHARACTER
COUNT
;COUNT== 11 BITS IN CHARACTER
;WAIT
W
AIT 1 BIT TIME
BIT
STOP BIT
CARRY TO FORM STOP
;SET CARRY
OF CHARACTER
;GET
GET NEXT BIT OF
:SEND NEXT BIT TO TTY

A
VIAORB
TBIT

X.
The DELAY subroutine
must preserve
preserve the Accum
ulator and Index Register
Register X.
Accumulator
subroutine used here must
transmitted
Remember that
that bit
bit 0
must be transm
itted first.
O of the data must
Remember

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
0003)
0003}
0004)
0004
0005
0005
0006)
0006}
0007)
0007
0008
0008
0009
0009
000A
OOOA
000BI
OOOB}
ooo
c)
oooc
000D
000E
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017)
0017}
0018)
0018
0019
0019
001A
01A
001B
001B
00
001Cc

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

A9
00
8D

LDA
LOA

#00

STA

VIAPCR

STA

VIAORB

LDA
LOA

#$FF
#$FF

STA

VIADDRB

LDA
LOA

$60

LDX
LOX

#11

JSR
JSR

DELAY

SEC
SEC
ROR
ROR
ROL
ROL

A
VIAORB

DEX
DEX
BNE
BNE

TBIT

VIAPCR
8D
VIAORB

A9
FF
FF
8D
VIADDRB
A5
60
A2
OB
OB
20
30
00
38
6A
2E

TBIT

VIAORB
CA
DO
F5
00

BRK
BRK

1 1 -109
109

In actual applications.
applications, you will
ill find itIt necessary to place a one on the teletypewriter
teletypewriter line
after configuration.
In the mark (one)
configuration, since that line should normally
normally be in
(one) state.
state.

Each character
11 bits, with
(zero) and ending
Each
character consists of 11
ith a Start bit (zero)
ending with
ith two Stop bits
(ones).
(ones).
Note that you can generate parity
parity by counting
counting bits as shown in Chapter
Chapter 6. The program
is:
is:

CHBIT
CHBIT
CHKZ
CHKZ

LOY
LDY
LOA
LDA
BPL
BPL
INY
ASL
BNE
BNE
BRK
BAK

#00
$60
CHKZ
CHKZ
A
CHBIT
CHBIT

;BIT COUNT== ZERO
ZERO
;GET
GET DATA
;IS NEXT DATA BIT 1?
;YES,
COUNT
YES, ADD 1 TO BIT COUNT
;EXAMINE NEXT
NEXT BIT
BIT POSITION
POSITION
;UNLESS
BITS ARE
ARE ZEROS
ZEROS
UNLESS ALL BITS

'1' bits in the data. The least significant
Index Register Y contains
contains the number
number of T
significant bit of
Index Register Y is therefore an even Parity bit.

!

These procedures
procedures are sufficiently
sufficiently common
common and complex
complex to merit a
IUART!
UART |
special
UART. or Universal
synchronous
special LSI device·
device: the UART,
niversal A syn ch
ro no u s
4 The UART will
Receiver/Transmitter
Receiver/Transmitter.24
ill perform
perform the reception
reception procedure
procedure and provide
Ready signal. It will
the data in parallel form and a Data Ready
ill also accept data in parallel
Ready signal when
form, perform the transmission
transmission procedure.
procedure, and provide a Peripheral Ready
UARTs may have many other features,
features. including:
itIt can handle more data. UARTs
including:

1)
1)

8). parity
options. and numbers
A bility
ility to handle various bit lengths
lengths (usually 5 to 8),
parity options,
numbers of
1, 1-1/2.
2).
Stop bits (usually 1.
1-1/2, and 2).

2)
2)

Indicators
errors, parity errors,
errors. and "overrun
Indicators for framing
ing errors,
"overrun errors" (failure to read a
character
received).
character before another
another one is received).
Rs-23225
(ATS) output
RS-23225 compatibility,
patibility: ie
i.e.,.. a Request-to-Send
Request-to-Send (RTS)
output signal that indicates
indicates
communications
(CTS) inthe presence of data to comm
unications equipment
equipment and a Clear-to-Send
Clear-to-Send (CTS)
in­
put signal that indicates.
ATS. the readiness of the communications
indicates, in response to RTS,
communications
equipment
provIsIons for other RS-232 signals,
signals. such as Received
Received
equipment. There may be provisions
Signal Quality,
Ready, or Data Terminal
Quality. Data Set Ready,
Terminal Ready
Ready.
Tristate
Tristate outputs
outputs and control
control compatibility
patibility with
ith a microprocessor.

3)

4)
5)

Clock options
options that allow the UART to sample IncomIng
incoming data several times in
In order
to detect
detect false Start bits and other errors.
errors.

6)
6)

Interrupt
Interrupt facilities
facilities and controls.

port. an output
UARTs act as four parallel ports: an input
input data port,
output data port,
input
port. an input
status port.
port, and an output
output control
control port. The status bits include
include error indicators
indicators as well
as Ready flags. The control
control bits select various options. UARTs
inexpensive ($5 to
UARTs are inexpensive
$50, depending
depending on features) and easy to use.
use.

11-110
1110

THE 6 8
5 0 ASYNCHRONOUS
ASYNCHRONOUS C O M M U N
IC A T IO N S INTERFACE
MMUNICATIONS
850
(ACIA)26, 27
ADAPTER (ACIA)26.
6850 ACIA,
ACIA, or Asynchronous Communications InterInter­
6850 ACIA
6850
The 6850
Adapter (see
specifically
REGISTERS
REGISTERS
(see Figure 11-36) is a UART specifically
face Adapter
designed for use in 68006800- and 6502-based
6502-based microcommicrocom­
puters. It occupies twoo memory addresses and contains twoo read-only registers
con(received data and status) and twoo write-only
rite-only registers (transmitted
(transmitted data and con­
(received
trol). Tables 11-16 and 11-17 describe
describe the contents
contents of these registers.
Note the follow
ing special features of the 6850
6850 ACIA:
following

registers
distinct registers.
1)
rite cycles
physically distinct
address physically
cycles address
and wwrite
Readand
1) Read
as addresses
Therefore, you cannot
cannot use the ACIA registers as
Therefore.
Shift. which
for instructions
instructions like Increment.
Increment, Decrement.
Decrement, or Shift,
which
involve both read and write
rite cycles.
involve

------

SPECIAL
FEATURES
OF 6850
6850 ACIA

copy
2) The
save aa copy
to save
have to
You wwill have
CPU.You
the CPU.
by the
read by
be read
cannot be
register cannot
Control register
ACIA Control
The ACIA
Control register
register in
memory if the program needs its value.
In memory
of the Control
register
Control register
in Control
ones in
placing ones
by placing
3) The
only by
reset only
be reset
can be
input. ItIt can
Reset input.
no Reset
has no
ACIA has
The ACIA
Is necessary before the ACIA
RESET)is
procedure (called MASTER
MASTER RESET)
1. This procedure
bits 0 and 1.
is used,
starting character.
used. in order to avoid having a random starting
4) The
active-low. Request-to-Send
should
particular. should
in particular,
(RTS).in
Request-to-Send (RTS),
all active-low
are all
signals are
RS-232 signals
The RS-232
Is not in use
be brought
brought high to make it
inactive if
use.
1f itIt is
It inactive
16
the ++ 16
and the
supplied and
Hz isIssupplied
1760 Hz
5) The
Typically 1760
clock. Typically
external clock.
an external
requires an
ACIA requires
The ACIA
register bit 1 = 0.
0, bit 0 = 1)
ill use the clock to
1) is used. The ACIA will
mode (Control register
lines.
center the reception
reception in
In order to avoid false Start bits caused by noise on the lines.
center

Status
the Status
of the
bit 00 of
flag isIs bit
RDRF)flag
or RDRF)
Full. or
6) The
Register Full,
Data Register
(Receive Data
Ready (Receive
Data Ready
The Data
Is bit 1
TORE) flag is
Empty. or TDRE)
(Transmit Data Register Empty,
register. The Peripheral Ready (Transmit
of the Status
Status register.

1 1 -111
111

Table 11-16. Definition
Definition of 6850
6850 ACIA Register Contents

Buffer Address
Data
Bus
Line
Line
Number
Number

RS-R/W
RS•R/W
Transmit
Transmit
Data
Register

RS•R/W
RS-R/W
Receive
Data
Register
Register

RS·R/W
RS-R/W

RS•R/W
RS-R/W

Control
Register

Status
Status
Register

(Write
rite Only) (Read Only)

Only)
(Write
rite Only)

(Read Only)

0

Data Bit 0*
o•

Data Bit 0

Counter Divide
Counter
Select 1 (CRO)
(CRO)

Receive Data Register
(RDRF)
Full (RDRF)

1

Data Bit 1

Data Bit 1

Counter Divide
Counter
Select 2 (CR1)
(CR1)

Transmit Data Register
Transmit
Empty (TDRE)
(TORE)

2

Data Bit 2

Data Bit 2

Word
ord Select 1
(CR2)
(CR2)

Data Carrier Detect
(DCD)
(DCD)

3

Data Bit 3

Data Bit 3

Word
ord Select 2
(CR3)
(CR3)

Clear-to-Send
(CTS)
(CTS)

4

Data Bit 4

Data Bit 4

Word
ord Select 3
(CR4)
(CR4)

Framing Error
(FE)
(FE)

5

Data Bit 5

Data Bit 5

Transmit
Transmit Control
Control 1
(CR5)
(CR5)

Receiver Overrun
(OVRN)
(OVRN)

6

Data Bit 6

Data Bit 6

Transmit
Transmit Control
Control 2
(CR6)
(CR6)

Parity Error (PE)
(PE)

7

Data Bit 7""..' Data Bit 7 .."

Receive Interrupt
Interrupt
(CR7)
Enable (CR7)

Interrupt
Interrupt Request
(IRQ)
(IRQ)

•* Leading bit = LSB = Bit 0
"•• Data bit will
ill be zero in 7-bit
7-bit plus parity
parity modes
*•·•
'* Data bit is "don't
o n 't care" in 7-bitit plus parity modes

1 1·112
-1 1 2

81ts
Table 11-17. Meaning
Meaning of the 6850 ACIA Control
Control Register Bits

CR6

CRB
CR&

Function

0
0
1
1

0
1
0
1

Transm11t1ng
low. Transm
ITT= = low,
RTS
itting Interrupt
Interrupt Disabled
RTS
itting Interrupt
Interrupt Enabled
Transmitting
RTS = low. Transm
terrupt
nsm1tt1ng
ITT's= high.
RTS
high, T ra n sm
ittin
In te
rru p t Disabled
Disabled
Break level on the
RTS = low. Transmits
RTS
Transmits a Break
Transmit
Transmit Data Output
Output. Transmitting
Transmitting
-fnterrupt
"Interrupt Disabled

R'
CR4

CR3
CR3

CR2
CR2

Function

0
0
0
0
1
1
1
1

0
0
1

0
1
0

Stop Bits
+ Even Parity ++ 2 Slop
7 Bits +
7 Bits +
+ Odd Parity ++ 2 Stop Bits
+ Even Parity ++ 1 Stop Bit
7 Bits +
7 Bits +
+ Odd Parity ++ 1 Stop Bit
+ 2 Stop Bits
8 Bits +
Btt
+ 1 Stop Bit
8 Bits +
+ 1 Stop Bit
8 Bits +
Even Parity +
+ Even
+ Odd Parity ++ 1 Stop Bit
8 Bits +

:r
CR1

CRO
CRO

Function

0
0
1

0
1
0
1

1
16
7
+ 64
Master Reset
Reset
Master

1

1

1

0
0
1
1

0
1
0
1

7
+

7
+

11-113
-1 1 3

Transmit

Clock

Panty

Clock

Gen

Gen

Enable

Read/Wrtte
Ch,p Select 0
Chip Select 1
Chip Select 2

Transmit

Chip
Select

Data

Transmit

and

Data

Read/Write

Register

Control

Transmit

Aegrster

Control

Select

Clear-toSend

Status
Register

DO
D1
D2

Interrupt

Interrupt

Log,c

Request

D3

Data

Data°
~

D4

Bus
Butters

Detect

D5
D6

Requestto- Send

D7
Receive
Control

Panty
Check

Receive
Data
Register
Receive

Shift
Register

Receive _____________________

_..,.

Clock

Clock
Gen

Sync

Receive

Logic

Data

11-36. Block Diagram of the 6850 ACIA
Figure 11-36.

11-114
11-114

Task: Receive data from a te le typ
e w rite r through
6850 ACIA and store the data
through a 6860
typewriter
in memory location 0060
0060
Source Program:
Program:

WAITD
WAITD

LDA
LOA
STA
LDA
LOA

#%00000011
#%00000011
ACIACR
#%01000101
01000101

STA
LDA
LSR
LSR
BCC
BCC
LDA
LOA
STA
BRK
BRK

ACIACR
ACIASR
A
WAITD
WAITD
ACIADR
$60

;MASTER RESET
RESET ACIA
:CONFIGURE
FOR TTY WITH ODD
ACIA FOR
;CONFIGURE ACIA
PARITY
; PARITY

;GET
GET ACIA STATUS
DATA BEEN
RECEIVED?
BEEN RECEIVED?
;HAS DATA
;NO.
NO, WAIT
WAIT
YES, FETCH
FROM ACIA
FETCH DATA FROM
;YES.
;SAVE DATA

Program:
Object Program:
Memory
Memory Address
Address
(Hex)
(Hex)

.

0000
0000
0001
0002
0003)
0003}
0004)
0004
0005
0005
0006
0006
0007
0008)
0008}
0009
0009)
000A
OOOA
0008)
OOOB}
ooo
c)
oooc
000D
000E
OOOE
000F
OOOF
0010
0010
0
011)
0011}
0012
012)
0013
0013
0014
0014
0015
0015

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)
A9
03
8D

LDA

#% 000
0 011
00000011

STA

ACIACR

LDA
LOA

#%01000101
#%01000101

STA

ACIACR

LDA

ACIASR

LSR
LSR
BCC
BCC

A
WAITD
WAITD

LDA

ACIADR

STA

$60

ACIACR

A9
45
8D
ACIACR
AD

WAITD
WAITD

ACIASR
4A
90
FA
AD
ACIADR
85
60
00

BRK
BRK

0
The program
theACIA
ACIAoriginally
originallybybyplacing
placingones
onesininControl register
Control bits
register
must reset the
program must
and 1.
an internal
internal power-on
power-on reset
reset which
which holds theholds
thein
ACIA
the
ACIA
1. The ACIA does have an
reset state until
until Master
Master Reset is applied.
applied.
The program
program configures
configures the ACIA Control
Control Register as
follows:
follows:
disable the receiver
receiver interrupt
interrupt
Bit 7 = 0 to disable
Request-to-Send (RTS)
(RTS) high (inactive)
Bit 6 = 1 to make Request-to-Send

EXAMPLE
OF 6850
6860 ACIA
CONFIGURATION

disable the transm
itter interrupt
interrupt
transmitter
Bit 5 == 00 to disable
words
Bit 4 = 0 for 7-bitit words
bits
Stopbits
with 2 2Stop
parityw ith
oddparity
forodd
Bit 3 == 00,, Bit 2 = 1for
Bit 1 = 0. Bit 0
for -s-1616clock
clock(1760
(1760Hz
Hzmust
mustbebesupplied)
supplied)
O = 1 for+

11-1165
11-

bits 0
inthe

The Received
Received Data
Data Status
Status flag
flag isis Status
Status register
register bit
bit 0.0. Suppose
The
Suppose we
we tried
tned to
to replace
replace
LOA
LDA
LSR
LSR

ACIASR
ACIASR
A A

with the
the single
single instruction
instruction
w
LSR
LSR

ACIASR
ACIASR

What wou
happen?
W
wouldId happen?
Remember that
that the
the Status
Status and
and Control
Remember
Control registers
registers share
share an
an address
address but
but are
are physically
physically dis­
distinct
tinct.
Try adding
adding an
an error-checking
routine to
to the
the program.
program Set.
Set.
Try
error-checking routine
(0061) == 00 if11no
no errors
errors occurred
occurred
(0061)
parity error
error occurred
occurred
== 11 ifif aa parity
(Status register
register bit
bit 66 == 1)
1)
(Status
an overrun
overrun error
error occurred
occurred
== 22 if11an
(Status register
register bit
bit 55 == 1)
1)
(Status
framing error occurred
occurred
== 3 if a fram
1)
(Status register bit 4 = 1)
that the
the priority
1sfrom
from MSB
MSB to
Assume that
priority of the errors is
to LSB
LSB in the
the ACIA Status
Status register
register
(i.e.,
e. parity errors have priority
errors which,
priority over overrun errors
which, in turn,
priority over
turn, have
have pnonty
over
framing
than one error has
has occurred)
fram
ing errors if11more than

11
-116
11-116

memory location 0060
0060 to a te le typ
e w rite r through a 6850
6850
letypewriter
Task: Send data from memory
ACIA
Source Program:

WAITR

LDA
LOA
STA
LDA
LOA

#% 0 0
00 011
00000011
ACIACR
#%01000101
01000101

STA
LDA
LOA
BIT
BEQ
BEO
LDA
LOA
STA
BRK
BAK

ACIACR
#%00000010
00000010
ACIASR
WAITR
$60
ACIADR

RESETACIA
;MASTER RESET
FOR TTY WITH ODD
;CONFIGURE ACIA FOR
iCONFIGURE
; PARITY

FOR DATA?
READY FOR
; IS ACIA READY
AIT UNTIL IT IS
;NO. WAIT
YES, GET
GET DATA
;YES.
TRANSMIT IT
;AND TRANSMIT

Object Program:
Object
Memory Address
Address
Memory
(Hex)
(Hex)
0000
0000
0001
0002
0002
00031
0003}
0004>
0005
0005
0006
0006
0007
0007
0008)
0008}
0009)
0009
000A
OOOA
000B
OOOB
OOOC
oooc
000D)
0000}
000E)
OOOE
000F
OOOF
0010
0010
0011
0012
0012
0013
0013
00141
0014}
0015)
0015
0016
0016

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

A9
03
8D
80

LOA
LDA

#% 00
0 011
00000011

STA

ACIACR

LDA
LOA

#%01000101
#%01000101

ACIACR
A9
45
8D
80

STA

ACIACR

ACIACR

A9
02
2C

WAITR

LDA
LOA

#%00000010
00000010

BIT
BIT

ACIASR

BEQ
BEO

WAITR

LDA
LOA

$60

STA

ACIADR

ACIASR
FO
FO
FB
FB
A5
60
8D
80

ACIADR
BRK
BAK

00

itter Status
Status flag is Status
Status register
register bit 1.
could you modify
odify the receive
1. How could
Transmitter
The Transm
program to use the Bit Test Instruction?
Instruction?
program

11-117

MUNICATIONS
INTERFACE
THE 6551 ASYNCHRONOUS C O M M U N
IC A T IO N S INTERFACE
(ACIA)
ADAPTER (ACIA)
6551 ACIA
The 6551 ACIA
ACIA is a variation of the 6850
6850 device that
that can also
REGISTERS
tie
REGISTERS
be used in 68006800- or 6502-based
6502-based systems. Figure 11-37
11-37 is a
block diagram
diagram of this device. It has most of the features
features of the
6850
provide 15
6850 ACIA and also has an on-chip baud rate generator
generator that can provide
programmable baud rates derived from a standard 1.8432
programmable
1.8432 MHz
MHz external
external crystal.
baud rates w ithout
Thus the 6551
6551 ACIA can provide virtually any of the common baud
out
an external
external timer
er or baud rate generator. The device
device has four
four internal
internal registers
addressed as described
described by Table 11-18. Its operation
operation is controlled
controlled by twoo registers:
1)
1)

The Control
(see Figure 11-38) controls
Control register
register (see
controls the baud rate generator,
generator, the word
word
length.
..e_.
______
_
length, the number
number of stop bits, and the receiver
receiver clock source.

2)

EXAMPLE OF
The Command
register (see
(see Figure 11-39) controls
controls parity
parity
Command register
6551 ACIA
checking
checking and generation.
generation, interrupt
interrupt enabling.
enabling, and the
CONFIGURATION
CONFIGURATION
RS-232 handshake
handshake signals. Note that
that the program
program may
reset the 6551 ACIA at any time
time by writing
ritin g any data into
the address of the Status
Status register
register (see
(see Figure 11-40). For example,
example. the following
following
program
program resets a 6551 ACIA and configures
configures it for a 10 character
character per second
teletypewriter
teletypewriter with
ith odd parity
parity and two stop bits:
LDA
STA
STA

#%10110011
#% 1
0110011
ACIASR
ACIASR
ACIAMR
ACIAMR

LOA
LDA
STA

#%00100011
#% 001
00011
ACIACR
ACIACR

:RESET6551
6551 ACIA
ACIA
;RESET
:CONFIGUREMODE
MODE FOR
FOR TTY (7
(7 BITS,
BITS, 22 STOP
STOP
;CONFIGURE
BITS)
: BITS)
:CONFIGUREFOR
FORODD
ODD PARITY,
PARITY, NO
;CONFIGURE
INTERRUPTS
; INTERRUPTS

We have given
given the name ACIAMR
ACIAMR to the Control
Control (Mode) Register.
The program
program configures
configures the 6551 ACIA Control
Control (Mode) register
register as follows:
follows:
for 22 stop
stop bits
bits
1 1for
Bit 7 =7 =
Bit 6 =6 =
0.0,bitbit5 5= =1 1forfor7-bit
7-bitwords
words
Bit 4 =
= 1 to generate
generate receiver
receiver clock from the on-board
on-board baud rate generator
generator
Bits 0-3 = 0011 for 109.92
109.92 Baud (10 characters
characters per second) from the internal
internal
generator
baud rate generator

The program
program configures
configures the 6551 ACIA Command
Command register
register as follows:
follows:
transmitter
Bit 7 = O.bit 6 = 0, bit 5 = 1 for odd parity
parity on both receiver
receiver and transm
itter
Bit 4 = 0 so characters
automatically
characters are not autom
atically echoed back through
through the
transm
itter
transmitter
itter interrupt
interrupt and bring RTS
transmitter
RTS high
Bit 3 = 0, bit 2 = 0 to disable the transm
(inactive)
Bit 1 =1 =11to
to disable
disable the
the receiver
receiver interrupt
interrupt (this is a mask bit)
Bit O 0
= =1 1toto enable
enable the
the Receiver/Transmitter
Receiver/Transmitter

11 - 1 1
118

Transmit
Control
Control

Transmit
Transmit
Data
Data
Register
Register

<t>
2
<1>2

^

/W
R/
W—

►

Select

CS0
CSo “
------ ►

Control

RSo
RS
q

Logic

CTS

Transmit

= >

Shift
Shilt

TxD

Register
Register

and
and

ccs,
s]

►

RSi1

Status

Interrupt
Interrupt

Register
Register

Logic

IRQ

R ES -------►

^

DSR
------ DSR

RxC
XTAL
XTAL11
XTAL2
XTAL2

Rate
Rate
Generator
Generator

^

Rece1ve
Receive

Receive

Data
Data

DCD
DCD

Baud
Baud

Control
Register
Register

DBo

^

Register
Register

cN

Shift

RxD
►— RxD

Register
Register

Bus
Bus
Buffers
DB7

o

Command

Receive
Receive

Register
Register

Control

'---------------►-□TR
'----------------RTS

-► R T S

Figure 11-37. Block Diagram of the 6551 ACIA
Table 11-18. Addressing
Addressing 6551 ACIA Internal
Internal Registers
RS t1

RSo
q

0

0

Transmit Data Register
Transmit
Register

Receiver
Receiver Data
Data Register
Register

0

1

Programmed Reset
"Don't Care")
Reset (Data
(Data is
is "Don't
Care")

Register
Status Register

1

0

Command Register

1

0

Control Register

Write
rite

Read
Read

The table shows that only the Command and Control registers are read/write.
read/write. The Programmed Reset
Reset operation

used to clear the S Y 6551 registers. The Programmed Reset
does not cause any data transfer, but is used
Reset is slightly
different
Reset (RES)
{RES) and
different from
from the Hardware Reset
differences are described in the
defini­
and these differences
the individual register definitions.

11 - 1 1
119

m

7 6 5 4 3 2 1 0 ..,__

I I

II
j

I

I I

Bit Number

Register
Control Register

j~L_

~

e

.._ _______

-BBaud
aud Rate Generator

External Clock Baud
Baud
16x External

0

0

0

0

0

0

0

1

50

0

0

1

0

75

0

0

1

1

1 0 9.92
.9 2

0

1

0

0

4.58
134
.5 8

0

1

0

1

1 50

0

1

1

0

300

0

1

1

1

600

1

0

0

0

1 2000

1

0

0

1

1 8000

1

0

1

0

2 400
00

1

0

1

1

3 600
00

1

1

0

0

4 800
00

1

1

0

1

7 2000

1

1

1

0

9 600
00

1

1

1

1

1 9,200
00

Receiver Clock
Clock Source
Source
- Receiver
External Receiver Clock
Clock
0 = External

= Baud
Baud Rate Generator
1 =
Word Length

.._ ________

■ W ord Length
Bit
Bit
Data Word
Length
6 5

'-----------Stop

~

~

000

8

011

7

10

6

1 1

5

Stop Bits

~
~

0 = 11 Stop Bit
1 = 2 Stop Bits

Sit if Word Length
1 Stop Bit
'A
•Allows for 9 -bitit transmission
transmission

=
= 8 Bits
Bits and Parity*
Parity•
Vt

Bits if Word Length
Length
1 1/2 Stop Bits
== 5 Bits
Bits and No Parity.
Parity.

plus parity).
(8 data bits plus
7

6

5 4

3 2

1 0 .,__Bit -B it Number

-H ardw are Reset
~Hardware
Reset
0 0
0 0 0 0 0 0
~“ Program Reset
Reset

Figure 11-38. Definition
Definition of 6551 ACIA Control
Control Register Contents
Contents

11-120
11120

I
I
j

I

g;

7 6 5 4 3 2 1 0 *,.__Bit

I I I I I

Bit Number

Command register
I I l4--Command

L

h

I

Data
Ready
-D a
ta Terminal Ready
0 = Disable Receiver/Transmitter
Receiver/Transmitter (DTR
(DTR high)

Enable Receiver/Transmitter
(OTA low)
1 = Enable
Receiver/Transmitter (DTR
~----Receiver-R eceiver Interrupt
Interrupt Enable
Bit 7
0 = IRQ Interrupt
Interrupt Enabled from
from Bit

-Transm itter Controls
Controls

Bit
Bit

~-------

3

2

Transmit
Transmit
Interrupt
Interrupt

0

0

Disabled

RTS
ATS
Level
Level
High

I
I
Other

0

1

Enabled
Enabled

Low

1

0

Disabled

Low

-—
-—
-—

1

1

Disabled
Disabled

Low

Transmit
BAK
Transmit BRK

for Receiver
• Normal/Echo
Normal/Echo Mode for

Normal
0 = Normal
1 -= Echo
Echo

~---------Parity

- Parity Check Controls
Bit
7 6
__5_
2-§___2..
--------- 0

Operation
0 Parity
Parity
Disabled
- No
Parity
Disabled
- No
Parity
Bit Bit

0

00

11

0

1 1 11

1

00

11

Mark Parity
Parity Bit
81t Transmitted,
Mark
Transmitted.

1

1 1 11

Space Parity
Panty Bit
Bit Transmitted,
Space
Transm,tted.

Generated - No
No Parity Bit Received

Odd Parity
Parity Receiver
Odd
Receiver and
and Transmitter
Transmitter
Even
Even Parity
Parity Receiver
Receiver and
and
Transmitter
Transmitter

Parity Check Disabled
Parity Check Disabled
7 6 5 4 3 22 11 0 -4--Bit -B it Number
Number
0

o

1°
I~,~
I~
I~
,~t:=;;~:::•R:::~t

1°1°

1 o

olo

0

1 0

- Hardware Reset

0

1 0

- Program Reset

Figure 11-39. Definition
Definition of 6551 ACIA Command
Command Register Contents
Contents

11-121

L

I

I
I
I
I

Register
of Status Register

IRQ Interrupt Disabled
1 = IRQ
Disabled
------Transmitter

I

I

7 6 5 4 3 2 1 0 ..,._Bit -B it Number

I I II II II II II II I
Cl

-S ta
tu Register
Status

'
Error•
■ Parity Error*

=
=

0 = No
No Parity Error
Error
1 = Parity Error
Error Detected
“ Framing Error*
Error•
0 = No
No Framing
Framing Error
Error
1 = Framing Error Detected

'------

Overrun•
■ Overrun*
0 = No
No Overrun
Overrun

=

1 = Overrun Has
Has Occurred

'-------

■ Receiver
Receiver Data Register Full
Full
0 == Not
Not Full
Full

=

1 = Full
Full

'--------

- Transmitter
Transmitter Data Register Empty

=
=

0 = Not Empty
Empty
1 = Empty

.._________

Data Carrier
Carrier Detect
Detect (DCD)
(DCD)
- Data

=
=

0 = DCD
DCD low (Detect)
(Detect)

DCD high (Not
(Not Detected)
1 = DCD
.._ _________

Data Ready
Ready (DSR)
(DSR)
■ Data

DSRlow (Ready)
(Ready)
0 == DSR
1 =
= DSR
DSR high (Not Ready)
Ready!
Interrupt (IRQI

.._ __________

* Interrupt (IRQ)

=

0 = No Interrupt

•No interrupt
*No
interrupt occurs for these conditions.
conditions.

7

6

5 4

3

2

1 0 >

1 = Interrupt Has
Has Occurred

-B it Number
-H ardw are Reset
-Program Reset

Figure 11-40. Definition
Definition of 6551 ACIA Status Register Contents

1 1-1222

LOGICAL AND PHYSICAL
PHYSICAL DEVICES28
An important
portant goal in writingg 1/0
I/O routines is to make them j!LOGICAL
LOGICAL DEVICES!|
independent
independent of particular physical hardware. The routines
1/0 devices, with
can then transfer
transfer data to or from I/O
ith the actual addresses being sup­
supplied as parameters. The I/O
1/0 device that
that can actually be accessed through a particpartic­
ular interface
interface is referred
referred to as a physical device. The I/O
1/0 device to which the pro­
program transfers data is referred
referred to as a logical device. The operating system or
supervisor program must provide a mapping of logical devices on to physical
devices, thatt is, assign actual
1/0 addresses and characteristics
actual physical I/O
characteristics to be
1/0 routines.
used by the I/O
Note the advantages
advantages of this approach:

1)
1)

The operating
operating system can vary the assignments
assignments under user control. Now the user
can easily substitute
substitute a test panel or a development
development system interface for the actual
1/0 devices. This is useful in field maintenance
I/O
maintenance as
debugging and testing.
as well as
as in debugging
Furthermore.
1/0 devices for different
Furthermore, the user can change the I/O
different situations:
situations: typical
examples are directing
directing intermediate
intermediate output
output to a video display and final output
output to a
printer or obtaining
obtaining some input
printer
input from a remote communications
unications line rather than
from a local keyboard.

2)

1/0 routines can handle several identical
The same I/O
identical or similar
ilar devices. The operating
system or user only has to supply
supply the address of a particular
particular teletypewriter.
teletypewriter, RS-232
RS-232
terminal. or printer,
printer. for example.
terminal,

3)

Changes. corrections.
1/0 configuration
Changes,
corrections, or additions
additions to the I/O
configuration are easy to make since
only the assignments
assignments (or mapping) must be changed.

On the 6502 microprocessor.
microprocessor, either
either the Preindexed (Indexed Indirect) or Postindexed
(Indirect Indexed) addressing mode can be used in the I/O
(Indirect
indepen­
1/0 routines to provide independence of specific
addresses. Preindexing
specific physical addresses.
Preindexing is convenient
convenient since itIt allows the
choice of a physical
table.
physical device address from a table.

1/0 addresses is maintained
zero. all that
If a table of I/O
maintained on page zero,
I/O
1/0 DEVICE
an I/O
1/0 routine
Is an index into that table. It can then ac­
TABLE
routine needs is
TABLE
ac1/0 device by using the Preindexed (or
(or Indexed In­
cess the I/O
Inexample. the device number
direct) addressing mode. If. for example,
number is in memory location DEV,
DEV.
the program to calculate
calculate the index would
would be:
LOA
LDA
ASL
TAX

DEV
DEV
AA

;GET DEVICE
:GET
DEVICE NUMBER
NUMBER
:;MULTIPLY
MULTIPLY BY
BY 22 FOR
FOR2-BYTE
2-BYTE ADDRESS
ADDRESS TABLE
TABLE

1/0 device with the instructions
Data may now be transferred to or from the appropriate
appropriate I/O
instructions
LOA
DATA
:GET DATA
DATA
LDA
DATA
:GET
(IOTBL.X)
:SEND TO
STA
(IOTBL.X)
:SEND
TO LOGICAL
LOGICAL I/O
1/0DEVICE
DEVICE
or
LOA
LDA
STA

(IOTBL.X)
(IOTBL.X)
DATA
DATA

:GETDATA
DATA FROM
FROMLOGICAL
LOGICAL I/O
1/0 DEVICE
DEVICE
:GET
:SAVE DATA
DATA
:SAVE

1/0 routine can transfer data to or from many different
1/0 devices merely by
The same I/O
different I/O
being supplied
flexibility
supplied with
ith different
different indexes. Compare the flexib
ility of this approach with the
inflexibility
1/0 routines that use direct
inflexibility of I/O
direct addressing and are
are therefore tied to specific
physical
addresses.
physical addresses.

11-123
11123

STA N D
AR D INTERFACES
INTERFACES
STANDARD
Other standard
standard interfaces
interfaces besides
besides the
the TTY
TTY current-loop
current-loop and
and
Other
microcomRS-232 can
can also
also be
be used
used to
to connect
connect peripherals
peripherals to
to the
the m
icrocom­
RS-232
puter. Popular
Popular ones
ones include:
include:
puter.

STANDARD
STANDARD
INTERFACES
INTERFACES

1) The
Theserial
serialRS-449.
RS-449,RS-422.
RS-422,and
andRS-423
RS-423interfaces.29
interfaces.29
1)
known as
The 8
-b it parallel
parallel General
General Purpose
Purpose Interface
Interface Bus.
Bus, also
also known
as IEEE-488
IEEE-488 or
or
8-bit
The
Hewlett-Packard Interface
Interface Bus
Bus (HPIB).30
(HPIB).30
Hewlett-Packard

2)
2)

3)
4)

31.^ This
TheS-100
S-100oror A
ltair/lm saihobbyist
hobbyistbus
bus
ThisIsisalso
alsoan
an8-bit bus. 8 -b it bus.
Altair/lmsa1
The
B-b1t
TheIntel
Intel M
ultibus.32
ThisIsisanother
another 8
-b itbus
busthat
thatcan.
can,however.
however,be
be expanded
expanded to
to
32 This
Multibus.
The
handle 16 bits
bits in parallel.
handle

1 1 -1
11-124

PROBLEMS
1)

Separating Closures from an Unencoded Keyboard

Purpose: The program should read entries from an unencoded 3 xx 33 keyboard and
array. The number
save them in an array.
number of entries is in memory location 0040 and
the array starts in memory location
location 0041.
Separate one closure from the next by waiting
end. Remember
aiting for the current
current closure to end.
to debounce
debounce the keyboard (this can be simply
ply a 1 ms wait).

Sample Problem:

= 04
(0040) =
7. 2,
2. 2,
Entries are 7,
2. 4
Result:
It:

(0041)
(0042)
(0043)
(0044)

=
=
=
=

07
02
02
04

2)Read
Read
a Sentence
from
Encoded
Keyboard
a Sentence
from
an an
Encoded
Keyboard
Purpose: The
The program
program should
should read
readentries
entries from
from an
anASCII
ASCIIkeyboard
ith a zero
keyboard (7(7bits
bits with
Parity bit) and place them in an array until
ASCII period 2E-|g.
until it receives an ASCII
2E15.
Each entry is marked by
The array starts in memory location 0040. Each
by a strobe
as in the example given under An Encoded Keyboard.
Sample Problem:
H. E.
E. L. L,
Entries are H,
L. 0.
O,
Result:

(0040)
(0040)
(0041)
(0042)
(0043)
(0043)
(0044)
(0044)
(0045)
(0045)

=
=
=
=
=
=

48 H
45 E
4C L
4C L
4F 0
O
2E
2E

11-1255
11-

3)

ave
A Variable
Variable Amplitude
plitude Square W a
v e Generator
Generator

Purpose: The program
program should generate
generate a square wave.
wave, as shown
shown in the next figure.
figure.
using a D/A
D/A converter.
converter. Memory
Memory location
location 0040
0040 contains
contains the scaled amplitude
amplitude
of the wave.
wave, memory
memory location
location 0041 the length
length of a half cycle
cycle in milliseconds.
milliseconds,
and memory
memory location
location 0042
0042 the number
number of cycles.
Assume
016
Assume that
that a digital
digital output
output of 8 0
-| 6 to the converter
converter results
results in an analog output
output of zero
volts. In general.
general, a digital
digital output
output of D results in an analog output
output of (D-80)/80
(D-80)/80 X -VREF
ref
volts.
Sample Problem:
(0040)
(0041)
(0042)

=
=
=

AO (hex)
(hex)
A0
04
03

Result:
+ VAEF
ref |I
I
➔■•VAEF
ref jI
Output
Output

Voltage

r----F— h -- -\-- ---f-II
4 l

4o |-----40
-VAEF I
- 4-1

- -\--- - -1----\-----1-

--VAEFFl
V rff L
!I

I1

4 ms

I

Time---------------------------------------------------------- ►
Time

The b a
base v o lt
voltage
,s 8 0
8015
0 vo
volts. FFull s c
scale is
is 1 0 0
10015
-VREF
volts.
Th
g e is
- |g == 0
-|q = - V p
^p vo
So A 016
- |g = ( A 0 - 8
0 )/8 0 X - V r
e p = -V p p
p/
-80)/80
REF
REF/4

VREF/4 with
ms.
The program produces
produces 3 pulses of amplitude
plitude Vp{Ep/4
ith a half cycle length
length of 4 ms.

4)

Averaging
Readings
Averaging Analog Readings

Purpose: The program
program should
should take four readings
readings from an A/D
A/D converter
converter 10 milliilli­
apart and place the average in memory
memory location
location 0040.
0040. Assume
Assume that
seconds apart
the A/D conversion
conversion time can be ignored.
Sample Problem:
89, 81.
81, 84
Readings are (hex)
(hex) 86,
86. 89.
Result: (0040) = 85

5)

A 30 Character-per-Second
Character-per-Second Terminal
inal

transmitit and receive routines
Purpose: Modify
odify the transm
routines of the example
example given under
under A
Teletypewriter
Teletypewriter to handle
handle a 30 cps terminal
terminal that
that transfers
transfers ASCII data with
ith one
bit and even parity. How could
could you write
rite the routines
routines to handle either
either
stop bit
terminal depending
depending on a flag bit in memory
memory location
location 0060;
0060: e.g.,.. (0060) = 0
terminal
for the 30 cps terminal.
terminal. (0060) = 1 for the 10 cps terminal?
terminal?

11126
-126

REFERENCES
1.
1.

Barnes, and V. Gregory, "Use Microprocessors
J. Barnes,
Microprocessors to Enhance Performance
Performance with
ith
Noisy Data,"
EON, August
1976. pp. 71
71-72.
Data," EDN,
ugust 20, 1976,
-72.

2. J.
J. E.
E. McNamara,
McNamara, Technical
Technical Aspects
Aspects of
of Data
Data Communications
2.
Communications
Mass.: Digital
Corporation, 1977), Chapter
13.
Digital Equipment
Equipment Corporation,
Chapter 13.

(Maynard,
(Maynard,

R. Swanson,"Understanding
R.
Swanson,"Understanding Cyclic
Cyclic Redundancy
Redundancy Codes," Computer
puter Design,
November
--November 1975, pp. 93-99.
J. Wong,
Wong, et al.,.. "Software
"Software Error Checking
Checking Procedures for Data Communications
Communications
Protocols,"
Protocols," Computer
Computer Design, February 1979, pp. 122-125.
122-125.

CRC generaThe last article
article contains
contains some 6800
6800 assembly language
language programs
programs for CRC
genera­
tion.
For example,
example. the
the 6844
6844 Direct
Direct Memory
Memory Access
Access Controller
Controller for
for 68006800- or
or 6502-based
6502-based
3. For
microcomputers
microcomputers is described
described in An Introduction
Introduction to Microcomputers:
Microcomputers: Volume
Volume 2 Real Microprocessors,
Some Real
Microprocessors, pp. 9-106
9-106 through
through 9-123.
4.

Real
A. Osborne, et al.,.. An Introduction
Introduction to Microcomputers:
Microcomputers: Volume
Volume 2 - Some Real
Microprocessors,
Microprocessors, pp. 9-45 through
through 9-54.

R. Huntington.
J. Gilmore, and R.
Huntington, "Designing
"Designing with
ith the 6820 Peripheral
Peripheral Interface
Adapter,"
Adapter," Electronics,
Electronics. December
December 23, 1976, pp. 85-86.
5.

L. Leventhal.
L.
Leventhal. 6800
6800 Assembly
Assembly Language
Language Programming,
Programming, pp. 11-31 through
through 11-47,
11-49 through
11-74.
11
through 11

6.

Osborne. et al.. An Introduction
Real
A. Osborne,
Introduction to Microcomputers:
Microcomputers: Volume
Volume 2 - Some Real
Microprocessors,
Microprocessors, pp. 10-29 through
through 10-47.

R6500 M icrocom
Microcomputer
System Hardware
Hardware Manual
Manual (Anaheim,
(Anaheim, Calif.:
Calif.: Rockwell
Rockwell InIn7. R6500
puter System
ternational!,
ternational), pp. 1-65 through
through 1-97.
W C.
C.Mavity,
Mavity, "M e
"Megabitit Bubble
Bubble Modules
Modules in
in on
on Mass
Mass Storgage,"
Storgage." Electronics.
Electronics, March
March
8. W.
1979, pp.
pp. 99-103.
99-103.
29, 1979,
Gieryic, "SYM-1
"SYM-1 6522-Based
6522-Based Timer."
Timer," M
Micro,
April 1979,
1979, pp.
pp. 11
:31 through
through
9. J,J. Gieryic,
icro. April
11:31
11:32. The magazine Micro
Micro is dedicated
dedicated exclusively
exclusively to 6502-based
6502-based personal com-­
puters:
It is available
COMPUTERIST, Inc.,.. P.
P. 0.
puters; it
available (monthly
(monthly publication)
publication) from the COMPUTERIST,
O. Box
3. South Chelmsford,
3,
Chelmsford, MA 01824.
10. M.
M. L.L.DeJong,
DeJong, "A
"A Simple
Simple 24-Hour
24-Hour Clock
Clock for
for the
theAIM
AIM 65,"
65," MMicro,
March 1979,
1979. pp.
pp.
10.
icro, March
-10:5 through
through 10:7.
11.
icrocomputers: Volume
11. A.
A. Osborne
Osborne et
et al..
al .. An
An Introduction
Introduction toto MMicrocomputers:
Volume 22 -- Some
Some Real
Real
Microprocessors, pp. 10-47 through
through 10-55.
Microprocessors.

12. C.
C. Foster,
Foster. Programming
Programming aa M icrocom
Microcomputer:
6502 (Reading,
(Reading. Mass.:
Mass.: AddisonAddison12.
puter: 6502
Wesley.
Wesley, 1978). This is a very elementary
elementary introduction
introduction to computers
computers based on the
KIM
microcomputer.
KIM microcomputer.
Camp, etet al.,
al.. M icrocom
Microcomputer
Systems Principles
Principles Featuring
Featuring the
the 6502/KIM
6502/KIM
13. R.R.C.C Camp,
puter Systems
(Portland: Matrix
Matrix Publishers.
Publishers, 1978).
14. A.
A. Caprihan,
Caprihan, etet al.,
al .."A
"A Simple
Simple M icrocom
Microcomputer
for Biomedical
Biomedical Signal
Signal Processing,"
Processing."
14.
puter for
Annual Conference
Conference on Industrial
Industrial Applications
Applications of Microprocessors.
Microprocessors, 1978,
4th Annual
1978. pp.
pp.
18-23. Proceedings
IEEE.445 Hoes Lane,
Lane. PiscataProceedings (since 1975) are available from IEEE,
way.
way, NJ 08854.
08854.

11-127
1127

15.
15.

The TTL Data Book for Design Engineers, Texas
Texas Instruments
ents Inc., P.
P. 0. Box 5012,
Dallas. TX 75222, 1976, pp. 7-151 through 7-156.
Dallas,

16.
16.

E. Dilatush,
Alphanumeric
E.
Dilatush, "Special
"Special Report: Numeric
Numeric and Alphanum
eric Displays,"
Displays," EDN,
EON, Febru­
Febru5. 1978, pp.
pp. 26-35.
-ary 5,

17.
17.

See Reference 15,
15, pp. 7-22 through
through 7-34.

18.
18.

L. DeJong,
DeJong. "6502
ASCII Keyboard Input
M. L.
"6502 Interfacing
Interfacing for Beginners: an ASCII
Input Port,"
Port."
Micro. February 1979,
1979. pp. 9-11 through
through 9-13.

19.
19.

E. R.
R. Hnatek, A User's Handbook of D/A and AID
E.
/D Converters (New York: Wiley,
Wiley.
1976).

20.

J. Kane et al.. An Introduction
Introduction to Microcomputers:
Microcomputers: Volume 3 -• Some Real
Real SupSup·
port Devices,
Devices. Section E.
.

21.

L. DeJong,
DeJong. "Digital-A
"Digital-Analog
M. L.
nalog and Analog-Digital
Analog-Digital Conversion Using the KIM-1,"
The Best of Micro,
Micro. Volume
1. pp. 30-33.
Volume 1,

22.

P. H.
H. Garrett,
Garrett. Analog Systems for Microprocessors
inicomputers
P.
Microprocessors and M inicom
puters (Reston,
(Reston.
VA.:.: Reston Publishing
Publishing Co., 1978.
1978).

23.

G. L.
L. Zick and T. T.
T. Sheffer. "Remote
lnstrumenta·
G.
"Remote Failure Analysis of Micro-based
Micro-based Instrum
enta­
tion:·
1977. pp. 30-35.
tion," Computer. September
September 1977,

24.

UARTs. see
see P.
P. Rony et al.,
al., "The Bugbook lla,"
Ila." E and L InstruFor a discussion
discussion of UARTs,
Instru­
Street. Derby,
Derby. CT.
CT. 06418
D. G.
G. Larsen et al.,..
ments Inc.. 61 First Street,
06418 or D.
"INWAS:
IEEETransactions
"INW
AS: Interfacing
Interfacing with
ith Asynchronous
Asynchronous Serial Mode."
Mode." IEEE
Transactions on In­
Industrial
Instrumentation.
1977. pp.
pp. 2-12. See
dustrial Electronics and Control Instrum
entation, February 1977,
See
McNamara. Reference 2.
2.
also McNamara,

-,

25.

as "Interface
··interface Between Data
Data Terminal
The official
official RS-232 standard is available as
Equipment and Data Communications
Communications Equipment
Equipment Employing Serial Binary Data
Equipment
Interchange"
Interchange" EIA RS-232C August
August 1969. You can find introductory
introductory descriptions
descriptions
G. Pickles,
Pickles. "Who's
?". Kilobaud. May 1977,
1977. pp.
pp. 50-4
of RS-232 in G.
h o ’s Afraid
Afraid of RS-232?",
C. A. Ogdin, "M icrocom
icrocomputer
Buses - Part II." M ini-Micro
and in C.
puter Buses
i-M icro Systems. July
1978. pp. 76-80. Ogdin
Ogd1n also describes the new RS-449
RS-449 standard. --1978,

26.

al.. An Introduction
A. Osborne et al..
Introduction to Microcomputers:
Microcomputers: Volume 2 - Some Real
Real
Microprocessors.
Microprocessors, pp. 9-55 through
through 9-61.

27.

K. Fronheiser.
evice
K.
Fronheiser, "D e
vice Operation
Operation and System Im plem
entation of the
plementation
Asynchronous Communications
Interface Adapter,"
Adapter," Motorola
ProAsynchronous
Communications Interface
otorola Semiconductor
iconductor Pro­
ducts Application
Application Note AN-754.
AN-754, 1975.

28.

C. W. Gear.
Gear. Computer
C.
puter Organization
Organization and Programming
Programming 2/E (New York: McGraw1974). Chapter
Hill, 1974),
Chapter 6.

29.

D.
Morris. "Revised Data Interface
Design. September
D. Morris,
Interface Standards."
Standards," Electronic Design,
September 1,
1,
-1977, pp. 138-141.

30.

Institute
Engineers. "IEEE
'"IEEEStandard Digital
Institute of Electrical and Electronics
Electronics Engineers.
Digital Interface
Instrumentation.''
IEEE Std488-1978.
IEEE. 445 Hoes
Hoes Lane,
for Programmable
Programmable Instrum
entation," IEEE
Std488-1978, IEEE,
Lane.
Piscataway. NJ 08854.
Piscataway,
B. Peatman,
Peatman. Microcomputer-Based
J. B.
Microcomputer-Based Design (New York: McGraw-Hill.
McGraw-Hill, 1977).
1977).
D. C.
C. Loughry.
S. Allen.
··IEEEStandard 488 and Microprocessor
SynergD.
Loughry, and M. S.
Allen, "IEEE
Microprocessor Synerg­
ism," £roceedin
Proceedings
of the
IEEE. February 1978,
2
S_ofJhe_[EBE,
1978. pp. 162-172.

11-128
11-

31.
31.

G. Morrow.
Morrow, and
and H.
H. Fullmer.
Fullmer, "Proposed
"Proposed Standard
Standard for
for the
the S-100
S-100 Bus."
Bus," Computer.
Computer.
G.
May 1978.
1978, pp.
pp. 84-89.
84-89.
May
M. L.
L. Smith.
Smith, "Build
"B uild Your
Your Own
Own Interface,"
Interface," Kilobaud.
Kilobaud, June
June 1977.
1977, pp.
pp. 22-28.
22-28.
M.

32.
32.

T. Rolander.
Rolander, "Intel
"Inte l M
ultibus Interfacing,"
Interfacing," Intel
Intel Application
Application Note
Note AP-28.
AP-28, Intel
Intel CorCor­
Multibus
T.
poration, Santa
Santa Clara.
Clara, CA.
CA, 1977.
1977. See
See also
also An
An Introduction
Introduction to
to MicrocomMicrocomporation.
puters: Volume
Volume 33 •- Some
Some Real
Real support
support Devices.
Devices. Section
Section J.
J.
puters:

11-1
29
11-129

Chapter 12
INTERRUPTS
Instruction cycle.
cycle.
Interrupts are inputs that
that the CPU examines as part of each instruction
Inputs allow the CPU to react to asynchronous
asynchronous events
In a more
more efficient
These inputs
events in
polling each device. The use of interrupts generally involves more
more
manner than polling
ordinary (programmed)
(programmed) I/O,
1/0, but interrupts provide a faster and
hardware than does ordinary
more direct response.1
alarms.
Why
hy use interrupts?
interrupts? Interrupts allow events such as alarms,
power failure, the passage
passage of a certain amount
amount of time, and periphperiph­
erals having data or being ready to accept data to get the

REASONING
BEHIND
INTERRUPTS
INTERRUPTS

immediate attention
program does not have to
attention of the CPU. The program
examine (poll)
(poll) every
source, nor need the programmer worry about the
every potential
potential source,
missing events. An interrupt
system completely missing
interrupt system is like the bell on a
telephone -— it rings when
don't't have to pick up the
when a call is received so that
that you don
receiver occasionally
CPU can go about
occasionally to see if someone is on the line. The CPU
about its normal
business (and get a lot more done).
something happens, the interrupt
done). When something
interrupt rouses the
CPU and forces it to service the input
course,
CPU
input before resuming normal operations. Of course,
this simple description
description becomes more complicated
complicated (just like a telephone switchboard)
switchboard)
when there are many interrupts
interrupts of varying importance
portance and there are tasks that cannot
be interrupted.
interrupted.
The implementation
implementation of interrupt
interrupt systems varies greatly.
Among
Among the questions
questions that
that must be answered to charactercharacter­
are:
ize a particular
particular system are:

CHARACTERISTICS
OF INTERRUPT
SYSTEMS
SYSTEMS

1)
1)

How many interrupt
interrupt inputs
inputs are there?

2)

CPU respond to an interrupt?
How does the CPU
interrupt?

3)

CPU determine
How does the CPU
determine the source of an interrupt
interrupt if the number
number of sources
exceeds the number
number of inputs?

4)

Can the CPU
differentiate between important
portant and unim
portant interrupts?
interrupts?
CPU differentiate
unimportant

5)
5)

How and when is the interrupt
interrupt system enabled and disabled?

different answers to these questions. The aim of all the implementaimplementa­
There are many different
however. is to have the CPU respond
respond rapidly to interrupts and resume normal
normal
tions, however,
activity
c tiv ity afterwards.

The number of interrupt inputs on the CPU chip determines the number of
different responses
that the CPU can produce
o u t any additional hardware or
different
responses that
produce w ithout
software. Each
Each input
response. Unfortunately,
input can produce a different
different internal
internal response.
Unfortunately, most
microprocessors
microprocessors have a very small number
number (one or two, typically)
typically) of separate interrupt
interrupt
inputs.

12-1
12

The ultimate
response of the CPU to an interrupt
ate response
interrupt must be to transfer control to the
correct interrupt
Program
interrupt service routine and to save the current value of the Program
CPU must
Counter. The CPU
must therefore
therefore execute
execute a Jump-to-Subroutine
p-to-Subroutine or Call instruction
instruction
address. This action
~ave
with
ith the beginning
beginning of the interrupt
interrupt service routine
routine as its address.
action will
ill save
the return
return address in the Stack and transfer
transfer control
control to the interrupt
interrupt service routine. The
amount
external hardware
amount of external
hardware required
required to produce
produce this response varies greatly. Some
CPUs internally
address: others require external
hardCPUs
internally generate
generate the instruction
instruction and the address;
external hard­
ware to form them. The CPU can only generate
generate a different
different instruction
instruction or address for
each separate input.
If the number of interrupting devices exceeds
exceeds the number of
POLLING
ideninputs, the CPU will
ill need extra hardware or software
are to iden­
VECTORING
tify the source of the interrupt. In the simplest case, the s oftft­
ware
ware can be a polling routine which
which checks the status of the
devices that
such a system over nor­
northat may be interrupting. The only advantage of such
mal polling is that
that the CPU knows that
that at least one device is active. The alternaalterna­
tive solution is for additional hardware to provide a unique
unique data input (or "vecc­
source. The twoo alternatives
tor") for each source.
alternatives can be mixed; the vectors can identify
groups of inputs from which
one by polling.
polling.
groups
hich the CPU can identify a particular one

l

An interrupt
interrupt system that
that can differentiate
differentiate between
between important
| PRIORITY!
PRIORITY*)
and unimportant interrupts is called a "p riority
rity interrupt
system."
insystem
." Internal
Internal hardware can provide as many priority levels as there are in­
use of a Priority
puts. External
External hardware can provide additional levels through the use
register
register and comparator. The external
external hardware does not allow the interrupt
interrupt to
reach the CPU unless its priority is higher than the contents of the Priority
register. A priority interrupt
handle low-priority
interrupt system may need a special way
ay to handle
-priority
interrupts that
long periods
periods of time.
that may be ignored for long

disabled. In fact,
Most
ost interrupt
interrupt systems can be enabled or disabled.
ENABLING
most CPUs autom
automatically
RESET is
atically disable interrupts when a RESET
AND
performed (so that
that the programmer
programmer can cQnfigure
configure the interrupt
interrupt
DISABLING
system) and on accepting an interrupt
interrupt (so that the interrupt
interrupt will
ill
INTERRUPTS
not interrupt
interrupt its own service routine). The programmer
programmer may wish
loop. or
to disable interrupts
interrupts while
hile preparing
preparing or processing data, performing
performing a timing
ing loop,
executing
executing a multi-byte
ulti-byte operation.
operation.
An interrupt
interrupt that
that cannot be disabled (sometimes called a
"non-maskable
"non-maskable in terrupt")
rrup t") may be useful to warn of power
power
failure, an event
event that
that obviously
obviously must
must take precedence
precedence over all
other
other activities.
activities.

NON-MASKABLE
NON-MASKABLE
INTERRUPT

The advantages
advantages of interrupts
interrupts are obvious.
obvious, but there are also
disadvantages:
disadvantages:

DISADVANTAGES
DISADVANTAGES
OF INTERRUPTS

Interrupt systems
systems may
may require
require aa large
large amount
amount of
of extra
extra
1) Interrupt
hardware.
2) Interrupts
There
Interrupts still
still require
require data
data transfers
transfers under
under program
program control
control through
through the
the CPU.
CPU. There
OMA.
is no speed advantage
advantage as there is with
ith DMA.

Interrupts are
are random
random inputs,
inputs, which
which makes
makes debugging
debugging and
and testing
testing ddifficult.
3) Interrupts
ifficult. Errors
Errors
may occur
occur sporadically,
sporadically, and therefore
therefore may be very hard to find.2
find.2
Interrupts may
may involve
involve aa large
large amount
amount of
of overhead
overhead ifif many
many registers
registers must
must be
be saved
4) Interrupts
saved
and the source must be determined
determined by polling.

12-2
12

602
65
0 2 INTERRUPT SYSTEM
microprocessor's internal response
response to an interrupt is moderately comThe 6602
6502 microprocessor's
com­
plex. The interrupt system consists of:
1)

ac6502
6602
An active-low
active-low maskable interrupt input (IRQ) and an ac­
tiv e-low
-lo w nonmaskable
(NMI).
nonmaskable interrupt input (NMI).
INTERRUPT
INPUTS
21 An interrupt disable (or mask)
mask) bit which disables the
2)
1. no
maskable interrupt. If the Interrupt
Interrupt Disable bit is 1,
maskable interrupts
interrupts are allowed:
allowed; the I bitit is stored in bit 2 of the Processor Status
P) register.
(or P)
The 6602
6502 checks the current status of the interrupt system at
the end of each instruction. If an interrupt is active and
response is as follows:
enabled, the response

6502
6602
INTERRUPT
RESPONSE
RESPONSE

1)

Program Counter (most significant bits
The CPU saves the Program
first) and the Status register in the Stack. Figure 12-1 shows the order in which
which
flrstl
saved. Note that
Accumulator
these registers are saved.
that the Accum
ulator and Index registers are not
saved automatically.
automatically.
21 The CPU disables the maskable interrupt (IRQ); that
is. it sets bit 2 of the
2)
that is,
Status register.
The CPU
CPU fetches
fetches an
an address
addressfrom
from aa specified
specified pair
pair of
of memory
memory addresses
addressesand
and
3) The
address in the Program
Program Counter. Table 12-1 contains
puts thatt address
contains the pairs of adad­
dresses assigned to the various inputs
inputs and to the Break instruction.
instruction.
following
Note the follow
ing special features of the 6502 interrupt
interrupt
system:
1)
1)

---------SPECIAL FEATURES
FEATURES
OF 6602
6502 INTERRUPT
SYSTEM

automatically
saves the Program Counter
The 6502 autom
atically saves
Counter
and the Status register
register in the Stack. Remember that
the Status register includes
includes the Interrupt
Interrupt Disable flag and the Break Command flag.

The 6502
6502 provides
provides no
no external
external signals
signals to
to indicate
indicate that
that itit has
hasaccepted
accepted an
an interrupt
interrupt
2) The
other
Bus.
other than the address that
that it places on the Address
Address Bus.
3)

determining
The 6502
6502 has no special internal
internal provisions for determ
ining the source of an interinter­
rupt
rupt when
when there are several sources tied to the same input.

The 6502
6502 has the following special instructions to manipulate its interrupt
system:
1)

2)
3)

enaCLI (Clear Interrupt
Interrupt Disable Bit) clears bit 2 of the Status register and thus ena­
bles the maskable interrupt.
interrupt.
SEI (Set Interrupt
Interrupt Disable Bitl
Bit) sets bit 2 of the Status register and thus disables
the maskable interrupt.
interrupt.
(Force Break)
Break) sets the Break Command flag,
flag. saves the Program Counter
BRK (Force
Counter and
interrupt, and places the concon­
Status register in the Stack,
Stack. disables the maskable interrupt.
tents of addresses FFFE
FFFE and FFFF
FFFF in the Program Counter.

4)
41 RTI (Return from Interrupt) restores the Status register and the Program
Program
ProCounter from the Stack. The result
result is that
that the old values are returned
returned to the Pro­
RTI differs
gram Counter
Counter and the Status register (including
(including the Interrupt
Interrupt bit). RTI
differs from
RTS (Return from Subroutine)
RTI restores the Status register
RTS
Subroutine) in that
that RTI
register as well as the
Program Counter
Counter and RTI does not add 1 to the return address
address as RTS does
(see Chapter
o!RTS).
(see
Chapter 11 for a discussion
discussion of
RTS).

12-3
12

After
fter

Before

lsss -4
01
0lss-3

01 ss -3

___

0lsss -4
01

_

0lss
01ss -2
0lsss -1
-1 1---01
0lsss t----·L01
01ss
+l
01ss +1

“..
T”

,

T

01ss
ss +2

j

t----➔

Stack
t3C
Pointer

Pom,er

pp

pp
PP

-1
01 ss -1

PCL
PCL

01ss
01ss
0 1sss ++1
1

PCH

T:::::..

01 ss +2

1I

Stack

ss

Stack

lsss -3
01
0lsss -2
01

Stack
Ste
ck

= original
original contents
contents of Stack Pointer
= original
original contents
contents of Status
Status (Pl
(P) register

=

PCH = original
PCH
original contents
contents of 8 higher
higher order bits of
of Program Counter
PCL =original
PCL
original contents
contents of 8 lower
lower order bits of Program Counter

Figure 12-1. Saving the Status of the Microprocessor
Microprocessor in the Stack
Table 12-1. Memory
Used in
Memory Map for 6502 Addresses Used
Reset
Response to Interrupts
Interrupts and Reset
Source
Source

|

Uaed (H exadecim
exadecimal)
Address Used
af)

Interrupt
(IRQI and BRK
BRK Instruction
Interrupt Request (IRQ)
Instruction

FFFEand
and FFFF
FFFF
FFFE

Reset (RESET)
(RESET)
Reset

FFFC and
and FFFD
FFFD
FFFC

Nonmaskable
(NMI)
Nonmaskable Interrupt
Interrupt (NMI)

FFFA and
and FFFB
FFFB
FFFA

The addresses are stored in the usual 6 5
502
0 2 fashion
fashion with
with the least significant
significant bits at the lower
lower address.

BRK
BRK
The BRK (Force Break) instruction produces almost exactly
exactly
INSTRUCTION
interrupt input (IRQ).
the same response as an interrupt
ORO). The only
INSTRUCTION
difference is that
that the Break Command flag (bit 4 of the Status
differentiate between
between a BRK
register) is set. Thus a service routine can differentiate
BRK instruction
and an IRO
IRQ input by examining bit 4 of the top byte in the Stack
Stack (remember Figure
12-1). A typical
typical program would
ould be:
PLA
AND
BNE
BNE

#%
00010000
#%00010000
BREAK
BREAK

;GET
;GET STATUS
STATUS REGISTER
REGISTERFROM
FROM STACK
STACK
;IS
:IS BREAK
BREAKCOMMAND
COMMAND FLAG
FLAGSET?
SET?
;YES,
;YES,GO
GOTO
TO BREAK
BREAKROUTINE
ROUTINE

The BRK
instruction is useful for debugging
debugging (see
Chapter 14)
returning control
BAK instruction
(see Chapter
14) and for returning
information
BAK in­
into a monitor
onitor or operating
operating system. See Chapter
Chapter 3 for more inform
ation about the BRK
struction.
struction.

interrupt is an edge-sensitive
edge-sensitive in­
NON-MASKABLE
The non-maskable interrupt
inNON-MASKABLE
put. The processor therefore
therefore reacts only to the edge of a
INTERRUPT
pulse on this line, and the pulse will
ill not interrupt
interrupt its
own service routine. Non-maskable
resNon-maskable interrupts
interrupts are useful for applications
applications that must res­
pond to loss of power
backpower (i.e.. must
must save data in a low-power
low-power memory or switch
switch to a back­
communications
equipment
up battery). Typical
Typical applications
applications are comm
unications equipm
ent that
that must retain codes
messages. and test equipm
equipment
and partial
partial messages,
ent that
that must keep track of partially
partially completed
tests. We will
ill not discuss the non-maskable
non-maskable interrupt
interrupt any further.
further. We will
ill assume that
all interrupt
IRO.
interrupt inputs
inputs are tied to IRQ.

12-4

lnterrupts3
620
65
2 0 PIA Interrupts3
6620
6520 PIA
interrupt systems involve programmable
programmable interface
Most 6502 interrupt
ultifunction devices such as the 6520 Peripheral InterInter­
INTERRUPTS
chips or multifunction
face Adapter, the 6522 Versatile
Versatile Interface
Interface Adapter, or the 6530
side of the 6620
and 6532 Multifunction
ultifunction Devices. Each side
6520 PIA has the following
features for use with
ith interrupts:
1)
2)
3)

An active-low
-lo w interrupt output.
1. bit 3 for conInterrupt enable bits (bit 0 of the Control register for control
control line 1,
con­
Interrupt
2).
trol line 2).
1, bit 6 for control
Interrupt status bits (bit 7 of the Control register for control
control line 1.
control
Interrupt
line 2).
2).

rising edge (low-to-high
Bits 1 and 4 of the Control register determine whether
hether a rising
transition) or falling
falling edge (high-to-low
(high-to-low transition)
transition) on the
the control
control line causes
causes an inin­
transition)
terrupt.
terrupt.
Note
Note that:
that:
1)
2)
3)

4)

interrupt enable
enable bits
bits have the opposite
opposite polarity
polarity from
from the 6602
6502 I (or InIn­
The PIA interrupt
terrupt Disable)
Disable) flag:
flag; that is,
'V to enable an interrupt.
interrupt.
is. they must be T
terrupt
RESET
clears the PIA Control
Control registers
registers and thus
thus disables
disables all the interrupts.
interrupts.
clears
RESET
check bits
bits 6 and 7 of the Control
Control register
register to see if a PIA has an
The CPU can check
interrupt pending.
ill remain
remain set
set until
until the CPU reads the
pending. Once set, these bits will
interrupt
PIA Data register.
dishile
ill remember an interrupt
interrupt that
that occurs
occurs w h
ile PIA interrupts
interrupts are dis­
The PIA will
abled and will
ill output
output an interrupt
interrupt request
request as soon as the PIA interrupt
interrupt is
enabled.
enabled.

12
12-5

6522 VIA INTERRUPTS
6522
6522 Versatile Interface Adapter may also be used as a
6522 VIA
The 6522
6522
source of interrupts. This device has an Interrupt
Enable
INTERRUPTS
INTERRUPTS
source
Interrupt Enable
(IER) which
register (IER)
hich can be used to enable the various interrupt
interrupt
(IFR) which
sources and an Interrupt
Interrupt Flag register (IFR)
which contains
contains the status of the various
sources.
enabling bits in the Interrupt
Interrupt
sources. Figure 12-2 shows the positions of the various enabling
Enable register and Figure 12-3 describes the Interrupt
Interrupt Flag register.

source can be enabled by setting the corres­
corresAn interrupt source
ponding
that the most significant bit con­
ponding enable bit. Note that
controls how the other enable bits are affected:

l"!Ee"!N~A~B~L""'IN~G,,,..A""N~D"
ENABLING AND
DISABLING
6522 VIA
6522
INTERRUPTS

1)
1)

If IER7
•1• in a bit position clears an enable bit
IER7 =
= 00., each
a c h '1'
and thus disables that interrupt.
interrupt.

2)
2)

IER7 = 1,
1. each T
If IER7
'V in a bit position sets an interrupt
interrupt bit and thus enables that
interrupt.

Zeros in the enabling bit positions
positions leave the enable bits unchanged.

are:
Some examples of enabling and disabling 6522 VIA interrupts
interrupts are:
1)
1)

Enable CA11 interrupt.
others.
Enable
interrupt, disable all others.
LDA
LOA
STA
LDA
LOA
STA

#% 01
111101
#%01111101
VIAIER
VIAIER
#%
10000010
#%10000010
VIAIER
VIAIER

;DISABLE
:DISABLEALL
ALL OTHER
OTHERINTERRUPTS
INTERRUPTS
:ENABLE
:ENABLECA1
CA1 INTERRUPT
INTERRUPT

The first operation sets IER7
'1's in bit positions 0. 2,
IER7 to zero,
zero. so that the Ts
2. 3,
3. 4,
4. 5,
5. and 6
second
clear the corresponding
corresponding enable bits and thus disable those interrupts. The second
IER7 to one,
one. so that the·"V
1• in bit position 1 sets the corresponding
operation sets IER7
corresponding enable
bit (CA1
(CA1 interrupt)
interrupt.
interrupt) and thus enables that interrupt.
2)

Enable
interrupts, disable all others.
Enable CB1
CB1 and CB2
CB2 interrupts.
others.
LDA
LOA
STA
LDA
STA

#% 01
#%01100111
VIAIER
VIAIER
#%10011000
#%
10011000
VIAIER
VIAIER

;DISABLE
:
DISABLEALL
ALL OTHER
OTHERINTERRUPTS
INTERRUPTS

:ENABLECB1,
CB1.CB2
CB2 INTERRUPTS
INTERRUPTS
:ENABLE

IER7 to zero,
zero. so that the •'V1•ss in bit positions
0. 1,
1. 2,
2. 5,
5. and 6 clear
The first operation sets IER7
positions 0,
the corresponding
corresponding enable bits and thus disable those interrupts. The second operation
IER7 to one,
one. so that the 'V
Tss in bit positions 3 and 4 set the corresponding
sets IER7
corresponding enable
bits (bit 3 for CB2,
CB2. bit 4 for CB1)
CB1) and thus enable those interrupts.
Besides the conditions
Besides
conditions described in Figure 12-3. the bits in the Interrupt
Interrupt Flag register
can also be cleared by writingg '1's
's into the required bit positions
that address.
positions in that
address.

modes
This procedure is useful for clearing flags that are being used in the independent
independent modes
have been caused accidentally
and for eliminating
inating undesired interrupts
interrupts that may have
accidentally during
reset or startup. Note that the Interrupt
Interrupt Flag register bit positions
positions are the same as the
Interrupt
Interrupt Enable register bit positions so that we can easily extend the previous
examples to eliminate
inate stray interrupts. This can be done with
ith either
either enabling
enabling or disabdisab­
operations. since the value of bit 7 does not matter. The extended examples are:
are:
ling operations,
1)
1)

Enable CA1
CA1 interrupt.
others. clear CA1
CA1 interrupt
Enable
interrupt, disable all others,
interrupt flag.
LDA
LOA
STA
LDA
STA
STA

01111101
#% 01
111101
VIAIER
VIAIER
#% 1
0000010
10000010
VIAIFR
VIAIFR
VIAIER
VIAIER

:DISABLE ALL OTHER
OTHER INTERRUPTS
INTERRUPTS
;DISABLE

;CLEAR
;CLEAR CA11 INTERRUPT
INTERRUPTFLAG
FLAG
:ENABLE
:ENABLE CA11 INTERRUPT
INTERRUPT

12-6

66

7

5

44

3

2

1

00

CB1

CB2

SR

CA1

CA2

Bit Number
Number

...-sit

.................T

Set
clear
control

T11

T2

tt

T

Interrupt
register
Enable register
Interrupt Enable

i t

enable
... _-•----<►----4t------Des,gnated
Designated interrupt
interrupt enable

'----41.,_---41.,_-

1 -- Interrupt
Interrupt enabled
0 - Interrupt
Interrupt disabled

b,ts 0O--66
or clear bits
Set or

'-------------------------Set

11 - Wnting
riting 1 sets
to 11
bit to
sets bit
0 -- Wnting
riting 11 sets bit to 0O
See
interrupt names
names.
for meaning of interrupt
Figure 1 2-3 for
See Figure

Writing 0O to any
of
any of
Writing
bits
effect
has no effect
bits 0 --66 has

text
the main text
Bit 77 is explained
explained further
further in the

Figure 12-2.
Description of the 6522 VIA Interrupt
Interrupt Enable Register
12-2. Description

IRQ

6

5

4

3

T1

T2

CB1

CB2

0
SR

CA1

- Bit Number
~

CA2

-Interrupt Flag register

Interrupt Flag register

--IR_Q_._T_1_...__T_2_._c_B_l _.__c_0_2_._s_R_._c_A_l_.._C_A_2_J.---

Bit 7 indicates
output. This bit corresponds
corresponds to the following
following logic
logic function:
function:
indicates the status of the IRQ output.

(IFRl II
IER2) V (IFR1
/\ IER2)
(IFR2 A
IER3) V (IFR2
(IFR3 A IER3)
IER4) V (IFR3
(IFR4 A IER4)
IER5) V (IFR4
IRQ -= (IFR6
A IERl)
IER1) V
(IFR5 A IER5)
IER6) V (IFR5
(IFR6 A IER6)
IER0)
(IFR0 A IER0)
(IFRO
follows:
Bits 0 - 6 are latches which
which are set and cleared as follows:

0

1

2

3

4

5
6

6

C leared
a re d by

Sett by

Bitit No.

on the CA2 pin.

writing the A Port Output
Output
Reading or wntmg
register (ORA)
01.
(ORAi using address 0 001
register

Active transition
transition of the signal
Active
CA1 pm
pin.
on the CAl

writing the A Port Output
Output
Reading or wntmg
register (ORA), using address
address 0 001
01.
register

Completion of eight
eight shifts
shifts.
Completion

writing the Shift
Shift
Reading or wntIng
register.
register

Active transition
transition of the signal
Active

writing the B Port
Reading or wntmg
Output register
register.
Output

Active transition
transition of the signal
Active

pin.
on the CB2 pm
Active transition
the signal
transIt1on of the
Active

Reading or writmg
writing the B Port
Readmg

on the CB1l pin.

Output
register
Output register

Time-out of Timer
er 2.
Time-out

low-order counter
counter or
Reading T2 low-order
writing T2 high-order
high-order counter
counter.
writing

Tim
e-out of Tim
er 1.
Timer
Time-out

T1 low-order
low-order counter
counter or
Reading Tl
writing T11 high-order
high-order latch
latch.
writing

Description of the 6522
6522 VIA Interrupt
Interrupt Flag Register
Figure 12-3. Description

12
12-7

2)

Enable CBl
CB1 and CB2 interrupts.
interrupts, disable all others.
others, clear CBl
CB1 and CB2 flags.
LDA
STA
LDA
STA
STA

#%01100111
#% 01
VIAIER
VIAIER
#%10011000
#% 1
0011000
VIAIFR
VIAIFR
VIAIER
VIAIER

:DISABLEALL
ALL OTHER
INTERRUPTS
;DISABLE
OTHER
INTERRUPTS

;CLEAR
:CLEARCB1,
CBl. CB2
CB2INTERRUPT
INTERRUPTFLAGS
FLAGS
:ENABLECB1.
CBl. CB2 CB2
INTERRUPTS
;ENABLE
INTERRUPTS

Note that
Enable
that bit 7 of the Interrupt Flag register and bit 7 of the Interrupt Enable
special. Bit 7 of the Interrupt
register are both special.
Interrupt Flag register indicates the status of
the IRQ output-— that is,
interrupts are both active and enabled. Bit
is. it is 1 if any of the interrupts
Enable register is the Set/Clear
earlier. Note
7 of the Interrupt
Interrupt Enable
Set/Clear control mentioned earlier.
Interrupt Flag register cannot
cannot be cleared directly:
directly; it can only be cleared
that bit 7 of the Interrupt
by either clearing all the active interrupt
interrupt flags or by disabling
disabling all the active interrupts.
Note the following about VIA interrupts:
1)
6502 I (or
11 The VIA interrupt enable bits have the opposite
opposite polarity from the 6502
Interrupt Disable)
Disable) flag; that
is. they must be '1
that is,
'V• to enable an interrupt.
RESET disables all the interrupts.
interrupts.
2) RESET
31 The CPU can check bit 7 of the Interrupt
3)
Interrupt Flag register to see if any interrupts
acare both active and enabled. That bit will
ill remain set until
until no interrupt
interrupt is both ac­
tive and enabled.
4)
ill remember an interrupt that
that occurs
41 The VIA will
occurs when VIA interrupts are dis­
disenabled.
abled and will
ill output a request via IRQ as the VIA is enabled.
There are several examples of VIA interrupts
interrupts later in this chapter.

12-8

6 530
3 0 and 6 532
3 2 Multifunction
ultifunction Device Interrupts
The 6630
6630
6530 device can provide an interrupt from its interinter­
6530 AND 6632
6532
IRO output
MULTIFUNCTION
MULTIFUNCTION
val timer. The IRQ
output is also pin PB7 from Port B and
should be set up as an input
DEVICE INTERRUPTS
input if it is to be used to cause an
interrupt.
interrupt. The interrupt
interrupt can be enabled by writing
riting to the
timer
er with
ith address line A3 high. The interrupt
interrupt can be disabled by writing
riting to the timer
with
ith address line A3 low. It can be cleared by reading or writing
riting the timer
er after
after an interinter­
rupt has
has occurred.
The 6632
6532 device can provide a timer
er interrupt like the 6630
6530 device. It can also
provide an interrupt based on the occurrence
occurrence of an edge on PA7; PA7 thus operates
provide
much like CA11 or CB11 on a 6520
6520 PIA or a 6522 VIA. The interrupt
interrupt can occur
occur either
either on a
low-to-high
edge) or on a high-to-low
edge).
low-to-high transition
transition (positive edge)
high-to-low transition
transition (negative edge).
6632
reading from
6532 interrupts are controlled and examined by writingg to and reading
addresses (see
(see Table 12-2 for a description
specific addresses
description of the addresses in a 6532 device).
following:
Note the follow
ing:
1)
1)

adTo control
control the PA7 interrupt.
interrupt, you simply
simply write
rite any data whatsoever
whatsoever into the ad­
1/0 section given by:
dress in the 6532 I/O
RS = 1 to activate
1/0 rather than the on-board RAM
RS
activate I/O
A2 = 1,
1. A4 = 0

The two least significant
significant address bits (not the data) then control
control the PA7 mode as
follows:
A1 = 1 to enable PA7 interrupt.
interrupt, 0 to disable it
AO = 1 for a positive (low-to-high)
(low-to-high) edge detect.
detect, 0 for a negative (high-to-low)
(high-to-low) edge
detect.
2)

flags. read from the address in the 6532 I/O
1/0 section
To read and clear the Interrupt
Interrupt flags,
given by:
RS = 1 to activate
1/0 rather than the on-board RAM
RS
activate I/O
A2 = 1,
1. AO== 1

Bit 7 is the Timer
Timer Interrupt
Interrupt flag and bit 6 is the PA7 Interrupt
Interrupt flag. These can easily be
read by means of the Bit Test instruction
instruction (Bit 7 is transferred to the Sign flag and bit 6 to
the Overflow
Overflow flag).

ACIA Interrupts
The 6860
6850 ACIA can also serve as a source
source for interrupts. You
should note the following features of the 'ACIA in interruptshould
based systems:
1)
2)
3)
4)

6860
6850 ACIA
INTERRUPTS
INTERRUPTS

The transmitter
itter interrupt (ACIA is ready for data) is enabled only if Control
6 = 1.
register bit 6 = 0 and Control register bit 5
receiver interrupt (ACIA has received new data) is enabled only if Control
The receiver
register bit 7 = 1.
Master reset does not affect
affect the interrupt enable bits.
Master
Bit 7 of the Status register is set if an interrupt has occurred.
occurred. This bit can be
cleared either
either by reading data from the ACIA or by writing
ritin g data into the ACIA.

12-9

12-2. Addressing
Table 12-2.
Addressing the 6532 Multifunction
ultifunction Device
Selection
election Lines

Address
Address Mode
ode
S
3
~

R/W
R/W

A4

A3

A2

A1
A1

AO

0

1(0)
1101

X

X

X

X

X

R AM
M Addressing
Addressing

Read IWr;tel
Read
(Write) RAM. AO - A6 select RAM address.
address.

1/0 Addressing
I/O
1

1(0)
1101

X

X

0

0

0

Read (W
IWr;tel
Read
rite) Port A data

1
1

1(0)
1101

X

X

0

0

1

Read (Write) Port A Data
Data Direction Register
Read
Register

1
1

1(0)
1101

X

X

0

1

0

Read (Write)
(Write) Port B data

11

1101
1(0)

X

X

0

1

1

Read (Write)
{Write) Port B Data
Data Direction
Read
Direction Register
Register

1

0

0

X

1

0

X

Disable
Disable interrupt
interrupt from
from PA77

1

0

0

X

1

1

X

Enable interrupt
interrupt from
from PA77

1

0

0

X

1

X

0

Negative
Negative edge detect

1

0

0

X

1

X

1

Positive edge detect

11

1

X

X

1

X

1

dge-Detection
E dge-D
etection Control
Control

Read and Clear Interrupt
Read
Interrupt Flags
Bit 7 is the Timer Flag
Flag

Btt 6 is the PA7 Flag
Bit
Flag
Write
rite Count
ount to Inte
rva l Timer
er
Interval
1

0

1

0

1

X

X

and disable
disable timer
timer interrupt
interrupt

1

0

1

1

1

X

X

and enable
enable timer
timer interrupt
interrupt

1

0

1

X

1

0

0

and decrement every ct>2pulse

i1

0

1

X

1

0

1

4>2 pulses
and decrement every 8 <t>2

1

0

1

X

1

1

0

and decrement every 64 <t>2
¢12 pulses

1

0

1

X

1

1

1

4>2 pulses
pulses
and decrement every 1 0244 4>2

<P2

CS2

For all operations
operations CS1 ==11,
, CS2 = 0.

Logic levels: 0O means
means low level
level
1 means high level
level
level of that signal does not matter (either 0O or 1)
X means level
1)

1212-10

65
0 2 Polling Interrupt
Interrupt Systems
602
Most
ost 6602
6502 interrupt
interrupt systems must poll each PIA, VIA,
VIA. ACIA,
or other device to determine
determine which one caused an interrupt.
is:
polling method is:
The polling
1)

Check each PIA by examining Control register bits 6 and 7:
BIT
BMI
BVS
BVS

2)

POLLING
POLLING
INTERRUPTS

PIACR
PIACR
INT1
INT1
INT2
INT2

BITS
STATUS BITS
PIA STATUS
:CHECKPIA
;CHECK
SET
BIT 77 SET
IF BIT
;BRANCH
INTERRUPT11 IF
TO INTERRUPT
:BRANCH TO
SET
BIT 66 SET
IF BIT
; BRANCH
INTERRUPT22 IF
TO INTERRUPT
:BRANCH TO

Check each VIA by examining Interrupt
Interrupt Flag register bit 7:
BIT
BMI
BMI

VIAIFR
VIAIFR
INTV
INTV

THIS VIA?
ON THIS
ACTIVE ON
INTERRUPTSACTIVE
ANY INTERRUPTS
:AREANY
;ARE
VIA?
REGISTER
;YES,
FLAG REGISTER
OF FLAG
ALL OF
EXAMINE ALL
GO EXAMINE
:YES,GO

inYou must still examine the Interrupt
Interrupt Flag
potential in­
Flag register if there is more than one potential
terrupt source from a particular
particular VIA. All that bit 7 tells you is that at least one source is
terrupt
enabled.
both active and enabled.
3)

Check each ACIA by examining Status register bit 7:
BIT
BIT
BMI
BMI

ACIA?
THISACIA?
ONTHIS
ACIASR
ACTIVE
ACTIVEON
INTERRUPTS
ANY INTERRUPTS
:AREANY
ACIASR ;ARE
NECESSARY
INTA
;YES. GO
GO DETERMINE
WHICH ONE
ONE IF
IF NECESSARY
INTA
DETERMINEWHICH
:YES,

transmitter
The interrupt
interrupt could still be either a receiver or a transm
itter interrupt.
The important features
features of a 6602
6502 polling system are:
ininterrupt examined
examined has the highest priority, since the remaining in­
The first interrupt
has
ill not be examined
examined if the first one is active. The second interrupt
interrupt has
terrupts will
on.
the next highest priority.
priority, and so on.
2)
VIAs, ACIAs.
ACIAs, or
21 The service routine must clear the interrupt flags from PIAs, VIAs.
automatically.
other devices if the clearing is not performed automatically.
1)

The programmer should
should be particularly careful of:

ports.
PIAs being used as interrupting output ports.
necessary. since the Interrupt
A dummyy read of the port is necessary,
Interrupt flag is not cleared autoauto­
matically when data is written
ritten into the port. PIA Status (Interrupt) flags are cleared
matically
only when
when the Data registers are read.
read.
•

independent input mode or through addresses that
that do
VIAs being used in the independent
not affect
affect the Interrupt
flags.
Interrupt flags.
·1• into the appropriThe Interrupt
Interrupt flag must then be explicitly
explicitly cleared by writing
riting a logic 'V
appropri­
ate bit of the Interrupt
Interrupt Flag register.
register.
Polling
w inputs.
inputs.
Polling routines are adequate if there are only a few
However, if there are many inputs, polling
polling routines are
However,
slow and aw kw
ard because:
because:
kward

DISADVANTAGES
DISADVANTAGES
OF POLLING
INTERRUPTS

1)
number of polling operations increases
increases
1) The average number
have to poll
ith the number
number of inputs. On the average,
you'll have
course. you'll
average. of course,
linearly with
half of the inputs before finding
finding the correct one.
one. You can reduce the average num-­
ber of polling
polling operations
operations somewhat
somewhat by checking the most frequent
frequent inputs first.
2)
2)

PIA,
consecutive or evenly spaced: therefore,
therefore,
addresses are rarely consecutive
VIA. and ACIA addresses
PIA, VIA,
separate instructions
instructions are necessary
necessary to examine each input. Polling routines are
therefore d iffic
u lt to expand. Tables of I/O
addresses could be used by placing the
1/0 addresses
ifficult
base address on page zero and using the post-indexed addressing mode or by placplac­
mode.
ing the entire table on page zero and using the pre-indexed addressing mode.

3)

Interrupts that are polled first may shut out those that are polled later unless the
Interrupts
makes varyconsecutive addresses makes
vary­
However. the lack of consecutive
order of polling is varied. However,
ing the order of polling
polling difficult.
difficult.
1 2-11

602
65
0 2 Vectored Interrupt Systems
been
The problem of polling in 6502-based systems has typically
typically been
methods. unique to a particular
solved by special methods,
particular application
application or
microcomputer.
microcomputer. Note that there is no way to know that
that the

6502
6602
VECTORED
INTERRUPTS
INTERRUPTS

6602 has accepted an interrupt other than by recognizing
recognizing the
6602
addresses FFFE
FFFE and FFFF
FFFF when they appear on the Address Bus.
Bus. Special hardware
addresses
source.4 We will
can then substitute the vector provided by the actual source.4
ill not discuss
6502 vectored interrupt
interrupt systems any further.

12-122
12

EXAMPLES
EXAMPLES
A Startup Interrupt
Purpose: The computer
puter waits
aits for a VIA interrupt
interrupt to occur
occur before starting
starting actual
actual operaopera­
tions.
Many systems
systems remain inactive
inactive u ntil
til the operator
operator actually
actually starts them or until
until a Data
Many
enaPointer. ena­
initialize the Stack Pointer,
must initialize
Ready signal
signal is received. On RESET,
RESET,such systems must
ble the startup
startup interrupt.
interrupt, and execute
execute an endless loop or jump-to-self
p-to-self instruction.
instruction.
1) as well
Remember that
that RESET
disables the processor
processor interrupt
interrupt (by setting
setting I to 1)
well as all
RESET disables
Remember
the VIA interrupts
interrupts (by clearing
clearing all the VIA interrupt
interrupt enable bits). In the flowchart.
flowchart, the
CPU examining
decision as to whether
hether startup
startup is active
active is made in hardware
hardware (i.e.,.. by the CPU
examining
decision
the interrupt
interrupt input
input internally)
internally) rather
rather than in software.
software.

Flowchart:
Flowchart:

(

Star,
Start

)

Initialize Stack
Pointer
Pointer
Enable startup
interrupt on VIA
Enable
Enable CPU interrupt

End

Source Program:
Main Program:

HERE
HERE

LDX
TXS
LDA
STA
LDA
STA
STA
CLI
CLI
JMP

#$FF
#$FF
#0
VIAPCR
# % 10000010
0000010
VIAIFR
VIAIER
HERE
HERE

;PUT
PAGE 1
OF PAGE
END OF
:PUT STACK AT END

INPUTS
LINES INPUTS
CONTROL LINES
:MAKE ALL CONTROL
;CLEAR
INTERRUPT FLAG
:CLEAR CA11 INTERRUPT
INTERRUPT
:ENABLE
;ENABLE CA11 INTERRUPT
INTERRUPT
CPU INTERRUPT
lENABLE
:ENABLE CPU
:WAIT
AIT FOREVER
FOREVER

Service Routine:
Interrupt Service

•=INTRP
*=INTRP
# %10000010
10000010
LDA
VIAIFR
STA
#$FF
LDX
#$FF
TXS
START
JMP

INTERRUPT FLAG
;CLEAR
:CLEAR CA11 INTERRUPT
:REINITIALIZE
POINTER
:REINITIALIZE STACK POINTER

12-13
12-

Object Program:
Program:
Memory
Memory Address
Address
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)

Main Program:
0000
0000
0001
0002
0003
0004
0005
0005
0006)
0006}
0007)
0007
0008
0008
0009
0009
OOOA
000A
OOOBt
000B}
OOOCt
oooc
000D
0000
000EI
OOOE}
000F)
OOOF
0010
0010
0011
0012
0012
0013

A2
FF
FF
9A
A9
00
8D
80

LDX
LOX

#$FF
#$FF

TXS
LDA
LOA

#00

STA

VIAPCR

LDA
LOA

#% 1
0000010
10000010

STA

VIAIFR

STA

VIAIER

CLI
CLI
JMP

HERE
HERE

LDA
LOA

#%10000010
10000010

STA

VIAIFR

LOX
LDX

#$FF

TXS
JMP

START
START

VIAPCR
A9
82
8D
80
VIAIFR
8D
80

VIAIER
VIAIER
58
4C
11
11
00

HERE
HERE

Interrupt
Interrupt Service Routine:
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+31
INTRP+3~
INTRP+4)
INTRP+4
INTRP+5
INTRP+6
INTRP+7
INTRP+8
INTRP+9} I
INTRP+A)
INTRP+A

A9
82
80
8D
VIAIFR
A2
FF
FF
9A
4C
START

1 2-14
14

The exact location
location of the interrupt
interrupt service routine
routine varies
INTERRUPTS ON
icrocomputer
PARTICULAR
with
ith the microcomputer.
microcomputer. If your m icrocom
puter has no
monitor, you can simply
simply place whatever
whatever address you want
want
monitor.
MICROCOMPUTERS
MICROCOMPUTERS
FFFEand FFFF
FFFF (or
lor whatever
in memory locations FFFE
whatever locations
addresses). You must then start the interrupt
respond to those addresses).
interrupt service routine at the adad­
chose. Of course,
course. you should place the routine so that it does not interfere
dress you chose.
with
ith fixed addresses or with
ith other programs.
If your
your m icrocom
puter has a monitor.
monitor, the monitor
onitor will
ill occupy
occupy ad­
INTERRUPT
icrocomputer
addresses FFFE
FFFEand FFFF.
FFFF.Those addresses will
dresses
ill either contain
contain a startstart­
HANDLING
HANDLING
BY MONITORS
MONITORS
ing address at which
hich you must place your interrupt
interrupt service
routine, or will
ill contain
contain the starting
starting address of a routine that allows
routine.
you to choose the starting
starting address of the interrupt
interrupt s;i:vice
service routine. A typical
typical monitor
monitor
routine would
ould be:
routine
be:
MONINT JMP

(USRINT)
(USRINT)

;JUMP
USER SUPPLIED
SUPPLIED INTERRUPT
INTERRUPTADDRESS
ADDRESS
JU
P TO USER

You must then place the address of your service routine
routine in memory locations USRINT
USRINT
and USRINT+1. Remember that MONINT is an address in the monitor
onitor program and its
FFFE and FFFF.
FFFF.
value is in addresses FFFE
USRINT and USRINT+1
USRINT+1 in your main
You can include
include the loading of memory locations USRINT
program.
LDA
LOA
STA
LDA
LOA
STA

#USRL
#USRL
USRINT
USRINT
#USRM
#USRM
USRINT+1
USRINT+1

;LOAD LSB'S OF USER
:LOAD
USER INTERRUPT
INTERRUPTADDRESS
ADDRESS
:LOAD MSB'S OF USER
;LOAD
USER INTERRUPT
INTERRUPTADDRESS
ADDRESS

These instructions
instructions must precede the enabling
enabling of the interrupts.

The main program only enables the interrupt
interrupt from the startup
startup VIA. We have assumed
that the startup
startup line is attached
attached to VIA input
input CA11 and that the active edge is the trailing
trailing
one (i.e.... a high-to-low
high-to-low transition). Other configurations
configurations would
would merely require different
different
values in the VIA Peripheral Control
Control register.
CPU
Note that
that the VIA interrupt
interrupt is enabled and the Stack Pointer
Pointer is loaded before the CPU
interrupt
interrupt is enabled (by clearing
clearing the I bit). What
hat would
would happen if you cleared the I bit
before loading the Stack Pointer? This will
ill not be a potential
potential problem if the monitor
monitor
already places a value in the Stack Pointer.
In this example, the return address and Status register that
that the 6502 stores in the Stack
on accepting
accepting an interrupt
interrupt are not useful. Thus the service routine simply
simply reinitializes
reinitializes the
Stack Pointer.

HERE instruction
Note that
that we could replace the JMP HERE
instruction with
ith a conditional
conditional branch that
provided a guaranteed jump,
BNE HERE.
HERE.The Zero flag is not zero since the last
p, such as BNE
operation was the one that enabled the CA11 interrupt.
interrupt. This shortcut
shortcut is often helpful to
operation
addressmake up for the fact
fact that
that the 6502 has no unconditional
unconditional branch with
ith relative address­
ing.
ing.

Remember
RESET and accepting an interrupt automatically
disable the interRemember that
that RESET
atically disable
inter­
rupt system. This allows the real startup routine to configure all the
•the VIAs and
interrupt sources w ith
o u t being interrupted. Note that you must explicitly
explicitly
other interrupt
ithout
Interrupt flag or else it will
ill interrupt
interrupt again as soon as the interrupt
interrupt system
clear the CA11 Interrupt
is re-enabled. You could also clear the flag by reading the VIA's
VIA's Output
utput Register A from
(see Table 11-7).
11-7).
the handshaking
handshaking address (see

12-15
12-

A Keyboard Interrupt
Purpose: The computer
Purpose:
computer waits
aits for a keyboard
keyboard interrupt
interrupt and places
the data from the keyboard
keyboard into
into memory
memory locaton
locaton 0040.
0040.

KEYBOARD
KEYBOARD
INTERRUPT

Sample Problem:
Keyboard
Keyboard data
Result: (0040)

=
=

06
06

Flowchart:

c

Start

I

Initialize Stack
Pointer
Enable keyboard
interrupt on VIA
Enable CPU interrupt

10040) ~ data

End

Program:
Source Program:
Main Program:
Program:

HERE
HERE

LDX
LOX
TXS
LDA
LOA
STA
STA
LDA
LOA
STA
STA
CLI
CLI
JMP

#$FF
#$FF

#0
#0
VIAPCR
VIADDRA
VIADDRA
#%10000010
#%10000010
VIAIFR
VIAIER
HERE
HERE

;PUT STACK AT END OF PAGE
PAGE 1

;MAKE ALL CONTROL LINES
LINES INPUTS
;MAKE
PORT A LINES INPUTS
:MAKE PORT
:CLEAR KEYBOARD INTERRUPT
INTERRUPT FLAG
:ENABLE KEYBOARD INTERRUPT
INTERRUPT FROM VIA
ENABLE CPU
CPU INTERRUPT
;ENABLE
INTERRUPT
;DUMMY
PROGRAM
DUMMY MAIN PROGRAM

Interrupt
Interrupt Service
Service Routine:
Routine:
*=INTRP
*=INTRP
PHA
LDA
LOA
VIAORA
STA
$40
PLA
RTI
RTI

ACCUMULATOR IN STACK
:SAVE ACCUMULATOR
DATA
:GET KEYBOARD DATA
;SAVE KEYBOARD DATA
DATA
;RESTORE
RESTORE ACCUMULATOR
ACCUMULATOR FROM STACK

12-16
12
16

Object Program:
Program:
Memory Address
(Hex)
(Hex)

Memory Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

Main Program:

0000
OOOU
0001
0002
0003
0004
0005
0006)
0006}
00071
0008
00091
0009}
OOOAt
000A
0008
0B

oooc
OOOC
000D
000E)
OOOE}
0
00Fl
OOOF
0010
0011)
0011}
00121
0013
0014
0015
0016

A2
FF
FF
9A
A9
00
8D

LDX

#$FF

TXS
LOA
LDA

#00

STA

VIAPCR
VIAPCR

STA

VIADDRA

LDA

#% 1
0000010
10000010

STA

VIAIFR
VIAIFR

STA

VIAIER
VIAIER

VIAPCR
VIAPCR
8D
VIADDRA

A9
82
8D
VIAIFR
VIAIFR
8D

VIAIER
VIAIER

cu

58
4C
14
00

HERE
HERE

CLI
JMP

HERE
HERE

PHA
PHA
LDA
LOA

VIAORA

STA

$40

Interrupt
Interrupt Service Routine:
INTRP
INTRP
INTRP+1
INTRP+1
INTRP+2)
INTRP+2}
INTRP+3)
INTRP+4
INTRP+5
INTRP+6
INTRP+7

48
AD
VIAORA
85
40
68
40

PLA
RTI
RTI

You must configure
configure the VIA completely
completely before enabling
enabling the interrupts. This includes
establishing
ports. determ
determining
establishing the directions
directions of ports,
ining the transitions
transitions to be recognized on
strobe lines,
that setting
setting bit 0
Auxiliary Control
lines. and enabling latches (remember that
O of the Auxiliary
latch).
register enables the Port A latch).

HEREis an endless loop (jump-to-self) instruction
The JMP HERE
instruction that
that is used to represent the
system. the main program goes
main program. After
After interrupts
interrupts are enabled in a working
working system,
til an interrupt
interrupt occurs and then resumes execution after the interinter­
about its business until
rupt service routine is completed.

12-17

The RTI
RT! instruction
instruction at the end of the service routine
routine transfers
CHANGING THE
CHANGING
control
control back to the JMP instruction
instruction in the main program. If you
INTERRUPT
want
ant to avoid this.
this, you can simply
simply change
change the Program
RETURN
Counter in the Stack. Remember that
that the Stack is always lo­
Counter
loADDRESS
cated on page 1 (addresses 0100
FF). the Stack Pointer
0100 - 01 FF),
Pointer
contains
contains the address of the next empty
empty location.
location, and the interrupt
interrupt response places the
Counter in the Stack underneath
underneath the Status register. Thus the following
following pro­
proProgram Counter
gram will
ill increment
increment the Program Counter in the Stack
Stack without
ithout removing it.

DONE

TXS
$0102.X
INC
$0102,X
BNE
DONE
BNE
DONE
$0103.X
INC
$0103,X
(next instruction)
instruction)

:MAKE STACK
STACK POINTER
POINTER INTO INDEX
INDEX
;MAKE
;INCREMENTLSB'S
LSB'SOF
OFRETURN
RETURNADDRESS
ADDRESS
INCREMENT
:AND CARRY
CARRYTO
TOMSB'S
MSB'SIFIFNECESSARY
NECESSARY
;AND

Since the 6502
automatically
register).
6502 does not autom
atically save its registers (other than the Status register),
you can use them to pass parameters
inparameters and results between
between the main program
program and the in­
terrupt
So. you could
Accumulator
terrupt service routine. So.
could leave the data in the Accum
ulator instead of in
memory
is. however.
memory location
location 0040. This is,
however, a dangerous
dangerous practice
practice that
that should be avoided
in all but the most trivial
trivial systems. In most applications.
applications, the processor is using its
registers during
randuring normal program
program execution;
execution; having the interrupt
interrupt service routines
routines ran­
domly
domly change
change the contents
contents of those registers would
would surely cause havoc. In general, no
interrupt
coninterrupt service routine should ever
ever alter
alter any register
register unless that register's
register's con­
tents
tents have been saved prior to its alteration
alteration and will be restored at the completion
of the routine.

Note that
that you need not explicitly
explicitly re-enable
re-enable the interrupts
interrupts at the end of the service
routine. The reason is that
that the RTI instruction automatically
automatically restores the old Status
(Pl register
fact. you will
(P)
register with
ith the Interrupt
Interrupt Disable bit in its original state.
state. In fact,
ill have
to alter
alter the Interrupt
Interrupt Disable bit
bit in the Stack (bit 2 of the top location) if you do not want
want
the interrupts
interrupts to be re-enabled.
Using the Stack
Stack is the most general approach to saving and restoring registers.
contents of the Accumulator
Accumulator in the Stack and the
The instruction PHA saves the contents
instruction PLA restores the contents
contents of the Accumulator
Accumulator from the Stack. This
expanded indefinitely
indefinitely (as long
method can be expanded
long as there is room in the Stack) since
nested service routines will
ill not destroy the data saved by the earlier routines.

automatically
You can save all the registers
registers in the Stack (remember that Status is autom
atically
saved) after
after an interrupt
interrupt with
ith the sequence:
PHA
TXA
PHA
TYA
PHA

;SAVE
:SAVE ACCUMULATOR
ACCUMULATOR
;SAVE INDEX
INDEX REGISTER
REGISTERX
;SAVE

;SAVE INDEX
INDEX REGISTER
REGISTERY
;SAVE

Note
between
Note that
that there
there is no direct
direct way
ay to transfer
transfer data betw
een the Stack and the Index
contents of the Accumulator
Accumulator must be saved first (why?).
registers. The contents
register; from the Stack (remember that RTI
atically restores
You can restore the register.
RT! autom
automatically
Status) after
after an interrupt
interrupt se vice routine
routine by removing
removing the data from the Stack in the op­
opwhich it .^as
posite order from which
.Jas entered:
PLA
TAY
PLA
TAX
PLA

;RESTORE INDEX REGISTER
REGISTERY
;RESTORE
;RESTORE INDEX REGISTER
REGISTERX
;RESTORE
;RESTOREACCUMULATOR
;RESTORE
ACCUMULATOR

12-18
2 -1 8

Note that
Accumulator
that the Accum
ulator is saved first
first and restored last.
An alternatwe
alternative approach
approach would
ould be for the interrupt
interrupt routine
routine to
maintain
maintain control
control until
until it received
received an entire
entire line of text
text (e.g
(e.g.,.. a string
string
of characters
characters ending
ending with
ith a carriage
carriage return). The main program
program
would
would be:

FILLING A
BUFFER VIA
INTERRUPTS

Main Program:
Program:

HERE
HERE

LDX
TXS
LDA
STA
STA
STA
LDA
STA
STA
CL!
CLI
JMP

#$FF
#$FF
#00
VIAPCR
VIADDRA
VIADDRA
$40
#% 1
0000010
10000010
VIAIFR
VIAIER

HERE
HERE

PAGE 1
;PUT STACK AT END OF PAGE

:MAKE ALL CONTROL LINES
LINES INPUTS
:MAKE PORT
PORT A LINES
LINES INPUTS
INPUTS
:CLEAR BUFFER
BUFFER INDEX TO START
;CLEAR KEYBOARD
KEYBOARD INTERRUPT
INTERRUPT FLAG
FLAG
;ENABLE KEYBOARD
KEYBOARD INTERRUPT
INTERRUPT FROM
FROM VIA
;ENABLE CPU
CPU INTERRUPT
INTERRUPT
;DUMMY
PROGRAM
DUMMY MAIN PROGRAM

Interrupt
Interrupt Service
Service Routine:
Routine:

ENDL

*=INTRP
*=INTRP
PHA
TXA
PHA
LDX
LDA
STA
CMP
BEG
BEQ
INC
PLA
TAX
PLA
RTI
RTI
JMP

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
;SAVE INDEX REGISTER
REGISTERX IN STACK
$40
VIAORA
$41.X
$41,X
#CR
ENDL
ENDL
$40

;GET
BUFFER INDEX
GET BUFFER
:GET
KEYBOARD DATA
GET KEYBOARD
DATA
;SAVE DATA
BUFFER
DATA IN BUFFER
;IS DATA
CARRIAGE RETURN?
RETURN?
DATA A CARRIAGE
:YES.
YES, END OF LINE
LINE
;NO.
INCREMENT BUFFER
BUFFER POINTER
POINTER
NO, INCREMENT
;RESTORE INDEX REGISTER
REGISTERX FROM
FROM STACK
RESTORE
;RESTOREACCUMULATOR
FROM STACK
RESTORE
ACCUMULATOR FROM

LPROC
LPROC

;PROCESS
INTERRUPTS
PROCESS LINE WITHOUT
WITHOUT INTERRUPTS

program fills a buffer
buffer starting
starting at memory
memory location
location 0041 until
until it receives a carriage
This program
return
(CR). Memory
return character
character (CR).
Memory location
location 0040
0040 holds the current
current buffer
buffer index.
When
hen the processor
processor receives a carriage
carriage return.
return, it leaves the interrupt
interrupt system disabled
disabled
while
while it handles
handles the line.
An alternative
alternative approach
would be to fill
fill another
another buffer
buffer while
hile hanhan­
approach would
dling
dling the first
first one:
one; this approach
approach is called double
double buffering.
buffering.

DOUBLE
BUFFERING

The line processing
LPROC with
processing routine
routine is begun at address LPROC
ith interrupts
interrupts disabled.
disabled, and
with
ith the original
original register
register contents
contents (P,
return address in the Stack.
(P, A, and X) and the return
In a real application,
application, the CPU could
could perform
perform other
other tasks between
between interrupts.
interrupts. It could.
could, for
instance.
transmitit a line from one buffer
instance, edit.
edit, move, or transm
buffer while
hile the interrupt
interrupt was filling
filling
another buffer.
another

1212-19

A Printer Interrupt
Purpose: The computer
puter waits
waits for a printer
printer interrupt
interrupt and sends the data from memory
memory
location
location 0040
0040 to the printer.
printer.
Sample Problem:
(0040)
Result:

=

5116
if
Printer
(ASCII 0)
Printer receives a 5 115
1 6 (ASCII
Q) when
when it is ready.

Flowchart:
Flowchart:
Start

Initialize Stack Pointer
Enable pnnter
interrupt on VIA

Data - (0040)

Enable CPU interrupt

Send data to pnnter

End

Source Program:
Main
Main Program:
Program:
LDX
LOX
TXS
STX
LDA
LOA
STA
LDA
LOA
STA
STA
CLI
JMP

cu

HERE
HERE

#$FF
#$FF

:PUT STACK AT END
END OF PAGE
PAGE 1

VIADDRB
#00
VIAPCR
#%10000010
#%10000010
VIAIFR
VIAIER

:MA!(E
PORT B LINES OUTPUTS
;MAKE PORT

HERE
HERE

:MAKE
;MAKE ALL CONTROL LINES INPUTS
:CLEAR PRINTER
PRINTER INTERRUPT
INTERRUPT FLAG
FLAG
:ENABLE PRINTER
PRINTER INTERRUPT
INTERRUPT FROM VIA
:ENABLE CPU
CPU INTERRUPTS
INTERRUPTS
:DUMMY
PROGRAM
DUMMY MAIN PROGRAM

Interrupt
Interrupt Service
Service Routine:
Routine:
*=INTRP
"=INTRP
PHA
LDA
$40
LOA
$40
STA
VIAORB
VIAORB
PLA
RTI
RT/

:SAVE ACCUMULATOR
ACCUMULATOR IN STACK
:GET DATA
DATA
:SEND DATA
PRINTER
DATA TO PRINTER
:RESTORE
RESTORE ACCUMULATOR
ACCUMULATOR FROM
FROM STACK

1 2-20

O bjectt P ro gram:

Memory
Memory Address
Address
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory Contents
Contents
Memory
(Hex)
(Hex)

Main Program:
0000
0000
0001
0002
0002
0003
0003
00041
0004}
00051
0006
0006
0007
0007
0008
0008
0009)
0009}
000A)
OOOA
OOOB
0008
000C
oooc
000D
0000
000E)
OOOE}
0
00F)
OOOF
0010
0010
0011)
0011}
0012)
0012
0013
0013
0014
0014
0015
0016
0016

A2
FF
FF
9A
8E
SE

LDX
LOX

#$FF
#$FF

TXS
STX

VIADDRB
VIAOORB

LDA
LOA

#0

STA

VIAPCR

LDA
LOA

10000010
#% 1
0000010

STA

VIAIFR

STA

VIAIER

CLI
CLI
JMP

HERE
HERE

PHA
LDA
LOA

$40

STA

VIAORB

VIADDRB
VIAOORB
A9
00
8D
80
VIAPCR
A9
82
8D
80
VIAIFR
8D
80

VIAIER
VIAIER
58
4C
14
00

HERE
HERE

Interrupt
Interrupt Service
Service Routine:
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+3
INTRP+3
INTRP+4)
INTRP+4}
INTRP+51
INTRP+6
INTRP+6
INTRP+7

48
A5
40
8D
80
VIAORB

PLA
RTI
RTI

68
40

12-21

Here.
keyboard. you could
could have the printer
Here, as with
ith the keyboard,
printer continue
continue to
interrupt
interrupt until
until it transferred
transferred an entire
entire line of text. The main propro­
gram and the service
service routine
routine would
would be:

EMPTYING
PTYING A
BUFFER WITH
BUFFER
INTERRUPTS

Main
Main Program:
Program:
LOX
LDX
TXS
STX
LOA
LDA
STA
STA
LOA
LDA
STA
STA
CLI
JMP

cu

HERE
HERE

#$FF
#$FF
VIADDRB
#0
VIAPCR
$40
#%10000010
10000010
VIAIFR
VIAIER
HERE
HERE

;PUT STACK AT END OF PAGE 1
;MAKE
PORT B LINES
LINES OUTPUTS
:MAKE PORT

;MAKE ALL CONTROL LINES INPUTS
INPUTS
:INITIALIZE
BUFFER INDEX TO ZERO
;INITIALIZE BUFFER
ZERO
;CLEAR PRINTER
PRINTER INTERRUPT
INTERRUPT FLAG
:CLEAR
:ENABLE PRINTER
PRINTER INTERRUPT
INTERRUPT FROM
FROM VIA
;ENABLE
CPU INTERRUPT
INTERRUPT
:ENABLE CPU
;DUMMY
PROGRAM
;DUMMY MAIN PROGRAM

Interrupt
Interrupt Service
Service Routine:

ENDL

*=INTRP
*=INTRP
PHA
TXA
PHA
LOX
LDX
LOA
LDA
STA
CMP
BEO
BEQ
INC
PLA
TAX
PLA
RTI
RTI
JMP

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
REGISTERX IN STACK
;SAVE INDEX REGISTER

$40
$ 41,X
1.X
VIAORB
#CR
ENDL
$40

;GET
BUFFER INDEX
GET BUFFER
;GET
OF DATA
FROM BUFFER
BUFFER
GET A BYTE OF
DATA FROM
:SEND DATA
PRINTER
DATA TO PRINTER
;IS DATA
CARRIAGE RETURN?
RETURN?
DATA A CARRIAGE
:YES.
YES, END OF LINE
;NO.
BUFFER POINTER
POINTER
NO, INCREMENT BUFFER
:RESTORE INDEX REGISTER
REGISTER X FROM
FROM STACK
RESTORE
;RESTORE ACCUMULATOR
;RESTORE
ACCUMULATOR FROM
FROM STACK

LCOMP

:HANDLE COMPLETED
COMPLETED LINE
LINE
:HANDLE

Again. double
double buffering
buffering could
could be used to allow
1/0 and processing
Again,
allow I/O
processing to occur
occur at the same
time w ith
ithout
CPU.
o u t ever halting
halting the CPU.

12-22
12-22

56
A Real-Time
eal-Tim e Clock lnterrupt
Interrupt5,6
•
Purpose: The computer
Purpose:
puter waits
waits for an interrupt
interrupt from a real-time
clock.

REAL-TIME
CLOCK
CLOCK

A real-timee clock simply provides a regular series of pulses.
een
pulses. The interval between
Real-time clock interrupts can be
the pulses
pulses can be used as a time reference. Real-time
counted to give any multiple of the basic time interval. A real-time
real-time clock can be propro­
dividing down the CPU
programmable
duced by dividing
CPU clock, by using a separate timer or a programmable
timer
er like the ones available in the 6522 VIA or in the 6530
6530 or 6532 Multifunction
ultifunction
devices (see
(see Chapter
11). or by using external sources such as the AC line frequency.
Chapter 11),

Note
Note the tradeoffs involved in determining the frequency
frequency of
FREQUENCY
frequency (say
(say 10 kHz)
kHz) allows the
the real-timee clock. A high frequency
OF REAL-TIME
creation
creation of a wide range of time intervals
intervals of high accuracy. On the
CLOCK_______
other
hand. the overhead involved
other hand,
involved in counting
counting real-time
real-time clock
interrupts
interrupts may be considerable, and the counts will
ill quickly
quickly exceed the capacity
capacity of a
-b it register or memory location. The choice of frequency
frequency depends on the precipreci­
single 8-bit
sion and timing
ing requirements
requirements of your application.
application. The clock may, of course, consist
partly of hardware; a counter
interrupt the pro­
procounter may count
count high frequency
frequency pulses andinterrupt
measure time
time to
cessor only occasionally. A program will
ill have to read the counter
counter to
to measure
high accuracy.
One problem is synchronizing operations with
ith the realreal­
time clock. Clearly, there will
ill be some effect
effect on the precipreci­
CPU starts the measure­
measuresion of the timing
ing interval
interval if the CPU
ment randomly
period. rather than exactly
randomly during
during a clock period,
exactly at
are:
the beginning.
beginning. Some ways to synchronize operations
operations are:

SYNCHRONIZATION
SYNCHRONIZATION
WITH
ITH REAL-TIME
CLOCK
CLOCK

1)
1)

startup interrupt
interrupt can start the clock as
Start the CPU
CPU and clock together. RESET
RESETor a startup
well as the CPU.
CPU.
CPU to start and stop the clock under program control.
2) Allow
llow the CPU
less than one clock period will
3) Use a high-frequency
high-frequency clock so that an error of less
ill be
small.
measure4) Line up the clock (by waiting
aiting for an edge or interrupt)
interrupt) before starting
starting the measure­
ment.
PRIORITY
A real-tim
real-timee clock interrupt should
should have very high priority,
OF REAL-TIME
since the precision of the timing intervals will be affected
affected by
CLOCK
CLOCK
any delay in servicing the interrupt. The usual practice
practice is to
make the real-time
real-time clock the highest
highest priority
priority interrupt
interrupt except
except for
kept extrem
ely short
power failure
failure. The clock interrupt service routine is generally kept
extremely
so that it does not interfere
interfere with
ith other CPU activities.
activities.

12-23
1

a)
ait for Real-Time Clock
al Wait

Program:
Source Program:

Program:
Main Program:

HERE
HERE

LDX
LOX
TXS
TXS
LDA
LOA
STA
STA
LDA
LOA
STA
STA
STA
STA
CLI
CLI
JMP

#$FF
#0
VIAPCR
VIAPCR
# %10000010
10000010
VIAIFR
VIAIFR
VIAIER
VIAIER

HERE
HERE

;PUT STACK
STACK AT END
END OF
OF PAGE
PAGE 1
;PUT

;MAKE
:MAKE ALL CONTROL
CONTROLLINES
LINES INPUTS
INPUTS
CLEAR
:CLEAR CLOCK
CLOCK INTERRUPT
INTERRUPTFLAG
FLAG
:ENABLECLOCK
CLOCK INTERRUPT
INTERRUPTFROM
FROMVIA
ENABLE
ENABLE
:ENABLECPU
CPU INTERRUPT
INTERRUPT
:DUMMY MAIN PROGRAM
PROGRAM

Interrupt Service
Service Routine:
Routine:
*=INTRP
"=INTRP
PHA
PHA
LDA
#%10000010
LOA
#%10000010
VIAIFR
VIAIFR
STA
PLA
PLA
BRK
BRK

;SAVE
:SAVE ACCUMULATOR
ACCUMULATORIN STACK
STACK
:CLEAR
:CLEAR CLOCK
CLOCKINTERRUPT
INTERRUPTFLAG
FLAG
:RESTOREACCUMULATOR
ACCUMULATORFROM
FROM STACK
STACK
;RESTORE

1 2-24

Object P ro g
Program:
Ob
ra m :
Memory
Memory Address
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)

Memory
Memory Contents
(Hex)
(Hex)

Main Program:
0000
0001
0002
0003
0004
0005
00061
0006}
0007)
0007
0008
0009
OOOA
000A
000BI
0008}
oooc
000C)
0000
000D
000E)
OOOE}
OOOF
000F)
0010
0011
0012
0013

A2
FF
FF
9A
A9
00
8D
80

LOX
LDX

#$FF

TXS
LOA
LDA

#00

STA

VIAPCR
VIAPCR

LOA
LDA

#% 1
0000010
10000010

STA

VIAIFR
VIAIFR

STA

VIAIER
VIAIER

CLI
CLI
JMP

HERE
HERE

PHA
LOA
LDA

10000010
#% 1
0000010

STA

VIAIFR
VIAIFR

VIAPCR
VIAPCR
A9
82
80
8D

VIAIFR
VIAIFR
80
8D
VIAIER
VIAIER
58
4C
11
11
00

HERE
HERE

Interrupt
Interrupt Service Routine:
INTRP
INTRP
INTRP+1
INTRP+1
INTRP+2
INTRP+3
INTRP+4)
INTRP+4}
INTRP+5
INTRP+5)
INTRP+6
INTRp+7

48
A9
82
80
8D

VIAIFR
VIAIFR
68
00

PLA
BRK
BRK

O of the VIA Peripheral Control register is 0,
0. the interrupt
If bit 0
interrupt will
ill occur
occur on the high-tohigh-tolow (falling) clock edge.
that bit is 1.
interrupt will
ill occur on the low-to-high
low-to-high (ris­
edge. If that
1. the interrupt
(risedge.
ing) clock edge.
The Clock Interrupt
Interrupt flag must be explicitly
explicitly cleared in the interrupt
interrupt service routine since
1/0 transfer is required. Note that Port A could still
no I/O
still be used for data as long as that
(see Ta­
Tadata was transferred using the address that does not affect
affect the interrupt
interrupt flags (see
ble 11-7)
11-7).

12-255
12

follow-­
We could.
could, of course.
course, generate
generate the pulse itself
itself using one of the 6522
6522 timers. The follow
ing example
(138815)
example uses timer
er 1 to produce
produce a single
single pulse 5000
5000 (1388
1 6> clock cycles in
length. Remember
Remember the following:
following:
1)
1)

The timer
er 1 counters
counters are loaded from twoo memory
memory locations
locations (VIAT11L and
VIAT1CH);
CH); loading
CH starts
loading the most significant
significant bits of the timer
er count
count into VIAT1CH
the timer
er and clears the T1 Interrupt
Interrupt flag (bit 6 of the Interrupt
Interrupt Flag register).

2)

The mode of operation
operation of timer
er 1 is controlled
controlled by bits 6 and 7 of the Auxiliary
Auxiliary ConCon­
trol register:
register:

3)

bit 6 = 0 for a single pulse and 1 for continuous
continuous operation
operation
bit 7 = 0 to disable
disable output
output pulses on PB7 and 1 to generate
generate such pulses.
The conclusion
conclusion of the timing
ing interval
interval sets the timer
er 1 Interrupt
Interrupt flag (bit 6 of the InIn­
terrupt
terrupt Flag register).

Table 11-7 describes
describes the addressing
addressing of the VIA.
VIA, Figure 11-10
11-10 describes
describes the Auxiliary
Auxiliary
Control
Control register.
register, and Figure 12-3 describes
describes the Interrupt
Interrupt Flag register.

Main Program:

HERE
HERE

LDX
LOX
TXS
LOA
LDA
STA
LOA
LDA
STA
STA
LOA
LDA
STA
LOA
LDA
STA
CLI
CLI
JMP

#$FF
#$FF
PAGE 1
;PUT STACK AT END OF PAGE
#00
VIAACR
%11000000
#% 1
1000000
VIAIFR
VIAIER
VIAIER
# $88
88
VIAT1L
VIAT1L
# $13
13
VIAT1CH

HERE
HERE

:GENERATE
ONE PULSE
PULSE FROM
FROM TIMER 1
GENERATE ONE
:CLEAR
TIMER 1 INTERRUPT
INTERRUPT
CLEAR TIMER
;ENABLE TIMER 1 INTERRUPT
INTERRUPT
;PULSE
LENGTH = 5000
PULSE LENGTH
5000 (1388 HEX)

;START TIMING INTERVAL
:ENABLE CPU
CPU INTERRUPT
INTERRUPT
:DUMMY
PROGRAM
DUMMY MAIN PROGRAM

Interrupt
Interrupt Service Routine:
Routine:
*=INTRP
PHA
LDA
#%1
1000000
LOA
%11000000
STA
VIAIFR
PLA
BRK
BRK

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
;CLEAR
:CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
:RESTOREACCUMULATOR
FROM STACK
;RESTORE
ACCUMULATOR FROM

The only change
change in the service
service routine
routine is the position
position of the Clock Interrupt
Interrupt flag in the
Interrupt
Interrupt Flag register.

12-26

bl
b)

Walt
ait for 10 Real-Time Clock Interrupts

Program:
Source Program:
Main
Main Program:
Program:

WTTEN

LOX
LDX
TXS
LOA
LDA
STA
STA
LOA
LDA
STA
STA
LOA
LDA
CLI
CMP
BNE
SEI
SEI
BRK
BRK

#$FF
#$FF
#00
VIAPCR
$40
#% 1
0000010
10000010
VIAIFR
VIAIER
#10
10

$40
$40
WTTEN

;PUT STACK AT END OF PAGE
PAGE 1

;MAKE ALL CONTROL
CONTROL LINES
LINES INPUTS
INPUTS
;CLEAR CLOCK
CLOCK COUNTER
COUNTER
;CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
;ENABLE CLOCK INTERRUPT
INTERRUPT FROM
FROM VIA
;NUMBER OF COUNTS== 10
;ENABLE CPU
CPU INTERRUPT
INTERRUPT
;HAVE TEN
TEN COUNTS ELAPSED?
ELAPSED?
;NO, WAIT
AIT
;YES,
CPU INTERRUPT
INTERRUPT
YES, DISABLE CPU

Interrupt
Interrupt Service Routine:
•=INTRP
*=INTRP
PHA
$40
INC
%10000010
LDA
#% 1
0000010
LOA
STA
VIAIFR
PLA
RTI
RTI

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
;INCREMENT
COUNTER
INCREMENT CLOCK COUNTER
;CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
;RESTORE ACCUMULATOR
FROM STACK
;REST0RE
ACCUMULATOR FROM

Clearly
Clearly we could
could generate
generate the pulses from the 6522
6522 timerer — for example, we could use
1). The only
register== 1).
timer
er 1 in its continuous
continuous mode (bit 6 of the Auxiliary
Auxiliary Control
Control register
other
Interrupt flag.
other change
change would
would be the bit
bit position
position of the Interrupt

12-27
12-

Objectt P ro g
Program:
Ob
m:
Memory
Memory Address
Address
(Hex)
(Hex)

Memory
Memory Contents
Contents
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Main Program:
0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006)
0006}
00071
0008
0008
0009
0009
OOOA
000A
000B
OOOB
oooc
OOOC
000D)
000D}
OOOE
000E)
OOOF
000F
0010)
0010}
0011 f
0012
0012
0013
0013
0014
0014
0015
0015
0016
0016
0017
0017
0018
0018
0019
0019
001A
001A

A2
FF
FF
9A
A9
00
8D

LDX

#$FF
#$FF

TXS
LDA

#00

STA

VIAPCR

STA

$40

LDA

10000010
#% 1
0000010

STA

VIAIFR

STA

VIAIER

LDA

#10
10

CLI
CLI
CMP

$40

BNE
BNE

WTTEN

VIAPCR
85
40
A9
82
8D
VIAIFR
8D
VIAIER

A9
OA
58
C5
40
DO
FC
78
00

WTTEN

SEI
SEI
BRK
BRK

Interrupt
Interrupt Service Routine:
Routine:
INTRP
INTRP
INTRP+1
INTRP+2
INTRP+3
INTRP+4
INTRP+4
INTRP+5
INTRP+6)
INTRP+6}
INTRP+7)
INTRP+7
INTRP+8
INTRP+9

48
E6
40
A9
82
8D

PHA
INC

$40

LDA

#% 1
0000010
10000010

STA

VIAIFR

VIAIFR
68
40

12-28
12

PLA
RTI
RTI

This interrupt
interrupt service routine
routine merely updates the counter
counter in memory location 0040. It is
transparent
transparent to the main program.

could main­
mainA more realistic real-time clock interrupt routine could
locations. For example.
tain real time in several memory locations.
example, the
following
follow
ing routine
routine uses addresses 0040
0040 through
through 0043
0043 as follows:
follows:
0040
0040 - hundredths
hundredths of seconds
0041 - seconds
0042
0042 - minutes
0043
0043 - hours
We assume that the routine
routine is triggered
triggered by a 100 Hz clock.
Flowchart:
Start

Clear clock interrupt
Hundredths =
Hundredths + 1

Hundredths

0

=

Seconds
=
Seconds + 1

Seconds

0

Minutes
Minutes + 1

Minutes
0
Hours
Hours + 1

End

12-29

INTAINING
M A IN
TA IN IN G
REAL TIME
REAL

S o urce P ro gram:
0

ENDINT

=INTRP
*=INTRP
PHA
LDA
STA
INC
LOA
LDA
SEC
SEC
SBC
SBC
BNE
BNE
STA
INC
LOA
LDA
SBC
SBC
BNE
BNE
STA
INC
LDA
SBC
SBC
BNE
BNE
STA
INC
PLA
RTI
RTI

:SAVE ACCUMULATOR
;SAVE
ACCUMULATOR IN STACK
%10000010
#%1
0000010
VIAIFR
$40
$40

:CLEAR CLOCK INTERRUPT
INTERRUPT FLAG
FLAG
;CLEAR
:UPDATE HUNDREDTHS OF SECONDS
SECONDS
;UPDATE
:IS THERE
THERE A CARRY TO SECONDS?
SECONDS?
;IS

100
#1
00
ENDINT
$40
$41
$41
#60
60
ENDINT
$41
$42
$42
#60
60
ENDINT
$42
$43

:NO, DONE
DONE
:YES,
HUNDREDTHS ZERO
ZERO
YES, MAKE HUNDREDTHS
:UPDATE SECONDS
SECONDS
:IS THERE
THERE A CARRY
CARRY TO MINUTES?
:NO,
DONE
NO. DONE
:YES,
SECONDS ZERO
ZERO
YES, MAKE SECONDS
:UPDATE MINUTES
;IS THERE
THERE A CARRY
CARRY TO HOURS?
HOURS?
:NO, DONE
DONE
;YES,
ZERO
YES, MAKE MINUTES ZERO
:UPDATE HOURS
HOURS
;RESTOREACCUMULATOR
FROM STACK
RESTORE
ACCUMULATOR FROM

Now a wait
ait of 300 ms could be produced in the main program with the routine:

WAIT30
AIT30

LOA
LDA
CLC
ADC
CMP
BCC
BCC
SBC
SBC
CMP
BNE
BNE

$40

;GET CURRENT
CURRENT REAL
REAL TIME
;GET

#30
30
100
#1
00
WAIT30
AIT30
100
#1
00
$40
WAIT30
AIT30

;DESIRED TIME IS 30 COUNTS LATER
LATER
iDESIRED
:MOD
;MOD 100

DESIRED TIME
;WAIT
AIT UNTIL DESIRED

We do not need explicit
SET CARRY
CARRY (SEC)
(SEC) instructions
explicit SET
instructions except
except in the first
first operation
operation in
interrupt service
service routine.
routine. The other
other operations
operations in the interrupt
interrupt service
service routine
routine are
the interrupt
only performed
It (and hence also pro­
properformed if the previous
previous subtraction
subtraction produced
produced a zero result
duced a Carry of 1 indicating
indicating no borrow). In the waitit program.
subtraction is only
duced
program, the subtraction
performed
performed at all if the Carry is 1 (otherwise
(otherwise a branch
branch occurs).
Of course, the program
ocprogram could
could perform
perform other
other tasks and check the elapsed timee only oc­
casionally. How would
would you produce
produce a delay of seven seconds?
seconds? Of three minutes?
minutes?
casionally.
Sometimes
want to keep tim e either
either as BCD digits
digits or as ASCII characters.
Sometimes you may want
characters. How
would
would you revise the last program
program to handle
handle these alternatives?
alternatives?

12-30
12
30

needed. you can disable the clock interrupt
When it is no longer needed,
interrupt
(or any other interrupt)
interrupt) in any of the following
following ways:

DISABLING
INTERRUPTS

1) By
By executing
executing an
an SEI instruction in the SEI
main
program. in
This
1)
instruction
thedismain program. This dis­
SE! instruction
ables the entire interrupt
interrupt system. An SEI
instruction in the service routine
routine has no
effect. since RTI
RT! restores
automatically
effect,
restores the
the old
old II flag:
flag: anyway.
anyway, the
the 6502
6502 autom
atically disables
disables inin­
terrupts
terrupts during
during the service routine.
2) By
By clearing
clearing the
the appropriate
2)
appropriate bit
bit in
in the
the Interrupt
Interrupt Enable
Enable register
register (see
(see Figure
Figure 12-2)
12-2)
either
either during
during the service routine or during
during the main program. This disables only the
single interrupt
VIA.
interrupt source from one VIA.
By setting
setting the
the Interrupt
Interrupt Disable
Disable flag
flag inin the
the Stack
Stack during
3) By
during the
the service
service routine.
routine. The
The
following
follow
ing program will
ill do the job (remember that the Interrupt
Interrupt Disable flag is bit 2
of the Status register and that the Status register is the top entry in the Stack -—
see Figure 12-1):
see
PLA
PLA
ORA
ORA
PHA
PHA

#%00000010
00000010

:GET STATUS
STATUS REGISTER
REGISTER
;GET
:SET INTERRUPT
INTERRUPTDISABLE
DISABLE FLAG
;SET
FLAG
:RETURN STATUS
STATUS REGISTER
REGISTERTO STACK
STACK
;RETURN

RTI will
RTI
ill then cause a return to the main program with
ith the entire interrupt
interrupt system
disabled.
Note, however,
however. that you must be very careful about not re-enabling the interrupts
Note,
interrupts
automatically.
atically, since the main program would be completely
completely unaware that interinter­
should re­
rerupts were no longer allowed. In general, all interrupt
interrupt service routines should
enable the interrupts
interrupts before returning; any other policy means that
that the ser­
service routines are not transparent
transparent to the main program.
program.

1 2-31

A T e letyp
letypewriter
e w riter Interrupt
teletypewriter
Purpose: The computer
computer waits
waits for data to be received from a teletypew
riter and stores
the data in memory
memory location
location 0040.
a)
al

Using
5 0 ACIA
Using a 6 860

(7-bit
(7-bit characters
characters with
ith odd parity
parity and twoo stop bits).

ACIA
INTERRUPT
ROUTINE

Source Program:
Main Program:
Main

HERE
HERE

LOX
LDX
TXS
LDA
LOA
STA
LDA
LOA
STA
CLI
CLI
JMP

#$FF
#$FF

;PUT
:PUT STACK AT END OF PAGE
PAGE 1

#%00000011
#%00000011
ACIACR
%11000101
#% 1
1000101
ACIACR

;MASTER
:MASTER RESET
RESET ACIA

HERE
HERE

;ENABLE ACIA INTERRUPT
INTERRUPT

CPU INTERRUPT
INTERRUPT
;ENABLE CPU
;DUMMY MAIN PROGRAM
:DUMMY
PROGRAM

Interrupt
Interrupt Service
Service Routine:
*=INTRP
PHA
LOA
ACIADR
LDA
ACIADR
STA
$40
$40
PLA
RTI
RTI

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
DATA FROM
:GET DATA
FROM ACIA
:SAVE DATA
:RESTORE ACCUMULATOR
FROM STACK
RESTORE
ACCUMULATOR FROM

12-32
12

O bject
c t P ro gram:
m:

Memory Address
Memory Contents
Instruction
Instruction
(Hex)
____________(Hex)_______________ (Hex)
(Hex)____________________(Mnemonic)
Main Program:
0000
0001
0002
0003
0004
0005
00
061
0006}
0007)
0007
0008
0009
000A
OOOA
000Bl
OOOB}

A2
FF
FF
9A
A9
03
8D

oooc
oooct

ACIACR
ACIACR

000D
OOOE
000E
OOOF
000F
0010

58
4C
OE
OE
00

LDX

#$FF

TXS
TXS
LDA

# %00000011
00000011

STA

ACIACR
ACIACR

LDA

%11000101
#% 1
1000101

STA

ACIACR
ACIACR

ACIACR
ACIACR
A9
C5
8D

cu

HERE
HERE

CLI
JMP

HERE
HERE

PHA
PHA
LDA
LOA

ACIADR
ACIADR

STA

$40

Interrupt
Interrupt Service Routine:
INTRP
INTRP
INTRP+1
INTRP+1
INTRP+21
INTRP+2}
INTRP+3)
INTRP+4
INTRP+5
INTRP+6
INTRP+7

48
AD

ACIADR
ACIADR
85
40
68
40

PLA
RTI
RTI

has no RESET
RESET input.
Reset (making Control
Remember that
that the ACIA has
input, so a Master Reset
O and 1 both '1') is necessary
necessary before the ACIA is used.
used. The ACIA Control
register bits 0
configuration is:
register configuration
is:
Bit 7 =
= 1 to enable the receive
receive interrupt
interrupt
Bit 6 = 1,
1, Bit 5 = 0 to disable
transmitter
make RTS
RTS high
disable the
the transm
itter interrupt
interrupt andmake
high
(inactive)
0. Bit 3 = 0,
0. Bit 2 = 1 to select 7-bit
Bit 4 = 0,
-bit data with
ith odd parity and two
stop bits
0. Bit 0
O = 1 for +-s- 16
Bit 1 = 0,
16 clock
clock (1760
(1760 Hz)
Hz)
the CPU
CPUmust
mustexamine
examine
To determine
determine if a particular
particular ACIA is
is the
the source
source of
of an
an interrupt.
interrupt, the
register. The program must examine the
the Interrupt
Interrupt Request bit. bit 7 of the Status register.
Receive Data Register Full bit (Status register bit 0) and the Transmit
Receive
Transmit Data Register
1) to differentiate
transmitit interrupts.
Empty bit (Status register bit 1)
differentiate between receive and transm
Either reading the Receive
riting into the Transmit
Transmit Data register clears
Receive Data register or writing
the ACIA Interrupt
Interrupt Request
Request bit.

12-33
12-33

bl
b)

Using a 6522
Using
6522 VIA
(Received data tied to both
both data
date bit
hit 7 and
anH tn
cnntmt line
linp 1 nf
to control
of
the VIA.)

START BIT
INTERRUPT

Source Program:
Main
Main Program:
Program:

HERE
HERE

LDX
TXS
LDA
STA
STA
LDA
STA
STA
CLI
CLI
JUMP

#$FF
#$FF
#0
VIAPCR
VIADDRA
VIADDRA
#% 1
0000010
10000010
VIAIFR
VIAIER

HERE
HERE

;PUT STACK AT END OF PAGE 1

;MAKE ALL CONTROL LINES INPUTS

;CLEAR START BIT INTERRUPT
INTERRUPT FLAG
;ENABLE START BIT INTERRUPT
INTERRUPT FROM VIA
:ENABLE CPU INTERRUPT
INTERRUPT
;DUMMY
DUMMY MAIN PROGRAM

Interrupt
Interrupt Service
Service Routine:
Routine:
•=INTRP
*=INTRP
PHA
LDA
STA
STA
JSR
LDA
STA
PLA
RTI
RTI

;SAVE ACCUMULATOR
ACCUMULATOR IN STACK
#%00000010
00000010
VIAIFR
VIAIER
TTYRCV
# %10000010
10000010
VIAIER

;CLEAR START BIT INTERRUPT
INTERRUPT FLAG
;DISABLE START BIT INTERRUPT
INTERRUPT
;FETCH
DATA FROM TTY
FETCH DATA
;RE-ENABLE START BIT INTERRUPT
INTERRUPT
;RESTORE ACCUMULATOR
FROM STACK
:RESTORE
ACCUMULATOR FROM

1 2-34
4

Objectt Program:
m:
Memory
Memory Address
Address
(Hex)
(Hex)

Instruction
Instruction
(Mnemonic)
(Mnemonic)

Memory
Memory Contents
Contents
(Hex)
(Hex)

Main
Main Program:
Program:
0000
0000
0001
0002
0002
0003
0003
0004
0004
0005
0005
0006)
0006}
00071
0008
0008
0009)
0009}
000A)
000A
000BB
oooc
OOOC
000D
000D
000E
000F
0010
0010
0011)
0011}
0012
0012)
0013
0013
0014
0014
0015
0015
0016
0016

A2
FF
FF
9A
A9
00
8D

LDX

#$FF
#$FF

TXS
LDA

#00

STA

VIAPCR

STA

VIADDRA
VIADDRA

LDA

#% 1
0000010
%10000010

STA

VIAIFR

STA

VIAIER

CLI
CLI
JMP

HERE
HERE

PHA
LDA

#%00000010
00000010

STA

VIAIFR

STA

VIAIER

JSR

TTYRCV

LDA

#% 1
0000010
10000010

STA

VIAIER

VIAPCR
8D
D

VIADDRA
VIADDRA
A9
82
8D
D
VIAIFR
8D
VIAIER
58
4C
14
00

HERE
HERE

Interrupt Service
Service Routine:
Interrupt

INTRP
INTRP
INTRP+1
INTRP+2
INTRP+3
INTRP+3
INTRP+4)
INTRP+4}
INTRP+5)
INTRP+5
INTRP+6
INTRP+6
INTRP+7)
INTRP+7}
INTRP+8)
INTRP+8
INTRP+9
INTRP+10)
INTRP+10}
INTRP+11)
INTRP+l
INTRP+12
INTRP+12
INTRP+13
INTRP+13
INTRP+14
INTRP+14
INTRP+15)
INTRP+15}
INTRP+161
INTRP+16
INTRP+17
INTRP+17
INTRP+18
INTRP+18

48
A9
02
8D
D
VIAIFR
8D
D
VIAIER
20
TTYRCV
A9
82
8D
D
VIAIER
VIAIER
68
40

12-35

PLA
RTI
RTI

Subroutine
teletypewriter
chapter.
Subroutine TTYRCV is the teletypew
riter receive routine shown in the previous chapter.
here. The transition
The edge used to cause the interrupt
interrupt is very important
portant here.
transition from the
(SPACE) state must cause the in te
terrupt.
normal 'V
'1' (MARK)
(MARK) state to the 'O’ (SPACE)
rru p t since this
transition
transition identifies
identifies the start of the transmission. No '0' to '1' transition
transition will occur until a
received.
nonzero data bit is received.

·o·

·o·

·o·

transiThe service routine must disable the VIA interrupt.
interrupt, since otherwise
otherwise each '1'• to 'O' transi­
tion in the character
course. you must re-enable the VIA in­
incharacter will
ill cause an interrupt.
interrupt. Of course,
terrupt
read.
terrupt after the entire character
character has been read.
Enable register is
Note how VIA interrupts
interrupts are enabled or disabled. Bit 7 of the Interrupt
Interrupt Enable
"Set/Clear
0. subsequent
a "Set/C
lear Control"
Control" bit. If that
that bitit is 0,
subsequent T
'1' bits clear interrupt
interrupt enable bits
1. subsequent ·1
and hence disable the corresponding
corresponding interrupts:
interrupts; if that bit is 1,
'1'• bits set
interrupt
processor
interrupt enable bits and hence enable the corresponding
corresponding interrupts. The processor
cannot
Flag register,
register. so either an enabling or a
cannot actually
actually write
rite into bit 7 of the Interrupt
Interrupt Flag
disabling
descriptions of
disabling pattern
pattern can be used to clear the interrupt
interrupt flags. Remember the descriptions
the Interrupt
Flag register in Figures 12-2 and 12-3.
12-3.
Interrupt Enable register and Interrupt
Interrupt Flag

12-36
12-36

MORE GENERAL SERVICE ROUTINES
More general service routines that are part of a complete
interrupt-driven
handle the following tasks:
interrupt-driven system must handle
1)

serSaving all registers thatt are used in the interrupt ser­
provice routine in the Stack so that
that the interrupted pro­
resumed.
gram can be correctly resumed.

FOR
TASKS FOR
GENERAL
GENERAL SERVICE
SERVICE
ROUTINES

Accumulator
and for
Remember that
that the 6502 only has Push instructions
instructions for the Accum
ulator and
for
the Status (P)
(Pl register. Pushing the Status register is unnecessaryafter
afteran
aninterrupt
interrupt
save all the
since the interrupt
interrupt response does this automatically.
automatically. A routine to save
registers in the Stack would
(as shown earlier):
earlier):
would be (as
PHA
TXA
PHA
TYA
PHA

:SAVE
;SAVE ACCUMULATOR IN STACK
:SAVE
INDEX REGISTER
REGISTERX IN STACK
STACK
;SAVE INDEX
:SAVE
INDEX REGISTER
REGISTERY IN STACK
STACK
;SAVE INDEX

programs, certain memory locations
locations on page
page zero are treated as
In some 6602
6502 programs,
extra registers. Such locations
locatlons may have to be saved and restored during
during in­
insave the contents
terrupt service routines. The procedure to save
contents of memory location
0040 would
be. for example:
ould be,
LOA
LDA
PHA
PHA

$40

:SAVE MEMORY
MEMORY LOCATION
LOCATION 0040 IN STACK
STACK
;SAVE

Of course, only those registers that
that are used by the interrupt
interrupt service routine must
saved.
be saved.
2)

service
Restoring all registers from the Stack after completing the interrupt service
routine. Remember that registers must be restored in the opposite order from that
saved.
in which
hich they were saved.

3)

Enabling and disabling
disabling interrupts appropriately. Remember that the CPU
CPU autoEnabling
auto­
one.
matically
atically disables its interrupts
interrupts upon accepting
accepting one.

The service routines should
should be transparent as far as the interrupt program
program is con­
con(i.e., they should have no incidental
effects).
cerned (i.e.,
incidental effects).
Any standard subroutines that
that are used by an interrupt service routine must be
reentrant. If some subroutines cannot be made reentrant, the interrupt service
use.7
routine must have separate versions to use.?

12-37
12-

PROBLEMS
1)

A Test
est Interrupt

Purpose: The computer
occur. then executes the endless
computer waits
waits for a VIA interrupt
interrupt to occur,
loop instruction:
instruction:

HERE
HERE

JMP

HERE
HERE

u ntil
til the next interrupt
interrupt occurs.

2)

A Keyboard Interrupt

Purpose: The computer
puter waits
waits for a 4 -digit
ig it entry
entry from a keyboard and places the digits
digits
into memory locations 0040
Each
0040 through
through 0043 (first one received in 0040). Each
digitit entry
entry causes an interrupt.
interrupt. The fourth
fourth entry
entry should also result in the disdis­
abling
abling of the keyboard interrupt.
interrupt.
Sample Problem:
Keyboard data =

04, 06, 01, 07

Result:
Result:

04
06
01
07

3)

(0040)
(0041)
(0042)
(0043)

=
=
=
=

A Printer Interrupt

Purpose: The computer
puter sends four
four characters from memory
memory locations 0040 to 0043
(starting with
Each character
ith 0040) to the printer. Each
character is requested by an interinter­
rupt. The fourth
fourth transfer
transfer also disables the printer
printer interrupt.
interrupt.

4)

A Real-Time
eal-Tim e Clock Interrupt

Purpose: The computer
puter clears memory location 0040 initially
initially and then complements
complements
memory location
location 0040
0040 each time the real-time
real-time clock interrupt
interrupt occurs.
locaHow would
would you change the program so that it complements
complements memory
memory loca­
tion 0040
0040 after every ten interrupts?
interrupts? How would
would you change the program so
that
periods. FF-|
FF15.
that it leaves memory location
location 0040
0040 at zero for ten clock periods,
q for
continuously? You may want
ant to use a display
five clock periods,
periods. and so on continuously?
location 0040
0040 so that it will
ill be easier to see.
rather than memory location
see.

5)

letypewriter
A T e letyp
e w riter Interrupt

Purpose: The computer
computer receives TTY data from an interrupting
interrupting 6850 ACIA and stores
the characters in a buffer
buffer starting
starting in memory location 0040. The process
process
continues until
until the computer
puter receives a carriage return (OD
(0D-|g).
continues
15). Assume that
ASCII with
the characters
characters are 7-bit
7-bit ASCII
ith odd parity. How would
would you change
change your
program to use a·VIA? Assume that subroutine
subroutine TTYRCV is available.
available, as in
the example. Include the carriage return as the final character
character in the buffer.

12-38
12

REFERENCES
1. A. Osborne. An Introduction
Concepts.
1.
Introduction to Microcomputers:
Microcomputers: Volume
Volume 1 -— Basic Concepts,
pp. 5-14 to 5-34.
(Berkeley: OSBORNE/McGraw-Hill. 1977). pp.
R. L.
L. Baldridge.
Power. Complexity
icrocomputer
2. R.
Baldridge, "Interrupts
"Interrupts Add Power,
plexity to M icrocom
puter System
Design".
EON. August
5. 1977, pp. 67-73.
Design", EDN,
August 5,
eventhal.
800
ssembly
anguage
3. L L e v e
n th a l, 6 8
00 Ass
e m b ly L a n
guage
OSBORNE/McGraw-Hill, 1979),
1979). pp. 12-5 to 12-25.

rogramming
,(Berkeley:
P ro g
ra m m in g .(B e
rk e le y :

icrocomputer
pp.
4. MCS6500
MCS6500 M icrocom
puter Family Hardware Manual.
Manual, MOS Technology
Technology Inc.,.. pp.
104-108.
5. J. Gieryic, "SYM-1 6522-Based Timer",
Timer". Micro,
Micro. April
April 1979.
31 to 11:32.
32.
1979, pp. 11:31
6. M. L.
L. DeJong.
65",, Micro.
pp.
DeJong, "A Simple 24-Hour
24-Hour Clock for the AIM 65”
Micro, March 1979, pp.
-10:5 to 10:7.
7. For further
further discussion
discussion and some real-life examples of designing
designing 65026502- and 6800see the following:
based systems with
ith interrupts.
interrupts, see
following:

6502
6502
T. Travis,
Travis. "Patching
ROM"., Electronics.
1. 1976,
1976. pp. 98 T.
"Patching a Program into a ROM”
Electronics, September
September 1,
101 .
10
G. L.
L. Zick and T.
T. T.
T. Sheffer,
Sheffer. "Remote
Instrumentation".
G.
"Remote Failure Analysis
Analysis of Micro-Based Instrum
entation",
1977. pp. 30-35.
Computer.
puter. September
September 1977,

6800
6800
S. C.
C. Baunach,
Baunach. "Ann Example of an M6800-based
GPIB Interface".
EON, September
20.
S.
M6800-based GPIB
Interface", EDN,
September 20,
1977, pp. 125-128.
L. E.
E. Cannon and P. S.
S. Kreager,
Kreager. "Using
L.
"Using a Microprocessor:
Microprocessor: a Real-Life Application.
Application. Part 2
Design. October 1975. pp. 81-89.
- Software".
Software". Computer
Computer Design,
D. Fullager et al.,.. "Interfacing
Electronics.
D.
"Interfacing Data Converters and Microprocessors",
Microprocessors", Electronics,
December 8,
December
8. 1976,
1976. pp. 81-89.
S. A. Hill,
Hill. "Multiprocess
1,tP
EON.
S.
ultiprocess Control Interface Makes Remote ix
P Command Possible".
Possible", EDN.
pp. 87-89.
-February 5, 1976, pp.
S. Holderby.
W. S.
Holderby, "Designing
"Designing a Microprocessor-based
Microprocessor-based Terminal
Terminal for Factory Data CollecCollec­
tion",
tion". Computer
Computer Design,
Design. March 1977, pp.
pp. 81-88.
Instruments",
EON,
A. Lange. "OPTACON Interface
Interface Permits the Blind to 'Read' Digital
Digital Instrum
ents". EDN,
February 5, 1976, pp. 84-86.
D. Logan and P.
P. S.
S. Kreager,
Kreager. "Using
J. D.
"Using a Microprocessor:
Microprocessor: a Real-Life Application.
Application. Part 1 Hardware",, Computer
Design, September
1975. pp. 69-77.
Hardware”
Computer Design.
September 1975,

12-39

Eidson. "Printer
A. Moore and M. Eidson,
rinter Control",
Control", Application
Application Note available from Motorola
Semiconductor
iconductor Products,
Products. Phoenix,
Phoenix. AZ.
C. Mulder
P. P.
P. Fasang,
Fasang. "A Microprocessor
M. C.
ulder and P.
Microprocessor Controlled
Controlled Substation
Substation Alarm LogLog­
ger", IECI
IECI '78 Proceedings - Industrial
Microprocessors. March
Industrial Applications
Applications of Microprocessors,
20-22.
20-22, 1978, pp. 2-6.
P. J. Zsombar-Murray
al.. "Microprocessor
Based Frequency Response
Response Analyzer".
P.
Zsombar-Murray et al„
icroprocessor Based
Analyzer",
IECI '78 Proceedings - Industrial
20-22.
IECI
Industrial Applications
Applications of Microprocessors.
Microprocessors, March 20-22,
1978, pp. 36-44.
IEEE's Industrial
The Proceedings of the IEEE's
Industrial Electronics and Control Instrumentation
Instrumentation
Group's Annual
Annual Meeting
eeting on "Industrial
"Industrial Applications
Applications of Microprocessors"
Microprocessors" contains
IEEEService
many interesting
interesting articles. Volumes (starting with
ith 1975) are available from IEEE
Center. CP Department.
Hoes Lane,
Lane, Piscataway.
Piscataway, NJ 08854.
Center,
Department, 445 Hoes

12-400

Chapter
Chapter 13
PROBLEM
PROBLEM DEFINITION AND
PROGRAM DESIGN
THE TASKS OF SOFTWARE DEVELOPMENT
chapters. we have concentrated
asIn the previous
previous chapters,
concentrated on the writing
riting of short programs in as­
sembly language. While
hile this is an important
portant topic.
topic, it is only a small part of software
development.
developm
ent Although
Although writing
ritin g assembly language programs is a major task for the
beginner, it soon becomes simple. By now,
now. you should be familiar
iliar with
ith standard
methods for programming
programming in assembly language on the 6502 microprocessor. The
next
next four chapters will
ill describe how to formulate
ulate tasks as programs and how to
combine short programs to form a working
working system.

Softw
are development
development consists of many stages. Figure
Software
13-1 is a flowchart
process. Its
13-1
chart of the software
software development
development process.
stages are:

STAGES OF
SOFTWARE
DEVELOPMENT
DEVELOPMENT

• Problem definition
definition
• Program design
• Coding
• Debugging
Debugging
• Testing
• Documentation
Documentation
• Maintenance
Maintenance and redesign

Each of these stages is important
Each
portant in the construction
construction of a working
working system. Note that
coding.
coding, the writing
ritin g of programs in a form that the computer
puter understands.
understands, is only one of
stages.
seven stages.
fact. coding is usually the easiest
RELATIVE
In fact,
easiest stage to define and perper­
learn.
IMPORTANCE
IMPORTANCE
form. The rules for writing
riting computer
computer programs are easy to learn.
They vary somewhat
somewhat from computer
computer to computer.
computer, but the basic
OF CODING
techniques
same. Few software projects run into troutechniques remain the same.
trou­
indeed. coding
ble because of coding;
coding; indeed,
coding is not the most time-consuming
time-consuming part of software
development.
development. Experts estimate
estimate that a programmer
programmer can write
rite one to ten fully debugged
Clearly. the mere coding
and documented
documented statements
statements per day. Clearly,
coding of one to ten statements
less than 25% of
is hardly a full day's effort. On most software
software projects, coding
coding occupies less
the programmer's
programmer’s time.
Measuring
Measuring progress in the other stages is difficult. You can say
MEASURING
MEASURING
that half of the program has been written.
ritten, but you can hilrdly
hardly say
PROGRESS
PROGRESS
that half of the errors have been removed or half of the problem
IN STAGES
design.
has been defined. Timetables
Timetables for such stages as program design,
debugging, and testing
testing are d iffic
u lt to produce. Many days or weeks of effort
effort may result
debugging.
ifficult
progress. Furthermore,
Furthermore. an incomplete
in no clear progress.
incomplete job in one stage may result in trementremen­
dous problems later.
definition or program design can make
later. For example,
example. poor problem definition
debugging
debugging and testing
testing very difficult.
difficult. Time saved in one stage may be spent many times
stages.
over in later stages.

13-1
13

Start

Problem

Coding

Definition
Definition

Program

Debugging

Design
Design

Design
Design
Evaluation

Testing

No

Yes

No

Documentation
Documentation

Maintenance
Maintenance and
and
redesign
redesign

C*)
End

Figure 13-1. Flowchart
Flowchart of Software
Software Development
Development

13
13-2

DEFINITION
DEFINITION OF THE STAGES
Problem definition is the formulation of the task in terms of
PROBLEM
PROBLEM
example.
DEFINITION
the requirements
requirements that
that it places on the computer. For example,
DEFINITION
tool. run a series
series
what
hat is necessary to make a computer
computer control
control a tool,
of electrical
tests. or handle comm
communications
electrical tests,
unications between
between a central
central controller
controller and a remote
instrument?
determine
instrument? Problem definition
definition requires that
that you determ
ine the forms and rates of inin­
puts and outputs.
needed. and the types of
outputs, the amount
amount and speed of processing that is needed,
possible errors and their
their handling. Problem definition
definition takes a vague idea of building
building a
computer-controlled
tasks and requirements
computer-controlled system and defines the tasks
requirements for the computer.
PROGRAM
Program design is the outline of the computer program which
DESIGN
will
ill perform the tasks that
that have been defined. In the design
stage. the tasks are described
stage,
described in a way that
that can easily be concon­
verted into a program. Among the useful techniques in this stage are flowcharting,
charting,
structured programming,
programming, modular programming,
programming, and top-dow
top-downn design.
design.

com•
Coding is the writing
ritin g of the program in a form that
that the computer can either
either directly understand or translate. The form may
language. assembly language,
language. or a high-level
be machine
machine language,
high-level language.

I

|iCODING
CODING |

I

I

Debugging, also called program
pro·
program verification.
verification, is making the pro| DEBUGGING |
do. In this
gram do what
at the design specified that
that it would do.
stage. you use such tools as breakpoints.
traces. simulators.
analyzers. and in-cirstage,
breakpoints, traces,
simulators, logic analyzers,
cuit
Is hard to define,
define. since you never know
cuit emulators. The end of the debugging
debugging stage is
when you have found
found the last error.
Testing.
Testing, also referred to as program validation.
validation, is ensuring that
|TESTING]
!TESTING!
the program performs the overall system tasks correctly. The
designer
exercisers. and various statistical
designer uses simulators.
simulators, exercisers,
statistical techniques
techniques to measure the
program's
control for hardware.
program's performance. This stage is like quality
quality control

Documentation
program in
in the
the l..
D_O_C_U_M_E_N_T_A_T_I_O_N.,.!
Documentation is
is the
the description
description of
of the
the program
|DOCUMENTATION]
proper form for users and maintenance personnel.
personnel. DocuDocu­
mentation
entation also allows the designer
designer to develop a program library so that subsequent
subsequent
tasks will
ill be far simpler. Flowcharts.
Flowcharts, comments.
comments, memory maps,
maps. and library forms are
some of the tools used in
documentation.
In documentation.
MAINTENANCE
Maintenance and redesign are the servicing, improvement,
Maintenance
MAINTENANCE
AND
and extension
extension of the program.
Clearly. the designer must be
program. Clearly,
REDESIGN
REDESIGN
ready to handle field problems
problems in computer-based
computer-based equipment.
equipment.
Special diagnostic
diagnostic modes or programs and other maintenance
maintenance
tools may be required. Upgrading
Upgrading or extension
extension of the program may be necessary
necessary to
meet new requirements
tasks.
requirements or handle new tasks.
The rest of this chapter
chapter will
ill consider only the problem definition and program
program
design stages. Chapter
Chapter 14 will
ill discuss debugging
debugging and testing.
testing, and Chapter 15 will
ill disdis­
cuss documentation.
documentation, extension.
extension, and redesign. We will
ill bring all the stages together
together in
16.
some simple systems examples in Chapter
Chapter 16.

PROBLEM DEFINITIO
N
DEFINITION
Typical microprocessor
microprocessor tasks require a lot of definition.
definition. For example,
hat must a pro­
Typical
example. what
proscale. a cash register, or a signal generator? Clearly,
Clearly. we have a
gram do to control
control a scale,
long way to go just
just to define
define the tasks involved.

13-33
13

DEFINING THE INPUTS
How do we start
Is with
start the definition?
definition? The obvious place to begin is
ith the inputs. We
should begin by listing all the inputs that
that the computer
computer may receive in this applicaapplica­
tion.
Examples of inputs
inputs are:

• Data blocks from transmission
transmission lines
• Status words from peripherals
• Data from A/0
A/D converters
Then, we may ask the following
ing questions about each input:

FACTORS
IN INPUT
1)
What
is
its
form:
i.e
..
what
signals
will
the
computer
actually
1)
hat
form;
.,
at
ill
puter actually
receive?
2) When
Does
When is the input
input available
available and how does the processor know it is available? Does
the processor have to request the input
input with
ith a strobe signal?Does the input
input provide
its own clock?
3) How long is it available?
4) How often does it change.
change, and how does the processor know that it has changed?
5) Does the input
input consist
consist of a sequence or block of data? Is the order important?
portant?
6) What
hat should be done if the data contains
contains errors? These may include transmission
errors. incorrect
data. sequencing
errors. extra data,
data. etc.
errors,
incorrect data,
sequencing errors,
7) Is the input
input related to other
other inputs
inputs or outputs?
outputs?

DEFINING THE OUTPUTS
The next step to define is the output
that the computer
output. We must list all the outputs that
must produce. Examples of outputs
outputs include:
include;

• Data blocks to transmission
transmission lines
• Control
Control words
words to peripherals
peripherals
• Data to D
0//A converters
converters

ing questions about each output:
Then, we may ask the following
1)
1)

What
.. w
what
computer
W
hat is
is its
its form:
form ; i.e
i.e.,
hat signals
signals must
must the
the com
puter produce?
produce?

2)
When must
must itit be
be available.
available, and
and how
how does
does the
the peripheral
peripheral know
know itit is
is available?
21 When
3)

How
How long
long must
must itit be
be available?
available?

4)

How
the peripheral
peripheral know
know that
that itit has changed?
How often
often must
must itit change.
change, and
and how
how does
does the
changed?
Is there a sequence of outputs?
outputs?

5)
6)

sense and recover from pe­
peWhat
hat should be done to avoid transmission
transmission errors or to sense
ripheral failures?

7)

How is the output
output related to other inputs
inputs and outputs?

13-4
13-4

PROCESSING SECTION
Between the reading of input
input data and the sending of output
output results is the processing
section. Here we must determine
indetermine exactly
exactly how the computer
computer must process the in­
put data. The questions are:
1)
1)

What
hat is the basic procedure
procedure (algorithm) for transforming
transforming input
input
data into output
output results?

2)

rates.
What
hat time constraints
constraints exist? These may include
include data rates,
delay times.
devices. etc.
times, the time constants
constants of input
input and output
output devices,

3)

What
hat memory constraints
constraints exist? Do we have limits
its on the amount
amount of program
memory or data memory.
memory, or on the size of buffers?

4)

What
hat standard
standard programs or tables must be used? What
hat are their requirements?

5)

cases exist.
What
hat special cases
exist, and how should the program handle them?

6)

How accurate
be?
accurate must
must the results be?
How should the program handle processing errors or special conditions
conditions such as
overflow.
overflow, underflow.
underflow, or loss of significance?
significance?

7)

FACTORS IN
PROCESSING

ERROR HANDLING
ERROR
HANDLING
handling of errors.
errors. Clearly,
Clearly. the
An important
important factor
factor in many applications is the handling
designer must make provisions
provisions for recovering
recovering from common errors and for diagnosing
diagnosing
malfunctions.
alfunctions Among the questions that
that the designer must ask at the definition
stage are:
ERROR
ERROR

1)
1)

What
hat errors could occur?

2)

CONSIDERATIONS
CONSIDERATIONS
Which
hich errors are most likely? If a person operates the
system. human error is the most common. Following
system,
Following
human errors,
errors. communications
unications or transmission
transmission errors are more common than
mechanical.
errors.
mechanical, electrical.
electrical, mathematical.
mathematical, or processor errors.

3)

Which
hich errors will
ill not be immediately
immediately obvious to the system? A special problem is
the occurrence
occurrence of errors that
that the system or operator may not recognize as incorrect.

4)

How can the system recover from errors with
ith a minimum
inimum loss
loss of time and data and
yet be aware that
that an error has occurred?
erWhich
hich errors or malfunctions
alfunctions cause the same system behavior? How can these er­
rors or malfunctions
alfunctions be distinguished
distinguished for diagnostic
diagnostic purposes?
example. do parity errors re­
reWhich
hich errors involve special system procedures? For example,
quire retransmission
retransmission of data?

5)
6)

Another question
question is: How can the field technician
technician systematically
systematically find the source of
Another
malfunctions
ithout
programs. special diagnostics.
malfunctions w ith
o u t being an expert? Built-in
Built-in test programs,
diagnostics, or
signature
signature analysis can help.^1

13-5

H UMAN
A N FACTORS
Many microprocessor-based
microprocessor-based systems involve human interaction
interaction.
Human factors must be considered throughout
throughout the developdevelop­
ment process for such systems. Among the questions that
that the
designer must ask are:

OPERATOR
OPERATOR
INTERACTION
INTERACTION

1) W
What input
input procedures
procedures are
are most
most natural
natural for
for the
the human
human operator?
operator?
1)
2) Can
Can the
the operator
operator easily
easily determine
determine how
how toto begin,
begin. continue
continue and
and end
end the
input
the input
operations?
operations?
3)

How is the operator
operator informed
informed of procedural
procedural errors and equipment
equipment malfunctions?
malfunctions?

4)

What
errors is
is the
the operator
operator most
most likely
likely to
W
hat errors
to make?
make?

5) How
How does
does the
the operator
operator know
know that
that data
data has
has been
been entered
enteredcorrectly?
correctly?
5)
Are displays
displays in
in aa form
form that
that the
the operator
operator can
can easily
easily read
read and
and understand?
6) Are
understand?
7) Is
Is the
the response
response of
of the
the system
system adequate
adequate for
71
for the
the operator?
operator?
8)

Is the system easy for the operator
operator to use?7

9)

Are there guiding
guiding features for an inexperienced
inexperienced operator?

10) Are
Are there
there shortcuts
shortcuts and
and reasonable
reasonable options
options for
for the
the experienced
experienced operator?
operator?
10)
11) Can
Canthe
the operator
operator always
always determine
determine or
or reset
reset the
11)
the state
state of
of the
the system
system after
after interrup­
interruptions or distractions?
distractions?
Building
Building a system for people to use is difficult.
difficult. The microprocessor
microprocessor can make the
system more powerful,
powerful. more flexible,
flexible. and more responsive. However,
designer still
However. the designer
must add the human touches that can greatly
greatly increase the usefulness
usefulness and attractiveattractive­
ness of the system and the productivity
productivity of the human operator.22

13-6
13

EXAMPLES
Response
itch
Response to a S witch
Figure 13-2
Figure
13-2 shows a simple system in which the input is
single SPST switch
single LED
from a single
itch and the output is to a single
display. In response to a switch
processor
display.
itch closure, the processor
second. This system should be
turns the display on for one second.
easy to define.

DEFINING
SWITCH
ITCH AND
SYSTEM
LIGHT SYSTEM
SWITCH
ITCH AND
LIGHT INPUT

answer each of the questions
questions
Let us first examine the input and answer
previously
previously presented:
1)

·o· (switch
The input
input is a single bit. which
hich may be either
either 'O'
(switch closed) orr '1' (switch
open)
open).

2)

The input
input is always available
available and need not be requested.

3)

The input
input is available
available for at least several milliseconds
milliseconds after
after the closure.

4)

The input
input will
ill seldom change
change more than once every few seconds. The processor
has to handle only the bounce in the switch.
switch. The processor must monitor
monitor the
closed.
switch
itch to determine
determine when
when it is closed.

5)

There is no sequence of inputs.

6)

The obvious
obvious input
input errors are switch
switch failure.
failure, failure
failure in the input
input cIrcuItry.
circuitry, and the
operator
attempting
operator attem
pting to close the switch
switch again before a sufficient
sufficient amount
amount of time
has elapsed. We will
ill discuss the handling
handling of these errors later.
later.

7)

The input
input does not depend on any other inputs
inputs or outputs.
outputs.

The next
next requirement
requirement in defining the system is to examine the
output. The answers to our questions
questions are:
1) The output
·o·to turn the display
on.
1)
output is a single bit. which
which is '0'
display on,
'1' to turn it off.

SWITCH
SWITCH
AND LIGHT
OUTPUTS

2)

There are no time constraints
constraints on the output.
output. The peripheral
peripheral does not need to be inin­
formed of the availability
availability of data.

3)

If the display
display is an LED,
available for only a few milliseconds
milliseconds at a
LED. the data need be available
pulse rate of about
about 100 times per second. The observer will
ill see a continuously
continuously lit
display.
The data must
must change
change (go off) after
after one second.

4)
5)
6)

There is no sequence of outputs.
The possible output
output errors are display
display failure
failure and failure
failure in the output
output circuitry.
circuitry.

7)

The output
output depends only on the switch
switch input
input and time.

The processing
ely simple. As soon
itch input becomes
processing section is extrem
extremely
soon as the switch
a logic '0',
second. No time or memo'O’, the CPU turns the light on (a logic '0')
'O') for one second.
memo­
ry constraints
constraints exist.

Let us now look at the possible
possible errors
errors and malfunctions. These
are:
• Another
Another switch
switch closure
closure before one second has elapsed

SWITCH AND
ERROR
LIGHT ERROR
HANDLING
HANDLING

• Switch
Switch failure
• Display failure

• Computer
puter failure
failure
Surely the first
igfirst error is the most likely. The simplest
simplest solution
solution is for the processor to ig­
nore switch
itch closures until
until one second has elapsed. This brief
brief unresponsive
unresponsive period will
ill
hardly be noticeable
noticeable to the human operator. Furthermore,
Furthermore, ignoring
ignoring the switch
switch during
during
this period means that
that no debouncing
debouncing circuitry
circuitry or software
software is necessary, since the
system will
ill not react to the bounce
bounce anyway.

13-77
13

Input

Port

+5V

CPU

Output

Port

·o·

input is a '1'
open, 'O' if the
The switch input
*1* if the switch is open,
switch is closed.
closed. The CPU
CPU applies
applies the output to the
switch
LEO; a '0'
·o·lights
lights the display.
display.
cathode of the LED;

Figure 13-2. The Switch
Switch and Light
Light System
Clearly, the last three failures
failures can produce
produce unpredictable
unpredictable results. The display
display may stay
on, stay off, or change state randomly.
on.
randomly. Some possible ways to isolate the failures
failures would
would
be:

i.e., a button
• Lamp-test
Lamp-test hardware
hardware to check the display;
display; i.e.,
button that
that turns the light
light on in-­
dependently
dependently of the processor
• A direct
direct connection
connection to the switch
switch to check its operation
operation
• A diagnostic
diagnostic program
program that
that exercises the input
input and output
output circuits
circuits
If both the display
display and switch
switch are working,
working, the computer
puter is at fault. A field technician
technician
with
ith proper equipment
equipment can determine
determine the cause of the failure.

13-8
13

A Sw itch-B
ased M emory
ory Loader
itch-Based
Loader
DEFINING A
Figure
Figure 13-3
13-3 shows a system that allows the user to enter
enter
data into any memory location in a microcomputer.
SWITCH-BASED
ITCH-BASED
microcomputer. One in­
inLOADER
M EMORY
O RY LOADER
put port, DPORT, reads data from eight toggle switches.
inforThe other input port, CPORT, is used to read control infor­
mation. There are three momentary switches:
mation.
itches: High Address, Low Address and
Data. The output is the value of the last completed entry from the data switches:
switches;
eight LEDs are used for the display.
display.
also. of course, require various resistors, buffers,
buffers. and drivers.
The system will
ill also,

We shall first examine the inputs.
inputs. The characteristics
switches are the same as
characteristics of the switches
however. here there is a distin
distinct
in the previous
previous example:
example; however,
ct sequence of inputs.
inputs, as
follows:
follows:
1)
1)

The operator
operator must set the data switches
switches according
according to the eight
eight most significant
significant
bits of an address,
address, then

2)

press the High Address button.
button. The high address bits will
ill appear on the lights, and
the program will
address.
ill interpret
interpret the data as the high byte of the address.
3) Then the operator must set the data switches
switches with
ith the value of the least significant
significant
byte of the address and
4) press the Low Address button. The low address bits will
ill appear on the lights, and
the program will
ill consider
consider the data to be the low byte of the address.
address.
5) Finally, the operator must set the desired data into the data switches
switches and
6) press the Data button.
button. The display
display will
ill now show the data, and the program stores
the data in memory at the previously
previously entered address.
address.
The operator may repeat the process to enter an entire program. Clearly, even in this
simplified
plified situation,
situation, we will
ill have many possible sequences to consider. How do we
cope with
ith erroneous sequences and make the system easy to use?7

Output is no problem.
problem. Afterr each input, the program
program sends
sends to the displays
displays the
active-low) of the input bits. The output
output data
complement (since
(since the displays
displays are active-low)
remains the same until
until the next input
input operation.
con­
The processing
processing section remains quite simple.
simple. There are no time or memory constraints. The program can debounce
debounce the switches
switches by waiting
aiting foraa few milliseconds.
milliseconds, and
must provide
provide complemented
complemented data to the displays.

errors are operator mistakes. These include
include:
The most likely errors
• Incorrect
Incorrect entries
• Incorrect
Incorrect order

M EMORY
ORY
LOADER
LOADER
ERROR
ERROR
HANDLING

• Incomplete
Incomplete entries; for example, forgetting
forgetting the data
The system must be able to handle these problems in a reasonable way, since they are
certain to occur
occur in actual
actual operation.
certain

The designer must also consider the effects
before,
effects of equipment failure. Just as before,
ifficulties are:
the possible difficulties
are:
• Switch
Switch failure
failure
• Display failure
• Computer
Computer failure

13-9
13

Input

Poet
DPORT

Data
Bus

J_
Input
CPU

J_

High Address

Low Address

Port

CPORT

J_

Data

+SV

Output
Port

Switch-Based Memory
Memory Loader
Figure 13-3. The Switch-Based

13-10

system. however,
however. we must pay more attention
In this system,
attention to how these failures
failures affect
affect the
system.
system. A computer
puter failure
failure will
ill presumably
presumably cause very unusual
unusual behavior
behavior by the system,
and will
ill be easy to detect. A display failure may not be immediately
mediately noticeable:
noticeable; here a
Lamp Test feature
feature will
ill allow
allow the operator
operator to check the operation. Note that we would
LED separately,
separately. in order to diagnose the case in which
like to test each LED
hich output
output lines are
failure:
shorted together.
together. In addition.
addition, the operator may not immediately
mediately detect
detect switch
switch failure;
however.
however, the operator
operator should soon notice it and establish which
which switch
itch is faulty
faulty by a
process of elimination.
elimination.
errors. Typical
Let us look at some of the possible operator errors.
Typical errors
will
ill be:
• Erroneous data
• Wrong
rong order of entries or switches
switches

OPERATOR
ERROR
ERROR
CORRECTION
IN MEMORY
MEMORY
LOADER

ithout
• Trying
Trying to go on to the next entry w ith
o u t completing
pleting the current
current
one
The operator
operator will
ill presumably
presumably notice erroneous data as soon as it appears on the disdis­
plays. What
plays.
h a t is a viable recovery procedure for the operator? Some of the options
options are:

1)
1)

The operator
operator must complete
complete the entry procedure;
procedure: i.e.,.. enter
enter Low Address and Data
if the error occurs in the High Address. Clearly,
Clearly. this procedure
procedure is wasteful
wasteful and
would
would only serve to annoy the operator.

2)

The operator
operator may restart the entry process by returning
returning to the high address entry
steps. This solution
1f the error was in the High Address,
Address. but forces the
steps.
solution is useful if
operator
stage.
operator to re-enter earlier data if the error was in the Low Address or Data stage.

3)

The operator
operator may enter
enter any part of the sequence at any time simply
simply by setting
setting the
Data switches
switches with
ith the desired data and pressing the corresponding
corresponding button.
button. This
procedure
sequence.
procedure allows the operator to make corrections
corrections at any point
point in the sequence.

This type of procedure
procedure should always be preferred over one that does not allow immediimmedi­
steps. or enters data into the system
ate error correction.
correction, has a variety
variety of concluding
concluding steps,
w ith
o u t allowing
allowing the operator
operator a final check. Any added complication
plication in hardware or
ithout
software will
ill be justified
justified in increased operator efficiency.
efficiency. You should always prefer to
software
puter do the tedious work and recognize arbitrary
arbitrary sequences; it never
let the m icrocom
icrocomputer
gets tired and never forgets what
what was in the operating
operating manual.
A further
further helpful
helpful feature would
would be status lights
lights that would
would define the meaning of the
display. Three status lights.
lights, marked "High
igh Address",
Address", "Low
o w Address".
Address", and "Data".
"Data",
would let the operator know what
hat had been entered w ith
o u t having to remember which
which
would
ithout
button
pressed. The processor would
sequence. but the added
button was pressed.
would have to monitor
onitor the sequence,
complication
plication in software
software would
would simplify
plify the operator's
operator's task.
task. Clearly,
Clearly. three separate sets
sets
of displays plus the ability
ability to examine a memory location
location would
would be even more helpful
helpful to
the operator.

We should note that, although we have emphasized
emphasized human interaction,
interaction, machine
We
interaction has many of the same characteristics.
characteristics. The microprocessor
or system interaction
should do the work. If complicating the microprocessor's task makes error recovrecov­
ery simple and the causes of failure obvious, the entire system will
ill work
ork better
better
and be easier
easier to maintain. Note that you should not waitit until
until after
after the software
software has
been completed
completed to consider
consider system use and maintenance:
maintenance: instead,
instead. you should include
stage.
these factors in the problem definition
definition stage.

13-11

A Verification
Verification Terminal
Figure 13-4
13-4 is a block diagram of a simple credit-verification
credit-verification
DEFINING A
terminal. One input port derives data from a keyboard (see
VERI Fl
FICATION
Figure 13-6);
13-5); the other input port accepts verification
verification data
TERMINAL
TERMINAL
from a transmission line. One output port sends data to a set of
Figure 13-6);
displays (see Figure
13-6); another sends the credit card number to the central
computer. A third output port turns on one light whenever
whenever the terminal is ready to
accept an inquiry, and another light when the operator sends the information. The
response returns. Clearly, the input
"B usy"
s y " light turns off when
when the response
input and output
output of
case. although
data will
ill be more complex
complex than in
In the previous case,
although the processing is still
simple.
Additional
response. Many terAdditional displays may be useful to emphasize the meaning of the response.
ter­
minals use a green light
light for "No",
yellow light
light for "Consult
"Consult
light for "Yes",
"Yes", a red light
o", and a yellow
Store Manager."
Manager." Note that
that these lights
lights will
ill still have to be clearly marked with
ith their
meanings to allow
allow for a color-blind
color-blind operator.

Let us first look at the keyboard input. This is.
is. of course,
course,
different from the switch
CPU must have some
different
switch input.
input, since the CPU
way of distinguishing
distinguishing new data. We will
ill assume that
that each key

VERIFICATION
VERIFICATION
TERMINAL
TERMINAL
INPUTS

closure provides a unique
unique hexadecimal
code
closure
hexadecimal code (we can code
each of the 12 keys into one digit) and a strobe. The program will
ill have to recognrecogn­
ize the strobe and fetch the hexadecimal number that
that identifies
identifies the key. There is a
time constraint.
constraint, since the program cannot
cannot miss any data or strobes. The constraint
constraint is
not serious,
serious. since keyboard entries will
ill be at least several milliseconds
milliseconds apart.
transmission input similarly consists of a series of characters, each identified
The transmission
(perhaps from a UART). The program
program will
by a strobe (perhaps
ill have to recognize each
strobe and fetch the character. The data being sent across the transmission lines
messages. A possible message format
is:
is usually organized into messages.
at is:
• Introductory
Introductory characters, or header
• Terminal
Terminal destination
destination address
• Coded yes or no
• Ending characters.
characters, or trailer

header. read the destination
address, and see if the
The terminal
terminal will
ill check the header,
destination address,
message is intended
intended for it. If the message
terminal, the terminal
terminal accepts the
message is for the terminal.
is) hard-wired
data. The address could be (and often is)
hard-wired into the terminal
terminal so that
that the terter­
intended for it. This approach simplifies
plifies the software at
minal receives only messages
messages intended
the cost of some flexibility.
flexibility.

The output is also more complex than in the earlier examples.
VERIFICATION
VERIFICATION
If the displays are multiplexed,
ultiplexed, the processor must not only
TERMINAL
TERMINAL
send the data to the display port but must also direct the data
OUTPUTS
to a particular display. We will
ill need either
either a separate control
control port
or a counter
counter and decoder
decoder to handle this. Note that hardware blanking
blanking controls
controls can
blank leading zeros
zeros as long as the first
ulti-digit
zero. Softfirst digitit in a m ulti-d
ig it number
number is never zero.
Soft­
ware can also handle this task.
task. Time constraints
constraints include
include the pulse length and frequency
frequency
continuous display
display for the operator.
required to produce a continuous
The communications output will
ill consist of a series of characters with
ith a particular
format. The program will
characill also have to consider the time required between
between charac­
output message is:
is:
ters. A possible format
format for the output
• Header
• Terminal
Terminal address
• Credit card number
number

• Trailer

13-12
13-

Keyboard
Input Port

Display

Display

Output Portis)

XMIT

CPU

Output Port

To Central Computer

RCV
Input Port

Status Light
Output Port

From Central Computer

t----t~

BUSY [>;splay

t----t~

READY Display

Figure 13-4. Block Diagram of a Verification
Verification Terminal
Terminal

The digit
digit keys allow digit
digit entries.
CLEAR
entire entry.
CLEAR deletes the entire
SEND transmits
transmits the entry to the central computer.
computer.

Figure 13-5. Verification
Verification Terminal
Terminal Keyboard

13-13
13-13

READY
READY

BUSY
BUSY

□
□

□
□

i ~ i O i— i 1— i i ~ i i ~ i i ~ i ' ~ i i ~ i
/_ / /_ / i_/ /____ / /_ / /_ / O i— i i ~ i i ~ l

The display consists
consists of ten 7-segm
7-segment
displays, which may be multiplexed, controlled by
by a shift
ent displays,
register, or addressed
addressed separately.
separately. Two additional lights, READY and
and BUSY, are also
also present.
present.
register,

Figure 13-6. Verification
Verification Terminal
Terminal Display

A central communications computer
computer may poll the terminals, checking for data
ready to be sent.
as:
The processing
processing in this system involves many new tasks, such as:
• Identifying
Identifying the control
control keys by number
number and performing
performing the proper actions
Adding the header,
terminal address,
outgoing message
• Adding
header, terminal
address, and trailer to the outgoing
message
• Recognizing the header and trailer
message
trailer in the returning
returning message
Checking the incoming
incoming terminal
terminal address
• Checking
arithmetic
Note that none of the tasks involve
involve any complex
complex arithm
etic or any
serious time or memory constraints.
constraints.

The number of possible errors in this system is,
is, of course,
course,
much larger than in the earlier
earlier examples. Let us first consider
the possible
possible operator errors.
errors. These include:
include:

VERIFICATION
VERIFICATION
TERMINAL
TERMINAL
ERROR
ERROR
HANDLING
HANDLING

credit card number
number incorrectly
incorrectly
• Entering the credit
• Trying
Trying to send an incomplete
incomplete credit
credit card number
Trying to send another
another number
number while
hile the central computer
puter is processing one
• Trying
• Clearing non-existent
non-existent entries
Some of these errors can be easily handled by correctly
correctly structuring
structuring the program. For ex­
example, the program should not accept
has
accept the Send key until
until the credit
credit card number
number has
been completely
additional keyboard entries until
until the
completely entered, and it should ignore any additional
response comes back from the central
central computer.
computer. Note that the operator
operator will
ill know that
on. The operator
the entry has not been sent, since the Busy light
light will
ill not go on.
operator will
ill also
know when the keyboard has been locked out (the program is ignoring keyboard en­
entries),
ill not appear on the display and the Ready
ill be off.
tries). since entries will
Ready light
light will
off.

13-14
13
14

Incorrect
Incorrect entries
entries are an obvious
obvious problem.
problem. If the operator
operator recogrecog­
CORRECTING
KEYBOARD
nizes an error,
error. he can use the Clear key to make corrections.
corrections. The
ERRORS
operator
ERRORS
operator would
ould probably
probably find it more convenient
convenient to have twoo Clear
keys. one that
keys,
that cleared the most
most recent
recent key and one that
that cleared
the entire
entire entry. This would
would allow
allow both for the situation
situation in which
which the operator
operator recogrecog­
nizes the error immediately
immediately and for the situation
situation in which
hich the operator
operator recognizes the
error late in the procedure.
procedure. The operator
operator should
should be able to correct
correct errors immediately
immediately
and have to repeat
repeat as few keys as possible. The operator
operator will.
ill, however.
however, make a certain
certain
number
ithout
number of errors w ith
o u t recognizing
recognizing them. Most
Most credit
credit card numbers
numbers include
include a selfself­
checking
permitting
1t to be sent to
checking digit;
digit; the terminal
terminal could
could check the number
number before perm
itting it
the central
central computer.
computer. This step would
would save the central
central computer
puter from wasting
wasting precious
precious
processing
processing time checking
checking the number.
This requires,
requires. however.
informing
however, that
that the terminal
terminal have some way
way of inform
ing the operator
operator of
error. perhaps
the error,
perhaps by flashing
flashing one of the displays
displays or by providing
providing some other
other special
special inin­
dicator
dicator that
that the operator
operator is sure to notice.
Still
Still another
another problem
problem is how the operator
operator knows
knows that
that an entry
entry has been lost or propro­
cessed incorrectly.
incorrectly. Some terminals
terminals simply
simply unlock
unlock after
after a maximum
maximum time delay. The
operator
ithout
operator notes that
that the Busy light
light has gone off w ith
o u t an answer
answer being received. The
operator
retries. the operator
operator is then expected
expected to try the entry
entry again. After
fter one or two retries,
operator
should report
report the failure
failure to supervisory
supervisory personnel.

Many
and
Many equipment
equipment failures are also possible. Besides the displays, keyboard, ancf
processor, there now exist
processor,
exist the problems of communications errors or failures anc*
central
central computer
computer failures.
The data transmission
transmission will
ill probably
probably have to include
include error checking
checking and correcting
correcting propro­
cedures. Some possibilities
possibilities are:

CORRECTING
TRANSMISSION
TRANSMISSION
ERRORS
ERRORS

1)
1)

Parity provides
provides an error detectton
detection facility
facility but
but no correction
correction
mechanism.
mechanism. The receiver
receiver will
ill need some way of requestrequest­
ing retransmission.
retransmission, and the sender will
ill have to save a copy
of the data until
until proper
proper reception
reception is acknowledged.
acknowledged. Parity
is. however.
is,
however, very simple
simple to implement.
implement.

2)

Short
Short messages may use more elaborate
elaborate schemes. For example.
example, the yes/no
yes/no
response to the terminal
inal could be coded so as to provide
provide error detection
detection and corcor­
rection
rection capability.
capability.
acknowledgement and a limited
limited number
number of retries could trigger
trigger an indicator
indicator
An acknowledgement
that
that would
would inform
inform the operator
operator of a communications
communications failure
failure (inability
(inability to-transfer
to-transfer a
message w ith
ithout
computer
o u t errors) or central
central com
puter failure
failure (no response at all to the
message within
ith in a certain
certain period of time). Such a scheme.
scheme, along with
ith the Lamp
Test, would
ould allow
allow simple
simple failure
failure diagnosis.

3)

communications
A comm
unications or central
central computer
puter failure
failure indicator
indicator should
should also "unlock"
nlock” the terter­
minal.
minal, i.e.,.. allow
allow it to accept
accept another
another entry. This is necessary if the terminal
terminal will
ill not acac­
cept entries
entries while
hile a verification
verification is in progress. The terminal
terminal may also unlock
unlock after
after acercer­
tain maximum
aximum time delay. Certain
Certain entries
entries could
could be reserved for diagnostics:
diagnostics; 1e.
i.e., certain
credit
credit card numbers
numbers could
could be used to check the internal
internal operation
operation of the terminal
terminal and
test the displays.

13-15
13
15

OF PROBLEM DEFINITION
REVIEW OF
Problem
Important
software
Problem definition
definition is as im
portant a part of softw
are development
development as it is of any
other engineering
engineering task.
other
task. Note that
that it does not
not require
require any programming
programming or
knowledge
knowledge of the
the computer;
computer; rather,
rather, it is based on an understanding
understanding of the system
system
and sound engineering
engineering judgment.
judgment. Microprocessors
Microprocessors can offer
offer fle x
ib ility that
that the
xibility
designer
designer can use to provide
provide a range of features
features which
which were
were not prevlously
previously availaavaila­
ble.
Problem
Problem definition
definition is independent
independent of any particular
particular computer,
computer, computer
computer language,
language,
or development
development system.
system. It should,
should, however,
however, provide
provide guidelines
guidelines as to what
h at type
type or
speed of computer
computer the application
application willill require
require and what
h at kind of hardhard­
ware/software
ware/softw
are trade-offs
trade-offs the designer
designer can make. The problem
problem definition
definition stage is
in fact
fact independent
independent of whether
hether or not a computer
computer is used at all, although
although a
knowledge
knowledge of the capabilities
capabilities of the computer
computer can help the designer
designer in suggesting
suggesting
possible
possible implementations
implementations of procedures.
procedures.

13-166
13-

PROGRAM DESIGN
Program design is the stage in which
Program
hich the problem definition is formulated as a propro­
gram. If the program is small and simple, this stage may involve little more than
gram.
program is larger or more complex, the
the writingg of a one-page flowchart.
chart. If the program
designer should consider more elaborate methods
We
discuss flowcharting,
programming, structured programming,
programming, and
We will
ill discuss
charting, modular programming,
top-down
design. We will
top-down design.
ill try to indicate the reasoning behind these methods, and
not. however.
their advantages and disadvantages. We will
ill not,
however, advocate
advocate any particular
particular
method since there is no evidence
evidence that
that one method
method is always
always superior
superior to all others. You
should remember
system. not to follow
remember that
that the goal is to produce
produce a good working
orking system,
follow
religiously
religiously the tenets
tenets of one methodology
methodology or another.
do. however,
however. have some obvious
princiAll the methodologies do,
obvious princi­
common. Many of these are the same principles
ples in common.
principles that
that apply
to any kind of design.
design, such as:
1)
1)

Proceed in small steps. Do not try to do too much at one
time.

BASIC
PRINCIPLES
PRINCIPLES
OF PROGRAM
DESIGN

Divide large
large jobs
jobs into
into small,
small. logically
logically separate
separate tasks.
tasks. Make
Make the
the sub-tasks
sub-tasks as
as inde­
inde2) Divide
pendent
possible. so that
pendent of one another
another as possible,
that they can be tested separately
separately and so
that changes
ithout
changes can be made in one w ith
o u t affecting
affecting the others.
Keepthe
the flow
flow of
of control
control as
assimple
simple as
aspossible
possible so
soas
asto
to make
make itit easier
easier to
to find
find errors.
errors.
3) Keep
Use pictorial
pictorial or
or graphic
graphic descriptions
descriptions as
as much
much as
as possible.
possible. They
They are
are easier
easier to
to
4) Use
visualize than word descriptions.
Is the great advantage
descriptions. This is
advantage of flowcharts.
flowcharts.
Emphasize clarity
clarity and
and sim
s1mplic1ty
at first.
first You
You can
can improve
improve performance
performance (if
(if neces­
neces5) Emphasize
plicity at
sary) once the system is
Is working.
sary)
working.
Proceed in
in aa thorough
thorough and
and systematic
systematic manner.
manner. Use
Use checklists
checklists and
and standard
standard pro­
pro6) Proceed
cedures.
Do not
not tem
tempt fate.
fate. Either
Either do
do not
not use
use methods
methods that
that you
you are
are not
not sure
sure of,
of. or
or use
use them
them
7) Do
very carefully.
carefully. Watch
atch for situations
situations that
that might
ight cause confusion.
confusion, and clarify
clarify them
as soon as possible.
Keep in
in mind
mind that
that the
the system
system must
must be
be debugged,
debugged. tested
tested and
and maintained.
maintained. Plan
Plan for
for
8) Keep
these later stages.
Usesimple
simple and
and consistent
consistent term
terminology
and methods.
methods. Repetitiveness
Repetitiveness isis no
no fault
fault in
in
9) Use
inology and
program design.
design, nor is complexity
plexity a virtue.
Have your
your design
design completely
completely formulated
formulated before
before you
you start
start coding.
coding. Resist
Resist the
the
10) Have
temptation
temptation to start writing
riting down
down instructions:
instructions: it makes no more sense than makmak­
ing parts lists or laying out circuit
circuit boards before you know exactly
exactly what
what will
ill be in
the system.
11) Be
Beparticularly
particularly careful
careful of
of factors
factors that
that may
may change.
change. Make
Make the
the implementation
implementation ofof
11)
likely changes
possible.
changes as simple
simple as possible.

1 3-17
17

FLOWCHARTING
CHARTING
Flowcharting
Flowcharting is certainly
certainly the best-known
best-known of all program
program design
design methods. Programming
Programming
textbooks
textbooks describe
describe how programmers
programmers first
first write
write complete
complete flowcharts
flowcharts and then start
fact. few programmers
writing
riting the actual
actual program.
program. In fact,
programmers have ever worked
worked this way,
way. and
flowcharting
flow
charting has often been more of a joke or a nuisance to programmers
programmers than a design
method. We will
ill try to describe
describe both the advantages
advantages and disadvantages
disadvantages of flowcharts.
flowcharts,
and show the place of this technique
technique in program
program design.

ADVANTAGES
ADVANTAGES OF
The basic advantage of the flowchart
chart is that
that it is a pictorial
representation.
FLOWCHARTING
FLOWCHARTING
representation. People find such representations
representations much more
meaningful
meaningful than written
ritten descriptions.
descriptions. The designer
designer can visualvisual­
ize the whole
whole system and see the relationships
relationships of the various
various parts. Logical
Logical errors and
inconsistencies
best.
inconsistencies often stand out instead of being hidden
hidden in a printed
printed page. At its best,
the flowchart
cha rt is a picture of the entire system.
more specific advantages
Some of the more
advantages of flowcharts
charts are:
1)
1)
2)
3)
4)

Standard
(see Figure 13-7) so that
Standard symbols
symbols exist (see
that flowcharting
charting forms are widely
widely
recognized.
Flowcharts can
can be
be understood
understood by
by someone
someone w ith
without
programming background.
background.
Flowcharts
u t aa programming
Flowcharts can
can be
be used
used to
to divide
divide the
the entire
entire project
project into
into sub-tasks.
sub-tasks. The
The flowchart
flowchart
Flowcharts
can then be examined
examined to measure overall progress.
Flowcharts
Flowcharts show the sequence
sequence of operations
operations and can therefore
therefore aid in locating
locating the
source of errors.
Flowcharting isis widely
widely used
used in
in other
other areas
areas besides
besides programming.
programming.
Flowcharting

5)
6) There
There are
are many
many tools
tools available
available to
to aid
aid in
in flowcharting,
flowcharting. including
including programmer's
programmer's
templates
templates and automated
automated drawing
drawing packages.

portant.
These advantages
advantages are all im p
orta n t There is no question
question that
flowcharting
charting will
ill continue
continue to be widely
widely used. But we should
should

pronote some of the disadvantages
disadvantages of flowcharting
charting as a pro­
gram design method, e.g.:

DISADVANTAGES
DISADVANTAGES
OF
FLOWCHARTING
FLOWCHARTING

1) Flowcharts
Flowcharts are
are ddifficult
to design,
design. draw,
draw. or
or change
change in
in all
all except
except the
the simplest
simplest situ
a1)
ifficu lt to
situa­
tions.
There is
is no
no easy
easy way
way to
to debug
debug or
or test
test aa flowchart.
flowchart.
2) There
3) Flowcharts
Flowcharts tend
tend to
to become
3)
ifficu lt to
become cluttered.
cluttered. Designers
Designers find
find itit ddifficult
to balance
balance between
between
the amount
amount of detail
detail needed to make the flowchart
chart useful
useful and the amount
amount that
makes the flowchart
chart little
little better
better than a program
program listing.
listing.
4)

Flowcharts show
show only
only the
the program
program organization.
organization. They
They do
Flowcharts
do not
not show
show the
the organization
organization
of the data or the structure
structure of the in p u
t/o u tp u t modules.
put/output

Flowcharts do
do not
not help
help w
with hardware
5) Flowcharts
ing problems
where
hardware or
or tim
timing
problems or give hints as to where
these problems
problems might
ight occur.
Flowcharts allow
allow for
for highly
highly unstructured
design. Lines
6) Flowcharts
unstructured design.
Lines and
and arrows
arrows backtracking
backtracking
and looping
looping all over the chart are the antithesis
antithesis of good structured
structured design
design principrinci­
ples.
ples.
Thus. flowcharting
Thus,
charting is a helpful technique that
that you should
should not try to extend too far.
far.

Flowcharts
Flowcharts are useful as program documentation.
documentation, since they have standard forms
and are comprehensible to non-programmers. As a design
design tool,
however, flowcharts
flowcharts
tool. however,
cannot
cannot provide
provide much more than a starting
starting outline:
outline; the programmer cannot debug a
detailed
detailed flowchart
chart and the flowchart
flowchart is often more difficult
ifficu lt to design than the program
itself.

13-18
18

^7
D
D

<>

0

Input/Output
Input/O
utput

operation
Processing operation
(Arithmetic, Logic.
Logic, Data
(Arithmetic,
Movement)
Movement)

Decision Logic

Subroutine
Subroutine

0

Connector point
point
Connector

Connector arrows
Connector

c

)

Terminal point
point
Terminal
(Beginning
(Beginning or Ending)

Standard Flowchart
Flowchart Symbols
Symbols
Figure 13-7. Standard

1 3-19
9

EXAMPLES

Response to a Switch
Response
This simple task, in which a single switch
itch turns on a light
second, is easy to flowchart.
for one second,
chart. In fact.
fact, such tasks are
typical
typical examples
examples for flowcharting
charting books, although
although they form a
small part of most systems. The data structure
structure here is so simple
that it can be safely ignored.
that

FLOWCHARTING
FLOWCHARTING
SWITCH
SWITCH AND
LIGHT SYSTEM

ifficulty
Figure 13-8
Figure
13-8 is the flowchart.
chart. There is little
little d ifficu
lty in deciding
deciding on the amount
amount of
detail required. The flowchart
chart gives a straightforward
straightforward picture
picture of the procedure, which
which
anyone could
Id understand.
understand.
Note that
that the most useful flowcharts
flowcharts may ignore program
program variables and ask questions
questions
directly.
here. Two
directly. Of course, compromises
compromises are often necessary here.
Two versions of the

language,
flowchart
chart are sometimes helpful -— one general version in layman's language,
non-programmers, and one programmer's version in terms
which will
ill be useful to non-programmers,
programmers.
of the program variables, which will
ill be useful to other programmers.

-------.

A third type of flowchart,
chart, a data flowchart,
chart, may also be
DATA
FLOWCHARTS
helpful. This flowchart
chart serves as a cross-reference
cross-reference for the other
flowcharts.
flowcharts, since it shows how the program handles a particular
particular
type of data. Ordinary
Ordinary flowcharts
flowcharts show how the program proceeds, handling
handling different
different
types of data at different
different points. Data flowcharts.
flowcharts, on the other hand, show how particuparticu­
lar types of data move through
through the system, passing from one part of the program to
another. Such flowcharts
flowcharts are very useful in debugging
debugging and maintenance.
maintenance, since errors
most often show up as a particular
particular type of data being handled incorrectly.
incorrectly.

13-20
13
20

Tum light on

Tum light off

End

Figure 13-8. Flowchart
Flowchart of One-Second Response
Switch
Response to a Switch

13-21

The Sw itch-Based
ased M emory
ory Loader
Loader
(see Figure 13-3) is considerably
This system (see
considerably more complex
example·. and involves many more decisions.
than the previous example,

Figure 13-9) is more
more d ifficult to write
The flowchart
rt (see Figure
and is not as straightforward as the previous
previous example. In
example. we face the problem that there is no way to
this example,
debug or test the flowchart.
flowchart.

FLOWCHARTING
THE
SWITCH-BASED
SWITCH-BASED
MEMORY
LOADER
MEMORY LOADER

The flowchart
chart in Figure 13-9 includes the improvements
improvements we suggested as part of the
problem definition.
definition. Clearly,
Clearly. this flowchart
beginning to get cluttered and lose
cha rt is beginning
lose its
description. Adding
meanadvantages over a writtenn description.
Adding other features that define the mean­
ing of the entry with
ith status lights and allow the operator to check entries after complecomple­
tion would
would make the flowchart
chart even more complex. Writing
ritin g the complete
complete flowchart
flowchart
from scratch could quickly
task. However,
However. once the program has
quickly become a formidable
idable task.
has
been written.
ritten, the flowchart
chart is useful as documentation.
documentation.

13-222
13

Su1rt

High byte of

Low byte of

Address==
Address

Address =

Switches

Switches

*

♦

= Switches
Ughts =
Lights

Lights = Switches
Lights

♦

*

Wait

Wait
ait

debounce
debounce

debounce
debounce

time

time
time

Data =- Switches

Lights = Switches
lights

♦
Store Data
Store
Address
at Address

Wait

debounce
time
No

No

WMI

dlbounce
time

Figure 13-9. Flowchart
Flowchart of Switch-Based
Switch-Based Memory
Memory Loader

13-23
13-

The Credit-Verification
redit-Verification Terminal

«

(see Figures 13-4 through
In this application (see
through 13-6),
13-6), the
flowchart
chart will
ill be even more complex
complex than in the switch-based
switch-based
memory loader case.
case. Here,
Here. the best idea
rt sec­
Idea is
Is to flowchart
sections separately so that
that the flowcharts
charts remain manageable.
manageable.
However. the presence of data structures
(as in the m ulti-d
ulti-digit
However,
structures (as
ig it
display
messages) will
display and the messages)
ill make the gap between
flowchart
chart and program much wider.

FLOWCHARTING
THE CREDIT
VERIFICATION
FLOWCHARTING
SECTIONS

Figure 13-10
Let us look at some of the sections. Figure
13-10 shows the keyboard entry process
process
for the digit keys. The program must fetch
fetch the data after each strobe and place the
digit
ig it into the display
display array if there is room for it. If there are already ten digits
digits in the ar­
array. the program simply
ray,
simply ignores the entry.
The actual program will
ill have to handle the displays at the same time. Note that either
software
software or hardware must de-activate
de-activate the keyboard strobe after the processor reads
reads a
digit.

Start

Clear Entry Array
Key Pointer = Stan
of Entry Array
Key Counter = 0

Key = Keyboard

Input Data
(Key Pointer) = Kev

=

Key Pointer
Key Pointer + 1
Kev Counter =
Key Counter -+ 1

End

Figure 13-10. Flowchart
Flowchart of Keyboard Entry Process
Process

13-24
13-24

Start

Oear DisptayArray
Key Pointer= Start
of DisplayArrav
Kev Counter= 0

Key

= Keyboard

Input Data

Send

Process with Send Key
Figure 13-11. Flowchart
Flowchart of Keyboard Entry Process
Key
Figure 13-11
Figure
13-11 adds the Send key. This key,
terminal could
key. of course,
course. is optional. The terminal
just send the data as soon as the operator enters a complete
complete number. However,
However. that
procedure would
would not give the operator a chance to check the entire entry. The
flowchart
chart with
ith the Send key is more complex because there are two alternatives.
1)
1)

If the operator
operator has not entered ten digits.
digits, the program must ignore the Send key
and place any other key into the entry.

2)

If the operator
operator has entered ten digits.
digits, the program must respond to the Send key by
transferring
transferring control
control to the Send routine.
routine, and ignore all other keys.
keys.

Note that the flowchart
chart has become much more difficult
ifficu lt to organize and to follow.
There is also no obvious way to check the flowchart.
flowchart.

13-25
13-

Stan

Clear Disptay Array
Key Pointer = Stan
of OtsplayArray
Key Counter = 0

Key = Keyboard
Input Data

(Key Pointer) = Key
Key Pointer

=

Kev Pointer + 1

Send

Figure 13-12. Flowchart
Flowchart of Keyboard Entry Process with
ith Function
Function Keys

Figure 13-12
Figure
13-12 shows the flowchart
chart of the keyboard entry
entry process with
ith all the func­
function keys. In this example.
example, the flow
w of control
control is not simple. Clearly.
Clearly, some written
ritten
description
description is necessary. The organization
organization and layout
layout of complex
complex flowcharts
flowcharts requires
careful
careful planning.
planning. We have followed
followed the process of adding
adding features
features to the flow
chart one
flowchart
at a time,
time. but this still
still results in a large amount
amount of redrawing.
redrawing. Again
Again we should
should rememremem­
ber that
process. the program
that throughout
throughout the keyboard
keyboard entry
entry process,
program must
must also refresh the disdis­
plays if they are multiplexed
ultiplexed and not controlled
controlled by shift
shift registers
registers or other
other hardware.

1 3-26
26

Header flag = 0
Parity Error flag = 0
ress Match flag=O
AddreSsPointer= Sta
of terminal address
Address Counter "" O

Nmess =O

Panty Error

flag= 1

Measg (Nmeu) =

Charac18f
Nmess

=Nmess +

Heade<flag = 1

AddressCounter =
AddressCounter+ 1
Address Pomter =
Address Pointer + 1

Turn off Busy

light

[)rspiayanswer

RTRAN

Figure 13-13. Flowchart of Receive
Receive Routine
Routine

13-27
13-

Figure 13-13
13-13 is the flowchart
cha rt of a receive routine. We assume that
that the serial/parallel
serial/parallel
conversion and error checking
UART). The processor
checking are done in hardware (e.g
(e.g.... by a UART).
must:
1)
1)

Look for the header (we assume that
that it is a single character).

2)

Read the destination
see if
Read
destination address (we assume that it is three characters
characters long) and see
the message is meant for this terminal;
inal; i.e.,.. if the three characters agree with
ith the
terminal
address.
terminal address.

3)

Wait
a it for the trailer
trailer character.

4)

If the message is meant for the terminal.
terminal, turn off the Busy lightt and go to Display
Answer
Answer routine.
errors. request retransmission
RTRANS routine.
In the event of any errors,
retransmission by going to RTRANS

5)

This routine
routine involves a large number
number of decisions.
decisions, and the flowchart
chart is neither
neither simple
nor obvious.

Clearly, we have come a long way
(Figure 13-8) of the
ay from the simple flowchart
cha rt (Figure
first example. A complete set of flowcharts
charts for the transaction terminal would be
logic. and
a major task. It would
would consist
consist of several interrelated
interrelated charts with
ith complex logic,
would
would require a large amount
amount of effort. Such an effort
effort would
would be just
st as difficult
ifficu lt as writrit­
ing a preliminary
preliminary program, and not as useful.
useful, since you could not check it on the comcom­
puter.

13-28
13-

MODULAR
MODULAR PROGRAMMING
PROGRAMMING
Once programs become large and complex.
complex, flowcharting
charting is no longer a satisfactory
satisfactory
design tool. However,
However. the problem definition
definition and the flowchart
chart can give you some idea
as to how to divide
divide the program into reasonable sub-tasks. The division of the entire
Clearly. most
program into sub-tasks
sub-tasks or modules is called "modular
odular programming."
programming." Clearly,
of the programs we presented in earlier chapters
chapters would
would typically
typically be modules in a large
system program. The problems that
that the designer faces in modular programming are

how to divide the program into modules and how to put the modules together.
The advantages
advantages of modular programming are obvious:

ADVANTAGES
OF MODULAR
PROGRAMMING
PROGRAMMING

1)

debug. and test than an
A single module is easier to write.
write, debug,
entire program.

2)

module isis likely
likely to
to be
be useful
useful in
in many
many places
places and
and in
in other
other programs,
programs. particularly
particularly ifif
AA module
task. You can build up a library of
it is reasonably general and performs a common
common task.
standard modules.

Modular
programming allows
allows the
the programmer
programmer to
to divide
divide tasks
tasksand
and use
use previously
previously
3) M
odular programming
written
ritten programs.
4)

Changes can
can be
be incorporated
incorporated into
into one
one module
module rather
rather than
than into
into the
the entire
entire system.
system.
Changes

Errorscan
can often
often be
be isolated
isolated and
and then
then attributed
attributed to
to aa single
single module.
module.
5) Errors
Modular
programming gives
gives an
an idea
idea of
of how
how much
much progress
progress has
has been
been made
made and
and
6) M
odular programming
1s left.
how much of the work
work is
The idea of modular programming is such an obvious one
that
ignored. These include:
that its disadvantages
disadvantages are often ignored.
Fitting the
the modules
modules together
together can
can be
be aa major
major problem,
problem. par­
par1) Fitting
ticularly
ticularly if different
different people write
write the modules.

DISADVANTAGES
OF MODULAR
PROGRAMMING

Modules require
require very
very careful
careful documentation,
documentation, since
since they
they may
may affect
affect other
other parts
parts of
of
2) Modules
the program, such as data structures
structures used by all the modules.
Testing and
and debugging
debugging modules
modules separately
separately isis ddifficult.
since other
other modules
modules may
may
3) Testing
ifficult, since
produce the data used by the module
module being debugged
debugged and still other
other modules may
use the results. You may have to write
rite special programs
programs (called "drivers")
"drivers") just
just to
produce sample data and test the programs. These drivers require extra programprogram­
effort that adds nothing
nothing to the system.
ming effort
system.
4) Programs
Programs may
may be
bevery
very d ifficu
difficultlt to
to modularize.
modularize. IfIfyou
you modularize
modularize the
the program
program poorly,
poorly.
integration
integration will
ill be very difficult.
ifficult, since almost all errors and changes will
ill involve
several modules.
5) MModular
odular programs
programs often
often require
require extra
extra time
time and
and memory,
memory. since
since the
the separate
separate
modules may repeat functions.
functions.
Therefore,
hile modular
modular programming
programming is certainly
certainly an improvement
provement over trying
trying to write
write
Therefore. while
the entire program from scratch, it does have some disadvantages
disadvantages as well.

Important considerations include restricting
restricting the amount
amount of information shared by
Important
modules, limiting design decisions that
that are subject
subject to change to a single module
module
and restricting
restricting the access of one module to another.3
another.^

13-29
13
29

An obvious problem is that
that there are no proven,
programs. We
systematic
atic methods for modularizing programs.
should mention the following
should
ing principles:4
1)
1)
2)

PRINCIPLES OF
MODULARIZATION
MODULARIZATION

Modules that reference common data should be parts of the same overall module.
Two modules in which
second. but not the reverse,
reverse.
which the first
first uses or depends on the second,
separate.
should be separate.

3)

A module that is used by more than one other
other module should be part of a different
different
overall module than the others.
others.

4)

Two modules in which
which the first
first is used by many other
other modules and the second is
separate.
used by only a few other
other modules should be separate.
Two modules whose frequencies
frequencies of usage are significantly
significantly different
different should be part
of different
different modules.
The structure
structure or organization
organization of related data should be hidden within
ith in a single
module.

5)
6)

program is difficultlt to modularize, you may need to redefine the tasks that
If a program
that are
haninvolved. Too many special cases or too many variables that
that require special han­
signs of inadequate problem definition.
dling are typical signs

1 3-30
30

EXAMPLES
Response to a Switch
Response
itch
This simple program can be divided into two
o modules:
its for the switch
itch to be turned on and turns
Module 1 w aits
the light on in response.
response.

MODULARIZING
MODULARIZING
THE SWITCH
SWITCH
AND LIGHT
SYSTEM
SYSTEM

Module 2 provides the one-second delay.
system. since it
11will
Module
odule 1 is likely to be specific
specific to the system,
ill depend on how the switch
switch
and light
light are attached. Module
odule 2 will
ill be generally
generally useful,
useful. since many tasks require
Clearly. it would
delays. Clearly,
would be advantageous
advantageous to have a standard delay module that could
provide delays of varying
varying lengths. The module will
ill require careful documentation
documentation so
that you will
delay. how to call the module,
module. and
ill know how to specify
specify the length of the delay,
what
hat registers and memory locations
locations the module affects.
A general version of Module 1 would
would be far less
would have to deal with
ith
less useful,
useful. since it would
different
different types and connections
connections of switches
switches and lights.

conf1gurat1on of
You would
would probably
probably find it simpler
simpler to write
rite a module for a particular
particular configuration
switches and lights
lights rather than try to use a standard routine. Note the difference
difference be­
switches
besituation and Module
odule 2.
tween this situation
2.

itch-Based
Loader
The Sw itch-B
ased M emory
ory Loader
switch-based memory loader is difficultlt to modularize,
The switch-based
since all the programming
programming tasks depend on the hardware
since
configuration and the tasks are so simple
that modules
simple that
orthwhile.
hardly seem w orthw
hile. The flowchart
flowchart in Figure 13-9 sugsug­
gests that one module might
ight be the one that waits for the
operator to press one of the three pushbuttons.
pushbuttons.

MODULARIZING
MODULARIZING
THE
SWITCHSWITCH- BASED
MEMORY
LOADER
MEMORY LOADER

Some other modules might
ight be:
• A delay module that provides the delay required to debounce
debounce the switches
switches
• A switch
switch and display module that reads the data from the switches
switches and sends it to
the displays
• A Lamp Test module

Highly
Highly system-dependent
system-dependent modules such as the last two are unlikely
unlikely to be generally
useful. This example is not one in which
hich modular
modular programming
programming offers great advantages.

13-31
13-

The Verification
Verification Terminal
The verification
hand. lends itself very
verification terminal, on the other
other hand,
well
well to modular
modular programming.
programming. The entire system can easily be
divided into three main modules:
,• Keyboard and display module
• Data transmission module

MODULARIZING
MODULARIZING
THE
VERIFICATION
VERIFICATION
TERMINAL
TERMINAL

• Data reception module
A general keyboard and display
display module could handle many keyboard- and displayas:
based systems. The sub-modules
sub-modules would
would perform such tasks as:
• Recognizing a new keyboard entry and fetching
fetching the data
• Clearing the array in response to a Clear key

• Entering digits
digits into storage
• Looking for the terminator
inator or Send key
• Displaying
Displaying the digits
digits

vary. the basic entry,
entry.
Although
lthough the key interpretations
interpretations and the number
number of digits
digits will
ill vary,
storage. and data display
processes will
data storage,
display processes
ill be the same for many programs. Such
function
Clearly. the designer must consider
function keys as Clear would
would also be standard. Clearly,

which modules will
ill be useful in other applications, and pay careful attention
attention to
modules.
those modules.
as:
The data transmission
transmission module could also be divided
divided into such sub-modules
sub-modules as:
1) Adding
Adding the
the header
header character.
character.
1)
2)
2)

Transmitting
Transm
itting characters
characters as the output
output line can handle them.

3)

Generating delay times between
between bits or characters.

Adding the
the trailer
trailer character.
character.
4) Adding
5)

Checking for transmission
transmission failures;
failures: i.e.,.. no acknowledgement
acknowledgement or inability
inability to
transmitit w ith
ithout
errors.
transm
o u t errors.

The data reception
reception module could include sub-modules
sub-modules which:
which:

1) Look
Look for
for the
the header
header character.
character.
1)
2) Check
inal address.
Check the
the message
message destination
destination address
address against
against the
the term
terminal
address

Store and
and interpret
interpret the
the message.
message.
3) Store
Look for
for the
the trailer
trailer character.
character.
4) Look
Generate bit
bit or
or character
character delays.
delays.
5) Generate
Note here how important
portant it is that each design decision (such as
INFORMATION
INFORMATION
rate. message format.
the bit rate,
format, or error-checking
error-checking procedure) be imim­
HIDING
plemented
plemented in only one module. A change in any of these decisions
PRINCIPLE
will
ill then require changes only to that single module. The other
modules should be written
ritten so that they are totally
totally unaware of the values chosen or the
methods used in the implementing
plementing module. An important concept here is the "inforr­

mation-hiding principle,"
principle:•55 whereby
abwhereby modules share only information that
that is ab­
solutely essential to getting the task done.
done. Other
Other information is hidden within
in a
single module.
module.
single

13-32
13-

Error handling
handling is a typical
typical context
context in which
which this principle
principle should be employed.
employed. When
When a
recover: instead, it should inform the
detects a lethal error, it should not try to recover;
module detects
calling module
module of the error status and allow that module to decide how to proceed. The
calling
information
reason
that the lower
lower level module often lacks sufficient
sufficient inform
ation to establish
reason is that
acexample, suppose that the lower level module is one that
that ac­
recovery procedures. For example.
numeric input
input from a user.
string of numeric
numeric digits
digits termi-i­
user. This module expects a string
cepts numeric
nated by a carriage return. Entry of a non-numeric
non-numeric character
character causes the module toterter­
abnormally. Since the module does not know
know the context
context (i.e.,.. is the numeric
minate abnormally.
file?). it cannot
1/0 unit
operand, a line number.
number, an I/O
unit number.
number, or the length of a file?),
cannot
string an operand.
followed a single error recovery
decide how to handle an error. If the module always followed
procedure, it would
would lose its generality
generality and only be usable in those situations
situations where that
procedure.
procedure was required.
procedure

1 3 -33
33

REVIEW OF MODULAR PR O G RAMMING
ING
Modular
Modular programming can be very helpful if you abide by
the following
ing rules:
1)
1)

RULES FOR
MODULAR
MODULAR
PROGRAMMING
PROGRAMMING

Use modules of 20 to 50 lines. Shorter
Shorter modules
modules are
usually
usually a waste
waste of time.
time, while
hile longer modules are seldom general and may be difif­
ficultlt to integrate.
ficu
integrate,

Try to make modules reasonably general. Differentiate
Differentiate between
between common
common
features like ASCII code or asynchronous
asynchronous transmission
transmission formats.
formats, which
hich will
ill be the
same for many applications.
applications, and key identifications.
identifications, number
number of displays.
displays, or number
number
message. which
of characters
characters in a message,
hich are likely to be unique
unique to a particular
particular application.
application.
Make the changing
changing of the latter
latter parameters simple. Major
ajor changes like different
different
character
character codes should be handled by separate modules.
Take extra
extra tim
time
on modules
modules like
like delays,
delays. display
display handlers,
handlers. keyboard
3) Take
e on
keyboardhandlers.
handlers,etc.
etc.
that
that will
ill be useful in other projects or in many different
different places in the present
program.
program.
possible. Restrict
4) Try to keep modules as distinct
distinct and logically separate as possible.
Restrict the
flow
flow of information
ation between
between modules
modules and implement
implement each design decision
decision in a
single module.
Do not
not try
try to
to modularize
modularize simple
simple tasks
tasks where
where rew
rewriting
5) Do
riting the
the entire
entire task
task may
may be
be
assembling or
or modifying
modifying the
the module.
module
easier than assembling
2)

1 3-34
34

STRUCTURED PROGRAMMING
PROGRAMMING
How
How do you keep
keep modules distinct
distinct and stop them from interacting? How
How do you
write
rite a program that
that has a clear sequence of operations so that
that you can isolate
errors? One answer
proand correct errors?
answer is to use the methods known as "structuredd pro­
gramming",
m ing", whereby
whereby each part of the program consists of elements
elements from a limited
set of structures and each structure has a single
single entry and a single exit.
Figure 13-14 shows a flowchart
chart of an unstructured
unstructured program. If an error occurs in
B. we have five possible sources for that
seModule
odule B,
that error. Not only must we check each se­
quence. but we also have to make sure that
that any changes made to correct the error do
not affect
affect any of the other
other sequences. The usual result is that
that debugging
debugging becomes like
wrestling
wrestling an octopus. Every time you think
think the situation
situation is under control.
control, there is
another
another loose tentacle
tentacle somewhere.
The solution
solution is to establish
establish a clear sequence of operations so
that
that you can isolate errors. Such a sequence uses single-entry.
single-entry,
single-exit
single-exit modules. The basic modules that
that are needed are:
1)
1)

An ordinary sequence; i.e.. a linear structure
structure in which
which
statements
statements or structures
structures are executed consecutively.
consecutively. In
the sequence:

BASIC
STRUCTURES OF
STRUCTURED
PROGRAMMING
PROGRAMMING

S1
51
S2
52
S3
53
second. and S3 third. S1,
S1, S2,
S2, and S3 may be
the computer
puter executes S11 first. S2 second,
single instructions
instructions or entire
entire programs.
2)

A conditional structure.
S1 else S2," where C is a condition
S1 and S2
The common
common one is "tfif C then S1
condition and S1
S1 if C is true,
true.
are statements
statements or sequences of statements. The computer
puter executes S1
and S2 if C is false.
false. Figure 13-15 shows the logic of this structure.
structure. Note that the
structure
S1 or
structure has a single entry and a single exit; there is no way to enter or leave S1
S2 other than through
through the structure.

3)

A loop structure.
The common
common loop structure
structure is "while
h ile C do S," where C is a condition
condition and S is a
statement
statement or sequence of statements. The computer
computer checks C and executes S if C
(see Figure 13-16) also has a single entry and a single exit.
exit.
is true. This structure
structure (see
Note that
false. since the
that the computer
puter will
ill not execute S at all if C is originally
originally false,
value of C is checked before S is executed.

languages. an alternative
proIn most structured
structured programming
programming languages,
alternative looping construct
construct is pro­
clause. Its basic structure
vided. This construct
construct is known
known as the do-until
do-until clause.
structure is "do S unttl
until
C",, where C is a condition
C”
condition and Sisis a statement
statement or sequence of statements. It is similar
to the do-while
do-while construct
construct except
except that the test of the looping condition
condition C is performed at
the end of the loop. This has the effect
guaranteeing that the loop is always executed
effect of guaranteeing
at least once. This is illustrated
illustrated by the flowchart
chart in Figure 13-17. The common indexcontrolled or DO loop can be implemented
implemented as a special case
either of these two basic
controlled
case of either
looping constructs.
constructs.

13-35
13-

C

B

Figure 13-14. Flowchart
Flowchart of an Unstructured
Unstructured Program

Start

51

52

End

Figure 13-15. Flowchart
Flowchart of the If-Then-Else Structure
Structure

13-36

Start

No

s
End

Figure 13-16. Flowchart
Flowchart of the Do-While
hile Structure
Structure

Start

s

End

Flowchart of the Do-Until
Do-Until Structure
Structure
Figure 13-17. Flowchart
4)

A case structure.
Although
prim itive structure
structure like sequential.
sequential, if-then-else,
if-then-else. and do-while, the
Although not a prim1t1ve
adJunct to the
case structure
structure is
commonly used that we include it here as an adjunct
Is so commonly
basic structure
structure descriptions.
descriptions. The case structure
structure is "case I of SO,
1 ,. . Sn". where I
SO, Sl..
Is
is an index and SO,
I . . .Sn are statements
statements or sequences of statements. If I is
SO, S1,
S1 is
statement S1
equal to zero then statement
statement SO
Is executed, if I is equal to 1 then statement
SO is
executed, etc. Only one of thenn statements
statements is
After its execution, control
Is executed. After
executed.
Is
case statement
passes
sequential statement
statement following
ing the case
statement group. If I is
passes to the next sequential
case statement!.
number of statements
statements in the case
statement), then none of
(i.e., the number
greater than n (i.e.,
passed directly
Is passed
the statements
statements in the case statement
statement is executed, and control
control is
directly to
Is Illustrated
the next sequential
sequential statement
statement follow
ing the case statement. This is
illustrated by
following
the flowchart
chart in Figure 13-18.

13-37

No

No

so

SI

S2

Sn

L--------1~--------11~--------•-----1~
End

Figure 13-18. Flowchart of the Case Structure
Note the following
ing features
features of structured programming:
1)l

2)
3)

Only the three basic structures, and possibly a small
number of auxiliary
auxiliary structures, are permitted.
permitted.
Structures
Structures may be nested to any level of complexity
plexity so that
that any structure
can, in turn, contain any of the structures.
Each structure has a single entry and a single
single exit.

Some examples
examples of the conditional structure illustrated
illustrated in
Figure 13-15
Figure
13-15 are:
1)
1)

S2 included:
included:

EXAMPLES
OF
STRUCTURES

if X >
~ 0 then NPOS
NPOS = NPOS
NPOS +
+1
else NNEG
NNEG = NNEG
NNEG +
+1
else

S1 and S2 are single statements.
Both S1
2)
2)

S2 omitted:
omitted:
if X ^ 0
-foOthen Y =
= 1/X

-foO)
false. S2 and "else"
Here no action is taken if C (X ^ 0
) is false.
"else" can be omitted
omitted in this case.
case.

13-38
13
38

Some examples
Figure 13-16
examples of the loop structure illustrated
Illustrated in Figure
13-16 are:
1)
1)

N.
Form the sum of integers
integers from 1 to N.
1=0
=0
SUM =00
hile I<< N
do while
1 + 1
I1 ==I+
1
SUM== SUM++ I
end

computer executes
executes the loop as long as I < N.
program within
ith in the "doThe computer
N. If N = 0, the program
all.
while"
hile" is not executed
executed at all-

2)
21

Count
SENTENCE until
Count characters
characters in an array SENTENCE
until you find an ASCII period.
NCHAR = 0
hile SENTENCE
do while
SENTENCE (NCHAR)
(NCHAR) ^-laPERIOD
PERIOD
NCHAR = NCHAR + 1
end

puter executes
executes the loop as long as the character
character in SENTENCE
The computer
SENTENCE is
1snot an ASCII
ASCII
period. The count
count is
first character
character is a period.
1szero if the first

The advantages of structured programming
programming are:
1)
1)

The sequence
sequence of operations
operations is simple
simple to trace. This allows
you to test and debug easily.

ADVANTAGES OF
ADVANTAGES
STRUCTURED
PROGRAMMING
PROGRAMMING

2) The
inology is
The number
number of
of structures
structures is
is limited
l1m1tedand
and the
the term
terminology
1s
standardized.
standardized.

The structures
structures can
can easily
easily be
be made
made into
into modules.
modules
3) The
4)

Theoret1c1anshave
have proved
proved that
that the
the given
given set
set of
of structures
structures isis complete;
complete; that
that is,
is, all
Theoreticians
all
programs
programs can be written
ritten in terms of the three structures.
structures.

5)

The structured
self-documenting
structured version of a program is partly
partly self-docum
enting and fairly easy to
read.
read.
6) Structured
Structured programs
programs are
are easy
easy to
to describe
describe wwith
program outlines.
outlines.
ith program
Structured programming
programming has
has been
been shown
shown in
in practice
practice to
to increase
increase programmer
programmer pro­
pro7) Structured
ductivity.
ductivity.

Structured programming basically forces much more discipline
discipline on the programmer
programming. The result is more
more systematic
than does modular programming.
atic and betterorganized programs.
programs.
The disadvantages of structured programming
programming are:

DISADVANTAGES
DISADVANTAGES
OF

1) Only
Only aa few
few high-level
high-level languages
languages (e.g.,
(e.g.,PL/M,
PL/M, PASCAL)
PASCAL) wwill
1)
ill
STRUCTURED
directly
directly accept
accept the structures.
structures. The programmer
programmer therefore
PROGRAMMING
PROGRAMMING
has to go through
through an extra translation
translation stage to convert
convert the
structures
verstructures to assembly
assembly language code. The structured
structured ver­
sion of the program, however, is often useful as documentation.
documentation,
2)
3)

4)

Structured
Structured programs
programs often
often execute
execute more slowly
slowly and use more memory
memory than
unstructured
unstructured programs.
Limiting
iting the structures
structures to the three basic forms makes some tasks very awkward
awkward to
perform. The completeness
completeness of the structures
structures only means that all programs
programs can be
implemented
implemented with
ith them; it does not mean that a given program can be impleimple­
mented
mented efficiently
efficiently or conveniently.
conveniently.
standard structures
structures are often
often quite
quite confusing,
confusing, e.g.
e.g., nested "if-then-else"
"if-then-else" strucstruc­
The standard
tures may be very d iffic
ifficult
read. since there may be no clear indication
u lt to read,
indication of where
inner structures
"do-while"
read.
structures end. A series of nested "do-w
hile" loops can also be difficult
ifficu lt to read.

13-39
13-39

5)

Structured programs consider
consider only the sequence of program
program operations,
operations. not the
Structured
flow of data. Therefore.
Therefore, the structures
structures may handle data awkwardly.
awkwardly.

6)

Few programmers
programmers are accustomed
accustomed to structured
structured programming.
programming. Many find the stanstan­
dard structures
structures awkward
awkward and restrictive.
restrictive.

We are neither
neither advocating nor discouraging the use of structured programming. It
systematizing
programming
is one way
ay of system
atizing program design. In general, structured programming
is most useful in the following
ing situations:
• Larger programs.
programs, perhaps exceeding
exceeding 1000 instructions.
instructions.
• Applications
Applications in which
hich memory
memory usage is not critical.

WHEN
WHEN TO USE
STRUCTURED
PROGRAMMING
PROGRAMMING

• Low-volume
Low-volume applications
costs.
applications where software
software development
development costs,
particularly
particularly testing and debugging.
debugging, are important
portant factors.
ra• Applications
Applications involving
involving string manipulation.
manipulation, process control.
control, or other algorithms
algorithms ra­
ther than simple
simple bit manipulations.
manipulations.

In the future, we expect
expect the cost of memory to decrease, the average size of
inmicroprocessor programs to increase, and the cost of software
are development
development to in­
crease. Therefore,
Therefore, methods like structured programming, which decrease softsoft­
ware development
development costs for larger programs but use more memory, will
ill become
more valuable.
Just
,n high-level
Just because structured
structured programming
programming concepts
concepts are usually
usually expressed in
high-level
languages does not mean that structured
structured programming
programming is not applicable
applicable to assembly
language
language programming.
programming. To the contrary.
contrary, the assembly language programmer, with
ith
the total
total freedom of expression that
that assembly level
level programming allows, needs
the structuring concepts provided by structured programming. Creating modules
single entry and exitit points, using
using simple control structures and keeping the
with single
complexity
plexity of each module minimal makes assembly language coding more effiffi­
cient.

1 3 -40

EXAMPLES
Response
itch
Response to a S witch
The structured version of this example is:
is:
SWITCH== OFF
OFF
do while
hile SWITCH = OFF
OFF
READ
READ SWITCH
end
LIGHT
LIGHT== ON
DELAY 1
LIGHT
OFF
LIGHT== OFF

STRUCTURED
PROGRAMMING
PROGRAMMING
IN THE
SWITCH AND
LIGHT SYSTEM

ON and OFF
switch and light- We assume that
defin1t1onsfor the switch
OFF must have the proper definitions
DELAY is a module that provides a delay given by its parameter
parameter in seconds
seconds.

However. in order to
me However,
A statement
statement in a structured
structured program may actually
actually be a subroutine.
structured programming.
programming, the subroutine
subroutine cannot
cannot have any exits
conform to the rules of structured
returns control
control to the main program.
other than the one that returns
loop. we set the variable
Since "d o -w
h ile ” checks the condition
condition before executing
executing the loop,
o-while"
SWITCH to OFF
readable.
straightforward. readable,
Is straightforward,
structured program is
starting. The structured
OFF before starting.
and easy to check by hand. However,
would probably
probably require somewhat
somewhat more memo·
memo­
However. it would
in111ahze
ry than an unstructured
unstructured program,
which would
would not have to initialize
SWITCH and could
program. which
combine the reading and checking
checking procedures.
combine

13-41
13-41

itch-Based
Loader
The Sw itch-B
ased M emory
ory Loader
The switch-based
switch-based memory loader is a more complex strucstruc­
tured programming
programming problem. We may implement
implement the
Figure 13-9
flowchart
chart of Figure
13-9 as followss (a • indicates a comcom­
ment):

STRUCTURED
PROGRAMMING
PROGRAMMING
FOR THE
FOR
SWITCH-BASED
SWITCH-BASED
MEMORY
LOADER
MEMORY LOADER

• INITIALIZE VARIABLES
VARIABLES
HIADDRESS = 00
LOADDRESS = 00
USES A DO-WHILE
• THIS PROGRAM USES
DO-WHILE CONSTRUCT WITH
WITH NO CONDITION
• (CALLED SIMPLY DO-FOREVER).
DO-FOREVER). THEREFORE,
THEREFORE. THE SYSTEM CONTINUALLY
CONTINUALLY
EXECUTES THE PROGRAM CONTAINED IN THIS DO-WHILE
• EXECUTES
DO-WHILE LOOP.
LOOP.

do forever
FOR HIADDRESS BUTTON; PERFORM
PERFORM THE REQUIRED
• TEST FOR
REQUIRED PROCESSING
PROCESSING
• IF IT IS ON.
ON.

if1f HIADDRBUTTON
HIADDRBUTTON = 1 then
begin
HIADDRESS = SWITCHES
= SWITCHES
LIGHTS =
do
DELAY (DEBOUNCE
(DEBOUNCE TIME)
until
until HIADDRBUTTON
HIADDRBUTTON ?M
-I=1
end
FOR LOADDRESS BUTTON; PERFORM
PERFORM LOW ADDRESS PROCESSING
• TEST FOR
PROCESSING
• IF IT IS ON.

if11LOADDRBUTTON
LOADDRBUTTON = 1 then
begin
LOADDRESS = SWITCHES
LIGHTS = SWITCHES
do
DELAY (DEBOUNCE
(DEBOUNCE TIME)
until
until LOADDRBUTTON
LOADDRBUTTON ±
-I=1
end

=

,

FOR DATABUTTON.
STORE DATA
• TEST FOR
DATABUTTON, AND STORE
DATA INTO MEMORY
• IF IT IS ON.

1f DATABUTTON
if
DATABUTTON = 1 then
thPn
begin
DATA= = SWITCHE~
DATA
SWITCHES
LIGHTS = SWITCHES
(HIADDRESS. LOADDRESS) = DATA
(HIADDRESS,
DATA
do
DELAY (DEBOUNCE
(DEBOUNCE TIME)
until
ntil DATABUTTON
DATABUTTON -I=1
end
end

1 3-42
2

THE LAST END
END ABOVE TERMINATES
TERMINATES THE
THE
• THE
do forever LOOP
LOOP
Structured
Structured programs
programs are not easy to write, but they can give a great deal of insight
insight into
the overall program logic. You can check the logic of the structured
structured program by hand
before writing
code.
ritin g any actual code-

13-43
13-43

The Credit-Verification
redit-Verification Terminal
look at the keyboard entry for the transaction terminal.
Let us look
ENTRY. the keyboard
We will
ill assume that
that the display
display array is ENTRY,
keyboard
strobe
KEYSTROBE. and the keyboard
KEYIN. The strucstrobe is KEYSTROBE,
keyboard data is KEYIN.
struc­

program w ith
ithout
tured program
o u t the function keys is:
is:
NKEYS = 110
0

STRUCTURED
PROGRAM FOR
FOR
THE CREDITVERIFICATION
VERIFICATION
TERMINAL
TERMINAL
STRUCTURED
KEYBOARD
ROUTINE

• CLEAR ENTRY TO START
do while
while NKEYS >
>0
NKEYS = NKEYS
NKEYS- 1
ENTRY(NKEYS) = 00
ENTRY(NKEYS)
end
FETCH A COMPLETE ENTRY FROM KEYBOARD
• FETCH
do while
hile NKEYS <
< 10
if KEYSTROBE
KEYSTROBE = ACTIVE then
begin
KEYSTROBE = INACTIVE
KEYSTROBE
INACTIVE
ENTRY(NKEYS) = KEYIN
ENTRY(NKEYS)
+1
NKEYS = NKEYS +
end
end

program must ignore
ignore extra digits after
Adding the SEND key means that the program
after it has
a complete entry, and must ignore
ignore the SEND key until it has a complete entry. The
is:
structured program is:
NKEYS = 110
0
• CLEAR ENTRY TO START

hile NKEYS >
do while
>0
NKEYS = NKEYS
NKEYS- 1
ENTRY(NKEYS)
ENTRY(NKEYS) = 0
end
FOR COMPLETE ENTRY FOLLOWED BY SEND KEY
• WAIT
AIT FOR
KEY
do while
hile KEY #
*S E N
D OR NKEYS *#1 0
SEND
10
KEYSTROBE = ACTIVE then
if KEYSTROBE
begin
KEYSTROBE
KEYSTROBE = INACTIVE
KEY== KEYIN
10 AND KEY
KEY #
if NKEYS *#1 0
*S E N
D then
SEND
begin
ENTRY(NKEYS) = KEY
+1
NKEYS = NKEYS +
end
end
end

13-44

following
Note the follow
ing features
features of this structured
structured program.
1)
1)

one. since keys are only entered after
The second if-then
if-then is nested within
ith in the first
first one,
after a
strobe is recognized. If the second if-then
if-then were on the same level as the first.
first, a
single key could fill the entry,
entry. since its value would
would be entered into the array during
during
each iteration
iteration of the do-while
do-while loop.

2)

KEY need not be defined
NKEYS is set to zero as part of the clearing
KEY
defined initially,
initially, since NKEYS
clearing
of the entry.

program to clear the entry originally by simulatAdding the CLEAR key allows the program
ulat­
pressing of CLEAR; i.e.,
e, by setting
NKEYS to 10 and KEY
KEY to CLEAR
CLEAR before
ing the pressing
setting NKEYS
starting.
d1g1ts that
starting. The structured
structured program
program must
must also only clear digits
that have previously
previously been
filled. The new structured program
program is:
is:
COMPLETE CLEARING
• SIMULATE COMPLETE
CLEARING
NKEYS = 110
NKEYS
0
KEY== CLEAR
KEY
CLEAR
FOR COMPLETE
• WAIT
AIT FOR
COMPLETE ENTRY
ENTRY AND SEND
SEND KEY
KEY
KEY#*S E N
SEND
OR NKEYS
NKEYS *#1 0
10
do while
hile KEY
D OR
CLEAR WHOLE ENTRY
• CLEAR
ENTRY IF CLEAR
CLEAR KEY
KEY STRUCK
STRUCK
KEY = CLEAR
if KEY
CLEAR then
begin
KEY== 0
KEY
NKEYS >
>0
do while
hile NKEYS
NKEYS = NKEYS
NKEYS - 1
NKEYS
ENTRY(NKEYS) = 0
ENTRY(NKEYS)
end
end
GET DIGIT
• GET
DIGIT IF ENTRY
ENTRY INCOMPLETE
INCOMPLETE
if KEYSTROBE
KEYSTROBE = INACTIVE then
begin
KEYSTROBE
KEYSTROBE =
= INACTIVE
KEY
KEY== KEYIN
KEYIN
KEY <
< 10 AND NKEYS
NKEYS *# 10 then
if KEY
begin
ENTRY(NKEYS) = KEY
KEY
ENTRY(NKEYS)
NKEYS = NKEYS
NKEYS +
+1
NKEYS
end
end
end

Note that the program
KEY to zero after clearing
program resets KEY
clearing the array, so that the operation
operation is
Is
not repeated.

13-45

We can similarly build a structured program
program for the receive
routine. An initial
initial program
program could
could just
just look for the header
header and
trailer
RSTB is the indicator
trailer characters.
characters. We will
ill assume that
that RSTB
indicator that
that a
program is:
is:
character
character is ready. The structured program

STRUCTURED
RECEIVE
RECEIVE
ROUTINE

HEADER FLAG TO START
• CLEAR HEADER
HFLAG = 0

FOR HEADER
HEADER AND TRAILER
TRAILER
• WAIT
AIT FOR
do while
hile HFLAG = 0 OR CHAR f.TRAILER
^TRAILER
GET CHARACTER IF READY,
READY. LOOK FOR
FOR HEADER
HEADER
• GET
if RSTB
RSTB = ACTIVE then
begin
RSTB = INACTIVE
RSTB
CHAR== INPUT
if CHAR = HEADER
HEADER then
then HFLAG = 1
end

Now
message address
address against the three
Now we can add the section that
that checks the message
corresponding digits
digits in TERMINAL
TERMINAL ADDRESS (TERMADDR). If any of the corresponding
are not equal, the ADDRESS MATCH
MATCH flag (ADDRMATCH)
(ADDRMATCH) is set to 1.
HEADER FLAG,
FLAG. ADDRESS MATCH
FLAG. ADDRESS COUNTER
COUNTER TO START
• CLEAR HEADER
MATCH FLAG,
HFLAG = 0
ADDRMATCH
ADDRMATCH = 0
ADDRCTR = 0

• WAIT
FOR HEADER,
HEADER. DESTINATION ADDRESS AND TRAILER
TRAILER
AIT FOR
do while
TRAILER OR ADDRCTR *f. 33
while HFLAG = 0 OR CHAR *f. TRAILER
• GET
GET CHARACTER IF READY
if RSTB
RSTB = ACTIVE then
begin
RSTB
RSTB = INACTIVE
CHAR== INPUT
end
CHECK FOR
FOR TERMINAL
HEADER
• CHECK
TERMINAL ADDRESS AND HEADER
if HFLAG = 1 AND ADDRCTR *f. 33 then
begin
ADDRMATCH
ADDRMATCH = 1
ADDRCTR+ 1
ADDRCTR = ADDRCTR
end
if CHAR = HEADER
HEADER then HFLAG = 1

end

13-46
13-46

header. a three-digit
The program
program must
must now wait
ait for a header,
three-digit identification
identification code,
code. and a trailer.
You must be careful
careful of what
hat happens
happens during
during the iteration
iteration when
when the program
program finds the
header. and of what
header,
hat happens
happens if an erroneous
erroneous identification
identification code character
character is the same
as the trailer.

A further addition can store the message in MESSG. NMESS
NMESS is the number of
end, the program
program knows that the
characters in the message; if it is not zero at the end.
terminal has received a valid message.
message. We have not tried to minimize
exminimize the logic ex­
pressions in this program.
program.
FLAGS. COUNTERS
COUNTERS TO START
• CLEAR FLAGS,
HFLAG = 0
HFLAG
ADDRMATCH
ADDRMATCH = 00
ADDRCTR = 00
NMESS = 00
FOR HEADER,
HEADER. DESTINATION ADDRESS AND TRAILER
TRAILER
• WAIT
AIT FOR
do while
TRAILER or ADDRCTR *,/,.
hile HFLAG = 0 OR CHAR *,/,.TRAILER
33
• GET
GET CHARACTER IF READY

if RSTB
RSTB = ACTIVE then
begin
RSTB = INACTIVE
RSTB
CHAR== INPUT
end
READ MESSAGE IF DESTINATION ADDRESS== TERMINAL ADDRESS
ADDRESS
• READ
if HFLAG = 1 AND ADDRCTR = 3 then
if ADDRMATCH
ADDRMATCH = 0 and CHAR #TRAILER
^TRAILER then
begin
MESSG(NMESS) = CHAR
MESSG(NMESS)
NMESS = NMESS +
+1
end

CHECK FOR
FOR TERMINAL ADDRESS
• CHECK
if HFLAG = 1 AND ADDRCTR *,/,.
33 then
if CHAR *,/,.TERMADDR(ADDRCTR)
TERMADDR(ADDRCTR) then
begin
ADDRMATCH = 1
ADDRMATCH
ADDRCTR = ADDRCTR +
+1
end
• LOOK FOR
FOR HEADER
HEADER
if CHAR = HEADER
HEADER then HFLAG = 1
end

13-47
13-

header during a pre­
preThe program checks for the identification
identification code only if it found a header
message only if it has
has previously found a header
vious iteration. It accepts the message
header and a
address. The program must work properly during the
complete, matching destination address.
iterations when it finds the header,
header. the trailer and the last digitit of the destination ad­
address. It must not try to match the header
header with the terminal address
address or place the trailer
dress.
address in the message.
message. You might try adding
adding the
or the final digitit of the destination address
logic from the flowchart
(Figura 13-13)
program. Note
rest of the logic
rt (Figure
13-13) to the structured program.
critical. You must be sure
aura that the program
that the order of operations is often critical.
program
phase and start the next one during
during the same iteration.
does not complete one phase

13-48

REVIEW OF STRUCTURED
STRUCTURED PR O G RAMMING
ING
Structured
Structured programming
programming brings
brings discipline
discipline to program
program design.
design. It forces
forces you to limitit
the
the types
types of structures
structures you use and the sequence
sequence of operations.
operations. It provides
provides singlesingle­
entry,
entry, single-exit
single-exit structures,
structures, which
hich you can check
check for logical
logical accuracy.
accuracy. Structured
Structured
programming often
programming
often makes
makes the designer
designer aware of inconsistencies
inconsistencies or possible
possible comcom­
binations
binations of inputs.
inputs. Structured
Structured programming
programming is not
not a cure-all,
cure-all, but
but it does bring
some order
order into
into a process
process that
that can be chaotic.
chaotic. The structured
structured program
program should also
aid in debugging,
debugging, testing,
testing, and documentation.
documentation.
Structured programming
Structured
programming is not
not simple.
simple. The programmer
programmer must
must not only define
define the
problem
problem adequately,
adequately, but
but must
must also work
ork through
through the logic carefully.
carefully. This is
tedious
difficult,lt, but
tedious and difficu
but it results
results in a clearly
clearly written,
ritte n , working
orking program.
program.
The particular structures we have presented are not ideal and
and
TERMINATORS
TERMINATORS
are often awkward.
awkward. In addition, it can be d ifficult to dis­
disFOR
FOR
tinguish where
where one structure ends and another begins,
partic­
begins, particSTRUCTURES
STRUCTURES
ularly if they
they are nested. Theorists may provide betterr struc­
structures in the future, or designers may wish to add some of their own. Some kind of
necessary, since indenting
terminator
inator for each structure
structure seems necessary,
indenting does not always clarify
o-while"
the situation.
situation. "End"
"End" is a logical terminator
inator for the "d o-w
h ile " loop. There is
1sno obvious
terminator.
terminator, however, for the "'if-then-else"
"if-then-else" statement:
statement: some theorists have suggested
ndif"
backwards). but these are both awkward
from the
"e n
d if" or " fi"i" ("if"
("if" backwards),
awkward and detract
detract from
readability
readability of the program.

We suggest the following
ing rules for applying structured pro­
programming:
gramming:
1)
2)

3)
3)
4)

5)

6)
7)

RULES FOR
FOR
RULES
STRUCTURED
PROGRAMMING
PROGRAMMING

Begin by writing a basic flowchart
chart to help define the
logic of the program.
Start w
with the
the "se q u
"sequential,"
"if-then-else,"
Start
n tia l," "if-th e n
-e ls e ," and
ile " constructs.
and "d o -w
"do-while"
constructs. They
They
are known to be a complete
complete set. ,e
i.e.,.. any program can be written
ritten in terms of these
these
structures.
Indent each level a few spaces from the previous level,
ill know
level. so that you will
which
which statements
statements belong where.
Use terminators
terminators for
for each
each structure;
structure; e.g
··end"
for the
the "d o-w
"do-while"
and "e n
··endif'"
or
Use
e.g.,.. "e n
d " for
ile " and
d if" or
"ff'
fi" for the "'if-then-else".
"if-then-else". The
The terminators
terminators plus
plus the
the indentation
indentation should
should make
make the
the
program reasonably clear.
clear.
Emphasize sim
simplicity
Emphasize
plicity and
and readability.
readability. Leave
Leave lots
lots of
of spaces.
spaces, use
use meaningful
meaningful
names, and make
names,
make expressions
expressions as
as clear
clear as
as possible.
possible. Do
Do not
not try
try to
to minimize
minimize the logic
logic
at the cost of clarity.
Comment
Comment the program in an organized manner.
Check the
the logic.
logic. Try
Try all
all the
the extreme
extreme cases
cases or
or special
special conditions
conditions and
and aa few
few sample
sample
Check
cases. Any logical errors you find at this level will
cases.
ill not plague you later.
later.

13-49
13-

DESIGN
TO P-DOWN DESIGN
The remaining
remaining problem
problem is how
how to check
check and integrate
integrate modules
modules
BOTTOM-UP
BOTTOM-UP
or structures.
structures. Certainly
Certainly wee want
a nt to divide
divide a large task
task into
into
DESIGN
sub-tasks.
sub-tasks. But
But how
how do we check
check the sub-tasks
sub-tasks in isolation
isolation and
put
ottom-up
put them
them together?
together? The standard
standard procedure,
procedure, called
called "b otto
m -up design,"
design," requires
requires
extra work
testing and debugging
extra
o rk in testing
debugging and leaves
leaves the
the entire
entire integration
integration task
task to the
end. What
hat wee need is a method
method that
that allows
allows testing
testing and debugging
debugging in the
the actual
actual
program
environment
program environm
ent and modularizes
modularizes system
system integration.
integration.
This method
"top-down
method is "top
-do w n design."
design." Here we start
start by writing
riting
the overall
overall supervisor
supervisor program.
program. We replace
replace the undefined
undefined subsub­
programs
tubs,"
programs by program
program "s tu
b s ," temporary
temporary programs
programs that
that may
either
either record
record the entry,
entry, provide
provide the
the answer
answer to a selected
selected test
test
problem,
problem, or do nothing.
nothing. We then
then test
test the supervisor
supervisor program
program
to see that
that its logic
logic is correct.
correct.
We proceed
proceed by expanding
expanding the stubs.
stubs. Each stub
stub willill often
often concon­
tain sub-tasks, which we will
ill temporarily
temporarily represent
represent as stubs.
stubs.
process of expansion, debugging, and testing continues
This process
until all the stubs are replaced by working programs.
programs. Note that
testing
level. rather
testing and integration
integration occur
occur at each level,
rather than all at the
end. No special driver
driver or data generation
generation programs
programs are necessary.
In the design. TopWe get a clear idea of exactly
exactly where we are in
down design assumes modular programming, and is compatipati­
ble with structured programming as well.

TOP-DOWN
TOP-DOWN
DESIGN
METHODS
METHODS

STUBS
EXPANDING
EXPANDING
STUBS
ADVANTAGES
ADVANTAGES
OF
TOP-DOWN
TOP-DOWN
DESIGN

The disadvantages
top-downn design are:
disadvantages of top-dow
1)
1)

The overall design may not mesh well with
ith system hardhard­
ware.

2)
2)
3)
3)

It may not take good advantage
advantage of existing
existing software.
Stubs may be difficult
ifficu lt to write.
write, particularly
particularly if they must
work correctly
correctly in several different
different places.
places.
Top-down
Top-down design may not result in generally
generally useful
useful modules.

4)
5)

DISADVANTAGES
DISADVANTAGES
OF
TOP-DOWN
TOP-DOWN
DESIGN

Errors at the top level can have catastrophic
catastrophic effects.
effects, whereas
whereas errors in bottom-up
bottom-up
design are usually
usually limited
limited to a particular
particular module

large programming projects, top-down
In large
top-down design has been shown to greatly
greatly im­
improve programmer productivity.
productivity. However,
However, almost all of these projects have used
some bottom-up
-up design in cases where
where the top-dow
top-downn method would have
resulted in a large amount of extra work.
Top-down
should not be followed
Top-down design is a useful tool that
that should
ed to extremes.
extremes. It pro­
provides the same discipline for system testing and integration
integration that structured pro­
programming provides for module design.
however, has more general
design. The method, however,
applicability,
use of programmed logic.
applicability, since it does not assume the use
However,
logic. However,
top-down
top-down design may not result in the most efficient
efficient implementation.
implementation.

13-500
13-

EXAMPLES
Response to a S witch
itch
The first structured programming example actually demondemon­
strates top-dow
top-downn design as well. The program
program was:
was:

TOP-DOWN
TOP-DOWN
DESIGN
OF SWITCH
SWITCH
AND LIGHT
SYSTEM
SYSTEM

OFF
SWITCH== OFF
OFF
do while
hile SWITCH = OFF
READ SWITCH
READ
end
LIGHT== ON
LIGHT
DELAY 1
DELAY
LIGHT== OFF
OFF
LIGHT

These statem
statements
none of them is fully defined. For exam­
examents are really stubs, since none
READ SWITCH mean? If the switch
SPORT. it
ple. what
hat does READ
switch were one bitit of input
input port SPORT,
means:
really means:
SPORT AND SMASK
SWITCH = SPORT
where SMASK has a ·1
course. be
'1'• bitit in the appropriate
appropriate position. The masking may. of course,
implemented
implemented with
ith a Bit Test instruction.
instruction.
Similarly, DELAY 1 actually
actually means (if the processor itself provides the delay):
Similarly,
REG= COUNT
COUNT
REG
REG * 0
f=.O
do while
hile REG
REG= REG
REG - 1
REG
end
COUNT is the appropriate
COUNT
appropriate number
number to provide a one-second delay. The expanded verver­

is:
sion of the program is:
SWITCH== 00
do while
hile SWITCH = 0
SPORT AND MASK
SWITCH = SPORT
end
LIGHT== ON
LIGHT
REG= COUNT
COUNT
REG
REG *f=.0
do while
hile REG
REG= REG
REG - 1
REG
end
LIGHT
LIGHT== NOT (LIGHT)
(LIGHT)

•

explicit, and could
Certainly this program
program is more explicit,
could more easily be translated into
actual instructions or statements.
statements.

13-51

Loader
The Sw itch-Based
ased M emory
ory Loader
This example
example is more complex
complex than the first
first example.
example, so we
must proceed systematically.
prosystematically. Here again.
again, the structured
structured pro­
stubs.
gram contains stubs.
HIGH ADDRESS
ADDRESS button
For example.
example, if the HIGH
button is one bit of input
input
port CPORT,
CPORT. "ifif HIADDRBUTTON = 1" really means:
1)
1)
2)
3)

TOP-DOWN
TOP-DOWN
DESIGN OF
SWITCH-BASED
SWITCH-BASED
MEMORY
MEMORY
LOADER

Input
CPORT
Input from CPORT
Complement
Complement
Logical
Logical AND with
ith HAMASK

where
·1• in the appropriate
·os· elsewhere. Similarly
where HAMASK has a T
appropriate bit position
position and 'Os'
Similarly
the condition
condition "ifif DATABUTTON = 1" really means:
1)
1)
2)
3)

Input
CPORT
Input from CPORT
Complement
Complement
Logical AND with
ith DAMASK

So. the initial
So,
initial stubs could just
just assign values to the buttons.
buttons, e.g.,..
HIADDRBUTTON = 00
LOADDRBUTTON = 00
LOADDRBUTTON
DATABUTTON = 0

A run of the supervisor
supervisor program should show that it takes the implied
implied "else"
"else" path
through
through the "if-then-else"
"if-then-else" structures,
structures, and never reads the switches.
switches. Similarly.
Similarly, if the
stub were:
HIADDRBUTTON = 1

the supervisor
program should stay in
In the "do while
supervisor program
hile HIADDRBUTTON = 1..
" loop waita it­
released. These simple
ing for the button
button to be released.
simple runs check the overall logic.
Now we can expand each stub and see if the expansion produces a reasonable
overall result. Note how debugging and testing proceed in a straightforward
straightforward and
HIADDRBUTTON = 1 stub to:
modular manner. We expand the HIADDRBUTTON
READ CPORT
CPORT
READ
HIADDRBUTTON = NOT (CPORT)
(CPORT) AND HAMASK
HIADDRBUTTf)N
The program should waitit for the HIGH
button to be closed. The program
HIGH ADDRESS
ADDRESS button
should then display
display the values of the switches
switches on the lights. This run checks for the
proper response to the HIGH
HIGH ADDRESS
ADDRESS button.

ADDRESS button
We then expand the LOW ADDRESS
button module
module to:
READ
READ CPORT
CPORT
LOADDRBUTTON
LOADDRBUTTON = NOT (CPORT)
(CPORT) AND LAMASK
With
ith the LOW ADDRESS
button in the closed position.
position, the program should display
display the
ADDRESS button
values of the switches
switches on the lights. This run checks for the proper
proper response to the LOW
ADDRESS button.
ADDRESS
Similarly, we can expand the DATA button
button module and check for the proper
proper response
Similarly.
nave been tested.
to that
that button.
button. The entire program
program will
ill then have

When ail
When
all the stubs have been expanded, the coding,
coding. debugging, and testing
stages will
ill all be complete. Of course, we must know exactly
exactly what
at results each
should produce.
produce. However,
stub should
However, many logical errors will
ill become obvious at each
level w ithout
o u t any further
further expansion.
level

13-52

The Transaction
Transaction Terminal
inal
This example, of course, will
ill have more levels of detail. We
could
Id start
program (see
(see Figure 13-19
start with
ith the following
ing program
19 for
a flowchart):
flowchart):
KEYBOARD
KEYBOARD
ACK =00
=0
do while
hile ACK =
TRANSMIT
RECEIVE
RECEIVE
end
DISPLAY
DISPLAY

TOP-DOWN
TOP-DOWN
OF
DESIGN OF
VERIFICATION
TERMINAL
TERMINAL

RECEIVE, and DISPLAY are program
program stubs that will
Here KEYBOARD, TRANSMIT,
TRANSMIT, RECEIVE,
be expanded later. KEYBOARD,
example. could simµly
KEYBOARD, for example,
simply place a ten-digit
ten-digit verified
number
number into
into the appropriate
appropriate buffer.

Start

Kevboard

ACK =O

No

Transmit

Display

Receive

End

Figure 13-19. Initial
Flowchart for Transaction
Transaction Terminal
ln1t1alFlowchart

13-53

Start

VER =O

No

End
Complete= 0

Yes

KEVIN

Verify

KEYOS

KEYBOARD Routine
Figure 13-20. Flowchart
Flowchart for Expanded KEYBOARD

The next
next stage of expansion could
ing pro­
could produce
produce the following
program for KEYBOARD (see Figure
Figure 13-20):
13-20):
VER
VER =00
VER = 0
do while
hile VER
COMPLETE
COMPLETE== 0
do while
hile COMPLETE
COMPLETE== 00
KEYIN
KEYIN
KEYDS
KEYDS
end
VERIFY
VERIFY
end

EXPANDING
EXPANDING
THE
KEYBOARD
KEYBOARD
ROUTINE

VER = 0 means that an entry has not been verified;
Here VER
verified; COMPLETE
COMPLETE= 0 means that
KEYIN and KEYDS
the entry is incomplete.
incomplete. KEYIN
input and display
display routines
KEYDS are the keyboard input
respectively.
VERIFY checks the entry. A stub for KEYIN
KEYIN would
respectively. VERIFY
would simply
simply place a random
entry (from a random number
number table or generator!
generator) into the buffer
buffer and set COMPLETE
COMPLETE to
1..

We would continue by similarly expanding, debugging,
TRANSMIT,
debugging, and testing TRANSMIT,
RECEIVE, and DISPLAY. Note that
RECEIVE,
that you should
should expand each program
program by one
one level
program at any one
so that
that you do not perform the integration of an entire program
one time.
use your judgment
You must use
judgment in defining levels. Too small a step wastes
wastes time,
large a step gets you back to the problems of system integration that
w hile too large
top-down
top-down design is supposed
supposed to solve.
solve.
13-54
13-54

REVIEW OF TO P-DOWN DESIGN
DESIGN
Top-down
Top-down design
design brings
brings discipline
discipline to the testing
testing and integration
integration stages
stages of propro­
gram design.
systematic
flowchart
design. It provides
provides a system
atic method
method for
for expanding
expanding a flow
chart or probprob­
lem definition
definition to the
the level
level required
required to actually
actually write
rite a program.
program. Together
Together with
ith
structured
structured programming,
programming, it forms
forms a complete
complete set
set of design
design techniques.
techniques.
Like
top-downn design
Like structured
structured programming,
programming, top-dow
design is not
not simple.
simple. The designer
designer must
must
have defined
systematically
defined the
the problem
problem carefully
carefully and must
must work
ork system
atically through
through each
level.
level. Here again the
the methodology
methodology may seem tedious,
tedious, but
but the payoff
payoff can be subsub­
stantial
stantial if you follow
llo w the rules.
We recommend
following
recommend the follow
ing approach
approach to top-down
top-down
design:
design:

FORMAT
FOR
FORMAT FOR
TOP-DOWN
TOP-DOWN
DESIGN

Start w
with
basic flow
flowchart.
1) Start
ith aa basic
chart.
2) Make
Make the
the stubs
stubs as complete
complete and as separate
separate as possipossi­
ble.
3) Define
Define precisely
precisely all the
the possible
possible outcomes
outcomes from
from each stub
stub and select a test set
set.
4) Check
Check each
each level
level carefully
and systematically.
systematically.
carefully and
6) Use
Use the
the structures
structures from
from structured
5)
structured programming.
programming.
Expand each
each stub
stub by
by one
one level.
level. Do
Do not
not try
try to
to do
do too
too much
6) Expand
much In
in one
one step
step
71 W
Watch
for common
common tasks
tasks and
and data
data structures.
7)
atch carefully
carefully for
structures.
8) Test
Test and debug
debug after
after each stub
stub expansion.
expansion. Do not try to do an entire level at a
time.
time.
9) Be aware
aware of what
hat the hardware
hardware can do. Do not
not hesitate
hesitate to stop
stop and do a little
little
bottom-up
bottom-up design
design where
where that
that seems
seems necessary.
necessary.

1313-55

PROBLEM DEFINITION A ND PROGRAM DESIGN
REVIEW OF PROBLEM
DESIGN
You should
should note
note that
that we have spent
spent an entire
entire chapter
chapter w ith
o u t mentioning
mentioning any
ithout
specific microprocessor
microprocessor or assembly
assembly language,
specific
language, and w ith
o u t writing
ritin g a single
single line of
ithout
actual
actual code. Hopefully,
Hopefully, though,
though, you now
now know
know a lott more about
about the examples
examples than
you would
would have if wee had just
st asked you to write
rite the programs
programs at the start.
start.
Although
Although wee often
often think
think of the writing
ritin g of computer
computer instructions
instructions as a key
key part
part of
software
softw
are development,
development, it is actually
actually one of the easiest
easiest stages.
stages.
Once you have written
ritte n a few
w programs,
programs, coding
coding will
ill become
become simple.
simple. You willill soon
learn the instruction
instruction set, recognize
recognize which
which instructions
instructions are really
really useful,
useful, and
remember
remember the
the common
common sequences
sequences that
that make up the largest
largest part
part of most
most propro­
grams. You willill than
then find
find that
that many
many of the other
other stages
stages of softw
are development
development
software
remain
remain difficult
ifficu lt and have few
w clear
clear rules.
We have suggested
suggested here soma
some ways
ays to systematize
systematize the important
important early
early stages.
stages. In
the problem
problem definition
definition stage,
stage, you must
must define
define all the characteristics
characteristics of the
system
system -— its inputs,
inputs, outputs,
outputs, processing.
processing, timee and memory
memory constraints,
constraints, and error
handling.
handling. You must
must particularly
particularly consider
consider how
how the system
system willill interact
interact with
ith the
larger
larger system
system of which
which it is a part, and whether
hether that
that larger
larger system
system includes
includes
electrical
electrical equipment,
equipment, mechanical
mechanical equipment,
equipment, or a human operator.
operator. You must
must start
start
at this
this stage
stage to make the system
system easy to use and maintain.
maintain.
In the program
program design
design stage,
stage, several
several techniques
techniques can help you to system
atically
systematically
specify
specify and document
document the logic
logic of your
your program.
program. Modular
Modular programming
programming forces
forces you
to divide
divide the total
total program
program into
into small,
small, distinct
distinct modules.
modules. Structured
Structured programming
programming
provides
systematic
provides a system
atic way
ay of defining
defining the logic
logic of those
those modules,
modules, w h
ile top-down
top-down
hile
design
systematic
design is a system
atic method
method for integrating
integrating and testing
testing them.
them. Of course,
course, no one
can compel
compel you to follow
llo w all
alt of these
these techniques;
techniques; they
they are, in fact,
fact, guidelines
guidelines more
than anything
anything else. But
But they
they do provide
provide a unified
unified approach
approach to design,
design, and you
should
should consider
consider them
them a basis on which
which to develop
develop your
your own
own approach.
approach.

13-56
13
56

REFERENCES
1.
1.

Ballard. D.
D. R.,.. "Designing
Ballard,
"Designing Fail-Safe Microprocessor
Microprocessor Systems."
Systems," Electronics.
Electronics, January
4. 1979, pp. 139-143.
4,
"A Designer's Guide to Signature
Signature Analysis,"
Analysis," Hewlett-Packard
Application Note
Hewlett-Packard Application
CA. 1977.
1977.
222, Hewlett-Packard.
Hewlett-Packard, Inc., Palo Alto. CA,
E. S.
S. and M. D.
D. Lippman. "Efficient
icrocomputer
ReDonn. E.
fficient and Effective
Effective M icrocom
puter Testing Re­
EON. February 20,
20. 1979,
1979. pp. 97-107
quires CarefulI Preplanning."
Preplanning," EDN,
97-107 (includes self-test
-examples for 6502).
Gordon. G.
G. and H.
H. Nadig,
Nadig. "Hexadecimal
Gordon,
"Hexadecimal Signatures
Signatures Identify
Identify Troublespots
Troublespots in
Microprocessor
3. 1977,
1977. pp. 89-96.
Microprocessor Systems."
Systems," Electronics.
Electronics. March 3,
Neil. M. and R.
R. Goodner,
Goodner. "Designing
Neil,
"Designing a Serviceman's
Serviceman's Needs into MicroprocessorMicroprocessorBased Systems."
1. 1979,
1979. pp. 122-128.
Based
Systems," Electronics. March 1,
Schweber. W. and L.
L. Pearce.
Pearce. "Software
Schweber,
"Software Signature
Signature Analysis
Analysis Identifies
Identifies and Checks
PROMs." EDN.
EON. November
5. 1978,
1978. pp.
pp. 79-81.
PROMs,"
November 5,
Srini. V,
V. P.,.. "Fault
Srini,
"Fault Diagnosis of Microprocessor
Microprocessor Systems," Computer.
Computer, January
January 1977,
pp. 60-65.
pp.

2.

'Make Your
For a brief discussion of human factors considerations.
considerations, see G. Morns.
Morris, "Make
Next Instrum
Instrument
Emphasize User Needs and Wants."
EON. October
ent Design Emphasize
ants," EDN.
October 20.
1978. pp. 100-105.

3.

D. L.
L. Parnas (see
(see the references below) has been a leader in the area of modular
proD.
modular pro­
gramming.
gramming.

4.

Collected
B. W. Unger (see
(see reference below).
below).
Collected by B.

5.

Formulated
D. L.
L. Parnas.
Parnas.
Formulated by D.

following
proThe follow
ing references provide additional
additional information
information on problem definition
definition and pro­
gram design:
Chapin,
N., Flowcharts.
Flowcharts, Auerbach.
Auerbach, Princeton.
Princeton, N.
Chapin. N.
N. J.,.. 1971.
Dalton,
icrocom puter Software
Systematically,"
Dalton. W. F.,.. "Design
"Design Microcomputer
Software like Other Systems —
- Systematically."
Electronics.
19. 1978,
1978. pp.
pp. 97-101.
Electronics, January 19,

Dijkstra. E.
E. W., A Discipline
N. J.,..
Dijkstra,
Discipline of Programming.
Programming, Prentice-Hall.
Prentice-Hall, Englewood Cliffs.
Cliffs, N.
1976.
1976.
Halstead. M. H.,.. Elements of Software
Elsevier. New York,
York. 1977.
1977.
Halstead,
Software Science. American
American Elsevier,
Hughes. J.
J. K.
K. and J. I.I. Michtom.
Hughes,
ichtom, A Structured
Structured Approach
Approach to Programming.
Programming. Prentice-Hall.
Cliffs, N.
Englewood Cliffs.
N. J. 1977.
Morgan.
D. E.
E. and D.
D. J. Taylor.
Morgan, D.
Taylor, "A Survey of Methods
Methods for Achieving
Achieving Reliable Software,"
Software,"
Computer. February 1977,
1977. pp. 44-52.
Computer.
Myers. W.,.. "The
pp. 12-25.
Myers,
"The Need for Software
Software Engineering."
Engineering," Computer.
puter. February 1978. pp.
Parnas,
Decomposing Systems into Modules:·
Modules." ComCom­
Parnas. D.
D. L.,
L.. "On the Criteria to be Used in Decomposing
munications
Qfthe ACM
ACM., December 1972,
1972. pp. 1053-1058.
-munications of
1053-1058.

Parnas. D.
D. L."A Technique
Examples."
Parnas,
Technique for the Specification
Specification of Software
Software Modules
Modules with
ith Examples,"
Communications
Qfthe ACM., May 1973,
1973. pp. 330-336.
Communications of
330-336.
Phister,
Technology and Economics.
Economics, Santa Monica Publishing
Publishing
Phister. M. Jr.,.. Data Processing Technology
Co.,.. Santa Monica.
CA. 1976.
Monica, CA,

Schneider.
ForSchneider, V.,.. "Prediction
"Prediction of Software
Software Effort and Project Duration
Duration -— Four New For­
mulas," SJGPLAN
Notices. June 1978,
mulas."
SIGPLAN Notices.
1978. pp. 49-59.
1 3-57
57

B. et al.,
al.. "Experimental
FlowShneiderman, B.
"Experimental Investigations
Investigations of the Utility
tility of Detailed Flow­
charts in Programming,”
Programming." Communications
Communications~ of the ACM, June 1977, pp.
pp. 373-381.
Tausworthe. R.
R. C.,
C., Standardized Development of Computer
Tausworthe,
Computer Software.
Software, Prentice-Hall.
Cliffs. N.
N. J.,.. 1977.
1977.
Englewood Cliffs,
Unger, B.
B. W., "Program
"Programming
Unger,
ming Languages for Computer System Simulation."
ulation," Simulation.
Simulation,
April 1978, pp. 101-110.
April
Algorithms+
Structures== Programs,
Programs. Prentice-Hall,
Prentice-Hall. Englewood Cliffs,
Wirth.
irth, N.,.. Algorithm
s + Data Structures
Cliffs.
N. J.,
1976.
N.
„ 1976"
Cliffs.
Wirth.
irth, N.,.. Systematic
Systematic Programming;
Programming; an Introduction.
Introduction, Prentice-Hall.
Prentice-Hall, Englewood Cliffs,
N. J „.. 1973.
1973.
N.
Yourdon. E.
E. U.,.. Techniques of Program Structure
Design. Prentice-Hall,
Prentice-Hall. Englewood
Yourdon,
Structure and Design,
Cliffs. N.
N. J.. 1975.
1975.
Cliffs,

13-58

Chapter 14
DEBUGGING AND TESTING
As we noted at the beginning
beginning of the previous chapter.
chapter, debugging
debugging and testing are
among the most time-consuming
e-consuming stages of software
software development.
development. Even though such

methods as modular programming, structured programming, and top-down
top-down design
errors. debugging and testing
can simplify programs and reduce the frequency
frequency of errors,
still are d ifficult
u lt because they are so poorly defined. The selection of an adequate set
process. Finding
of test data is seldom a clear or scientific
scientific process.
Finding errors sometimes seems like a
progame of "pin
in the tail on the donkey,"
donkey,” except
except that
that the donkey is moving and the pro­
grammer
Surely. few tasks are as frustrating
grammer must position
position the tail by remote control. Surely,
frustrating as
debugging
debugging programs.

This chapter
chapter will
ill firstt describe the tools available to aid in debugging. It will
ill then
discuss basic debugging procedures, describe the common types of errors,
errors. and
discuss
present
present some examples
examples of program debugging. The last sections will
ill describe
how to select
programs.
select test
st data and test
st programs.
tools.
We will
ill not do much more than describe the purposes of most of the debugging
debugging tools.
area. and not enough space to discuss all the
There is very little
little standardization
standardization in this area,
devices and programs that
that are currently
currently available. The examples should give you some
uses. advantages.
llm11at1ons
idea of the uses,
advantages, and lim
itations of particular
particular hardware or software
software aids.

SIMPLE
PLE DEBUGGING TOOLS
simplest debugging tools available are:
The simplest
• A single-step
single-step facility
facility
< A breakpoint
breakpoint facility
facility
• A Register
Register Dump program (or utility)
• A Memory
Memory Dump program
SINGLEThe single-step
cility
single-step fa c
ility allowss you to execute
execute the program one
STEP
step at a time. Most 6502-based
6502-based microcomputers
icrocomputers have this
facility.
course. the only
facility, since the circuitry
circuitry is fairly simple. Of course,
things that
that you will
ill be able to see when
when the computer
computer executes
executes a single-step
single-step are
states of the output
output lines that
that you are monitoring. The most important
portant lines are:
the states
are:
• Data Bus
• Address Bus
■ Control
Control Ii
lines
nes

SYNC (synchronization)
READ/WRITE
• SYNC
(synchronization) and READ/WRITE
If you monitor these lines (either
(either in hardware
hardware or in software).
software), you will
ill be able to
addresses, instructions.
instructions, and data as the program executes.
executes.
see the progression of addresses.
You will
ill be able to tellll what
h at kind of operations the CPU is performing. This inforinfor­
mation will
ill inform
inform you of such errors as incorrect
incorrect Jumpp instructions.
instructions, omitted
omitted or incorincor­
operation codes,
incorrect data values.
rect addresses,
addresses, erroneous operation
codes. or incorrect
values. However,
However. you can­
cancontents of registers and flags w ith
o u t some additional
additional debugging
debugging facility
facility
not see
see the contents
ithout
or a special sequence of instructions.
instructions. Many of the operations
operations of the program cannot be
checked in real time.

14
14-1

There are many errors that a single-step
single-step mode cannot
LIMITATIONS
cannot help you
LIMITATIONS
to find. These include
include timing
ing errors and errors in the interrupt
interrupt
OF SINGLEOMA systems. Furthermore.
or DMA
Furthermore, the single-step
single-step mode is very
STEP MODE
slow. typically
less than one millionth
slow,
typically executing
executing a program at less
illionth
of the speed of the processor itself. To single-step
single-step through
through one second of real
real processor
time would
days. The single-step
is useful only to check the
would take more than ten days.
single-step mode is
logic of short instruction
sequences.
instruction sequences.

I

program will automatA breakpoint is a place at which the program
| bre
AKPOINTJ
BREAKPOINT!
ically halt or wait
a it so thatt the user can examine the current
status of the system. The program
program will
reill usually not start again until the operator re­
pass through
quests a resumption of execution.
execution. Breakpoints
Breakpoints allow you to check or pass
through an
Thus. to see
see if an initialization
correct. you can
entire section of a program. Thus,
initialization routine is correct,
place a breakpoint
breakpoint at the end of it and run the program. You can then check memory
locations and registers to see if the entire section is correct. However,
However. note that if the
section is not correct,
correct. you’
you'lll still
error, either with earlier break­
still have to pin down the error,
breakpoints or with
mode.
ith a single-step
single-step mode.
Breakpoints complement
complement the single-step mode.
mode. You can use
use breakpoints either to
localize the error or to pass through sections that you know are correct. You can
can
mode. In some cases,
cases, breakpoints
then do the detailed
detailed debugging in the single-step mode.
ut/output
do not affect
affect program timing;
ing; they can then be used to check in p u
t/o u tp u t and interinter­
rupts.
Breakpoints often use part or all of the microprocessor
BRK AS A
BRK
microprocessor interrupt
interrupt
BREAKPOINT
system. Some microprocessors
microprocessors have a special Software Interrupt
Interrupt
or Trap facility
facility that
that can act as a breakpoint. The 6502 BRK
BRK (Force
(Force
Break) instruction
Break)
instruction can be used in this way. If you are not already using the maskable in­
interrupt
(IRO) and the non-maskable interrupt
(NMil in your system,
system. you can use those
terrupt (IRQ)
interrupt (NMI)
vectors as externally
externally controlled
controlled breakpoints. Table 14-1
14-1 gives the address locations of
the 6502 interrupt
interrupt vectors. Chapter
Chapter 12 describes the vectors in more detail. The break­
breakpoint
conpoint routine can print
print register and memory contents, or just waitit (by executing
executing a con­
dition
dition jumpp dependent
dependent on a switch
switch input) u ntil
til the user allows the computer
computer to pro­
proceed. But remember
BRK)use the Stack and Stack Pointer
ceed.
remember that the interrupts
interrupts (including
(including BRK)
Register. Figure 14-1
to store the return address and the Status Register.
14-1 shows a routine in
BRK results in an endless loop. The programmer
breakwhich
hich BRK
programmer would
would have to clear this break­
point
RESETor interrupt
signal.
point with
ith a RESET
interrupt signal.
Table 14-1. 6502 Interrupt
Interrupt Vectors

Input

Vector
Vector Addresses (Hexadecimal)

n
m
NMI

FFFA, FFFB
FFFB
FFFA,
FFFC, FFFD
FFFD
FFFC,
FFFE,FFFF
FFFF
FFFE,

RESET
RESET
!RO or BRK
IRQ
BRK

•=BREAK
*=BREAK
JMP
BREAK
BREAK

;ADDRESS FOR
FOR BREAK
BREAK ROUTINE
ROUTINE
;ADDRESS
;WAIT
PLACE
;WAIT IN PLACE

The interrupt
BREAKwhen it finds
interrupt service routine
routine must
must force
force a jump
jump to address BREAK
the Break Command
Command flag set (this differentiates
differentiates between BRK
BRK and an IRQ
!RO input).
14-1. A Simple Breakpoint
Figure 14-1,
Breakpoint Routine

14-2

The simplest
simplest method for inserting
inserting breakpoints
breakpoints is to replace the first
first byte of the instruc­
instruction with
BRK instruction
ith a BRK
instruction or to replace the instruction
instruction with
ith a JMP or JSR
instruction.
JSR instruction.
BRK instruction
The BRK
instruction is preferable since only a single byte must be replaced and the
breakpoint
breakpoint will
ill not overrun the subsequent
subsequent instructions.
instructions.
Many monitors
onitors have facilities
facilities for inserting
inserting and removing
INSERTING
INSERTING
breakpoints
breakpoints implemented
plemented via some type of Jumpp instruction.
BREAKPOINTS
1nstruct1on
Such breakpoints
breakpoints do not affect
affect the timing
ing of the program until
until
However. note that
the breakpoint
breakpoint is executed. However,
that this procedure
procedure will
ill not work if part or all
ROM or PROM.
PROM. Other monitors
of the program is in ROM
onitors implement
plement breakpoints
breakpoints by actually
actually
checking
checking the address lines or the Program Counter
Counter in
in hardware or in software. This
method allows breakpoints
1nROM
ROM or PROM,
breakpoints on addresses in
affect the timing
ing
PROM. but it may affect
if the address must be checked in software. A more power!u
powerful fac,hty
cility would
would allow the
user to enter an address to which
hich the processor would
would transfer control. Another
Another
possibility
possibility would
would be a return dependent
dependent on a sw,tch
switch:
*=BRKPT
VIAORA
BIT
VIAORA
BPL
BRKPT
BPL
BRKPT
RTI
RT!

.ADDRESS FOR
FOR BREAKPOINT
BREAKPOINT ROUTINE
:ADDRESS
ROUTINE
;WAIT
FORSWITCH
SWITCH TO
:W
AIT FOR
TO CLOSE
CLOSE

course. other VIA data or control
Of course,
control lines could also be used. Remember that
that RTI
RT! auto­
automatically
atically restores the Status register and re-enables the interrupt
interrupt. IfI the interrupt
interrupt comes
line. the routine
from a VIA control
control line,
routine would
would also have to clear the corresponding
corresponding bit in the
Interrupt
Interrupt Flag register.
register.

14-3

program that
A Register Dump utility on a microcomputer is a program
REGISTER
REGISTER
information
lists the contents of all the CPU registers. This inform
ation is
DUMPS
usually not directly
usually
directly obtainable.
obtainable. The following
ing routine will
ill print
PRTHEX
the contents of all the registers on the system printer, if we assume
assume that
that PRTHEX
prints
Accumulator
prints the contents
contents of the Accum
ulator as twoo hexadecimal
hexadecimal digits.
digits. Figure
Figure 14-2 is a
flowchart
flow
chart of the program
program and Figure
Figure 14-3 shows
shows a typical
typical result. We assume
assume that
that the
routine
routine is entered
entered with
ith a JUMP TO SUBROUTINE instruction
instruction that
that stores the old Program
Program
Counter
BAK instruction
ProCounter at the top of the Stack. An interrupt
interrupt or BRK
instruction will
ill store both
both the Pro­
gram Counter
Counter and the Status
Status register
register at the top of the Stack.

; PLACE ALL CPU REGISTER
REGISTER CONTENTS IN STACK (PC
(PC ALREADY
ALREADY ON STACK)
PHP
PHP
PHA
TXA
PHA
TYA
PHA
TSX
TXA
CLC
ADC
PHA

;SAVE STATUS IF NECESSARY
NECESSARY (NOT AFTER
AFTER IRO)
;SAVE CONTENTS OF ACCUMULATOR
ACCUMULATOR
;SAVE INDEX REGISTER
REGISTER X
;SAVE INDEX REGISTER
REGISTER Y
;SAVE ORIGINAL STACK POINTER
POINTER

#6

;OFFSET BACK TO ORIGINAL VALUE
;OFFSET

; PRINT CONTENTS OF REGISTERS
REGISTERS
; ORDER
ORDER IS S,
S, Y, X, A, P,
P, PC(LOW),
PC(LOW). PC(HIGH)
PC(HIGH)

PRNT1
PRNT1

LDY
LOY
LDA
LOA
JSR
INX
DEY
BNE

#7
#7
$0100,X
$0100.X
PRTHEX
PRTHEX

;NUMBER OF BYTES== 7
;GET A BYTE FROM STACK
;AND
AND PRINT IT

PRNT1
PRNT1

; RESTORE
RESTORE REGISTERS
REGISTERS FROM STACK
PLA
PLA
TAY
PLA
TAX
PLA
PLP
RTS
RTS

;PULL
;PULLAND
AND DISCARD
DISCARDSTACK
STACKPOINTER
POINTER
iRESTORE
;RESTOREINDEX
INDEXREGISTER
REGISTERYY
;RESTORE
;RESTOREINDEX
INDEXREGISTER
REGISTERXX

;RESTORECONTENTS
CONTENTS OF
OFACCUMULATOR
ACCUMULATOR
;RESTORE
;RESTORE
:RESTORESTATUS
STATUS REGISTER
REGISTERIFIFNECESSARY
NECESSARY
;RESTORE
;RESTOREPC
PCAND
AND SP
SP

14
14-4

Stan

Store all registers
in Stack
Count = 7 (number
of bytes in registers)
Base= 0100 16
Index = Stack
Pointer+ 1

Print (Base+tndex)
as 2 hexadecimal
digits

Index = Index + 1
Count = Count - 1

Restore all registers

from Stack

End

Figure 14-2. Flowchart
Flowchart of Register Dump Program

(S)
(Y)
(X)
(A)
(P)
(PCL)
(PCH)

A6

05
08
3E
24
15

A2

Figure 14-3. Results of a Typical 6502 Register Dump

14-5
14

program that
A Memory
Memory Dump is a program
that lists the contents of memomemo­
MEMORY
MEMORY
(such as a printer). This is a much more
ry on an output device (such
DUMP
DUMP
efficient
efficient way to examine data arrays or entire programs than just
looking at single locations. However,
However. very large memory dumps
dumps are not useful (except
paper) because of the sheer mass
mass of inform
information
to supply scrap paper)
ation that they produce.
produce.
They may also take a long time to execute on a slow printer. Small dumps may,
however. provide the programmer with a reasonable
reasonable amount of information that
however,
can be examined as a unit. Relationships such
such as regular repetitions
repetitions of data pat­
patterns or offsets of entire arrays may become obvious.
obvious.
ifficult
A general dump is often rather d iffic
u lt to write. The programmer
programmer should be careful of
the follow
ing situations:
situations:
following
11 The size
size of the memory area exceeds 256 bytes,
1)
counter will
ill not
bytes. so that an 8-bitit counter
suffice.
2)

The ending location
location is an address smaller than the starting
starting location. This can be
error. or simply
treated as an error,
ply cause no output.
output, since the user would
would seldom want
want to
print
print the entire memory contents
contents in an unusual order.
order.

Since the speed of the Memory
Memory Dumpp depends on the speed of the output
output device,
device. the
efficiency
efficiency of the routine seldom matters. The following program will
ill ignore
ignore cases

where the starting address
address is larger than the ending address,
address, and will handle
handle
blocks of any length. We assume that the starting
starting address is in memory addresses
addresses
START and START+l
START
START+1 and the ending
ending address is in memory addresses
addresses LAST and
LAST+l. We have assumed that addresses START
START and START+l
LAST+1.
START+1 are on page zero,
zero. so
tht their contents
contents can be used indirectly.
indirectly.
PRINT CONTENTS
CONTENTS OF
OF SPECIFIED
SPECIFIEDMEMORY
MEMORY LOCATIONS
LOCATIONS
: PRINT
DUMP
DUMP
DBYTE
DBYTE

DONE
DONE

LDY
LDY
LDA
CMP
CMP
LDA
SBC
SBC
BCC
BCC
LDA
JSR
JSR
INC
INC
BNE
BNE
INC
INC
JMP
RTS
RTS

#0
:11=0
LAST
LAST
START
START
LAST+1
START+1
DONE
DONE
(START).Y
(START).Y
PRTHEX
PRTHEX
START
START
DBYTE
DBYTE
START+1
DBYTE
DBYTE

:KEEP OFFSET
OFFSETAT ZERO
;KEEP
ZERO ALWAYS
;ARE WE BEYOND
BEYOND FINAL ADDRESS?
ADDRESS?
:ARE

:YES. DUMP COMPLETED
:YES.
COMPLETED
;NO. GET
GET CONTENTS
CONTENTS OF
OF NEXT
NEXT LOCATION
LOCATION
;NO.
:PRINT CONTENTS
CONTENTS AS 2 HEX
HEX DIGITS
DIGITS
;PRINT
:INCREMENT MEMORY
INCREMENT
MEMORY POINTER
POINTER

There is no direct
direct way to perform the 16-bit
16-bit comparison
comparison and increment
increment that this routine
requires.
requires.

Figure 14-4
Figure
14-4 shows the output from a dump of memory locations 1000
1000 to 101F.
23 1F
6E 42
6E
47 36
34 ED
ED

60
38
23
BC
BC

54
17
81
AF
AF

37 28
59 44
El
FF
E1 FF
FE FF
FE
FF

3E
3E
98
FF
FF
27

00
37
5A
SA
02

Figure 14-4. Results of a Typical
Typical Memory Dump

14-6
14

case in which
are
This routine correctly
correctly handles the case
hich the starting
starting and ending locations are
it!}. You will
the same (try it!).
ill have to interpret
interpret the results carefully
carefully if the dump area
area in­
inStack. PRTHEX
PRTHEX may also
cludes the Stack, since the dump subroutine
subroutine itself uses the Stack.
change memory and Stack locations.
In a memory dump.
dump, the data can be displayed in a number
number of different
different ways. Common
ASCII characters
hexforms are ASCII
characters or pairs of hexadecimal digits
digits for 8-bitit values and four hex­
adecimal digits
digits for 16-bit
16-bit values. The format
at should be chosen based
based on the intended
use of the dump. It is almost
almost always easier to interpret
interpret an object
object code dump if
1f itIt is
Is dis­
disASCII form.
played in hexadecimal
hexadecimal form rather than ASCII
A common
common and useful dump format
at is illustrated
illustrated here:
here:
1000

54 68 65 20 64 75 6D 70

The dump

Each line consists of three parts.
parts. The line starts with
Each
ith the hexadecimal
hexadecimal address of the
first
first byte displayed on the line. Following
Following the address are eight
eight or sixteen bytes disdis­
ASCII representation
played in hexadecimal
hexadecimal form. Last is the ASCII
representation of the same eight
eight or six­
sixbytes. Try rewriting
teen bytes.
riting the memory dump program so that it will
ill print
print the address and
ASCII characters
the ASCII
characters as well as the hexadecimal
hexadecimal form of the memory contents.

1 4-7

MORE A D VANCED
NC ED DEBUGGING TOOLS
The more advanced debugging tools that
that are most w idely
e ly used are:

programs to check program
program logic
logic
• Simulator programs
Logic analyzers to check signals and timing
• Logic
Many variations
variations of both these tools exist, and we shall discuss only the standard
features.
res.

SOFTWARE
The simulator is the computerized
computerized equivalent
equivalent of the pencil-andpencil-andSIMULATOR
paper computer.
program that
SIMULATOR
computer. It is a computer program
that goes through the
operating cycle of another computer, keeping track of the concon­
tents of all
ail the registers, flags, and memory locations. We could, of course.
course, do this
hand. but
by hand,
but it would
would require a large amount
amount of effort
effort and close attention
attention to the exact
effects
never gets tired or confused.
effects of each instruction.
instruction. The simulator
ulator program
program riever
confused, forgets
forgets
register. or runs out of paper.
paper.
an instruction
instruction or register,
Most
FORTRAN programs. They can be purchased or used on the
Most simulators
simulators are large FORTRAN
time-sharing
time-sharing services. The 6502
6502 simulator
ulator is available in several versions from different
different
sources.
rces.

Typical simulator features
features are:
1)

A breakpoint facility. Usually, breakpoints
breakpoints can be set after
after a particular
particular number
number of
cycles have been executed.
executed, when
when a memory
memory location
location or one of a set of memory
locations
locations is referenced.
referenced, when
when the contents
contents of a location
location or one of a set of locations
are altered, or on other
other conditions.
conditions.
Register and
andmemory
memory dump
dumpfacilities
facilities that
that can
can display
display the
the values
valuesofofmemory
memory loca2) Register
loca­
tions. registers,
registers. and I/O
1/0 ports.
tions,
trace fa
facility
that wwill
print the
the contents
contents of
of particular
particular registers
registers or
or memory
memory loca3) AA trace
cility that
ill print
loca­
tions whenever
whenever the program
program changes or uses them.

load fa
facility
that allows
allows you
you to
to set
set values
values initially
initially or
or change
change them
them during
during the
the
4) AA load
cility that
simulation.
simulation.
Some simulators
ulators can also simulate
simulate input/output.
input/output, interrupts.
interrupts, and even OMA
DMA.

The simulator has many advantages:
1)
1)

It can provide
provide a complete
complete description
description of the status of the computer.
computer, since the
simulator
ulator program
program is not restricted
restricted by pin limitations
itations or other
other characteristics
characteristics of the
underlying circuitry.
circuitry.
underlying

2)

It can provide
provide breakpoints.
breakpoints, dumps.
dumps, traces, and other
other facilities.
facilities, without
ith o u t using any of
processor'ss memory space or control
the processor’
control system. These facilities
facilities will
ill therefore
therefore not
interfere
interfere with
ith the user program.

3) Programs,
Programs. starting
starting points,
points. and
and other
other conditions
conditions are
are easy
easy to
to change.
change.
4) AAll
ll the
the facilities
facilities of
of aa large
large computer,
computer. including
including peripherals
peripherals and
and software,
software. are
are availa­
available to the microprocessor
microprocessor designer.

On the other hand, the simulator is limited by its software
are base and its separation
from the real microcomputer. The major limitations are:
1)
1)

The simulator
cannot help with
ulator cannot
ith timing
ing problems.
problems, since it operates far more slowly
slowly
than real time and does not model actual
actual hardware or interfaces.
2)
ulator cannot
cannot fully
lly model the in p u
t/o u tp u t section.
21 The simulator
put/output
The sim
simulator
is usually
usually quite
quite slow.
slow. Reproducing
Reproducing one
one second
second of
of actual
actual processor
processor
3) The
ulator is
time may require hours of computer
puter time. Using the simulator
ulator can be quite
quite expen­
expensive.
sive.

14-8
14

are side of debugging; it has the typical advanadvan­
The simulator represents the software
tages and limitations of a w holly
approach. The simulator can pro­
proolly software-based
software-based approach.
are problems, but cannot help with
vide insight into program logic and other software
timing.
problems.
timing, 1/0.
I/O, and other hardware problems.

The logic or microprocessor analyzer
LOGIC
LOGIC
analyzer is the hardware solution
to debugging.
analyzer is the parallel digital verver­
debugging. Basically, the analyzer
ANALYZER
sion of the standard oscilloscope.
analyzer displays
displays informainforma­
oscilloscope. The analyzer
tion in binary, hexadecimal
CRT. and has a variety
hexadecimal or mnemonic
mnemonic form on a CRT,
variety of triggering
triggering
events.
events, thresholds.
thresholds, and inputs. Most
Most analyzers also have a memory so that they can disdis­
play the past contents
busses.
contents of the busses.
The standard
standard procedure
procedure is to set a triggering
triggering event.
event, such as the occurrence
occurrence of a particuparticu­
Bus. For example,
example. one might
lar address on the Address
Address Bus or instruction
instruction on the Data Bus.
ight
trigger
icrocomputer
extrigger the analyzer if the m icrocom
puter tries to store data in a particular
particular address or ex­
ecute an input
input or output
output instruction.
instruction. One may then look at the sequence
sequence of events that
preceded the breakpoint
breakpoint. Common problems you can find in this way
ay include
include short
noise spikes (or glitches), incorrect signal sequences, overlapping wave-forms,
noise
wave-forms,
and other timing or signaling errors.
are simulator could
errors. Of course, a software
could not be
could conveniently
used to diagnose those errors any more than a logic analyzer could
conveniently
logic.
be used to find errors in program logic.

Logic analyzers vary in many respects. Some of these are:
1)
1)

Number
Number of input
input lines. Att least 24 are necessary to monitor
monitor
an 8-bit
-b it Data Bus and a 16-bit
16-bit Address
Address Bus
Bus. Still
till more are
necessary for control
control signals.
signals, clocks, and other
other important
portant inin­
puts.

IMPORTANT
IMPORTANT
FEATURES
FEATURES
LOGIC
OF LOGIC
ANALYZERS

2)

Amount
ount of memory. Each previous
previous state that is saved will
ill occupy
occupy several bytes.

3)

processors.
Maximum
aximum frequency.
frequency. It must
must be several MHz to handle the fastest
fastest processors.

4)

inimum
M inim
um signal
signal width
id th (important
(important for catching
catching glitches).
Type and number
number of triggering
triggering events
events allowed. Important
portant features are pre- and
post-trigger delays: these allow
allow the user to display
display events occurring
occurring before or
post-trigger
after
after the trigger
trigger event.
Methods
rather complex
complex
ethods of connecting
connecting to the microcomputer.
microcomputer. This may require a rather
interface.
Number
Number of display
display channels.
Binary, hexadecimal
hexadecimal or mnemonic
mnemonic displays.

5)

6)
7)
8)
10)

9)

Display
Display formats.
Signal
Signal hold time requirements.
requirements.

11)
12)

Probe capacitance.
capacitance.
Single
Single or dual thresholds.
thresholds.

In comparing
Allll of these factors
factors are important
portant in
comparing different
different logic and microprocessor
microprocessor
analyzers. since these instruments
analyzers,
instruments are new and unstandardized.
unstandardized. A tremendous
tremendous variety
products is already
already available
available and this variety
variety will
ill become even greater
greater in the future.
of products
course. are necessary only for systems with
Logic analyzers, of course,
ith complex timing.
Simple applications with
ith low-speed
low-speed peripherals have few
w hardware problems that
a designer cannot handle with
oscilloscope.
ith a standard oscilloscope.

14-9
14

DEBUGGING WITH
H CHECKLISTS
The designer
designer cannot
cannot possibly check an entire program by hand;
hand: however,
however. there are
certain
certain trouble
trouble spots that the designer
designer can easily check. You can use
atic hand
use systematic
hand

large number of errors w ithout
checking to find a large
o u t resorting to any debugging
debugging tools.
tools.
The question is where to place the effort. The answer
on
answer is on
WHAT
WHAT TO
points that
that can be handled with
ith either
either a yes-no anwer
anwer or with
INCLUDE IN
a simple arithmetic
etic calculation. Do not try to do complex
CHECKLIST
arithmetic. follow
follow all the flags,
flags. or try every conceivable
arithmetic,
conceivable case.
it
case. Lim
L1m1t
your hand checking
Leave the complex problems
checking to matters that can be settled easily
easily. Leave
to be solved with
ith the aid of debugging
debugging tools. But proceed systematically:
systematically; build your
checklist.
checklist, and make sure that the program performs the basic operations correctly.
The first step is to compare the flowchart
cha rt or other program
program documentation w ith
code. Make sure that everything
the actual code.
everything that appears in one also appears in
1n the
other. A simple checklist
checklist will
ill do the job. It is easy
completely omit a branch or a pro­
easy to completely
processing section.

Next
program loops.
loops. Make sure that all registers and memory
ext concentrate on the program
locations used inside the loops are initialized
1nit1altzedcorrectly. This is a common source of er­
errors: once again,
again. a simple checklist
rors;
checklist will
ill suffice.
Now look at each conditional branch.
case that should produce a
Now
branch. Select a sample case
branch and one that should not;
not: try both of them.
them. Is the branch correct
reversed? If
correct or reversed?
the branch involves checking
checking whether
hether a number
number is above or below a threshold,
threshold. try the
equality
1sconsistent
equality case
case. Does the correct
correct branch occur? Make sure that your choice is
defin1t1on
with
ith the problem definition.
loops as a whole. Try the first and last iterations
Look at the loops
iterations by hand,
hand. these are
are often
troublesome
1szero;
zero: i.e.,.. there
troublesome special cases
cases. What
a t happens if the number of iterations
iterations is
there
Prois no data or the table has no elements? Does the program fall through
through correctly?
correctly? Pro­
grams often will
ill perform one iteration
iteration unnecessarily.
unnecessarily, or.
decrement coun­
or. even worse,
worse. decrement
counters past zero before checking
checking them.
assume (hopefully)
(hopefully) that
Check off everything
everything down to the last statement.
statement. Don't assume
program. Hand checking will
the first error is the only one in the program.
ill allow you to get
runs, since
since you will
rid of many simple
the maximum benefit
benefit from debugging runs,
ill get rid
simple
errors ahead of time.
A quick
quick review of the hand checking
checking questions:

HAND
CHECKING
QUESTIONS

1)

Is every element
element of the program design in the
the program (and
(and
vice versa for documentation
documentation purposes)?

2)

Are all registers and memory locations used
used inside loops initialized before they
used?
are used?
Are all conditional
conditional branches logically
logically correct?
Do all loops start and end properly?
cases handled correctly?
Are equality
equality cases
correctly?
Are trivial
cases handled correctly?
trivial cases

3)
3)
4)
5)
6)

14-100
14

LOOKING
ERRORS
LOOKING FOR ERRORS
COMMON
Of course, despite all these precautions (or if you skip over
COMMON
ERRORS
ERRORS
some of them).
them), programs often still don't
don't work. The designer
is left
hand
ft with
ith the problem of how to find the mistakes. The hand
checklist
checklist provides a starting place if you didn't
didn't use it earlier; some of the errors
that you may not have eliminated
eliminated are:
that
Failure to
to initialize
1) Failure
initialize variables
variables such
such as
as counters,
counters, pointers,
pointers, sums,
sums, indexes,
indexes, etc.
etc.
Do not assume that
locations. or flags necessarily contain
that the registers.
registers, memory locations,
used.
zero before they are used.
Inverting the
2) Inverting
the logic
logic of
of aa conditional
conditional jump,
jump, such
such as
as using
using Branch
Branch on
on Carry
Carry Set
Set
when
when you mean
mean Branch
Branch on
on Carry
CarryClear
Clear. Be
Be particularly
particularly careful
careful of
of the
the fact
fact that
that the
the
6502 (unlike most other microprocessors) uses
uses the Carry as an inverted borrow
alter
after a subtraction
subtraction or comparison. So the effects of a comparison
comparison or subtraction
subtraction are
Accumulator.
as follows
follows (A is the contents
contents of the Accum
ulator, M the contents
contents of the memory
location):
Zero flag = 1 if A = M
Zero flag== 00 if A £
l=M
M
Carry flag = 1 if1fA >
L M
Carry flag =00 if
1fA< < M
11A== M (the equality case)
case: So Branch on Carry
Note particularly
particularly that Carry== 1 if
Set means jum
Jump
Jump
p if A ?
> Mand
and Branch on Carry Clear means jum
p if11A < M. If you
side. try either reversing the roles of A and Mor
want
ant the equality
equality case on the other
other side,
or
adding
Jump
L 10 use
adding 1 to M. For example.
example, if,I you want
ant a jum
p if11A >
CMP
BCS
BCS

#10
10
ADDR

> 10 use
use
If. on the other hand,
hand. you want
Jump
If,
ant a jum
p if A >
CMP
BCS
BCS

#11
ADDR

3)

Updating counters, pointers, and indexes in the wrong place or not at all. Be
Be
sure that there are no paths through
through a loop that either
either skip or repeat the updating
updating
instructions.
instructions.

4)

buffer. no
Failure totofall
fallthrough
throughcorrectly
correctlyinintrivial
trivia lcases
casessuch
suchas
as no
no data in
in aa buffer,
no
tests to beberun.
assume that
such cases
cases w
will
run,or no entries in a transaction. Do notassume
that such
never occur
occur unless the program specifically
specifically eliminates
eliminates them.

Other
Other problems to watch
atch for are:
5)

6)

instructions like TAX move the
Reversing the order of operands.
operands. Remember that instructions
contents
contents of A to X. not the other
other way around.

Changing condition flags before you use them.
Almost
ost all instructions
instructions except
except stores and branches affect
affect the Sign and Zero flags.
Note especially
PLP and RTI
RTI may change all the flags.
flags.
especially that
that PLP

7)

Confusing the Index
Index registers and the indexed memory location.
Note that
that INX and INY increment
increment the Index registers while
hile INC ADDR.X and other
similar
similar instructions
instructions increment
increment the contents
contents of an indexed memory location.

B)
8)

Confusing data and addresses.
Remember that
$40
that LDA # $
4 0 loads A with
ith the number
number 4015.
40-)g. w hile
ile LDA $40 loads A
with
ith the contents
contents of memory location
location 004015.
0040-]g. Be particularly
particularly careful when using
the pre-indexed
addresses
pre-indexed and post-indexed
post-indexed addressing modes in which
which a pair of addresses
on page zero contains
contains the actual or base address of the data.
data.

14-11
14-

9)

Accidentally
Accidentallyreinitializing
reinitializingaaregister
registerorormemory
memorylocation.
location.
initial1zat1on state­
Make sure that no Jumpp instructions
instructions transfer control
control back to initialization
statements.
ments.

10)
10)

Confusing numbers and characters.
ASCII and EBCDIC
EBCDIC representations of digits
Remember that the ASCII
digits differ
differ from the
digits
example. ASCII
ASCII 7 is
digits themselves. For example,
iq , whereas hex 0716
07-|g is
Is 3 715.
,s the ASCII
ASCII
BELL character.
BELL

11)
11)

numbers.
Confusing binary and decimal numbers.
Remember that the BCD representation
representation of a number
number differs from its
,ts binary repre­
repreBCD 36,
36. when treated as
as a simple hexadecimal constant,
sentation. For example. BCD
constant.
itl.
is equivalent
equivalent to 54 decimal (try it).

12)
12)

13)
13)

Reversing the order in subtraction. Be careful also with
ith other operations (like
(like
division) that
division)
that do not commute. Remember that SBC,
SBC. CMP,
CMP. CPX,
CPX. and CPY
CPY all
subtract
From the contents
subtract the contents
contents of the addressed memory location from
contents of the
Accum
ulator or Index register
register.
Accumulator
macros.
Ignoring the effects
effects of subroutines and macros.
Don't
on't assume that calls to subroutines
subroutines or invocations
invocations of macros will
ill not change
flags. registers,
registers. or memory locations. Be
Be sure of exactly what
flags,
hat effects subroutines
have. Note that it11is
,s very important
these effects so
or macros have.
portant to document
document these
so that
ithout
the user can determine
determine them w ith
o u t going through
through the
the entire listing.

14)
14)

15)
15)

Using the Shift
hift instructions improperly.
Remember the precise effects of ASL,
ASL. LSR.
LSR. ROL,
ROL. and ROR.
ROR They are 1-bit shifts
that affect
Carry. Sign,
Sign. and Zero flags.
flags. ASL and LSR
affect the Carry,
LSR both clear the empty bit;
ROR and ROL
ROL are circular
ROR
circular shifts that
that include the Carry in the circular
circular register.
register.
Carry. Sign,
Sign. and Zero flags are affected even if these instrucRemember that the Carry,
instruc­
tions are applied
applied to the data in a memory location.
Counting the length of an array incorrectly.
addresses
Remember that there are five (not four) memory locations included in addresses
0300
0300 through
through 0304.
0304, inclusive.

16)
16)

Confusing 8- and 16-bit
16-bit quantities.
long. The only 6502 register that
that can hold a com­
comAddresses are actually
actually 16 bits long.
plete address is
Is the Program Counter.

17)
17)

18)
18)

Forgetting that
that addresses or 16-bit
16-bit data occupy two memory locations.
locations.
Absolute
locations. as
as
Absolute direct
direct or absolute indexed addresses occupy two memory locations,
do the addresses that are stored on page zero for use in post-indexing
post-indexing or pre-inpre-in­
dexing. The Program Counter
is
Counter also occupies
occupies two memory locations when it is
In the Stack. Note that in
In the pre-indexed and post-indexed
stored in
post-indexed addressing
modes. two memory locations are used even
even though only one is
,s specified. The ad­
admodes,
dress immediately
following
dress
immediately follow
ing the one specified is also needed
indirect
needed to hold the indirect
address.
address.
crosses a page
page
JMP indirect
indirect will
ill not work properly if1f the indirect
indirect address crosses
boundary. See
See the discussion of indirect
indirect addressing in Chapter 3 for a description
description
of this peculiarity.
peculiarity.

Confusing the Stack
Stack and the Stack Pointer.
Pointer.
The instruction
instruction TXS affects
affects the Stack Pointer,
contents of the Stack.
Pointer. not the
the contents
Stack. PHA,
PHA,
PLA. PHP,
PHP. and PLP
PLP transfer data to or from the
PLA,
the Stack.
Stack. Remember that JSR.
JSR. RTS.
RTS.
RTI. and BRK
BAK also use the Stack. Remember also that
that you must initialize the
RTI,
the Stack
Pointer before calling
calling any subroutines
subroutines or allowing
allowing any interrupts. The 6502 Stack
Stack
,s always on page one; only the eight
is
eight least significant
significant bits of the Stack address are
are
actually
actually in the Stack Pointer.

14-12
14-

19)
19)

Changing a register
register or memory location before using
using it.
Remember that LDA. STA,
STA. LDX,
LDX. STX,
STX. LDY,
LDY. STY,
STY. TAX. TXA,
TXA. etc. all change the
contents
source).
contents of the destination
destination (but not the source).

Forgetting to
to transfer
transfer control
controlpast
pastsections
sections of
ofthe
the program
programthat
that should
shouldnot
notbe
be
20) Forgetting
executed
executed in particular situations.
Remember that the computer
puter will
ill proceed sequenttally
sequentially through
through the program
memory unless specifically
so.
specifically ordered not to do so.
21)

Forgetting that
that the Carry is always
always included in addition and subtraction
operations.
Subtract-with
The 6502
6502 only has Add-with-Carry
Add-with-Carry and Subtract-w
ith Borrow instructions.
instructions, unlike
many other
other processors which
hich have regular
regular Add and Subtract
Subtract instructions
instructions that do
not include
include the Carry. The Carry must be explicitly
explicitly cleared before an addition
addition and
Its value is
Is not to affect
Note. however,
however.
set before a subtraction
subtraction if its
affect the operation. Note,
(CMP. CPX.
CPX. CPY)
CPY) do not include
the comparison
comparison instructions
instructions (CMP,
include the Carry
Carry.

Inverting the
the significance
significance of
of the
the Carry
Carry ininsubtraction.
subtraction.
22) Inverting
In subtraction
subtraction and comparison
comparison InstructIons.
instructions, the resulting
resulting Carry is
bor­
Is an inverted boris. the Carry is set if
11no borrow is required. Accordingly
row
w -— that is,
Accordingly, the subtractsubtract-Carry)
with-Borrow
ith-Borrow instruction
instruction subtracts
subtracts the inverted Carry (1 —
Carry) along with
ith the
contents of the specified
specified memory location.
contents
23) Using
Usingthe
the decimal
decimal mode
mode improperly.
improperly.

1s set. all arithm
anthmettc
When
hen the Decimal Mode flag is
etic results are decimal.
decimal, thus the
flag must be explicitly
explicitly cleared after the decimal
decimal operations
operations are completed:
completed; otherother­
wise it will
ill change the results of operations
operations which
hich were not intended
intended to be
decimal. Note that all paths that include
include a Set Decimal Mode instruction
instruction must also
include
include a Clear Decimal Mode instruction:
instruction; be particularly
particularly careful of fall-through
fall-through
cases and error exits.

Using the
the Bit
Bit Test
Test instruction
instruction improperly.
improperly.
24) Using
Test instruction
Note that
that the BitT e
instruction sets the sign and overflow
overflow flags according
according to bits
7 and 6 of the tested memory location,
o u t regard to the contents
contents of the AcAc­
location. w ith
ithout
cumulator. This instruction
instruction is convenient
convenient fortes-ting
testing status bits in 6520 PIAs and
cumulator.
for other
other bit checking
checking operations.
operations, but it requires careful documentation
documentation since its
results are often unclear
reader.
unclear to a reader.

DEBUGGING
Interrupt-driven
programs are particularly difficultlt to debug,
Interrupt-driven programs
INTERRUPTIf. for example,
example. the program
randomly. If,
since errors may occur randomly.
DRIVEN
enables the interrupts
interrupts a few instructions
instructions too early,
ill oc­
early. an error will
ocPROGRAMS
interrupt is received while
hile the program is executing
executing
cur only if an interrupt
those few instructions
fact you can usually assume that ran­
raninstructions. In fact
occurring errors are caused by the interrupt system.2
domly occurring
system.2 Typical errors in interrupt-driven programs
programs are;
are:
1)
1)

Forgetting to re-enable interrupts after
it.
after accepting one and servicing it.
The processor disables the interrupt
interrupt system automatically
atically on RESET
accept­
RESETor on accepting an interrupt.
interrupt. Be sure that no possible sequences fail to re-enable the interrupt
interrupt
that. in addition
system. Remember that,
addition to re-enabling
re-enabling interrupts.
interrupts, the program often
reset. If this is not
has to perform some action
action to cause the interrupting
interrupting signal to be reset.
done. it will
service.
done,
ill appear as if the interrupting
interrupting device is constantly
constantly requesting
requesting service.

2)

Using the Accumulator
Accumulator before saving it; i.e.,.. PHA must precede any operations
that
that change
change the Accumulator.
Accumulator.

3)

Forgetting to save and restore the Accumulator.

14-133
14-

4)

order.
Restoring registers in the wrong order.
saved was:
was:
If the order in which
hich they were saved
PHA
TXA
PHA
TYA
PHA

:SAVE ACCUMULATOR
ACCUMULATOR CONTENTS
CONTENTS
;SAVE
:SAVE INDEX
;SAVE
INDEX REGISTER
REGISTERXX
:SAVE INDEX
INDEX REGISTER
REGISTERYY
;SAVE

be:
the order of restoration
restoration should be:
PLA
TAY
PLA
TAX
PLA
5)

6)

:RESTOREINDEX
INDEXREGISTER
REGISTER
;RESTORE
YY
:RESTORE
XX
:RESTOREINDEX
INDEX REGISTER
REGISTER

:RESTOREACCUMULATOR
ACCUMULATOR CONTENTS
CONTENTS
: RESTORE

Enabling interrupts
interrupts before establishing all the necessary conditions such as
as
priority.
pointers. counters,
priority, flags. PIA and VIA configurations.
configurations, pointers,
counters. etc.
etc.
here.
A checklist
checklist can aid here.
Leaving results in registers and destroying them in the restoration process.
process.
earlier. registers should not be used
used to pass
pass information
proAs noted earlier,
ation between the pro­
gram and the interrupt
interrupt service routines.

7)
7/

Forgetting that
BRKI leave the old Program
that the interrupts (including BRK)
Program Counter
and Status
Status Register
Register in the Stack
Stack whether
whether you use them or not.
not.
You may have to re-initialize
re-initialize or update
update the Stack Pointer.

8)

Ignoring the possibility
possibility that
that the service routine may be entered with the
Decimal
Decimal Mode
Mode flag set.
CLO instruction
this possibility
You may have to include
include a CLD
instruction in the service routine if this
possibility
exists. Note that
RTI will
automatically
exists.
that RTI
ill autom
atically restore the original
original state of the flag at the
end of the service routine.

9)

Not disabling the interrupt
interrupt during m ulti-word
ord transfers or instruction se­
sequences.
Watch
atch particularly
particularly for situations
situations where the interrupt
interrupt service routine may use
use the
same memory locations that the program is using.
using.

Hopefully,
Hopefully, these lists will
ill at least give you some ideas as to where to look for erer­
rors. Unfortunately.
rors.
Unfortunately, even
even the most systematic
atic debugging can still leave some
some
truly puzzling problems, particularly
particularly when
when interrupts are involved.^
involved.3

14-14
-14

Start

Data = (0040)

Yes

Result = (SSEG
+ Data)

Result= 0

(0041 ) = Result

End

Flowchart of Decimal to Seven-Segment
Seven-Segment Conversion
Figure 14-5. Flowchart

Debugging Example 1:: Decimal to Seven-Segm
ent Conversion
Seven-Segment
The program converts
converts a decimal
decimal number in memory location
seven-segment code in memory location 0041. It
0040 to a seven-segment
blanks the display if memory location 0040 does not contain
contain a
decimal number.

DEBUGGING
A CODE
CONVERSION
CONVERSION
PROGRAM

Initial Program (from flowchart
chart in Figure 14-5):
Initial

DONE
DONE
SSEG
SSEG

LDX
LOX
CPX
CPX
BCC
BCC
LDA
LOA
STX
STX
BRK
BRK
.BYTE
.BYTE
BYTE
.BYTE

;GET
:GET DATA
:IS
GREATERTHAN 9!r
;IS DATA GREATER
;YES,
DONE
;YES. DONE
:GET
TABLE
FROM TABLE
ELEMENT FROM
;GET ELEMENT
;SAVE
CODE
SEVEN-SEGMENTCODE
:SAVE SEVEN-SEGMENT

# $40
40
#99
DONE
DONE
(SSEG.X)
(SSEG.X)
$41
$41
$3F,$06,$5B,$4F,$66
$3F.$06.$5B.$4F.$66
$6D,$7D,$07,$7D,$6F
$6D,$7D,$07,$7D.$6F

procedure. we were able to find the following
Using the checklist
checklist procedure,
following errors:
1)
1) The block that cleared Result had been omitted.
2)
2)

The Conditional
Conditional Branch was incorrect.

For example,
< 9 and a borrow is
O<
Carry. since 0
CPX #9 clears the Carry,
zero. CPX
example. if the data is zero,
DONE) still did
required. However, the Jumpp utilizing
utilizing the inverted condition
condition (i.e
(i.e.,.. BCS
BCS DONE)
case incorrectly
produce the correct
correct result. Now the program handles the equality
equality case
incorrectly
not produce
is:
since,
correct version is:
CPX #99 sets the Carry and causes a jump. The correct
9. CPX
since. if the data is 9,
CPX
CPX
BCS
BCS

#1
0
#10
DONE
DONE

;IS
DIGIT?
DECIMAL DIGIT?
DATA AA DECIMAL
;IS DATA
CODE
;NO.
ERRORCODE
KEEPERROR
:NO. KEEP
1414-15

Second Program:

DONE
DONE
SSEG
SSEG

:GET BLANK CODE
CODE FOR
FOR DISPLAY
DISPLAY
;GET
:GET DATA
:GET
DIGIT?
:IS DATA A DECIMAL DIGIT?
KEEP ERROR
ERRORCODE
CODE
;NO. KEEP
;GET ELEMENT
ELEMENT FROM
FROM TABLE
;GET
;SAVE SEVEN-SEGMENT
CODE OR
OR ERROR
SEVEN-SEGMENT CODE
CODE
: CODE

LOA
LDA
LOX
LDX
CPX
BCS
BCS
LOA
LDA
STX

#00
$40
#$
40
#10
10
DONE
DONE
(SSEG.X)
(SSEG.X)
$41

BRK
BRK
.BYTE
.BYTE
.BYTE
.BYTE

$3F.$06.$5B.$4F.$66
$3F.$06,$5B.$4F.$66
$6D.$7D.$07.$7D.$6F
$6D,$7D,$07,$7D,$6F

This version was hand checked successfully.
successfully.
Since the program
with
program was simple.
simple, the next stage was to single-step
single-step through
through it w
ith real
real
data. The data selected for the trials was:
0
9
10
6B15
6B-|6

(the
(the smallest
smallest number)
number)
(the
largest
number)
(the
largest
number)
(a
case)
(a boundary
boundary case)
(a
case)
(a randomly
randomly selected
selected case)

The first trial was wwith
firsterror
errorwas
wasobvious
obvious—- LD X#$40
LDX#$40
ith zero in location
location 0040.
0040. The first
memory location
location 0040.
0040. The
loaded the number
number 40
40 into
into X. not the contents
contents of memory
The correct
correct
instruction
LOX $40 (direct rather
instruction was LDX
rather than immediate
immediate addressing). After
After this
correction
made. the program moved along with
correction was made,
ith no apparent
apparent errors until
until it tried to
execute
LOA (SSEG.X)
(SSEG.X) instruction.
execute the LDA
instruction.
063F. an address that
The contents
contents of the Address Bus during
during the data fetch was 063F,
that was
not even being used. Clearly, something
something had gone wrong.
It was now time for some more hand-checking.
hand-checking. Since we knew that
that BCS
BCSDONE
DONEwas corcor­
LOA instruction.
rect. the error was clearly in the LDA
instruction. A hand check showed:
LDA (SSEG.X)
contents of Index Register X to the page-zero address SSEG
LOA
(SSEG.X)adds the contents
SSEG and
case.
uses the sum to fetch the address that
that contains
contains the actual
actual data. In the present
present case,
since Register X contains
contains zero,
zero. the indirect
indirect address is in memory
memory locations
locations SSEG
SSEG and
SSEG+1 -— that
is. it is 063F. The instruction
SSEG+1
that is,
instruction is therefore
therefore getting
getting an address from a
table that
LOA SSEG.X
SSEG.X —
-wewe want
that consists
consists of data. The correct
correct instruction
instruction is LDA
ant to get
table. not the address of the data.
data from the table,

zero. rather than the
Even with
ith this correction.
correction, the program still
still produced
produced a result of zero,
expected 3F.
obviously in the last instruction
instruction -— it should be STA $41,
expected
3F. The error was obviously
$41.
not STX $41. Note the importance
following
portance of follow
ing through
through to the very end of the program.
program,
ittin g after
after what
hat might
ight seem to be the last error.
rather than q uitting
error.
The revised program
program now was:
Third Program:

DONE
DONE
SSEG
SSEG

LDA
LOA
LOX
LDX
CPX
CPX
BCS
BCS
LDA
LOA
STA

#0
$40
#100
DONE
DONE
SSEG.X
SSEG.X
$41

BRK
BRK
.BYTE
.BYTE
.BYTE
.BYTE

$3F,$06,$5B.$4F.$66
$3F.$06,$5B,$4F,$66
$6D,$7D,$07,$7D,$6F
$6D,$7D,$07.$7D.$6F

;GET
ERRORCODE
CODE FOR
FOR DISPLAY
GET ERROR
;GET
GET DATA
;IS DATA A DECIMAL DIGIT?
DIGIT?
:NO.
KEEP ERROR
ERROR.CODE
NO, KEEP
CODE
:GET
ELEMENT FROM
FROM TABLE
GET ELEMENT
:SAVE SEVEN-SEGMENT
SEVEN-SEGMENT CODE
CODE OR ER
ERROR CODE
CODE
ROR

14-166
14-

The results now were:
Data
00
09
OA
0A
6B

Result
3F
6F
6F
6F

The program was not clearing
clearing the result if the data was invalid.
invalid, i.e.,.. greater than 9. The
program never stored the blank code since the destination
destination address DONE
DONE was
misplaced
misplaced -— it should have been attached
attached to the STA $41 instruction.
instruction. After
fter these corcor­
rections
made. the program produced
cases.
rections were made,
produced the correct
correct results for all the test cases.
Since the program
program was simple.
simple, it could be tested for all the decimal
decimal digits. The results
were:
were:
Data

Result
Result

0
1
2
3
4
5
6
7
8
B
9

3F
06
5B
4F
66
6D
7D
07
7D
6F

B is
Is wrong
7F. Since everything
Note that the result for number
number 8
wrong -— itIt should be 7F.
everything else is
correct. the error is almost
In the table. In fact,
fact. entry 8
B in the table had been
correct,
almost surely in
miscopied.

program is:
is:
The final program
SEVEN-SEGMENT CONVERSION
CONVERSION
; DECIMAL TO SEVEN-SEGMENT
LDA
LDX
CPX
CPX
BCS
BCS
LDA

#0
$40
#100
DONE
DONE
SSEG.X
SSEG.X

DONE
DONE

STA

$41

SSEG
SSEG

BRK
BRK
.BYTE
.BYTE
.BYTE
.BYTE

$3F.$06.$5B.$4F.$66
$3F,$06,$5B,$4F,$66
$6D. $7D.$07.$7F.$6F
$6D,
$7D,$07,$7F,$6F

;GET
CODE FOR
FOR DISPLAY
GET BLANK CODE
GET DATA
;GET
;IS DATA A DECIMAL DIGIT?
DIGIT?
;NO.
KEEP ERROR
ERRORCODE
CODE
NO. KEEP
;GET
SEVEN-SEGMENT CODE
GET SEVEN-SEGMENT
CODE FROM
FROM
TABLE
TABLE
;SAVE SEVEN-SEGMENT
SEVEN-SEGMENT CODE
CODE OR
OR
ERRORCODE
CODE
; ERROR

1 4-17
7

The errors encountered
encountered in this program are typical
typical of the ones that 6502 assembly
language programmers
programmers should anticipate.
anticipate. They include:

1) Failing
Failing to
to initialize
initialize registers
registers or
or memory
memory locations.
1)
locations.
2) Inverting
Inverting the
the logic
logic on
on conditional
conditional branches.
branches.
2)
3) Branching
Branching incorrectly
incorrectly inin the
the case
case inin wwhich
3)
hich the
the operands
operands are
are equal.
equal.
4) Confusing
Confusing im
immediate
and direct
direct addressing,
addressing. i.e..
4)
mediate and
i.e. data
data and
and addresses.
addresses.
5) Failing
Failing to
to keep
keep track
track of
of the
the current
current contents
5)
contents of
of registers.
registers.
Branching to
to the
the wrong
wrong place
place so
so that
that one
one path
path through
through the
the program
program isis incorrect.
6) Branching
incorrect.
7) Copying
Copying lists
lists of
of numbers
numbers (or
(or instructions)
instructions) incorrectly.
incorrectly.
B) Using
Using the
the indirect
indirect addressing
addressing modes
modes incorrectly.
incorrectly.
8)
AND. DEC.
DEC. INC)
INC) and simple addressing
Note that straightforward
straightforward instructions
instructions (like AND,
modes seldom cause any problems. Among the particularly
particularly annoying
annoying errors that are
frequent
frequent in 6502 assembly language programming
programming are using the Carry improperly
properly after
subtraction
subtraction or comparison
comparison (the Carry is set if no borrow is required) and forgetting
forgetting to
clear the Decimal Mode flag.

14-18
14-

Debugging
Debugging Example 2: Sort into Decreasing Order
The program sorts an array of unsigned
unsigned 8-bit
-b it binary numbers
numbers into
decreasing order.
order. The array begins in memory location
location 0041 and
its length is in memory location
location 0040.

DEBUGGING
DEBUGGING
A SORT
PROGRAM
PROGRAM

Initial Program (from flow
flowchart
14-6).
Initial
chart in Figure 14-6):

PASS
PASS

COUNT
COUNT

LDY
LOY
LDX
LOX
LOA
LDA
CMP
sec
BCC
STA
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
BRK
BRK

#00
$40
$41,X
$41,X
$42,X
$42,X
COUNT
COUNT
$42.X
$42,X

:CLEAR
INTERCHANGE FLAG
FLAG BEFORE
BEFOREPASS
PASS
CLEAR INTERCHANGE
:GET
LENGTH OF
OF ARRAY
GET LENGTH
NEXT PAIR
PAIR OF
OF ELEME
ORDER?
:IS NEXT
ELEMENTS IN ORDER?
:YES,
GE NECESSARY
ECESSARY
YES, NO INTERCHA
INTERCHANGE
:NO,
GE PAIR
PA1R
NO, INTERCHA
INTERCHANGE
,CHECK FOR
FOR COMPLETED
COMPLE-ED PASS
PASS
;CHECK

PASS
PASS
PASS
PASS

.WERE ALL ELEME
ORDER7
;WERE
ELEMENTS lIN ORDER?
;NO, MAKE ANOTHER
ANOTHER PASS
;NO.

In the flowchart
In
The hand check shows that all the blocks in
chart have been implemented
implemented in
the program and that
that all the registers have been initialized.
init1al1zed The conditional
cond t,onal branches
must be examined carefully. The instruction
BCC COUNT must 'orce
1f the
instruction BCC
force a branch
branch if
value in A is greater than or equal to the next element
element in the array
array. Remember that we
are sorting
sorting elements into decreasing order and we are mov•ng
oving backward
backward through
through the
array in the usual 6502 manner. The equal
ty case must
equality
ust not result in an interchange,
since such an interchange
interchange would
ould create an endless loop, with
ith the two equal elements
always being swapped.
Try an example:
(0041) = 30
(0042) = 37

37, The Carry is cleared since a borrow is
CMP $42,X
$42,X results in the calculation
calculation of 30 - 37.
required. This example should result in an interchange
interchange but
but does not.
BCS
ill provide the proper branch in this case.
BCS COUNT
COUNT will
case. If the two numbers are equal,
equal.
BCS COUNT
COUNT is again correct.
the comparison
comparison will
ill set the Carry and BCS

BNE PASS
PASS at the end of the program?7 If there are any elements
order.
How about BNE
elements out of order,
SEO PASS.
PASS.
the interchange
interchange flag will
ill be one, so the branch is wrong.
wrong. It should be BEQ
Now let's hand check the first
first iteration
iteration of the program. The initialization
initialization results in the
following
follow
ing values:

LENGTH (2)
(2)
X = LENGTH
y
= 0
Y =
The effects of the loop instructions
instructions are:
are:

COUNT
COUNT

LOA
LDA
CMP
BCS
BCS
STA
DEX
DEX
BNE
BNE

$41, X
$42.
$42, X
COUNT
COUNT
$42, X

:A== (0043)
;A
: (0043)-(0044)
(0044) = (0043)
: (0044)
:X = LENGTH
LENGTH -1 (1)
;X

PASS
PASS

The indexed addresses are clearly
clearly incorrect
incorrect since they are both beyond the end of the
array. We will
ill change them by subtracting
subtracting two from the addresses included
included in the
indexed instructions.
instructions. This offset
offset is a common
common problem in 6502 assembly language
programs, because arrays and tables have a zeroth element. Thus an array with
ith five
elements occupies memory addresses
addresses BASE
BASE through
through 8ASE+4,
BASE+4, not BASE+11 through
BASE+5. When
hen using indexed addressing on the 6502 microprocessor, be careful
careful that
your addresses are not in error at one end of the array or the other.
14
14-199

Start

Interchange Flag= 0
Index Length of

=

Array
Base = Start of
Array

Interchange (Base+
Index) and (Base+

lndex-1 I
Interchange Flag = 1

Index = Index - l

End

Figure 14-6. Flowchart of Sort Program

14-20
14-

The initialization
initialization now
now results
results In
in the
the values:
values:
The
X == LENGTH
LENGTH (2)
(2)
X
yY == 00
The effects
effects of
of the
the loop
loop instructions
instructions are:
are:
The

COUNT
COUNT

LDA
LDA
CMP
CMP
BCS
BCS
STA
STA
DEX
DEX
BNE

;A
(0041)
:A== (0041)
(0041 )-(0042)
)-(0042)
:;(0041

$3F,X
$3F.X
$40,X
$40,X
COUNT
COUNT
$40, X
X
$40,

1)
(0041)
::(0042) = (004
;X == LENGTH
LENGTH - 1 (1)
:X

PASS
PASS

Note that
that we
we have
have already
already checked
checked the
the Conditional
Conditional Branch
Branch InstructIons
instructions. Clearly
Clearly the
Note
logic is incorrect.
incorrect. IfIf the first
first tw
elements are out
out of order.
order, the results
results after
after the first
first
twoo elements
logic
iteration shou
should
Id be:
iteration
(0041)
(0041)
(0042)
X

OLD (0042)
OLD (0041)
LENGTH
LENGTH - 1

(0041)
(0042)
X

UNCHANGED
OLD (0041)
LENGTH
LENGTH - 1

Instead, they
they are:
Instead.

The interchange
interchange requires a bit more care and the use of the Stack:
PHA
LDA
STA
PLA
STA

$40,X
$40.X
$3F,X
$3F.X
$40,
$40.XX

be
An interchange
interchange always requires a temporary
temporary storage place in which
which one number
number can be
saved while
hile the other one is being transferred.
All these changes
changes require a new copy of the program.
program, ,i.e..
e

PASS
PASS

COUNT
COUNT

LDY
LDY
LDX
LDX
LDA
LDA
CMP
CMP
BCS
BCS
PHA
PHA
LDA
LDA
STA
STA
PLA
PLA
STA
STA
DEX
DEX
BNE
BNE
DEY
DEY
BEQ
SEO
BRK
BRK

PASS
BEFOREPASS
:CLEAR
FLAG BEFORE
INTERCHANGE FLAG
:CLEAR INTERCHANGE
:GET
ARRAY
OF ARRAY
LENGTH OF
:GET LENGTH
ORDER?
IN ORDER?
;IS
ELEMENTS IN
OF ELEMENTS
PAIR OF
NEXT PAIR
:IS NEXT

#0
$40
$3F,X
$3F,X
$40,X
$40.X
COUNT
COUNT

NECESSARY
:YES,
INTERCHANGE NECESSARY
NO INTERCHANGE
:YES. NO
STACK
THE STACK
USING THE
;NO.
ELEMENTS USING
INTERCHANGE ELEMENTS
.NO. INTERCHANGE

$40.X
$40,X
$3F,X
$3F.X
$40,X
$40.X
;CHECK
PASS
COMPLETED PASS
FOR COMPLETED
:CHECK FOR
PASS
PASS
:WERE
ORDER?
IN ORDER?
ELEMENTS IN
ALL ELEMENTS
;WERE ALL
;NO,
PASS
ANOTHER PASS
MAKE ANOTHER
:NO, MAKE

PASS
PASS

elements:
three elements:
are three
How
there are
that there
say that
Let's say
iteration? Let's
last iteration?
the last
about the
How about
(0040)
(0040)
(0041)
(0041)
(0042)
(0042)
(0043)
(0043)

=
=
=
=

03
03
02
02
04
04
06
06

(number
elements)
of elements)
(number of

1421
14-21

cdch
1. So,
So. during
each time through.
through, the program
program decrements
decrements X by 1.
during the third
third iteration.
iteration,
(X) = 1.
1. The effects
(X)
effects of the loop instructions
instructions are:
LOA
LDA
CMP

(A)== (0040)
(0040)
: :(A)
(0040) - - (0041)
(0041)
; ;(0040)

$3F.X
$40.X
$40,X

This is incorrect:
incorrect: the program has tried to move beyond the starting
starting address of the data.
The previous iteration
iteration should,
should. in fact,
fact. have been the last one.
number of pairs
one, since the number
is one less than the number
number of elements. The first
first element
element in the array has no prepre­
decessor to which
hich it can be compared. The correction
correction is to reduce the number
number of iteraitera­
tions by one: this can be accomplished
DEX after
LOX $40. We must
accomplished by placing
placing DEX
after LDX
must also
add 1 to all the addresses in the indexed instructions.
instructions.

How about the triviall cases?7 What
happens if the array contains no elements at
hat happens
program does not work
all, or only one element? The answer
answer is that
that the program
ork correctly
change a whole block of data improperly and w ithout
and may change
o u t any warning (try
itl).
handle the triviall cases are simple but essential; the cost
it!). The corrections to handle
is only a few
that could be very difficult to
w bytes of memory to avoid problems that
solve later.
is:
The new program
program is:

PASS
PASS

COUNT

DONE
DONE

LOY
LDY
LDX
LOX
CPX
CPX
BCC
BCC
DEX
DEX
LDA
LOA
CMP
BCS
BCS
PHA
LOA
LDA
STA
PLA
STA
DEX
DEX
BNE
BNE
DEY
DEY
BEO
BEQ
BRK
BRK

#0
#0
$40
#22
DONE
DONE

:CLEAR
INTERCHANGE FLAG
FLAG BEFORE
BEFOREPASS
PASS
CLEAR INTERCHANGE
:GET
LENGTH OF
OF ARRAY
GET LENGTH
:DOES
MORE ELEMENTS?
ELEMENTS?
DOES ARRAY HAVE 2 OR MORE
;NO. NO ACTION NECESSARY
NECESSARY
;NUMBER
PAIRS== LENGTH
LENGTH - 1
NUMBER OF PAIRS
;IS NEXT
NEXT PAIR
PAIR OF
OF ELEMENTS
ELEMENTS IN ORDER?
ORDER?

$40.X
$40,X
41.X
$4
1.X
COUNT
COUNT

:YES. NO INTERCHANGE
INTERCHANGE NECESSARY
NECESSARY
;YES,
;NO. INTERCHANGE
INTERCHANGE ELEMENTS
ELEMENTS USING
USING THE STACK
STACK
:NO.

$41.X
4 1.X
$40,X
$40,X
$41.X
$41,X
:CHECK FOR
FOR COMPLETED
COMPLETED PASS
PASS
:CHECK
PASS
PASS
;WERE ALL ELEMENTS
ELEMENTS IN ORDER?
ORDER?
:WERE
ANOTHER PASS
PASS
;NO. MAKE ANOTHER

PASS
PASS

Now it's time to check the program
program on the computer
computer or on the simulator.
simulator. A simple
simple set of
data is:
(0040)
(0041)
(0042)

= 02
02
= 00
00
= 01
01

length of
of array
array
length
array to
to be
be sorted
sorted
array

This set consists
consists of two elements
elements in the wrong
wrong order. The program should require two
passes. The first
passes.
first pass should
should reorder the elements.
elements, producing:
producing:
(0041)
= 01
01
(0042) = = 00
00
Y = = 01
01

reordered array
array
reordered
Interchange flag
flag
Interchange

The second pass should find the elements
elements in the proper
proper (descending) order and propro­
duce:
Y

== 00
00

Interchange flag
flag
Interchange

14-22
14-

This program
program isIs rather
rather long
long for
for single
single stepping,
stepping. so
sowe
we wwill
use breakpoints
breakpoints instead.
instead. Each
Each
This
ill use
breakpoint w
will halt
halt the
the com
computer and
and print
print the
the contents
contents of
of all
all the
breakpoint
the registers.
registers. The
The break­
breakpoints w
will come:
come:
points
1)
1)

After
the initialization.
After DEX to check
check the
initialization.

2) After
After CMP
CMP $41,X
$41.X to
to check
check the
the comparison.
comparison.
2)
3)
3)
4)
4)

After
After STA $41.X
$41,X to check the interchange.
After
pass through the array
After DEY to
to check
check the completion
completion of a pass

The contents
contents of the
the registers
registers after
after the
the first
first breakpoint
breakpoint were:
were:
The
Register
Register

Contents
Contents

X
Y
Y

01
01

P (status)
(status)

25
25 (35
(35 if1fyou
you use
use BRK
BRK to
to create
create
the
the breakpoint
breakpoint since
since the
the Break
Break
Command
Command flag
flag w
will be
be set)
set)

00
00

These are
are all correct,
correct. so
so the
the program is
Is performing
the initialization
init1ahzat1oncorrectly
These
performing the
correctly in this
this
case.
the second breakpoint
The results at the
breakpoint were:
Register

Content;
Conten,s

00
01
01
00
A4 (B4
(84 if11you use BRK)
BRK)

A
X
y
Y
P (status)
(status)

00

These results are also correct.

The results at the third breakpoint
breakpoint were:
Register
A
X

Contents
00
01
00
26 (36 if
1f you use BRK)
BRK)

yY
P (status)
Checking
Checking memory
memory showed:
showed:
(0041)
(0042)

01
00

The
The results
results at
at the fourth
fourth breakpoint
breakpoint were:
Register
Register
A
A
X
X

yY
P
P (status)
(status)

Contents
Contents
00
00
FF
A4 (84
(B4 ifif you use BRK)
BRK)
A4

The
The Zero
Zero flag
flag (bit
(bit 11 of
of the
the Status
Status Register)
Register) Is
is incorrect.
incorrect, indicating
that no
no interchange
interchange
1nd1cating that
occurred. Register
Register Y
Y does
does not
not contain
contain the
the correct
correct value
value -— it
should have
have been
been set
set to
occurred.
11should
one
one after
after the
the interchange.
interchange. In
In fact.
fact, aa look
look at
at the
the program
program shows
shows that
that no
no instruction
instruction ever
ever
changes
changes Index
Index Register
Register Y
Y to
to mark
mark the
the interchange.
interchange. The
The correction
correction is
is to place
place the
the inin­
struction
struction LDY
LDY #1
#1 after
after BCS
BCS COUNT
COUNT.

14-23
14
-23

Now the procedure
(zerol. set the Zero
procedure is to load Index Register Y with
ith the correct
correct value (zero),
flag to 1,
1. and continue.
continue. The second iteration
iteration of the second breakpoint
breakpoint gives:
Contents
Register
Contents
A
X
Y
P (status)

02
02
00
00
00
00
BAK)
25 (35 if you use BRK)

Clearly
ithout
(parClearly the program
program has proceeded
proceeded incorrectly
incorrectly w ith
o u t reinitializing
reinitializing the registers
registers (par­
ticularly
ticularly Index Register X). The Conditional
Conditional Branch
Branch that
that depends
depends on the interchange
interchange
should
should transfer
transfer control
control back to a point
point that
that reinitializes
reinitializes X; note that
that we do not need to
reinitialize
reinitialize Y (it will
ill be zero anyway
anyway -— why?)
why?) nor do we need to check the length
length of the
array again.
The final
final version of the program
program is:
SORT
SORT

ITER
ITER
PASS
PASS

COUNT

DONE
DONE

LOY
LDY
LDX
CPX
CPX
BCC
BCC
LOX
LDX
DEX
DEX
LDA
CMP
BCS
BCS
LDY
PHA
LDA
STA
PLA
STA
DEX
DEX
BNE
BNE
DEY
DEY
BEQ
BEO
BRK
BAK

#00
$40
#22
DONE
DONE
$40

INTERCHANGE FLAG TO START
;CLEAR INTERCHANGE
:DOES ARRAY HAVE 2 OR MORE
MORE ELEMENTS?
ELEMENTS?
;DOES

$40.X
$40,X
$41.X
$41,X
COUNT
#1

ELEMENTS IN ORDER?
ORDER?
;IS NEXT PAIR OF ELEMENTS

:NO. NO ACTION NECESSARY
NECESSARY
;NO.
:YES. NUMBER
NUMBER OF PAIRS== LENGTH
LENGTH - 1
:YES,

;YES. NO INTERCHANGE
INTERCHANGE NECESSARY
NECESSARY
;YES,
SET INTERCHANGE
INTERCHANGE FLAG
;NO. SET
;INTERCHANGE ELEMENTS
ELEMENTS USING
USING THE STACK
INTERCHANGE

$41.X
4 1.X
$40.XX
$40,
$41.X
$41,X
:CHECK FOR
FOR COMPLETED
COMPLETED PASS
;CHECK
PASS
PASS
ITER
ITER

;WERE ALL ELEMENTS
ELEMENTS IN ORDER?
ORDER?
;WERE
;NO. MAKE ANOTHER
ANOTHER PASS
PASS
;NO,

Clearly
Clearly we cannot
cannot check
check all the possible
possible input
input values for this program.
program. Two
Two other
other simple
simple
sets of data for debugging
debugging purposes
purposes are:
1)
1)

Two equal elements
elements
(0040)
(0041)
(0042)

2)

=
=
=

02
00
00

Two elements
elements already in decreasing
decreasing order
(0040)
(0041)
(0042)

=
=
=

14-24
14
24

02
01
00

INTRODUCTION
INTRODUCTION TO TESTING
TESTING
Program testing
testing is closely related to program debugging.
Surely some of the test
st cases will
ill be the same as the test
test
data used for debugging, such as:

USING TEST
CASES FROM
DEBUGGING

• Trivial
Trivial cases such as no data or a single element
element
• Special
Special cases that
that the program singles out for some reason
• Simple examples
examples that
that exercise
exercise particular parts of the program
In the case of the decimal to seven-segment
seven-segment conversion program, these cases
cover all the possible situations. The test data consists
consists of:
• The numbers
numbers 0 through
through 9
• The boundary
boundary case 10
• The random
random case 6B

The program
cases Here debugging and testing are
program does not distinguish
distinguish any other
other casesvirtually
virtually the same.

In the sorting program, the problem is more difficult. The number
number of elements
elements could
range from 0 to 255.
255, and each of the elements
elements could
could lie anywhere
anywhere in that
that range. The
number
therefore enormous
he program
number of possible
possible cases is therefore
enormous. Furthermore
Furthermore, the
program is
moderately
moderately complex.
complex. How do we select
select test data that w ill give us a degree of conficonfi­
decisions. The testing
dence
dence in that
that program?
program? Here testing requires some design decisions.
testing
problem
ifficult
problem is particularly
particularly d iffic
u lt if the program
program depends
depends on sequences
sequences of real-time
real-time data.
How do we select
select the data,
data. generate
generate it.L and present
It to the microcomputer
present it
icrocom puter in a
realistic
realistic manner?
manner?
Most
ost of the tools mentioned
mentioned earlier
earlier for debugging are helpful
also. Logic or microprocessor analyzers can help
in testing also.
check the hardware;
hardware; simulators can help check the software.
software.
Other tools can also be of assistance, e.g.,
Other
1)
2)
3)
4)

5)
6)

TESTING
AIDS

I/O
that can simulate
simulate a variety
variety of devices
devices from a single
single input
input and a
1/0 simulations that
single
single output
output device.
In-circuit emulators
emulators that
that allow
allow you
you to
to attach
attach the
development
In-circuit
the prototype
prototype to
to aa development
system or control
control panel and test it.
ROM simulators
simulators that
that have
have the
the flexibility
flexibility of
ofaaRAM
RAMbut
butthe
thetim
timing
ROM
ing ofof the particular
particular
ROM or PROM that
that will
ill be used in the final
final system.
Real-time operating systems
systems that
that can provide
provide inputs
inputs or interrupts
interrupts at specific
specific
Real-time
times (or perhaps
br!Jakperhaps randomly)
randomly) and mark the occurrence
occurrence of outputs.
outputs. Real-time
Real-time break­
points
points and traces may also be included.
included.
Emulations (often on microprogrammable
microprogrammable computers)
computers) that
that may provide
provide real-time
real-time
execution
1/0A
4
execution speed and programmable
programmable I/O
Interfaces
1/0 system and test the
Interfaces that
that allow
allow another
another computer
computer to control
control the I/O
microcom
puter program.
microcomputer

7) Testing
program for
for logical
logical errors.
errors.
Testing programs
programs that
that check
check each
each branch
branch in a program
8)

Test generation
generation programs that
that can generate
generate random
random data or other
other distributions.
distributions.
Test

Formal testing
exist. but
testing theorems
theorems exist,
but they are usually
usually applicable
applicable only to very short
programs.
rams.

You must be careful that
that the test
st equipment
equipment does not invalidate the test
test by
environment. Often,
Often, test
test equipment
equipment may buffer, latch, or condition
modifying the environment.
signals. The actual system may not do this, and may therefore
input and output
output signals.
behave quite differently.
differently.

14-25
14-

Furthermore,
software
Furthermore, extra
extra softw
are in the test
st environment
environment may use some of the memomemo­
ry space or part
part of the interrupt
interrupt system.
system. It may also provide
provide error
error recovery
recovery and
other
other features
features that
that willill not
not exist
xist in the final
final system.
system. A software test bed must be
just as realistic as a hardware test bed,
bed, since software failure
as
failure can be just as critical
critical as
hardware failure.
Emulations
Emulations and simulations
simulations are, of course,
course, never
never precise.
precise. They
They are usually
usually adeade­
quate
quate for
for checking
checking logic,
logic, but
but can seldom
seldom help test
st the interface
interface or the timing.
timing. On
the other
other hand, real-time
real-time test
st equipment
equipment does not
not provide
provide much of an overview
overview of
the program
program logic
logic and may affect
affect the interfacing
interfacing and timing.
timing.

14-26
14
26

SELECTING TEST DATA
programs can be checked for all cases. The designer must choose
Very few real programs
choose a
sample set that
that in some sense describes the entire range of possibilities.
Testing
course. be part of the total development
Testing should.
should, of course,
development propro­
STRUCTURED
cedure. Top-down
Top-down design and structured
structured programming
programming provide
provide for
TESTING
testing
1s called structured
testing as part of the design. This is
structured testing.5
testing.5
Each module
module within
ith in a structured
structured program
program should be checked
checked separately. Testing, as
should be modular, structured, and top-down.
wellll as design, should

But that
that leaves the question of selecting test
st data for a
module. The designer must first list all special cases that
that a
program recognizes. These may include:
program
include:
•

TESTING
SPECIAL
CASES

Trivial
r1v1aI cases

cases
■ Equality
Equality cases
•

Special situations
situations

these.
The test data should include
include all of these.

You must next
next identify
identify each class of data that
that statements
statements
program may distinguish. These may include
w ithin
in the program
include:
•
•
•
•

Positive
Positive or negative
negative numbers
numbers
Numbers
Numbers above or below
below a particular
particular threshold
threshold

FORMING
FORMING
CLASSES
OF DATA

Data that does or does not include
include a particular
particular sequence
sequence or character
character
1s not present
ume
Data that
that is or is
present at a particular
particular time

!Ota, number
If the modules
modules are short.
short, the total
number of classes should still
still be small even though
though
d1v1s1onis
1s mult1pl1cat1ve,
two-way
d1vis1ons result in 2 x 2 x 2 = 8
each division
ultiplicative: ,e.
i.e., three two-w
ay divisions
classes of data.

You must now separate the classes according
whether the
according to whether
SELECTING
program produces a different
different result for each entry in the class
class
DATA FROM
(as in a table) or produces the same result for each entry (such
(such
CLASSES
as a warning that
that a parameter
parameter is above a threshold). In the disdis­
crete case,
case. one may include
include each element
element if the total number
number is small or sample if the
number
number is large. The sample should include
include all boundary
boundary cases and at least one case
selected randomly.
randomly. Random number
number tables are available
available in
number
1n books,
books. and random number
generators
generators are part of most computer
computer facilities.
facilities.
You must be careful of distinctions that
that may not be obvious. For example,
example, an 8-bit
8-bit
unsigned number greater
microprocessor will
ill regard an 8-bit
8-bit unsigned
greater than 127 as nega­
negative. The programmer must consider this when using
using conditional branches that
depend on the Sign flag. You must also watch
watch for instructions that
that do not affect
affect
flags, overflow
overflow in signed arithmetic,
etic, and the distinctions between
between address-length
(16-bitl
(16-bit) quantities
quantities and data-length
data-length (8-bit) quantities.

1 4-27
27

Program
Testing Example 1: Sort Program
cases here are obvious:
The special cases
• No elements in the array

element. magnitude
• One element,
magnitude may be selected randomly
randomly

TESTING
A SORT
PROGRAM

The other special case to be considered is one in which
which elements are equal.
equal.

There may be some problem here with
ith signs and data length. Note that the array itself
must contain
contain fewer
fewer than 256 elements. The use of the instruction
instruction LDY #1 rather than
INY to set the Interchange
Interchange flag means that there will
ill be no problems if the number of
elements or interchanges
128. We could check the effects
interchanges exceeds 128.
effects of sign by picking
cases with
half the regular test cases
ith numbers of elements between 128 and 255 and half
between 2 and 127. All magnitudes
agnitudes should be chosen randomly
randomly so as to avoid unun­
conscious bias as much as possible.
possible.

(see Chapter 8)
Testing Example 2: Self-Checking Numbers (see
r8)__________
,-------,

Here we will
ill presume that a prior validity
validity check has ensured that
TESTING AN
has the right
d1g1ts Since
the number
number has
right length and consists of valid digits.
ARITHMETIC
ARITHMETIC
the program makes no other distinctions.
distinctions, test data should be
PROGRAM
PROGRAM
selected randomly. Here a random number
number table or random num­
number generator
generator will
ill prove ideal: the range of the random numbers is
Is 0
O to 9.
9.

14-288
14

TESTING PRECAUTIONS
designer can simplify
plify the testing
testing stage by designing pro·
pro­
The designer
following
grams sensibly. You should
should use the follow
ing rules:

RULES FOR
TESTING
TESTING

1)
1)

ithout
Try to eliminate
inate trivial
trivial cases as early as possible w ith
out
dist1nct1ons.
introducing unnecessary
unnecessary distinctions.
introducing

2)

cases. Each special case means additional
Minimize
inimize the number
number of special cases.
additional testing
and debugging
debugging time.

processing.
to processing.
prior to
data prior
the data
on the
checks on
error checks
or error
validity or
3)
performing validity
Consider performing
3) Consider
4)

handling
in handling
unnecessary distinctions.
and unnecessary
Be
distinctions, particularly
particularly in
inadvertent and
of inadvertent
careful of
Be careful
numbers or using operations
operations that
that refer to signed numbers.
signed numbers

the
that the
sure that
Be sure
errors Be
of errors.
source of
often aa source
are often
These are
hand. These
by hand.
cases by
5) Check
boundary cases
Check boundary
problem definition
definition specifies
specifies what
hat is to happen in these cases
cases.
problem
6)
6)
7)
7)

d1st1nct1onand separate
Make the program
program as general
general as reasonably
reasonably possible. Each distinction
routine increases the required
required testing.
routine
Divide the program
program and design the modules
modules so that
that the testing
testing can proceed in
Divide
steps in conjunction
conjunction with
ith the other
other stages of software
software development.6
development®

CONCLUSIONS
process.
Debugging and testing
testing are the stepchildren
stepchildren of the software
are development
development process.
Most
ost projects leave far too little time for them and most textbooks
textbooks neglect
neglect them.
that these stages are the most expensive
expensive
But designers and managers often find that
produce.
and time-consuming.
time-consuming. Progress may be very d ifficult
u lt to measure or produce.
testing microprocessor software
are is particularly
particularly difficult
ifficu lt because
Debugging and testing
computers
larger computers
that can be used on larger
tools that
powerful hardware
hardware and software
softw are tools
the powerful
seldom available
available for
for microcomputers.
microcomputers.
are seldom

designer should
should plan debugging
debugging and testing
testing carefully.
carefully. We recommend
recommend the
The designer
follow
ing procedure:
procedure:
following
pro·
1) Try
rite programs
tested. Modular
Modular pro­
and tested.
debugged and
be debugged
easily be
can easily
that can
programs that
write
to w
Try to
gramming, structured
structured programming,
programming, and top-dow
design are useful
useful techni·
techni­
top-downn design
gramming,
ques.
Decide
design. Decide
2) Prepare
testing plan
program design.
the program
of the
part of
as part
plan as
and testing
debugging and
Prepare aa debugging
early what
hat data
data you must
must generate
generate and what
hat equipment
equipment you willill need.
early
3) Debug
process.
design process.
top-downn design
the top-dow
of the
part of
as part
module as
each module
test each
and te
Debug and
and
4) Debug
checklists, breakpoints,
breakpoints, and
Use checklists,
systematically. Use
logic systematically.
module's logic
each module's
Debug each
single-step mode.
mode. If the program
program logic
logic is complex,
complex, consider
consider using
using the soft·
ft­
the single-step
ware simulator.
simulator.
ware
An
problem. An
is aa problem.
this is
5) Check
ing system
atically ifif this
systematically
timing
module's tim
each module's
Check each
oscilloscope can solve
solve many
many problems
problems if you plan the test
st properly.
properly. If the
oscilloscope
timing
ing is complex,
complex, consider
consider using
using a logic
logic or microprocessor
microprocessor analyzer.
analyzer.
of
classes of
any classes
for any
6) Be
representative sample.
atch for
Watch
sample. W
data isis aa representative
test data
the te
that the
sure that
Be sure
that the
the program
program may distinguish.
distinguish. Include
Include all special
special and trivial
trivia l cases.
data that
7) IfIf the
differently or
cases isis
of cases
number of
the number
or the
element differently
each element
handles each
program handles
the program
large, select
select the test
st data randomly.?
randomly.7
large,
st results
documentation. IfIf problems
you
occur, you
problems occur,
the documentation.
of the
part of
as part
results as
test
all te
Record all
8) Record
willill not
not have
have to repeat
repeat test
st cases that
that have
have already
already been checked.
checked.

1 4-29
9

REFERENCES
1.
1.

For more information
analyzers. see:
see:
For
ation about logic analyzers,
N.
Andreiev. "Special
"Special Report: Troubleshooting
Troubleshooting Instruments."
5.
N. Andreiev,
Instruments," EDN
EDN. October 5,
pp, 89-99
1978, pp.
R. L.
L. Down,
Down. "Understanding
R.
"Understanding Logic Analyzers," Computer
Computer Design June 1977, pp.
188-191.
R.
. Gasperini, "A Guide to Digital Troubleshooting
Troubleshooting Aids," Instruments
Instruments and Control
Systems. February 1978, pp. 39-42.
R. Lorentzen. "Troubleshooting
R.
"Troubleshooting Microprocessors with a Logic Analyzer System."
System,"
Computer
1979. pp. 160-164 (includes a 6502-based
Computer Design. March 1979,
6502-based example).
Marshall. "What
29.
M. Marshall,
hat to Look for in Logic Timing Analyzers," Electronics.
Electronics. March 29,
p, 109-114.
1979, p.
K. Pines,
Pines. "What
Do?", Digital Design,
Design. September
K.
hat Do Logic Analyzers Do?".
September 1977,
1977. pp. 5572.
I Spector. "Logic
Telephone,"
EDN, March
20.March
1979.20,
pp.1979,
139-142.
Spector,Analysis
"Logic by
Analysis
by Telephone,"
EDN.
pp. 139-142.

2.
2.

J. Weller. Assembly Level
Level Programming for Small Computers, Lexington
W. J.
Lexington Books.
Books,
Lexington.
MA. 1975,
1975. Chapter 23.
Lexington, MA,

3.
3.

R. L.
L. Baldridge, "Interrupts
Power. Complexity
R.
"Interrupts Add Power,
Complexity to M icrocom
puter System
icrocomputer
Design," EDN.
EDN. August
August 5,
5. 1977,
1977. pp. 67-73.

4.
4.

H. R.
Bums. "Time-Scaled
H.
. Burris,
"Time-Scaled Emulations of the 8080 Microprocessor,"
Microprocessor," Proceedings of
Conference. pp. 937-946.
the 1977 National Computer
Computer Conference,

5.
5.

D. A.
A. Walsh,
Walsh. "Structured
1977. pp. 111-118.
D.
"Structured Testing,"
Testing." Datamation,
Datamation, July 1977,
P. F.
F. Barbuto Jr.
Jr. and J.
J. Geller,
Geller. "Tools for Top-Down
P.
Top-Down Testing,"
Testing," Datamation.
Datamation, October
1978, pp. 178-182.

6.
6.

R. A. DeMillo et al„
al., "Hints
Data Selection: Help for the Practicing
R.
ints on Test Data
Practicing Pro­
Programmer,"
grammer," Computer.
Computer. April
April 1978, pp. 34-41
W. F.
F. Dalton,
Dalton. "Design M icrocom
icrocomputer
puter Software,"
Software," Electronics. January 19,
19, 1978,
1978. pp.
pp.
97-101.

7. T.
T. G. Lewis,
Lewis. Distribution
7.
Distribution Sampling
Sampling for Computer
Computer Simulation.
Simulation, Lexington
Lexington Books,
Books,
Lexington, MA,
Lexington.
MA. 1975.
1975.
R. A.
A. Mueller
R.
Mueller et al„.. "A Random Number Generator for Microprocessors,"
Microprocessors," Simulation.
ulation.
April 1977,
1977. pp. 123-127.

1 4-30
0

Chapter 15
Chapter
DOCUMENTATION AND REDESIGN
REDESIGN
DOCUMENTATION
software
working program
program is not
not the only
only requirement
requirement of softw
are development.
development. AdeAde­
The working
software
quate documentation
documentation is also an important
portant part of a softw
are product.
product. Not only
quate
does documentation
designer in the testing
testing and debugging
debugging stages,
stages, it is
documentation help the designer
essential for
for later
later use and extension
extension of the program.
program. A poorly
poorly documented
documented
also essential
program willill be difficult
ifficu lt to maintain,
maintain, use, or extend.
extend.
program
Occasionally, a program
program uses too
too much memory
memory or executes
executes too slowly.
slowly. The
Occasionally,
designer must
must then
then improve
improve it. This stage is called redesign,
redesign, and requires
requires that
that you
designer
that can yield the most improvement.
program that
concentrate on the parts of the program

OCUMENTING
SELF-D O C
U M ENTIN G PROGRAMS
self-documentAlthough no program
ever completely
pletely self-docum
ent­
program is ever
ing, some of the rules that
ing,
that we mentioned
mentioned earlier can help.
These include:

FOR
RULES
RULES FOR
SELF-DOCUMENTING
SELF-DOCUMENTING
PROGRAMS

Clear, simple structure
• Clear,
structure with
ith as few transfers of control
control
(jumps) as possible
meaningful names and labels
• Use of meaningful
etc.
factors. etc.
parameters. numerical
devices. parameters,
1/0 devices,
,• Use of names for I/O
numerical factors,
usage. execution
plicity rather
rather than on minor
inor savings in memory usage,
,• Emphasis on simplicity
time.
time, or typing
typing
For example,
ing program sends a string of characters to a teletypewriter:
teletypewriter:
following
example. the follow

w

LDX
LOX
LDA
LOA
STA
JSR
JSR
DEX
DEX
BNE
BNE
BRK
BRK

$40
$0FFF,X
$0FFF.X
$A000
$AOOO
XXX
XXX

w

Even
o u t comments
comments we can improve the program,
program. as follows:
ithout
Even w ith
MESSG
MESSG
COUNT
COUNT
TTYVIA
OUTCH
OUTCH

=$1000
=$1000
=$40
=$40
=$A000
=$AOOO
COUNT
LDX
COUNT
LOX
LDA
MESSG-1.X
MESSG-1.X
LOA
STA
TTYVIA
BITDLY
BITDLY
JSR
JSR
DEX
DEX
OUTCH
BNE
OUTCH
BNE
BRK
BRK

ithout
Even w ith
Surely this program is easier to understand
understand than the earlier version. Even
out
further documentation.
documentation, you could probably
probably guess at the function
function of the program and
further
the meanings of most of the variables. Other
Other documentation techniques cannot

substitute for self-documentation.
self-documentation.
1 5-1

Some fu r
further n o
notes on
on c h o o
choosing
names:
So
s in g n a m
s:

CHOOSING
USEFUL
NAMES

1)
1)

CRT
Use the obvious name when
when it is available,
available, like TTY or CRT
for output
RESET for addresses, DELAY or
output devices, START or RESET
SORT for
LENGTH for data.
SORT
for subroutines.
subroutines, COUNT or LENGTH

2)

.§.ORT 16;BIT
}_§_-~ITARRAY.
6,RRAY. These seldom
Avoid acronyms like S168A
S16BA for SORT
seldom mean
anything
anything to anybody.
anybody.
DONE. PRINT,
PRINT, SEND,
SEND, etc.
Use full words or close to full
full words
words when
when possible.
possible, like DONE,
Keep the names as distinct as possible.

3)
4)

15-2
15

COMMENTS
COMMENTS
The most obvious form of additional documentation is the comment. However,
However,
programs (even those used as examples in books)
books) have effective
few
w programs
effective comments.
You should
should consider the following
ing guidelines for good comments.

1)
1)

code. Rather,
Rather.
Don't
on't repeat
repeat the meaning of the instruction code.
Comexplain the purpose of the instruction
instruction in the program. Com­
ments like
DEX
DEX

COMMENTING
COMMENTING
GUIDELINES

;X=X-1
;X=X-1

Rather. use
use
add nothing
nothing to documentation.
documentation. Rather,
DEX
DEX

;LINE
;LINENUMBER=LINE
NUMBER=LINENUMBER-1
NUMBER-1

what
anyone
can
Remember that you
youknow
know w
hatthe
theoperation
operationcodes
codesmean and
mean
and else
anyone
what w
task
look them up in the
themanual.
manual The
Theimportant
importantpoint
pointisisto explain
to explain
h atthe
program is performing.
performing.
program
2)
2)

Make
possible. Do not use abbreviations or acronyms
Make the comments as clear as possible.
are well-known
ASCII, VIA, or UART)
UART) or standard (like
(like no for num­
numunless they are
well-known (like ASCII,
ber. ms for millisecond.
etc.l. Avoid comments
ber,
millisecond, etc.).
comments like
DEX
DEX

;LN=LN-1
;LN=LN-1
or

;DEC LN
LN BY
BY 11
;DEC

DEX
DEX

The extra typing
typing simply
ply is not all that expensive.

3)
3)

Comment
obscure point.
point. Be particularly
mark
Comment every important or obscure
particularly careful to mark
operations that may not have obvious functions, such as
AND #%00100000
00100000 ;TURN
TURN TAPE
TAPE READER
READERBIT
BIT OFF
OFF
or
GCODL,X
;CONVERT TO GRAY
GRAY CODE
CODE USING
USING TABLE
TABLE
LDA GCODL.X
;CONVERT
Clearly. I/O
1/0 operations often require extensive comments. If you're not exactly
Clearly,
sure of what
does. or if you have to think about it,
sure
hat an instruction
instruction does,
clarifying
it. add a clarifying
comment. The comment
comment will
ill save
ill be helpful in documentadocumenta­
save you time later and will
tion.

4)

obvious. A comment
Don't
on't comment
comment the obvious.
ent on each line simply
ply makes
ifficu lt to
makes it difficult
find the important
portant points. Standard sequences like
'
DEX
DEX
BNE
BNE

SEARCH
SEARCH

need not be marked unless you're doing something special.
need
ent will
special. One comment
lines. as in
often suffice for several lines,
LSR
LSR
LSR
LSR
LSR
LSR
LSR
LSR

A
A
A
A

;GET MOST
MOST SIGNIFICANT
SIGNIFICANT DIGIT
DIGIT
;GET

LDA
LDX
LDX
STA
STA
STX
STX

$40
$41
$41
$41
$41
$40

;EXCHANGE MOST
MOST SIGNIFICANT,
SIGNIFICANT. LEAST
LEAST
;EXCHANGE
; SIGNIFICANT
SIGNIFICANT BYTES
BYTES

5)

Place comments on the lines to which they refer or at the start of a sePlace
quence.

6)

program. change the com­
Keep your comments up-to-date. If you change the program,
comments.
ments.

1 5-3

elsecan

task the

7)

Use standard forms and terms in commenting.
commenting. Don't
on't worry
worry about repetitiveness.
Varied names for the same things
things are confusing.
confusing, even if the variations
variations are just
COUNT and COUNTER,
COUNTER. START
START and BEGIN,
BEGIN. DISPLAY and LEDS,
LEDS. or PANEL
PANEL and
COUNT
SWITCHES.
SWITCHES.
There's no real gain in not being consistent. The variations
variations may seem obvious to
now. but may not be clear later;
later: others will
you now,
ill get confused
confused from the very beginbegin­
ning.

B)
8)

Make
Make comments mingled with
ith instructions brief. Leave a complete
complete explanation
explanation
to header comments
comments and other
other documentation.
documentation. Otherwise.
Otherwise, the program gets lost
in the comments
comments and you may have a hard time even finding
finding it.

9)

Keep improving your comments. If you come to one that
that you cannot
cannot read or unun­
derstand.
derstand, take the time to change it. If you find that
that the listing
listing is getting
getting crowded.
crowded,
lines. The comments
add some blank lines.
comments w on't
n 't improve themselves:
themselves; in fact.
fact, they will
ill
just
just become worse as you leave the task behind and forget
forget exactly
exactly what
hat you did.

10)
10)

Before every
every major section, subsection, or subroutine, insert a number of
comments describing the functions of the code thatt follows. Care should be
taken to describe all inputs.
inputs, outputs.
outputs, and side effects.
effects, as well
well as the algorithm
algorithm
employed.

11)

It is good practice
practice when modifying working programs to use comments to inin­
made.
dicate the date, author, and type of modification made.

Remember, comments are important. Good ones will
ill save you time and effort. Put
possible.
some work into comments and try to make them as effective
ffective as possible.

15-4
15-4

Commenting Example 1:: Multiple-Precision
Commenting
Addition
Addition

MENTING
CO M M E
N TIN G
EXAMPLES
EXAMPLES

The basic program
program is:

ADDWD
ADDWD

LDX
CLC
LDA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BAK

$40
$40,X
$40,X
$50,X
$50.X
$40,X
$40,X
ADDWD
ADDWD

First. comm
comment
za ions. data fetches.
First,
ent the important
portant points. These are typoca
typicaliv " a
initializations,
fetches,
and processing
processing operations.
operations. Don't
, e updating
updating poin­
poinDon't bother
bother with
ith standard
standard seouec,ces
seauences like
a•e c'earer
bers. so use them freely.
ters and counters. Remember that
that names are
dearer ha
than ru
numbers,
Is·
The new version of the program
program is:
:MULTIPLE-PRECISION ADDITION
MULTIPLE-PRECISION

:THIS PROGRAM
PROGRAM PERFORMS
PERFORMS MULTI-BYTE
Tl-BYTE Bl
BINARY ADD-•O,
ADDITION
INPUTS: LOCATION 0040
(HEX)== E
UMBERS (IN BYTES)
BYTES)
INPUTS:
0040 (HEX)
LENGTH OF NUMBERS
THROUGH 0050
(HEX) = FIRST
FIRST NUMBER
NUMBER STARTING
STARTING
LOCATIONS 0041 THROUGH
0050 (HEX)
WITH MSB'S
THROUGH 0060
(HEX)== SECOND
SECOND NUMBER
NUMBER STARTING
STARTING
LOCATIONS 0051 THROUGH
0060 (HEX)
WITH MSB'S
OUTPUTS: LOCATIONS 0041 THROUGH
THROUGH 0050
(HEX)== SUM STARTING
STARTING WITH
OUTPUTS:
0050 (HEX)
MSB'S
LENGTH
LENGTH
NUMB1
NUMB1
NUMB2

ADDWD
ADDWD

=$40
$40
=$41
=$51
LDX
CLC
CLC
LDA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BAK

LENGTH
LENGTH

:COUNT = LENGTH
LENGTH OF NUMBERS
NUMBERS (IN BYTES)
BYTES)
;COUNT

NUMB1-1.X
NUMB1-1.X
NUMB2-1.X
NUMB2-1.X
NUMB1-1.X
NUMB1-1.X

;GET BYTE
BYTE FROM
FROM STRING
STRING 1
;GET
;ADD BYTE FROM
FROM STRING
STRING 2
;STORE
:STORE RESULT
RESULT IN STRING
STRING 1

ADDWD
ADDWD

:CONTINUE
:CONTINUE UNTIL ALL BYTES
BYTES ADDED

15-5

Second,
instructions that might
ight not have obvious
Second. look for any instructions
functions and mark them. Here,
Here. the purpose of CLC is to clear the
functions
Carry the first
first time through.

QUESTIONS
FOR
FOR
COMMENTING
COMMENTING

Third, ask yourself
yourself whether
whether the comments
comments tell you what
hat you would
would need to know if you
Third.
e.g.:
program. e.g.:
wanted
wanted to use the program,
1)
1)

alternative entry points?
Where is the program entered? Are there alternative

2)

What
a t parameters are necessary?
hat form must they be supplied?
necessary? How and in what

3)

What
hat operations
operations does the program perform?

4)

From where does it get the data?

5)
5)

Where does it store the results?

6)
6)

What
hat special cases
cases does it consider?

7)

errors?
What
hat does the program do about
about errors?

8)

How does it exit?

Some of the questions
questions may not be relevant to a particular
particular program and some of the
the
and dissect the
won't
answers may be obvious. Make sure that you w
o n 'thave to sit
sit down and
explanation isis
muchexplanation
too much
that too
program to figure out what
hat the answers are.
are. Rememberthat
just dead wood that you will
ill have to clear out of the way. Is there anything
anything that you
just
-you
would add to or subtract
subtract from this listing? If so,
you are the one who has to
so. go ahead —
would
feel that
that the comm
enting is adequate and reasonable.
reasonable.
commenting
MULTIPLE-PRECISION
:MULTIPLE-PRECISIONADDITION

BINARY ADDITION
Tl-BYTE BINARY
PERFORMSMULTI-BYTE
PROGRAM PERFORMS
:THIS PROGRAM
BYTES)
(IN BYTES)
NUMBERS (IN
OF NUMBERS
INPUTS:
LENGTH OF
(HEX) = LENGTH
LOCATION 0040 (HEX)
INPUTS: LOCATION
STARTING
LOCATIONS
NUMBER STARTING
FIRST NUMBER
(HEX) = FIRST
THROUGH 0050 (HEX)
LOCATIONS 0041 THROUGH
MSB'S
WITH MSB'S
STARTING
LOCATIONS
NUMBER STARTING
SECOND NUMBER
(HEX)= SECOND
THROUGH 0060 (HEX)
LOCATIONS 0051 THROUGH
WITH MSB'S
STARTING WITH
(HEX)= SUM STARTING
OUTPUTS:
0050 (HEX)
THROUGH 0050
LOCATIONS 0041 THROUGH
OUTPUTS: LOCATIONS
MSB'S
LENGTH
LENGTH
NUMB1
NUMB1
NUMB2

ADDWD

=$40
$40
=$41
=$51
LDX
LOX
CLC
CLC
LDA
LOA
ADC
STA
DEX
DEX
BNE
BNE
BRK
BRK

BYTES)
NUMBERS (IN BYTES)
OF NUMBERS
:LENGTH
LENGTH OF
RESULT
NUMBER AND RESULT
OF 1ST NUMBER
:MSB'S OF
NUMBER
SECOND NUMBER
:MSB'S OF SECOND
COUNT
BYTES)
NUMBERS (IN BYTES)
LENGTH OF NUMBERS
:COUNT== LENGTH
LENGTH
LENGTH
CLEAR CARRY
START
CARRY TO START
:CLEAR
STRING 1
FROM STRING
BYTE FROM
GET BYTE
NUMB1-1.X ;GET
STRING 2
FROM STRING
BYTE FROM
1.X :ADD BYTE
NUMB2-1.X
STRING 1
RESULT IN STRING
:STORE RESULT
NUMB1-1.X STORE
ADDWD
ADDWD

CONTINUE UNTIL ALL BYTES
BYTES ADDED
;CONTINUE

15-6

Commenting Exam
ple 2:
2: T eletyp
e w riter Output
Output
Teletypewriter
Example
Commenting
The basic
basic program
program is:
is:
The

TBIT

LDA
LDA
ASL
ASL
LDX
LDX
STA
STA
JSR
JSR
ROR
ROA
SEC
SEC
DEX
DEX
BNE
BNE
BRK
BAK

$60
$60
AA
#11
#11
$A000
$AOOO
BITDLY
BITDLY
A
A

TBIT
TBIT

Commenting the
the im
portant points
points and
and adding
adding names
names g•ves
gives:
important
Commenting

:TELETYPEWRITER OUTPUT PROGRAM
(HEX) TO THE
MEMORY LOCATION
LOCATION 0060
0060 (HEX)
;THIS PROGRAM PRINTS THE CONTENTS OF MEMORY
TELETYPEWRITER
ORY LOCATIO
TRANSMITTED IN MEMORY
LOCATION 0060
0060
INPUTS: CHARACTER TO BE TRANSMITTED
OUTPUTS: NONE
NBITS
TDATA
TDATA

=11
=11
==$60
$60

TTYVIA
TTYVIA

=$A
000
=$A000
LDA
ASL
LDX
STA
STA
JSR
JSR
ROR
ROA
SEC
SEC
DEX
DEX
BNE
BNE
BRK
BAK

TBIT
TBIT

TDATA
TOATA
AA
#NBITS
#NBITS
TTYVIA
TTYVIA
BITDLY
BITDLY
AA

TBIT
TBIT

PER CHARACTER
NUMBER OF BITS PER
BE
ADDRESS OF CHARACTER TO BE
TRANSMITTED
TRANSMITTED
PORT
TELETYPEWRITER OUTPUT DATA
DATA PORT
:TELETYPEWRITER
GET DATA
DATA
;GET
BIT
FORM START BIT
LEFT AND FORM
:SHIFT LEFT
BITS IN CHARACTER
OF BITS
COUNT
:COUNT== NUMBER OF
TELETYPEWRITER
BIT TO TELETYPEWRITER
:SEND NEXT BIT
W
AIT 1 BIT
BIT TIME
:WAIT
BIT
GET NEXT
NEXT BIT
:GET
BITS
STOP BITS
FORM STOP
TO FORM
SET CARRY
CARRY TO
;SET
;COUNT
BITS
:COUNT BITS

157
15-7

Note how easily we could
could change
change this program
program so that
that it would
would transfer
transfer a whole
whole string
of data, starting
DPTR and DPTR
DPTR + 1 and ending
starting at the address in page-zero locations
locations DPTR
ending
(ASCII ETX),
ETX). Furthermore.
with
ith an "03"
3 ” character
character (ASCII
Furthermore, let us make the terminal
terminal a 30
character per second device
device with
change subroutine
subroutine
character
ith one stop bit (we will
ill have to change
BITDLY). Try making
making the changes
changes before looking
looking at the listing.
listing.
:STRING
PROGRAM
STRING OUTPUT PROGRAM
;THIS PROGRAM
PROGRAM TRANSMITS A STRING
STRING OF CHARACTERS
CHARACTERS TO A 30 CPS
CPS TERMINAL.
TRANSMISSION CEASES
CEASES WHEN AN ASCII ETX
ETX (03 HEX)
HEX) IS ENCOUNTERED
ENCOUNTERED
INPUTS: LOCATIONS 0060
0060 AND 0061 (HEX)
ADDRESS OF
OF
INPUTS:
(HEX) CONTAIN ADDRESS
STRING TO BE TRANSMITTED
STRING
NONE
OUTPUTS: NONE
DPTR
DPTR
ENOCH
ENDCH
NBITS
TRMVIA
TRMVIA
TCHAR

TBIT

DONE
DONE

=$60
$60
=$03
=$03
=10
10
=$AOOO
=$A000
LDY
LDA
CMP
BEG
BEQ
ASL
LDX
STA
JSR
ROR
ROR
SEC
SEC
DEX
DEX
BNE
BNE
INY
JMP
BRK
BRK

#00
(DPTR).Y
(DPTR).Y
#ENOCH
#ENDCH
DONE
DONE
A
#NBITS
#NBITS
TRMVIA
TRMVIA
BITDLY
A

TBIT

;POINTER
BUFFER
POINTER TO OUTPUT DATA
DATA BUFFER
:ENDING CHARACTER
CHARACTER = ASCII ETX
ETX
;NUMBER OF BITS
CHARACTER
BITS PER
PER CHARACTER
;TERMINAL OUTPUT DATA
PORT
DATA PORT
:POINT TO START OF OUTPUT DATA BUFFER
BUFFER
;GET
CHARACTER FROM BUFFER
BUFFER
GET A CHARACTER
;IS IT ENDING
ENDING CHARACTER?
CHARACTER?
;YES,
DONE
YES, DONE
;NO.
SHIFT LEFT
LEFT AND FORM
FORM START BIT
NO, SHIFT
;COUNT== NUMBER OF BITS PER
PER CHARACTER
CHARACTER
COUNT
:SEND NEXT BIT TO TERMINAL
;WAIT
W
AIT 1 BIT TIME
:GET
GET NEXT BIT
;SET CARRY TO FORM STOP
STOP BIT
BIT
;COUNT
:COUNT BITS
BITS
:PROCEED TO NEXT CHARACTER
CHARACTER
;PROCEED

TCHAR

Good comments
comments can make it easy for you to change
change a program
program to meet new requirerequire­
ments. For example.
example, try changing
changing the last program
program so that
that it:
• Starts each message with
ith ASCII STX (0215)
(02-]g) followed
followed by a three-digit
three-digit identification
identification
memory locations
locations IDCODE through
through IDCODE+2
code stored in memory
• Adds
Adds no start
start or stop bits
• Waits
aits 1 ms between
between bits
• Transmits
Transmits 40 characters,
characters, starting
starting with
ith the one located at the address in DPTR
DPTR and
DPTR+1

• Ends each message with
(0315)
ith twoo consecutive
consecutive ASCII ETXs (03-)
6)

15-8
15

FLOWCHARTS AS D O C U MENTATION
TIO N
use of flowcharts
We have already described the use
flowcharts as a design tool
in Chapter 13.
Flowcharts are also useful in documentation.
documentation, particpartic­
13. Flowcharts
ularly if:

FOR
HINTS FOR
USING
FLOWCHARTS

• They are not so detailed as to be unreadable
• Their decision points are clearly explained and marked
• They include
include all branches
• They correspond to the actual program listings
Flowcharts are helpful
helpful if they give you an overall picture
picture of the program. They are not
Flowcharts
read as an ordinary
helpful if they are just
just as difficult
ifficu lt to read
ordinary listing.
helpful

STRUCTURED
TA TIO N
STRUCTURED PROGRAMS AS D O C U MENTATION
A structured
structured program can serve as documentation
documentation for an assembly language program
if:
• You describe the purpose of each section in the comments
comments

structure
• You make it clear which
hich statements
statements are included
included in each conditional
conditional or loop structure
by using indentation
indentation and ending
ending markers
• You make the total structure
structure as simple as possible
• You use a consistent,
well-defined language
consistent. well-defined

Furthermore.
The structured
structured program can help you to check the logic or improve it. Furthermore,
since the structured
structured program is machine-independent.
machine-independent, it can also aid you in implementimplement­
ing the same task on another
another computer.

15-9

MEMORYMAPS
MEMORY
A memory map is simply a list of all the memory assignments
assignments in
in a program.
program. The
map allows you to determine the amount of memory needed, the locations
locations of data
data
subroutines, and the parts of memory not allocated. The map is a handy reference
or subroutines,
for finding
finding storage locations and entry points and for dividing
dividing memory between
different
different routines
routines or programmers. The map will
ill also give you easy
easy access
access to data and
subroutines
subroutines if you need them in later extensions
extensions or in maintenance. Sometimes a
graphical
graphical map is more helpful
helpful than a listing.
A typical map would be:

TYPICAL

MEMORY
MAP
Program Memory

Address

Routine

Purpose
Purpose

E000-E1
FF
E000-E1FF
E200-E240
E241-E250
E251-E270
E271-E3F9
E271-E3F9
E3FA-E3FF
E3FA-E3FF

INTRPT
INTRPT
BRKPT
BRKPT
DELAY
DELAY
DSPLY
DSPLY
MAIN

Interrupt
Interrupt Service Routine for Keyboard
Break Instruction
Service Routine for Break
Instruction
Delay Program
Display Control Program
Main Program
Interrupt
Reset Vectors
Interrupt and Reset
Data Memory

0000
0001-0002
0001-0002
0003-0041
0003-0041
0042-0051
0042-0051
0051-006F
0051-006F
0100-0lFFF
0100-01

NKEYS
NKEYS
KPTR
KPTR
KBFR
KBFR
DBFR
DBFR
TEMP
TEMP
STACK
STACK

Number
Keys
Number of Keys
Keyboard Buffer Pointer
Keyboard Buffer
Display Buffer
Temporary
Temporary Storage
RAM Stack

Remember that the 6502 RAM Stack is always on page 1 of memory.
memory.

15-10
15
10

PARAMETER AND DEFINITION LISTS
subroutine
program and each subroutine
Parameter and definition lists at the start of the program
rules can
make understanding
simpler. The following rules
program far simpler.
changing the program
understanding and changing
help:
1)

defini1/0 units, parameters, defini­
Separate RAM locations,
locations, I/O
constants.
tions, and memory system constants.

2)

Arrange lists alphabetically when possible,
ith a descripdescrip­
possible, with
Arrange

FOR
RULES
RULES FOR
DEFINITION
LISTS

tion of each entry.
3)

lists. Such
Qive each parameter thatt might change
include it in the lists.
and include
name and
change a name
Give
parameters may include
include timing
ing constants.
constants, inputs
inputs or codes corresponding
corresponding to particpartic­
parameters
ular keys or functions,
control or masking
masking patterns.
patterns, starting
starting or ending
ending characters.
characters,
functions. control
ular
thresholds, etc.
thresholds.

4)

list. These constants
Make the memory system constants into a separate list.
constants will
ill
Make
include Reset and interrupt
interrupt service
service addresses.
addresses, the starting
starting address of the program.
program,
include
RAM areas. Stack areas,
areas. etc.

5)

Give each port used by an I/O
though devices
devices may share
name, even though
1/0 device a name,
current system. The separation
separation will
ill make expansion
expansion or reconfiguration
reconfiguration
ports in the current
much simpler.
simpler.
much

TYPICAL
DEFINITION
LIST

A typical list of definitions will
ill be:
CONSTANTS
:MEMORY SYSTEM CONSTANTS
INTRP
INTRP
RAMST
RESET
RESET
STPTR
STPTR

=$E200
=$E200
=$E300
=$E300
=$01
FF
=$01FF

INTERRUPT ENTRY
ENTRY POINT
,INTERRUPT
STORAGE AREA
OF DATA STORAGE
.START OF
RESET ADDRESS
ADDRESS
:RESET
1)
PAGE 1)
(ON PAGE
;TOP ADDRESS IN RAM STACK (ON

=$A000
=$AOOO
=$A001
=$A001
=$AOOO
=$A000
=$ABDO
=$A
800

FOR DISPLAYS
:OUTPUT VIA FOR
FOR KEYBOARD
;INPUT VIA FOR
KEYBOARD
FOR KEYBOARD
:OUTPUT VIA FOR
DATA PORT
PORT
;TTY DATA

=$0

1/0 UNITS
; I/O
DSPLY
KBDIN
KBDOT
TTYVIA
TTYVIA

: RAM LOCATIONS

NKEYS
NKEYS
KPTR
KPTR
KBFR
KBFR
DBFR
DBFR
TEMP

•=RAMST
·=RAMST
·=·+1
"=
*+ 1
·=·+2
*=
*+ 2
'='+$40
*= *+
$40
*= *+
$10
'='+$10
*= *+
$14
·=·+$14

;NUMBER
KEYS
:NUMBER OF KEYS
KEYBOARD
POINTER
BUFFER POINTER
:KEYBOARD BUFFER
KEYBOARD
BUFFER
;KEYBOARD INPUT BUFFER
:DISPLAY DATA
DATA BUFFER
BUFFER
;DISPLAY
TEMPORARY
STORAGE
;TEMPORARY STORAGE

PARAMETERS
:PARAMETERS
BOUNCE
BOUNCE
GOKEY
GOKEY
MSCNT
OPEN
OPEN
TPULS

=2
=10
=$C7
=$C7
=$0F
=$OF
=1
1

,DEBOUNCING TIME IN MS
KEY
OF 'GO' KEY
:IDENTIFICATION OF
FOR 1 MS DELAY
;COUNT FOR
KEYS
OPEN KEYS
FOR OPEN
PATTERN FOR
;PATTERN
MS
FOR DISPLAYS IN MS
LENGTH FOR
;PULSE LENGTH

1 5-11

DEFINITIONS
DEFINITIONS

ALLHI
ALLHI
STCON
STCON

=$FF
=$FF
=$80
= $ 80

;ALL
PATTERN
ONES PATTERN
;ALL ONES
PULSE
iPATTERN
CONVERSION PULSE
START CONVERSION
FOR START
;PATTERN FOR

Of course.
course, the
the RAM
RAM entries
entries w
usually not
not be
be in
in alphabetical
alphabetical order.
order, since
since the
the designer
designer
willill usually
Of
must order
order these
these so
so as
as to
to minimize
minimize the
the number
number of
of address
address changes
changes required
required in
in the
the propro­
must
gram.

15-12
1512

LIBR
LIBRARY ROUTINES
Standa
tines will
Standard docum
documentation of subroutines
ill allow you to
build up
library of
to build
up a
a library
of
useful progra
ms. The
to make
useful
programs.
The idea
idea Is
is to
make these programs easily accessible.
standard for·
for­
ible. A
A
standa
mat
will
allow
you
or
anyone else
else to see at a glance what
mat w ill allow you or anyone
hat the progra
program does.
The best
best
does The
procedure is
is to
to make
make up
up aa standa
procedure
standard form and use it
consistently.
programs
1t consm
ently. Save
Save these
these
progra
in a
ganized manne
in
a well-or
well-organized
manner (for
(for example, accord
according
and type
type of
of
ing to processor,
sor. language,
language. and
progra
m). and
will
program),
and you
you w
ill soon
soon have
have a useful set. But remember that, w ith
o utt organi
organiza­
withou
zation
and proper
using the library may be more
tion and
proper docum
documentation, using
re w rit­
more d iffic
difficultlt than
than rewriting
m from
from scratc
h. Debug
ging a system requires a
ing the
the progra
program
scratch.
Debugging
a precise
precise understanding
understanding
of
the effects of each subroutine.
of all
all the
Among
the informa
tion that
STANDARD
Among the
inform ation
that you will
ill need in
In the standard
rd form
form is:
,s·
PROGRAM
RAM
•• Purpos
Purpose of the program
LIBRA
LIBRARY
RY
,• Processor
sor used
FORMS
• Language used
eters require
•• Param
Parameters
required and how they are passed
subroutine
passed to the
the subrou
tine
•• Results
and how they are passed
Results produc
produced and
program
passed to the main
main progra
m
•• Numbe
r of bytes of memory used
Number
•• Numbe
Number of
of clock
clock cycles
cycles require
required. This numbe
numberr may be an averag
average or
o· a
a typical
tYPICalfigure,
figure.
or
ion time w•
or it
it may
may vary
vary widely
widely. Actual
Actual execution
will, of course
course, ceoend
depend on
processor
on the
the proces
sor
clock
rate and the memory cycle time
clock rate
11me
•,Regist
Registers affected
• Flags affected
,A
•A typ,ca
typical example
•,Error
Error handlin
handling
g
,Spec,a
cases
•Special cases
•Docum
ented program I st
Documented
listing
rig
If
the
progra
m 1s
complex the standard library form should
If the program
is complex,
general
shou1d also
also include
,nclude a
a genera
l
flowcha
rt or
ructured program. As we have mentioned
flow
chart
or a
as
structured
ned before,
before. a
a library
library program
progra
m is
is
most
1,1<ely
be useful
11perform
most likely to
to be
useful ifif it
performs a single d1st1n
distinctc functio
function
in
a
reasonably
general
n 1n a reason
genera
manner.

15-13
15
-1 3

j

LIBRARY EXAMPLES
EXAMPLES
LIBRARY
Library Exam
Example
1 : Sum
Sum of
of Data
Data
Library
ple 1:
Purpose: The
The program
program SUM8
SUMS computes
computes the
Purpose:
the sum
sum of
of aaset
set of
of 8 -b
8-bit unsigned
unsigned binary
binary num­
numbers.
bers.
Language: 6502
6502 Assembler.
Assembler.
Language:
Initial Conditions:
Conditions: Address
Address one
one less
less than
Initial
than the
the starting
starting address
address of
of the
the set
set of
of numbers
numbers in
in
memory
memory locations
locations 0040
0040 and
and 0041,
0041. length
length of
of set
set in
in Index
Index Register
RegisterY.
Y.
Final Conditions:
Conditions: Sum
Sum in
in Accumulator.
Accumulator.
Final
Requirements:
Requirements:

Memory
Memory
Time
Registers
Registers
RAM
RAM
All flags affected.

bytes.
- 99 bytes.
- 7 +12n
1 2n clock cycles,
cycles. where
where nn is
is the
the length
length of
of the
the set
set ofof·
numbers.
numbers. May be
be longer
longer ifif page
page boundaries
boundaries are
are crossed.
crossed.
A.Y
A.Y
locations 0040 and
and 0041.
0041.

(all data in hexadecimal)
hexadecimal)
Typical Case: (all
Start:
(0040 and 0041) = 004F
Y = 03
(0050) = 27
(0050)
(0051) = 3E
(0052) = 26
(0052)
End:
End:
BB
A = 8B
Error Handling: Program ignores all carries.
carries. Carry bit reflects only the last operation.
Initial contents
contents of Index register Y must be 1 or more.
Initial
more. Decimal Mode
cleared.
flag should be cleared.
Listing:

:SUM
S-BIT DATA
SUM OF 8-BIT
SUMS
SUM8
ADDS
ADD8

LOA
LDA
CLC
ADC
ADC
DEY
DEY
BNE
BNE
RTS
RTS

#00

($40),Y
($40),Y

:SUM =ZERO
=ZERO
;CLEAR
:CLEAR CARRY
CARRY EACH
EACH TIME
:SUM
:SUM== SUM++ DATA ENTRY
ENTRY

ADDS
ADD8

15
-1 4
15-14

Library Exam
ple 2:
2: D ecim
al-to-Seven Segm
ent Conversion
Conversion
Segment
Decimal-to-Seven
Example
Library
Purpose: The
The program
program SEVEN
SEVEN converts
converts aa decimal
decimal number
number to
to aa seven-segment
seven-segment display
display
Purpo•e:
code.
code.
Language: 6502
6502 Assembler.
Assembler.
Lenguege:
Initial Condition•:
Conditions: Data
Data in
in Index
Index Register
Register XX.
lnltlel
Final condition•:
conditions: Seven-segment
Seven-segment code
code in
in Accumulator
Accumulator.
Final
Requirements:
Requirement•:
Memory
Memory
Time
Time
Registers
Registers
Allll flags
flags affected
affected.

19 bytes.
bytes, including
including the
the seven-segment
seven-segment code
code table
table (10
19
entries).
entries).
- 16
16 clock
clock cycles
cycles ifif the
the data
data ,s
is valid.
valid. 13
13 ifif itit is
is not.
1f page
May be
be longer
longer if
page boundaries
boundaries are
are crossed
crossed.
May
-- A. X
-

Input data
data In
in Index
Index Register
Register X
X Is
is unchanged
unchanged.
Input

Typical Case: (data In
in hexadecimal)
hexadecimal)
Typical
Start:
Start:

X = 05
End:
A

=

6D

Is not a decimal
1f the data is
Error
Program returns
returns zero in the Accum
ulator if
decimal
Accumulator
Error Handling: Program
digit.
digit.

Listing:
Listing:
;DECIMAL
VERSION
SEVEN-SEGMENT CONVERSION
.DECIMAL TO SEVEN-SEGMENT

DISPLAY
CODE TO BLANK DISPLAY
;GET
ERRORCODE
:GET ERROR
DIGIT?
DECIMAL DIGIT?
;IS
:IS DATA A DECIMAL
CODE
ERRORCODE
KEEPERROR
NO. KEEP
;NO.
FROM
CODE FROM
SEVEN-SEGMENT CODE
GET SEVEN-SEGMENT
:YES. GET
; YES,
;: TABLE
TABLE

SEVEN
SEVEN

LDA
CPX
CPX
BCS
BCS
LDA
LDA

##0
0
# 10
DONE
DONE
SSEG.X
SSEG.X

DONE
DONE
SSEG
SSEG

RTS
RTS
. BYTE
BYTE
. BYTE
BYTE

$3F,$06,$5B,$4F,$66
$3F.$06.$5B.$4F.$66
$6D,$7D,$07,$7F,$6F
$6D.$7D.$07.$7F.$6F

1515
15-15

Library Exam
ple 3:
3: Decim
al Sum
Sum
Decimal
Example
Library
Purpose: The
The program
program DECSUM
DECSUM adds
adds tw
ulti-word decimal
decimal numbers.
numbers.
multi-word
twoo m
Purpose:
Language: 6502
6502 Assembler.
Assembler.
Language:
Initial Conditions:
Conditions: Address
Address of
of MSBs
MSBs of
of one
one number
number in
in memory
memory locations
locations 0040
0040 and
and
Initial
0041, address
address of
of MSBs
MSBs of
of other
other number
number in
in memory
memory locations
locations 0042
0042
0041.
and 0043.
0043. Length
Length of
of numbers
numbers (in bytes)
bytes) in
in Index
Index Register
Register Y.
Y. NumNum­
and
with
arranged starting
starting w
ith most
most significant
significant digits.
digits.
bers arranged
Final Conditions:
Conditions: Sum
Sum replaces
replaces number
number with
w ith starting
starting address in memory
memory locations
locations
0040 and 0041.
0041.
0040
Requirements:
Requirements:
bytes.
14 bytes.
-- 14
of
number of
the number
where nn isisthe
cycles. where
- 11
clock cycles,
22n clock
11++22n
crossed.
11page boundaries
longer if
boundaries are crossed.
bytes. May be longer
Registers - A.
A, Y
0043.
through 0043.
RAM - memory
0040 through
locations 0040
memory locations
Decimal Mode
carry. Decimal
produced aa carry.
sum produced
Allll flags affected
affected - Carry
Mode
shows ifif sum
Carry shows
Is cleared.
flag is
Memory
Memory
Time

Typical Case: (all data in hexadecimal)
Typical
Start:
(0040 and 0041) = 0060
(0042 and 0043) = 0050
(Y)
(Y) = 02
(0060) =
(0061)
(0061) =

55
34

(0050)
(0050) =
(0051)
(0051) =

15
88

(0060)
(0060) =
(0061)
(0061) =
Carry
Carry =

71
71
22
0

End:
End:

of
The contents of
Error
validity of decimal inputs. The
the validity
does not check the
Error Handling: Program does
Index
more
or more.
be 11 or
must be
Y must
Register Y
Index Register

Listing:
Listing:
ADDITION
(BCD)ADDITION
DECIMAL (BCD)
; MULTl-DIGIT DECIMAL
DECSUM
DECSUM
DECADD
DECADD

SED
SEO
CLC
CLC
DEY
DEY
LDA
LDA
ADC
ADC
STA
STA
TYA
TVA
BNE
BNE
CLD
CLO
RTS
ATS

DECIMAL
:MAKE
ARITHMETIC DECIMAL
ALL ARITHMETIC
.MAKE ALL
START
:CLEAR
TO START
CARRYTO
.CLEAR CARRY
($40),Y
($40).Y
($42).Y
($42).Y
($40).
$40)YY

STRING 11
FROM STRING
;GET
DIGITS FROM
DECIMAL DIGITS
:GET 22 DECIMAL
STRING22
FROM STRING
DIGITS FROM
OF DIGITS
;ADD
PAIR OF
:ADD PAIR
STRING 11
IN STRING
:STORE
RESULTIN
;STORERESULT

DECADD
DECADD

MODE
ARITHEMETICMODE
BINARY ARITHEMETIC
;RETURN
TO BINARY
;RETURNTO

151
15-16

TOTAL D O C U M E
N TA TIO N
ENTATION
Complete documentation
documentation of microprocessor
microprocessor software
software will
ill inin­
Complete
So.
clude all or most of the elements that we have mentioned. So.
the total documentation package may involve:

DOCUMENTATION
DOCUMENTATION
PACKAGE
PACKAGE

• General flowcharts
program
• A writtenn description of the program
• A list of all parameters and definitions
• A memory map
program
• A documented listing of the program
• A description of the test
s t plan and test
st results

include:
The documentation may also include:
• Programmers'
charts
Programmers' flowcharts
• Data flowcharts
• Structured programs
programs
procedures outlined above are the minimal acceptable set of
The documentation procedures
demands even
Production software demands
documents for non-production
non-production software. Production
greater documentation efforts. The following
following documents
documents should also be produced:
• Program Logic Manual
• User's Guide
• Maintenance
aintenance Manual

produced with the
The program
ritte n explanation produced
program logic manual expands on the written
ritten for a technically
technically competent
competent individual
individual who
who may not
software. It should be written
possess
knowledge assumed in
ritten explanation
explanation in the software.
1n the written
possess the detailed knowledge
goals. the algorithms
algorithms
The program logic manual should explain the system's design goals,
necessary.
used,
hat tradeoffs
tradeoffs were necessary.
used. and what
It should then explain in great detail what
hat data structures
structures were employed and how they
proare manipulated.
manipulated. It should provide a step-by-step
step-by-step guide to the operations
operations of the pro­
gram. Finally,
contain any special tables or graphs that help explain the propro­
Finally. it should contain
gram. Code conversion charts.
charts, state diagrams.
diagrams, translation
translation matrices.
matrices, and flowcharts
flowcharts
should be included.

The User's guide
guide is probably the most important and most overlooked piece of
documentation. No matter
atter how wellll a system is designed,
designed, it is useless if no one
can take advantage of its features. The User's guide should introduce
introduce the system to
all users,
sophisticated and unsophisticated.
unsophisticated. It should then provide detailed explanaexplana­
users. sophisticated
tions of system features and their use.
ill help to clarify
clarify the points
use. Frequent examples will
in the text. Step-by-step
Step-by-step directions
directions should be provided (and testedl).
ith
tested!). Programmers with
knowledge of a system often take shortcuts
shortcuts that the general reader cannot
detailed knowledge
discussion of the writing
ritin g of User's guides is beyond the scope of this
follow. Further discussion
book.
effort in preparing a
However. remember that you can never spend too much effort
book. However,
User's guide,
ill be the most frequently
frequently referenced system document.
document.
guide. since it will
The maintenance manual
designed for the programmer who has to modify the
manual is designed
system. It should outline
outline step-by-step
step-by-step procedures for those reconfigurations
reconfigurations designed
into the system. In addition,
provisions b uilt
ilt into the program for
addition. it should describe any provisions
future expansion.
future
Documentation should
ft­
postponed until the end of the softshould not be taken lightly or postponed
programming
ith proper programming
ware development. Proper documentation, combined with
practices, is not only an im portant part of the final product but can also make
conshould make con­
development simpler,
more productive. The designer should
simpler, faster, and more
development
every stage of software
are development.
thorough documentation part of every
sistent and thorough
1 5 -17

REDESIGN
Sometimes
Sometimes the designer may have to squeeze the last microsecond of speed or
the last byte of extra memory out of a program.
program. As larger single-chip
single-chip memories have
become available.
available, the memory problem
problem has become less serious.
serious. The time problem, of
course. is serious only if the application
course,
application is time-critical:
e-critical; in many applications
applications the
microprocessor
microprocessor spends most of its time waiting
aiting for external
external devices,
devices. and program speed
1snot a major factor.
is
Squeezing the last bit of performance out of a program is
seldom as important
portant as some w riters
rs would have you believe.
In the first place, the practice is expensive
expensive for the follow
ing
following
reasons:
reasons:
1)
1)
2)

COST OF
REDESIGN

It requires extra programmer
programmer time, which
which is often the single largest cost in software
development.
development.
It sacrifices structure
structure and simplicity
plicity with
ith a resulting
resulting increase in debugging
debugging and
testing time.

3)

The programs
programs require extra documentation.
documentation.

4)
4)

The resulting
resulting programs will
ill be difficult
ifficu lt to extend, maintain.
maintain, or re-use.
re-use.

In the second place, the lower
lower per-unit cost and higher performance may not really
be important. Will
ill the lower cost and higher
higher performance
performance really sell more units? Or
would
would you do better
better with
ith more user-oriented
user-oriented features? The only applications that
would seem to justify
stify the extra effort
effort and time are very high-volume, low-cost
low-cost
and low-performance
low-performance applications where the cost of an extra memory chip will
ill far
outweigh
outweigh the cost of the extra software
are development.
development. For other applications,
applications, you
will
ill find that
that you are playing
playing an expensive
expensive game for no reason.
reason.
However.
program, the following
However, if you must redesign a program,
ing
MAJOR
MAJOR OR
help. First, determine
hints will
ill help.
determine how much more perforperfor­
MINOR
MINOR
mance or how much less memory usage
usage is necessary. If
REORGANIZATION
REORGANIZATION
the required improvement
improvement is 26¾
25% or less, you may be
program. If it is more than 26%,
able to achieve it by reorganizing the program.
25%, you have
made a basic design error; you will
ill need to consider drastic changes in hardware
or software.
software. We will
ill deal first
first with
ith reorganization
reorganization and later with
ith drastic changes.
1f it allows
Note particularly
particularly that saving memory
memory can be critical
critical if
allows a program to fit into the
limited
ROM and RAM available in a simple one-chip
limited amount
amount of ROM
one-chip or two-chip
o-chip microcomicrocom­
puter. The hardware
reduced. if their
hardware cost for small systems can thus be substantially
substantially reduced,
their
requirements
1/0 limitations
requirements can be limited
ited to the memory size and I/O
itations of that particular
particular
one-chip
one-chip or two-chip
o-chip system.

15-18
15
18

REORGANIZING TO USE LESS
LESS M EMORY
ing procedures will
ill reduce memory usage for 6502
6502
The following
assembly language
programs:
language programs:

SAVING
MEMORY
MEMORY

Be
subroutines. Be
with subroutines.
code w
In-line code
repetitious in-line
1)
Replace repetitious
1) Replace
sure,
instructions do not offset most of the gain.
sure, however, that the Call and Return instructions
In slower programs because of the time
Note that
that this replacement
replacement usually results in
transferring control
control back and forth.
spent in transferring
2)

onewith oneaccess itit w
and access
zero and
page zero
on page
data on
Place
used data
frequently used
most frequently
the most
Place the
1/0 addresses there.
byte addresses.
ant to place a few I/O
addresses. You may even want

3)

after
updated after
automatically
Is autom
Pointer is
Use
atically updated
Stack Pointer
The Stack
possible. The
when possible.
Stack when
the Stack
Use the
Remember.
necessary. Remember,
each use so that no explicit
explicit updating
updating instructions
instructions are necessary.
however, that
that the 6502 Stack can never be longer than one page.
page.
however.

4)

instead.
program instead.
the program
reorganize the
Eliminate
to reorganize
Try to
instructions. Try
Jump instructions.
Eliminate Jump

5)

that you can manipulate as 8-bit
8-bit quantities.
Take advantage of addresses that
example.
These include
include page zero and addresses that are multiples
ultiples of 10015
1 6- For example,
you might
ight try to place all ROM
6-byte section of memory.
memory, and
ROM tables in one 100 115-byte
all RAM variables into another
another lO O
ig-byte section.
10015-byte

6)

worrying
without
address
can you
youthat
Organize data
data and
and tables
tables so that so
can them
address
them w
ith o u t worrying
Organize
willill
This w
about address calculation carries
o u t any
indexing.This
actual indexing.
anyactual
without
carriesororw ith
again allow you to manipulate
manipulate 16-bn
16-bit addresses as 8-b,t
-b it quantities.
quantities.

7)
7)

Use the Bit Test
Test or Shift instructions to operate on bit positions at either
either end
of a word.

program.
the program.
of the
8
sections of
previous sections
from previous
results from
leftover results
Use leftover
B) Use
ROR,
and ROR,
ROL,and
LSR, ROL,
INC, LSR,
DEC, INC,
ASL, DEC,
as ASL,
9) Take
instructions as
suchinstructions
of such
advantage of
Take advantage
which operate directly on memory locations w ithout
o u t using registers.
10)
10)

bits.flag bits.
Use INC
INC or
or DEC
DEC to
to set
set or
or reset flag
reset
Use

11)
11)

Use relative
relative jumps
jumps rather
rather than jumps
thanwith
jumps
w ithaddressing.
direct addressing.
direct
Use

12)
BRK, RTS, and RTI to perform jumps and reach subroutines, if they are
12) Use BRK,
not already being used.
instructions can act as one-byte
one-byte CALL instructions
instructions
used. These instructions
Stack.
if the required data and addresses are already in the Stack.
13)
13)

Accumulator
Watch
atch for special short forms of instructions such as the Accum
ulator shifts
BIT.
(ASL
ROA A) and BIT.
AOL A, and ROR
A. ROL
LSR A,
A. LSR
(ASL A,

14)
14)

arithmetic
Use algorithms rather than tables to calculate
calculate arithm
etic or logical expressions
and to perform code conversions. Note that this replacement
replacement may result in slower
programs.

15)
15)

Reduce the size of mathematical
mathematical tables by interpolating between
between entries. Here
time.
again,
execution time.
again. we are saving memory at the cost of execution

comparisons
16)
16) Take advantage of the CPX and CPY instructions to perform comparisons
w ithout
o u t involving the Accumulator.
Although some of the methods that
that reduce memory usage also
SAVING
EXECUTION
save time, you can generally save an appreciable amount of
Even
loops. Even
frequently executed
executed loops.
TIME
TIME
time only by concentrating on frequently
completely eliminating
inating an instruction
instruction that is executed only once
completely
can save at most a few microseconds. But a savings in a loop that is executed frefre­
quently will
ill be multiplied
ultiplied many times over.
over.
quently

15-19
15

So. if you must reduce execution time, proceed as follows:
So,
1) Determine
Determine how
how frequently
frequently each
each program
programloop
loopisisexecuted.
executed. You
You can
can do
do this
this by
by
1)
hand or by using the software
software simulator
ulator or another
another testing
testing method.

Examine the
the loops
loops in
in the
the order
order determined
determined by
by their
their frequency
frequency of
of execution,
execution,
2) Examine
starting
restarting with
ith the most frequent. Continue
Continue through
through the list until
until you achieve the re­
quired reduction.
First, see
see ifif there
there are
are any
any operations
operationsthat
that can
can be
be moved
moved outside
outside the
the loop,
loop,i.e..
i.e .
3) First,
repetitive
repetitive calculations,
calculations, data that
that can be stored in a register or on the Stack, data or
zero. special cases
cases or errors that
addresses that
that can be stored on page zero,
that can be
handled elsewhere,
elsewhere. etc. Note that this will
ill require extra initialization
initialization and memory
but will
ill save time.
Try to
to eliminate
eliminate Jump
Jump statements.
statements. These
These are
are very
very time-consuming.
time-consuming.
4) Try
Replacesubroutines
subroutineswwith
in-linecode.
code.This
This wwill
saveat
at least
leastaaCall
Call and
and aaReturn
Return
5) Replace
ith in-line
ill save
instruction.
instruction.
Use page
page zero
zero for
for temporary
temporary data
data storage.
storage.
6) Use
Use any
any of
of the
the hints
hints mentioned
mentioned in
insaving
saving memory
memory that
that also
alsodecrease
decrease execu­
execu7) Use
addresses. BRK,
BRK. RTI,
RTI. special short forms
tion time. These include
include the use of 8-bit
-b it addresses,
etc.
of instructions.
instructions, etc.
Do not
not even
even look
look at
at instructions
instructions that
that are
are executed
executed only
only once.
once. Any
Any changes
changes
8) Do
that you make in such instructions
instructions only invite
invite errors for no appreciable
appreciable gain.
Avoid indexed
indexed and
and indirect
indirect addressing
addressingwhenever
whenever possible
possible because
because they
they take
take
9) Avoid
extra lime
time.
10) Use
Usetables
tables rather
ratherthan
thanalgorithms;
algorithms;make
makethe
the tables
tables handle
handle as
asmuch
much of
of the
the tasks
tasks
10)
11many entries must be repeated.
repeated.
as possible even if

15-20
1
0

MAJOR
R REORGANIZATIONS
If you need more
more than
than a 26%
25% increase
increase in speed or decrease
decrease in memory
memory usage, do
not try reorganizing the code. Your chances of getting that
that much of an improveimprove­
ment
ment are small unless you call in an outside expert.
expert. You are generally better
better off
change.
making a major change.

The most obvious change is a better
better algorithm. Particularly
Particularly if11
BETTER
BETTER
sorts. searches,
searches. or mathematical
ALGORITHMS
you are doing sorts,
athematical calculations.
calculations, you
ALGORITHMS
ure
may be able to find a faster or shorter method in the iltera
literature.
Libraries of algorithms
'ro..-i professional groups. See,
See.
algorithms are available in some journals
journals and from
example. the references at the end of this chapter.
for example,

More hardware can replace some of the software.
ers. shift
registers.
software. Counters,
shift registers,
arithmetic
arithm
etic units.
units, hardware multipliers.
multipliers, and other fast aod-ors
add-ons ::a
can save both time and
UARTs. keyboards,
keyboards. encoders,
encoders. and other
e· slower
01,e add-ons
memory. Calculators.
Calculators, UARTs,
add-ons may save
memory even though
ano seria
nterfaces. and
though they operate slowly. Compatible
Compatible oara
parallel and
septal interfaces,
other devices specially
t,me by tak­
takspecially designed for use with
ith the 6502
6502 or 6800. may save tim
CPU.
ing some of the burden off the CPU.
Other changes may help as well:
ell:

OTHER
MAJOR
CHANGES

1)
1)

A CPU with
ith a longer word will
ill be faster
faster if11the data ,s
is (:"g
eng
enough. Such a CPU
CPU will
ill use less total memory • 6-c
16-b’t- :-;r
pro­
cessors. for example,
example. use memory more ef-' c
e'>t • -~3
cessors,
efficiently
than 8-o
8-bit
processors. since more of their
O"S are
a,e ore
1,ord long.
·1ong
processors,
their ns rue
instructions
one word

2)
2)

Versions of
of the
the CPU
CPU may
may exist
exist that
that operate
operate at
at higher
higher clock
clock rates.
rates. But
But remem­
rememVersions
10 ports,
ports. and you will
ber that you will
ill need •as
faster riemo"f
memory and I/O
ill have to adjust any
delay loops.

Two CPUs
CPUs may
may be
be able
able to
to do
do the
the job
job in
in parallel
parallel or
or separately
separately ifif you
you can
can divide
divide
3) Two
communications
the job and solve the comm
unications problem.
4)

specially microprogrammed
microprogrammed processor
processormay
may be
be able
able to
to execute
execute the
the same
same pro­
proAA specially
gram much
much faster. The cost,
ill be much higher
higher even if you use an offcost. however,
however. will
he-she'f emulation
the-shelf
emulation.

5)

You can make tradeoffs
tradeoffs between
between time and memory. Lookup tables and function
function
ROMs
algorithms, but will
ill occupy
occupy more memory.
ROMs w ill be faster than algorithms.

------

DECIDING
This kind of problem, in which a large improvement
improvement is necesneces­
ON A MAJOR
sary, usually results from lack of adequate planning
MAJOR
planning in the
definition and design stages. In the problem definition stage
CHANGE
CHANGE
you should
determine which processor and methods will
ill be
should determine
ill be high.
adequate to handle
handle the problem. If you misjudge, the cost later will
high. A
cheap solution may result in an unwarranted
unwarranted expenditure
expenditure of expensive
expensive developdevelop­
ment time. Do not try to just get by; the best solution is usually to do the proper
design and chalk a failure up to experience. If you have followed
ed such methods as
programming, structured programming,
programming, top-down
design,
flowcharting,
charting, modular programming,
top-down design,
proper documentation,
documentation, you
you willill be able to salvage
salvage a lott of your
your effort
effort even
even if
and proper
you have
have to make
make a major
major change.

15-21

REFERENCES
1.
1.

Collected Algorithm
Algorithmss from ACM. ACM,
ACM. Inc., P.
P. 0. Box 12105, Church Street Sta­
Station. New York 10249.
tion,

T. C.
C. Chen,
Chen, "A utom
"Automatic
Computation of
of Exponentials,
Exponentials, Logarithms,
2. T.
atic Computation
Logarithms. Ratios,
Ratios. and
and
Research and Development.
Square Roots," IBM Journal
Journal of Research
Development, Volume
Volume 18,
18, pp.
pp.
380-388,
1972.
380-388, July, 197Z
3. H.
H.Schmid,
Schmid. Decimal
Decimal Com
Computation,
Wiley-lnterscience, New
3.
putation, Wiley-lnterscience,
New York,
York, 1974.
1974.
4. D.
D. E.E. Knuth,
Knuth, The
The AArt
of Computer
Computer Programming.
Programming, Volume
Volume 1:1: Fundamental
rt of
Fundamental
Algorithms.
Reading, Mass.,
Mass., 1967.
Algorithms. Addison-Wesley,
Addison-Wesley, Reading.
1967.
D. E.E. Knuth,
Knuth, The
The AArt
of Computer
Computer Programming,
Programming, Volume
Volume 2:2: Seminumerical
5. D.
rt of
Seminumerical
Algorithms.
Reading, Mass.,
Mass., 1969.
Algorithms. Addison-Wesley,
Addison-Wesley, Reading,
D. E.E.Knuth,
Knuth, The
The AArt
of Computer
Computer Programming,
Programming, Volum
Volume 3:
6. D.
rt of
3: Sorting
Sorting and
and Search­
Searching, Addison-Wesley,
Reading, Mass.,
Mass., 1973.
ing.
Addison-Wesley, Reading,
B.Carnahan
Carnahan et
et al..
al., Applied
Applied Numerical
Numerical M
Methods,
Wiley,
7. B.
ethods, W
iley, New
New York,
York. 1969.
1969.
A. M.
M. Despain,
Despain, "Fourier
"Fourier Transform
Transform Computers
Computers Using
8. A.
Using CORDIC
CORDIC Iterations,"
Iterations," IEEE
IEEE
Transactions
Computers. October
pp. 993-1001.
Transactions on Computers,
October 1974, pp.
993-1001.
Y. L.
L. Luke,
Luke, Algorithm
Algorithmss for
for the
the Computation
Computation of
of M athem
Mathematical
9. Y.
atical Functions.
Functions. Academic
Academic
Press, New York, 1977.
Press,
10. K.K.Hwang,
Hwang, Computer
Computer Arithm
Arithmetic.
Wiley,
New York,
York, 1978.
10.
etic, W
iley, New
1978.
11. New
New methods
methods for
for performing
performing arithm
arithmetic
operations on
11.
etic operations
on computers
computers are
are often
often dis­
disArithmetic.
cussed in the triennial
triennial Symposium on Computer
Computer Arithm
etic. The Proceedings
(starting with
IEEEComputer
ith 1969) are available from the IEEE
Computer Society, 5855 Naples
Plaza, Long Beach,
Beach. CA 90803.
Plaza,
12. A.
A. D.
D. Edgar,
Edgar. and
and S.
S. C.
C. Lee,
Lee. "FOCUS
12.
puter Number
"FOCUS M icrocom
Microcomputer
Number System,"
System," ComCommunications
ACM, March 1979, pp. 166-177.
munications of the ACM.
--

15-22
15-

Chapter 16
PROJECTS
SAMPLE PROJECTS
PROJECT
1 : A Digital Stopwatch
Stopwatch
PROJECT #1:
STOPWATCH
STOPWATCH
Purpose: This project
project is a digital
stopwatch. The operator
operator enters
d1g1tal stopwatch.
INPUT
two digits
digits (minutes
(minutes and tenths of minutes) from a
PROCEDURE
PROCEDURE
key.
presses the GO key.
calculator-like keyboard
keyboard and then presses
calculator-like
The system counts
counts down
down the remaining
remaining time on two
nencoded
11 for a description
(see Chapter
LED displays
seven-segment LED
displays (see
Chapter 11
description of unencoded
seven-segment
LED displays).
keyboards and LED
InHardware: The project
project uses one input
input port and one output
output port (one 6522 Versatile
Versatile In­
Hardware:
keyboard. a 7404 inVIA). two seven-segment
Adapter or VIA),
seven-segment displays, a 12-key keyboard,
in­
terface Adapter
o'.
gate. depending
NANO gate or a 7408 AND gate,
verter,
either a 7400 NAND
depending on the polarity
polarity of
verter. and either
resistors.
the seven-segment
seven-segment displays. The displays may require drivers.
drivers, inverters.
inverters, and resistors,
depending on their
their polarity
polarity and configuration.
configuration.
depending
1. and 2 are used to
0. 1,
16-1. Output
The hardware
hardware is organized as shown in Figure 16-1,
utput lines 0,
0. 1.,22., and 3 are used to determine
scan the keyboard. Input
Input lines 0,
determine whether
whether any keys
have been pressed.
utput lines 0,
digits to the sevenBCD digits
1. 2, and 3 are used to send BCD
0. 1,
pressed. Output
LED displays
segment decoder/drivers.
decoder/drivers. Output
utput line 4 is used to activate
activate the LED
displays (if line 4 is
segment
'1', the displays
displays are lit). Output
utput line 5 is used to select the left or right
right display.
display, output
output
T.
Thus.
Is being used. Thus,
line 5 is T
'V if the left display
display is being used,
right display
display is
·o·if the right
used. '0'
Is 1'
hne 5 is
the common
common line on the left display
display should be active
active if
V. while
while
,s ‘ 1’ and line
11line 4 is
·o·.
Is 'O'.
1· and line 5 is
Is '1'
Ine 4 is
1f line
the common
common line on the right
right display
display should be active
active if
Output
utput line 6 controls
controls the right
right hand decimal
decimal point
point on the left display. It may be driven
with
ith an inverter
inverter or simply
simply left on.
on.

Keyboard Connections: The keyboard is
calculator keyboard available for
Is a simple calculator
50<( from a local source. It consists of 12 unencoded
unencoded key-switches
key-switches arranged in four rows
50¢
obcolumns each.
iring of the keyboard does not coincide
coincide with
ith the ob­
each. Since the wiring
of three columns
16-1
keys. Tables 16-1
served rows and columns.
columns, the program
program uses a table to identify
identify the keys.
and 16-2 contain
input and output
output connections
decimal point
point
connections for the keyboard. The decimal
contain the input
key is present
present for operator
operator convenience
convenience and for future
future expansion:
expansion; the current
current program
does not actually
actually use-the key.
In an actual
actual application.
application, the keyboard would
would require pullup
pullup resistors to ensure that the
pressed. It
inputs would
would actually
actually be read as logic Ts
'1's when the keys were not being pressed.
inputs
would also require
require current-lim
iting resistors or open-collector
open-collector drivers on the output
output port
current-lim1tIng
would
to avoid damaging
damaging the VIA drivers in
outputs were driving
driving against
In the case where two outputs
time.
each other. This could occur
occur if two keys in
in the same row were pressed at the same time,
thus connecting
different column
column outputs.
connecting two different

1 6-1

PB7 -(not
used)
PB511-----------,
Output PB5 II-----------+---------,
Port PB411---------1-t---t---------,
(VIA PB311-----------if-+--t---------!----t--------,
Port s1P8 2 11-------,-....---if-+--t-------<-----,1----t-------.
PB .,_ _____
-+--+-++-----il-l-+--+-+----,
1
PBo

''

u

Coc, C2
PA3

R3

Input PA
2
Port

R2

(VIA PAi
Port Al
PAo

,, u

'

,

Co D1 D2 D3

-

DP

K■vboard

Rt

Display
and
Driver

Oioplay
and
Driver

(left)

(right)

Common

Common

Ro

1/0 Configuration
Figure 16-1. I/O
Configuration for a Digital
Digital Stopwatch
Stopwatch

Keyboard
Table 16-1. Input
Input Connections
Connections for Stopwatch
Stopwatch Keyboard
Input
Input Bit

Keys Connected
Keys

0
1
2
3

·3·_ '5'.
·5·, '8'
•3',
·2·. '6', ’9'
·9·
■2',
·o·.T.
'T’
’O’,
'1', 7
'GO'
4'. '.', 'GO'

·a·

Table 16-2. Output
utput Connections
Connections for Stopwatch
Stopwatch Keyboard
Output
utput Bit

Keys Connected
Keys

0
1
2

·o·.'2',
·2·. '3',
·3·, '4'
·4·
'O',
'1'., '8', '9',
'9'. 'GO'
'GO'
T
'5', '6'.
'6', 7'7',\ '.'
'5'.

·a·.

6-2
16
-2

General P ro g
Program
Flowchart:
G en
ra m F lo w
Start

Initialization

ldent,fy

l<eydosun,

Save key value

Count time on LEDs

End

Display Connections: The displays are standard seven-segment
seven-segment displays with
ith their
decoders. Clearly,
Clearly. undecoded seven-segment
own integral
integral decoders.
seven-segment displays would
would be cheaper
but would require some additional
additional software (the seven-segment
seven-segment conversion routine
7). Data is entered into the display as a single binary coded decimal
shown in Chapter 7).
digit; the digits
11-22. The decimal point
digits are represented as shown in Figure 11
point is a single
LED that is turned
LED
turned on when the decimal point
point input
input is a logic '1'. You can find more in­
information
formation about displays in References
References 12 and 13 at the end of this chapter.

16-3

Program D e s c r
Description:
P ro g
The program is modular
subroutines. The emphasis is on clarity
odular and uses several subroutines.
clarity and
generality
generality rather than efficiency;
efficiency: obviously.
obviously, the program does not utilize
utilize the full
capabilities
Each section of the listing
capabilities of the 6502 processor. Each
listing will
ill now be described in
detail.

1)

Introductory
Introductory Comments
The introductory
introductory comments
comments fully
lly describe the program;
program; these comments
comments are a
reference so that other
other users can easily apply, extend, and understand
understand the propro­
gram. Standard formats, indentations,
indentations, and spacings
spacings increase the readability
readability of the
program.

2)
2)

Variable Definitions
All variable definitions
definitions are placed at the start of the program
program so that they can easily
Each variable is placed in a list alphabetically
be checked and changed. Each
alphabetically with
ith other
variables of the same type; comments
comments describe the meaning
meaning of each variable. The
categories
are:
categories are:

a)
a)
b)
b)

Memory system constants
Memory
constants that may vary from system to system depending
depending on
the memory space allocated to different
different programs or types of memories
Temporary storage (RAM)
(RAM) used for variables
Temporary

c)

1/0 (VIA)
(VIA) addresses
I/O

d)

Definitions
Definitions

The memory
memory system constants
constants are placed in the definitions
definitions so that
that the user may
relocate the program, temporary
storage. and memory stack w ith
ithout
temporary storage,
o u t making any
other changes. The memory constants
constants can be changed
changed to accommodate
accommodate other
programs or to coincide
coincide with
ROM and RAM adith a particular
particular system's allocation
allocation of ROM
ad­
dresses.
dresses.

Temporary storage is allocated
allocated by advancing
advancing the location
Temporary
location counter
counter as shown in
Chapter 3.
3. An =
(Equate) pseudo-operation
— (Equate)
pseudo-operation names the temporary
temporary storage
locations. An ORG
ORG (origin) pseudo-operation
pseudo-operation places the temporary
temporary storage
locations in a particular
particular part of memory. No values are placed in these locations
locations so
so
that the program could eventually
eventually be placed in ROM
ROM or PROM
PROM and the system
could be operated from power-on
power-on reset without
ithout reloading.
Each memory
Each
memory address occupied
occupied by a VIA is named so that the addresses can
easily be changed to handle varied configurations.
configurations. The naming
naming also serves to
clearly distinguish
distinguish control
control registers from data registers.
The definitions
definitions clarify
clarify the meaning of certain constants
constants and allow
allow parameters to
Each definition
be changed easily. Each
definition is given in the form (binary, hex,
hex, octal, ASCII,
ASCII, or
decimal) in which
which its meaning is the clearest. Parameters (such as debounce
debounce time)
are placed here so that
that they can be varied with
ith system needs.
needs.

3)
3)

Initialization
Initialization
Memory locations
FFFC and FFFD
FFFD (the 6502 RESET
RESETlocations) contain
locations FFFC
contain the starting
starting
address of the main program. The main program can thus be placed anywhere
anywhere in
memory and reached via a "RESET"
"RESET" signal.
The initialization
initialization consists of three steps:
a)
a)

b)

Place a starting
starting value in the Stack Pointer
Pointer. The Stack is used only to store
subroutine
addresses. Note that the Stack Pointer
subroutine return addresses.
Pointer is only 8 bits long
since the 6502 Stack is always on page one of memory.
Configure
Configure the VIA.

c)

Start the number
number of digitit keys pressed
pressed at zero.
zero.

16-4

4)

Look
Closure
Look for Key Closure
Flowchart:
Start

Ground all koyboord
columns

End

:'1en
columns ano
Key closures are identified
identified by grounding
grounding all the keyboard columns
and then
a; thee
c·e •that
column-to-row
checking for grounded
grounded rows (i.e.,.. colum
n-to-row switch
switch closures). Note
checking
eao. -thee bits
program does not assume that the unused input
input bits are all n,g
high: nstead,
uCt o
'!) ns•·
attached to the keyboard are isolated with
ith a log,ca
logical AND
nstruction
attached
5)

Debounce Key
oy wa111ng
Nare by
,, so'
The program debounces the key closure in
software
aiting for two milliseillise­
Subroutine
made. Subroutine
ean contact
conds. This is usually
usually long enough for a clean
contact to be made.
DELAY
counts with
ith Index Reg,s
Register X 'or
for one millisecond.
millisecond. The number
number of milliilli­
DELAY counts
seconds is in Index Register Y. DELAY would
would have to be adjusted if a slower
slower clock
or slower memories were being used. You could make the change simply
simply by
redefining the constant
constant MSCNT
MSCNT.
redefining

16
16-5

6))

Identify
Closure
Identify Key Closure
Flowchart:

(

Start

)

~ZET

KeyTable
KeyTable Index = -1
Keyboard Output =
FE15
= 1111
111102
fe
16 =
110 2

Yes

Key Table Index =
Key Table Index +
+
Key
NROWS
NROWS
Shift Keyboard
Shift
Output left 1 bit

=

Key Table Index =

+1
Key Table Index +
Shift
hift keyboard input

Key T a b l e ^ ^ ^
■ ^ ^ In d e x = K L A S T ^ ^
T lY e s

^LY es

+
Key ID== (KTAB +

10 =
= Error
Error code
Key ID

Key Table Index)

C

End

The particular
particular key closed is identified
identified by grounding
grounding single
single columns
columns and observing
observing
whether
q closure
whether a closure is found.
found. Once a
closure is found
found (so the key column
column is deterdeter­
mined).
mined), the key row can be determined
determined by shifting
shifting the input
input until
until a grounded
grounded bit
is found.
found.
The output
output patterns
patterns required
required to ground
ground single
single keyboard
keyboard columns
columns are obtained
obtained by
shifting
shifting the original
original pattern
pattern left one bit
bit after
after each column
column is examined.
examined. The highhigh­
est numbered
numbered key in the keyboard
keyboard is used as a marker
marker to indicate
indicate that
that all the colcol­
grounded w ith
o u t a closure
closure being found. When
hen this value is
umns have been grounded
ithout
reached,
ulator to indicate
indicate to the main
reached. the error code FF
FF is placed in the Accum
Accumulator
program
program that
that the closure
closure could
could not be identified
identified (ie
(i.e.,.. the key closure
closure ended or a
hardware
hardware error occurred).
occurred).
The key identifications
identifications are in table KTAB in memory. The
KEY
keys in the first
first column
column (attached
(attached to the least significant
significant outoutTABLE
put bit) are followed
followed by those in the second column.
column, etc.
Within
ithin a column.
column, the key in the row attached
attached to the least significant
significant input
input bit is
first.
ithout
first, etc. Thus, each time a column
column is scanned w ith
o u t finding
finding a closure.
closure, the numnum­
column (NROWS)
must be added to the key table index in order to
ber of keys in a column
(NROWS) must
column. The key table index is also incremented
incremented before each bit
move to the next column
in
in the row inputs
inputs is examined;
examined; this process stops when
when a zero input
input is found.
found. Note
that
-1. since it is always
that the key table index is initialized
initialized to -1,
always incremented
incremented once in
the search forr the proper
proper row.
If we cannot
cannot identify
identify the key closure.
closure, we simply
simply ignore it and look for another
another
closure.

16-6
16

■

7)

8))

Act
ct on Key Identification
Identification
If the program has enough digits
easel. it looks only for the GO
GO
digits (two in this simple case),
keys. If it finds a digitit key,
key, it saves
saves the value in the key ar­
arkey and ignores all other
other keys.
pressed, and increments
ray, increments
increments the number
number of digit
ig it keys pressed,
increments the key array
pointer.
If the entry
entry is not complete,
complete, the program must waitit for the key closure to end so
that
that the system will
ill not read the same closure again. The user must waitit between
key closures (i.e..., release one key before pressing another
proanother one).
one). Note that the pro­
gram will
other. depending
ill identify
identify double
double key closures as one key or the other,
depending on
which
hich closure the identification
identification routine
routine finds first. An improved version of this
program would
would display
display digits
digits as they were entered and would
would allow the user to
omitit a leading or trailing
trailing zero.
"7", "GO”
"GO' too get a count
count of sevenzero, (i.e.,
(i.e., key in",", "7",
tenths
tenths of a minute).

Set
Set Up Display Output
Output
se· so •that
..,a-:he
Is sent
The digits
digits are placed in memory locauons
locations w,ithh b,t
bit 4 set
the output
output is
to the displays. Sits
'car: do;;ig it: to
:o direct
Bits 5 and 6 are set for the most s,gr
significant
direct the outout­
put
n: _=.)
put to the left display
display and to light
light the dec,rna
decimal oo
point
LED

9)

Pulse the LED Displays
Pulse
Each display
orocess is reoea
ed 1500
Each
display is turned
turned on for twoo m,lliseconos
milliseconds. -h•s
This process
repeated
sss are fre­
fretimes in order to get a total delay of 0.1 minutes, or 6 seconcs
seconds -Thee 01;
pulses
quent
LED displays
r..,o s
quent enough so that
that the LED
displays appear to be literr.contmuously

1 6-7
7

10)
10)

Decrement Display Count
Decrement

Flowchart:
Flowchart:
Start

Right Display = Right
Display - 1

No

End

left Display =
Left Display - 1

Vas

End of timer

Right Display = 9

program

End

one. If this affects
The value of the less significant
significant digitit is reduced by one.
affects bit 4
(LEDON
(LEDON-— used to turn the displays on),
on). the digitit has become negative. A borrow
must then be obtained
obtained from the more significant
significant digit.
digit. If the borrow
borrow from the more
significant
4. the count
significant digitit affects bit 4,
count has gone past zero and the countdown
countdown is
finished. Otherwise, the program sets the value of the less
less significant
significant digit
ig it to 9
and continues.
Note that comments
comments describe both sections of the program and individual
individual statements.
The comments
comments explain what
hat the program is doing, not what
what specific
specific instruction
instruction codes
do. Spacing and indentation
indentation have been used to improve readability.
readability.

16-8
16

;PROGRAM NAME:
NAME: STOPWATCH
STOPWATCH
:DATE OF PROGRAM:4/28/79
PROGRAM:4/28/79
:PROGRAMMER: LANCE A. LEVENTHAL
:PROGRAM REQUIREMENTS:
REQUIREMENTS: DD(221) BYTES
BYTES
;RAM REQUIREMENTS:
REQUIREMENTS: 5 BYTES
BYTES
:1/0
REQUIREMENTS: 1 INPUT PORT.
PORT, 1 OUTPUT PORT (1 6522
I/O REQUIREMENTS:
6522 VIA)

:THIS PROGRAM IS A DIGITAL STOPWATCH
STOPWATCH THAT ACCEPTS INPUTS FROM A
CALCULATOR-LIKE
PROVIDES A COUNTDOWN
CALCULATOR-LIKE KEYBOARD AND THEN PROVIDES
COUNTDOWN
; ON TWO 7-SEGMENT LED DISPLAYS IN MINUTES ANDTE
TENTHS
; OF MINUTES
:KEYBOARD
:A 12-KEY KEYBOARD IS ASSUMED
;THREE
PROCESSOR
THREE COLUMN
COLUMN CONNECTIONS ARE OUTPUTS FROM -rlE
THE PROCESSOR
; SO THAT
KEYS CAN BE GROUNDED
THAT A COLUMN OF KEYS
A;FOUR
PROCESSOR SO -THAT
FOUR ROW CONNECTIONS ARE INPUTS TO THE PROCESSOR
; COMPLETED CIRCUITS CAN BE IDENTIFIED
IDENTIFIED
__
S':CC JS
:THE KEYBOARD IS DEBOUNCED BY WAITING
FOR TWO
WAITING FOR
MILLISECONDS
; AFTER
AFTER A KEY CLOSURE
CLOSURE IS RECOGNIZED
RECOGNIZED
G --,,
~::JONE
'E
:A NEW KEY CLOSURE
CLOSURE IS IDENTIFIED
IDENTIFIED BY WA-,
WAITING
FOR THE OLD
; TO END SINCE NO STROBE
STROBE IS USED
;THE KEYBOARD COLUMNS
S ARE CONNECTED
,EC=J X
-o) B-s
BiTS 0
; TO 2 OF THE VIA B POW
PORT
;THE KEYBOARD ROWS A"E
E~ ,ED TO BITS 0
ARE CONNECTED
; TO 3 OF THE VIA
~ POQVIA A
PORT

--=

; DISPLAYS
TWO 7-SEGMENT LED DISPLAYS ARE USED WITH SEPARATE DECODERS
;TWO
DECODERS
; (7447 OR 7448
DEPENDING ON THE TYPE OF DISPLAY)
7448 DEPENDING
:THE DECODER
DECODER DATA
CONNECTED TO BITS 0
OTO
DATA INPUTS ARE CONNECTED
TO 3
; OF THE VIA B PORT
PORT
ACTIVATE THE LED
;BIT 4 OF THE VIA B PORT
PORT IS USED TO ACTIVATE
DATA TO LEDS)
: DISPLAYS (BIT 4 IS 1 TO SEND
SEND DATA
LEDS)
:BIT 5 OF THE VIA B PORT
PORT IS USED
USED TO SELECT
SELECT WHICH
; LED IS BEING
BEING USED
USED (BIT 5 IS 1 IF THE LEADING DISPLAY
: IS BEING
BEING USED,
USED, 0 IF THE TRAILING DISPLAY IS BEING
BEING USED)
USED)
:BIT 6 OF THE VIA B PORT
PORT IS USED TO LIGHT THE DECIMAL
: POINT LED ON THE LEADING DISPLAY (BIT 6 IS 1 IF
; THE DISPLAY IS TO BE LIT)
LIT)

;METHOD
;STEP
STEP 1 - INITIALIZATION
INITIALIZATION
: THE MEMORY STACK POINTER
POINTER (USED
(USED FOR
FOR SUBROUTINE
SUBROUTINE RETURN
RETURN
; ADDRESSES)
ADDRESSES) IS INITIALIZED. THE NUMBER OF DIGIT KEYS
KEYS PRESSED
PRESSED IS SET
SET
; TO ZERO
ZERO
STEP 2 - LOOK FOR
:STEP
FOR KEY CLOSURE
CLOSURE
COLUMNS ARE GROUNDED AND THE KEYBOARD ROWS
ALL KEYBOARD COLUMNS
ARE EXAMINED
EXAMINED UNTIL A CLOSED CIRCUIT IS FOUND

16-9

;STEP 3 - DEBOUNCE KEY CLOSURE
CLOSURE
; A WAIT
KEY BOUNCE
AIT OF 2 MS IS INTRODUCED TO ELIMINATE KEY
STEP 4 - IDENTIFY KEY CLOSURES
;STEP
CLOSURES
; THE KEY
KEY CLOSURE
CLOSURE IS IDENTIFIED BY GROUNDING SINGLE
SINGLE KEYBOARD
KEYBOARD
COLUMNS
KEY
COLUMNS AND DETERMINING THE ROW AND COLUMN OF THE KEY
CLOSURE. A TABLE IS USED TO ENCODE
ENCODE THE KEYS
KEYS ACCORDING TO THEIR
THEIR
CLOSURE.
; ROW AND COLUMN
COLUMN NUMBER
; IN THE KEY TABLE, THE DIGITS ARE IDENTIFIED
IDENTIFIED BY THEIR
THEIR VALUES,
: THE DECIMAL
KEY IS NO. 11
11
DECIMAL POINT KEY IS NO. 10, THE "GO"
"GO" KEY
;STEP 5 - SAVE KEY CLOSURE
CLOSURE
DIGIT KEY CLOSURES
CLOSURES ARE SAVED IN THE DIGIT KEY
KEY ARRAY UNTIL
TWO
BEEN IDENTIFIED.
IDENTIFIED. DECIMAL
POINTS. FURTHER
FURTHER DIGITS,
DIGITS.
TWO DIGITS HAVE BEEN
DECIMAL POINTS,
AND CLOSURES
CLOSURES OF THE "GO"
BEFORE TWO DIGITS HAVE BEEN
BEEN
"GO" KEY BEFORE
IDENTIFIED ARE IGNORED
IGNORED
IDENTIFIED
AFTER TWO
BEEN FOUND,
FOUND. THE "GO"
KEY IS USED TO
AFTER
TWO DIGITS HAVE BEEN
"GO" KEY
START THE COUNTDOWN
COUNTDOWN PROCESS
PROCESS
;STEP
LEDS
STEP 6 - COUNT DOWN
DOWN TIMER INTERVAL ON LEDS
A COUNTDOWN
PERFORMED ON THE LEDS
LEDS WITH THE LEADING DIGIT
COUNTDOWN IS PERFORMED
REPRESENTING
REPRESENTINGTHE REMAINING NUMBER OF MINUTES AND THE TRAILING
; DIGIT REPRESENTING
REPRESENTINGTHE REMAINING NUMBER OF
OF TENTHS OF MINUTES

:STOPWATCH
;STOPWATCH VARIABLE
VARIABLE DEFINITIONS
:MEMORY
;MEMORY SYSTEM CONSTANTS
BEGIN
=$0400
BEGIN
=$0400
STKBGN =$FF
=$FF
TEMP
=0
=0

;STARTING
;STARTING ADDRESS FOR PROGRAM
;STARTING
;STARTING STACK ADDRESS ON PAGE 1
;STARTING
;STARTING ADDRESS FOR RAM STORAGE

;RAM TEMPORARY STORAGE
STORAGE

DCTR
KEYNO

*=TEMP
*=TEMP
•=•+2
*=
*+ 2
•=•+2
'=
'+ 2

NKEYS

•=•+1
*=
*+1

: 16-BIT
COUNTER FOR
FOR TIMING LOOP
LOOP
16-BIT COUNTER
:DIGIT KEY
KEY ARRAY -— HOLDS IDENTIFICAIDENTIFICA­
1E BEEN
: TIONS OF DIGIT KEYS
KEYS THAT HA' 'E
BEEN
; PRESSED
PRESSED
;NUMBER OF DIGIT KEYS
KEYS PRESSED
PRESSED

;1/0
ADDRESSES
I/O UNITS AND VIA
VIA ADDRESSES
VIAORB =$A000
=$AOOO
VIAORA
VIAORA =$A001
=$A001
VIADDRB
VIADDRB =$A002
=$A002
VIADDRA
VIADDRA =$A003
=$A003
VIAPCR =$A00C
=$AOOC

;OUTPUT PORT
PORT FOR
FOR KEYBOARD AND DISPLAY
;INPUT PORT
PORT FOR
FOR KEYBOARD
;DATA
DIRECTION REGISTER
REGISTERFOR
FOR PORT
PORT B
DATA DIRECTION
;DATA
DIRECTION REGISTER
REGISTER FOR
FOR PORT
PORT A
DATA DIRECTION
;VIA
PERIPHERAL CONTROL REGISTER
REGISTER
VIA PERIPHERAL

;DEFINITIONS
DECPT
DECPT
ECODE
ECODE

=%01000000
01000000
=$FF

GOKEY
KLAST

=11
=11

;CODE TO LIGHT DECIMAL
LED
DECIMAL POINT LED
ERROR CODE
;ERROR
CODE IF ID ROUTINE
ROUTINE DOES
DOES NOT FIND
; KEY
KEY
KEY
;IDENTIFICATION NUMBER FOR
FOR "GO"
"GO” KEY
;HIGHEST NUMBERED KEY
KEY

16-10
-1 0

LEDON
LEDON
LEDSL
LEDSL
MSCNT
MSCNT
MXKEY
MXKEY

=%00010000
=%
00010000
=%00100000
=%
00100000
=$C7
=$C7
=2
=2

NROWS ==4
NROWS
4
OPEN =%
=%00001111
OPEN
00001111
TPULS = 2
=2
TPULS
TWAIT = 2
=2
TW

;CODETO
;CODE
TOSEND
SENDOUTPUT
OUTPUTTO
TO LEDS
LEDS
;CODETO
TOSELECT
SELECTLEADING
;CODE
LEADINGDISPLAY
DISPLAY
:COUNTNEEDED
;COUNT
NEEDEDTO
TOGIVE
GIVE11 MS
MS DELAY
DELAYTIME
TIME
:MAXIMUM NUMBER
;MAXIMUM
NUMBEROF
OFDIGIT
DIGITKEY
KEY
CLOSURESUSED
;: CLOSURES
USED
:NUMBEROF
;NUMBER
OFROWS
ROWSIN
IN KEYBOARD
KEYBOARD
:INPUTFROM
;INPUT
FROMKEYBOARD
KEYBOARDIF
IFNO
NOKEY
KEYCLOSED
CLOSED
:NUMBEROF
OFMS
;NUMBER
MS BETWEEN
BETWEENDIGIT
DIGITDISPLAYS
DISPLAYS
:NUMBEROF
OFMS
;NUMBER
MSTO
TO DEBOUNCE
DEBOUNCEKEYS
KEYS

•=$FFFC
*=$FFFC
;RESET
ADDRESSTO REACH
REACHSTOPWA
RESET ADDRESS
STOPWATCH
CH PROGRAM
PROGRAM
.WORD
.WORD

BEGI
BEGIN

,VECTORTO
TO START
START OF
;VECTOR
OF STOPWATCH
STOPWATCH
PROGRAM
;. PROGRAM

;INITIALIZATIONOF
OF STOPWATCH
STOPWATCHPROGRAM
INITIALIZATION
PROGRAM
•=BEGIN
"=BEGIN
LOA
LDA
#0
STA
STA
VIADDRA
VIADDRA
STA
STA
VIAPCR
VIAPCR
LOA
LDA
#$FF
STA
STA
VIADDRB
VIADDRB
LDX
LOX
#STKBGN
#STKBGN
TXS
TXS

;MAKE PORT
PORTA LINES
;MAKE
LINES INPUTS
INPUTS
;MAKE ALL CONTROL
CONTROLLINES
LINES INPUTS
;MAKE
INPUTS
:MAKE PORT
PORTB LINES
LINESOUTPUTS
OUTPUTS
;MAKE
;INITIALIZESTACK
STACK POINTER
INITIALIZE
POINTER

;INITIALIZE DIGIT
;INITIALIZE
DIGIT KEY
COUNTER
KEY COU
TEA
INITL
INITL

LOA
LDA
STA
STA

#0
#0
NKEYS
NKEYS

. U
BEROF
OF DIGIT
IG KEYS
EYS== ZERO
;NUMBER
ZERO

:SCAN KEYBOARD
KEYBOARDLOOKING
LOOKINGFOR
;SCAN
CLOSUREE
FORKEY COS
SRCHK JSR
JSR
SRCHK

SCANC
SCANC

.WAI
;WAIT FOR
FORKEY
KEYCLOSURE
CLOSURE

:WAIT FOR
FORKEY
KEY TO BE
;W
DEBOUNCED
BE DEBOU
CED
LOY
LDY
JSR
JSR

#TWAIT
#TW
A IT
DELAY
DELAY

:GETDEBOUNCE
;GET
DEBOUNCETIME
TIMEIN
IN MS
MS
:WAIT
FORKEY
KEYTO
;W
AIT FOR
TO STOP
STOPBOUNCING
BOUNCING

IDENTIFYWHICH
WHICH KEY
IDENTIFY
KEY WAS PRESSED
PRESSED
JSR
JSR
CMP
CMP
BEO
BEQ

IDKEY
IDKEY
#ECODE
#ECODE
SRCHK
SRCHK

:IDENTIFYKEY
IDENTIFY
KEYCLOSURE
CLOSURE
;WAS KEY
;WAS
KEYCLOSURE
CLOSUREIDENTIFIED?
IDENTIFIED?
:NO. W
WAIT
FORNEXT
; NO.
AIT FOR
NEXTCLOSURE
CLOSURE

16-11

START TIMING
PRESSED AND ENOUGH DIGITS ENTERED
ENTERED
TIMING IF "GO"
"GO’' KEY PRESSED
LDX

NKEYS

CPX
BNE
CMP
BEO
BEQ
BNE

#MXKEY
#MXKEY
ENTDG
ENTDG
#GOKEY
#GOKEY
SHIM
STTIM
WAITK
WAITK

;HAS MAXIMUM
KEYS
MAXIMUM NUMBER OF DIGIT KEYS
; BEEN
BEEN ENTERED?
ENTERED?
;NO.
ENTER DIGIT KEY
NO, GO ENTER
;YES.
"GO"?
YES, IS KEY "GO"?
;YES.
YES, START TIMING
;NO.
IGNORE KEY
NO, IGNORE

;ENTER
KEY INTO ARRAY.
"GO" KEY
ARRAY, IGNORE
IGNORE DECIMAL
DECIMAL POINT OR "GO"
ENTER DIGIT KEY
ENTDG

CMP
BCS
INC

#10
10
WAITK
WAITK
NKEYS
NKEYS

STA

KEYNO.X

;IS KEY A DIGIT?
;NO, IGNORE
IGNORE IT
;YES.
YES, INCREMENT NUMBER OF DIGIT KEYS
KEYS
; ENTERED
ENTERED
;SAVE DIGIT KEY IN ARRAY

:WAIT
;W
AIT FOR
FOR CURRENT
CURRENT KEY CLOSURE TO END
WAITK
WAITK

JSR
BEO
BEQ

SCANO
SRCHK
SRCHK

;WAIT
FOR ALL KEYS TO BE RELEASED
RELEASED
W
AIT FOR
;LOOK FOR
FOR NEXT CLOSURE (SCANO ALWAYS
ALWAYS
; SETS
SETS Z)
Z)

;PROCESS DIGITS FOR
FOR DISPLAY
;PROCESS
SHIM
STTIM

LDA
ORA

KEYNO
#DECPT
#DECPT

ORA
ORA
STA
LDA
ORA
STA

#LEDON
#LEDON
#LEDSL
#LEDSL
KEYNO
KEYNO+1
#LEDON
#LEDON
KEYNO+l
KEYNO+1

;GET LEADING DIGITS
;TURN ON DECIMAL
FOR LEADING
DECIMAL POINT FOR
; DIGIT
;SET OUTPUT TO LEDS
LEDS
; SELECT
SELECT LEADING DISPLAY
DISPLAY
;GET TRAILING DIGIT
;SET OUTPUT TO LEDS

;PULSE THE LED DISPLAYS
;PULSE
LEDLP
TLOOP
DSPLY

LDA
STA
LDA
STA
LDA
STA
LDY
JSR
LDA
STA
LDY
JSR
DEC
DEC
BNE
DEC
DEC
BNE

#66
DCTR+1
DCTR+l
#2
50
250
DCTR
DCTR
KEYNO
VIAORB
#TPULS
#TPULS
DELAY
KEYNO+l
KEYNO+1
VIAORB
#TPULS
#TPULS
DELAY
DCTR
DCTR
DSPLY
DCTR+1
DCTR+l
TLOOP

1500 PULSES
;SET COUNTERS
COUNTERS FOR
FOR 1500
PULSES

;SEND LEADING DIGIT TO LED 1
;DELAY
DELAY BETWEEN DIGITS
;SEND TRAILING DIGIT TO LED 2
DELAY BETWEEN DIGITS
:DELAY

16-12
16

DECREMENT COUNT
COUNT ON
ON LED
LED DISPLAYS
DISPLAYS
DECREMENT
LDA
LOA
DEC
DEC
BIT
BIT
BNE
BNE
DEC
DEC
BIT
BIT
BEQ
BEG
LDA
LOA
ORA
ORA
STA
STA
BNE
BNE

#LEDON
#LEDON
KEYNO+1
KEYNO+l
KEYNO+1
KEYNO+l
LEDLP
LEDLP
KEYNO
KEYNO
KEYNO
KEYNO
INITL
INITL
##9
9
#LEDON
#LEDON
KEYNO+1
KEYNO+l
LEDLP
LEDLP

;GET
;GET BIT
BIT PATTERN
PATTERN TO
TO LOOK
LOOK FOR
FOR CARRIES
CARRIES
DIGIT
TRAILING DIGIT
DOWN TRAILING
COU
;COUNTT DOWN
ZERO?
PAST ZERO?
DIGIT PAST
IS TRA,LI
;IS
TRAILINGG DIGIT
TIME
EW TIME
DISPLAY NEW
.NO DISPLAY
;NO,
DIGIT
LEADING DIGIT
COUNT DOW
YES. COUNT
.
;YES.
DOWN LEADING
ZERO?
PAST ZERO?
DIGIT PAST
LEADING DIGIT
,IS LEADING
;IS
TASK
TIMING TASK
EXTTIMING
FORNEXT
WAIT
;YES,W
;YES.
AIT FOR
DIGIT99
MAKE TRAILi
;NO. MAKE
;NO.
TRAILINGGDIGIT
LEDS
TOLEDS
OUTPUTTO
;SETOUTPUT
;SET
DISPLAYS
TO PULS
.RETUR TO
:RETURN
PULSINGGDISPLAYS

CLOSURE
..\ KEY CLOSURE
=oR
- '
EYBOARD , :.
SUBROUTINE SCANC
SCANC SCA
SCANS THE
THE KEYBOARD
WAITING
FOR A
;SUBROUTINE
ALL KEYBOARD INPUTS ARE
ARE GROUNDED
OED
; ALL
SCANC
SCANC

LDA
LOA
STA
STA
KEYCLS
LDA
KEYCLS LOA
AND
AND
CMP
BEQ
BEG
RTS
RTS

##0
0
VIAORB
VIAORB
VIAORA
VIAORA
#OPEN
#OPEN
#OPEN
#OPEN
KEYCLS
KEYCLS

KEYBOARD COLUM
ALL KEYBOARD
GROU
;GROUNDDALL
COLUMNSs
RO DA
KEYBOARDROW
;GETKEYBOARD
;GET
DATAA
p -s
USEDINPUTS
.IGNORE U
;IGNORE
UNUSED
•OED)
GROU
pu-s
ARE A'
;ARE
ANY INPUTS
GROUNDED?
~
;NO.0 W,\AIT

-

SPECIFIED
BER OF MS SPECIFIED
E U
SUBROUTINE
WAITS FOR
NUMBER
J:OR,THE
;SUBROUTINE DELAY WAITS
REGISTERX
-1 'G WITH INDEX REGISTER
REGISTERY BY COUNTING
; IN INDEX REGISTER
DELAY
DELAY
WTLP
WTLP

LDX
LOX
DEX
DEX
BNE
BNE
DEY
DEY
BNE
BNE
RTS
RTS

#M
SCNTT
#MSC

DELAY
MS DELAY
FOR11 MS
.COUNT FOR
;COUNT
MS
;WAIT
;W
AIT 11MS

WTLP
WTLP
;COUNT
MS
:COUNT MS
DELAY
DELAY

OF
NUMBER OF
SUBROUTINE
COLUMN NUMBER
AND COLUMN
ROW AND
THE ROW
DETERMINES THE
IDKEY DETERMINES
:SUBROUTINE IDKEY
TABLE
FROM AA TABLE
;; THE
KEY FROM
THE KEY
IDENTIFIESTHE
AND IDENTIFIES
CLOSURE AND
KEY CLOSURE
THE KEY
IDKEY
IDKEY

FCOL
FCOL

LDA
LOA
STA
STA
LDX
LOX
LDA
LOA
AND
AND
CMP
CMP
BNE
BNE
ROL
ROL
TXA
TXA
ADC
ADC
TAX
TAX
CMP
CMP
BNE
BNE
LDA
LOA
RTS
RTS

#% 1
1111110
#%11111110
VIAORB
VIAORB
#$FF
#$FF
VIAORA
VIAORA
#OPEN
#OPEN
#OPEN
#OPEN
FROW
FROW
VIAORB
VIAORB

ZERO
COLUMNZERO
GROUNDCOLUMN
TOGROUND
PATTERNTO
;GETPATTERN
;GET
ZERO
COLUMNZERO
:GROUNDCOLUMN
;GROUND
INDEX=
TABLEINDEX
;KEYTABLE
;KEY
= -1-1
DATA
ROWDATA
KEYBOARDROW
:FETCHKEYBOARD
;FETCH
INPUTS
UNUSEDINPUTS
.IGNOREUNUSED
:IGNORE
GROUNDED?
INPUTSGROUNDED?
ANYINPUTS
,AREANY
;ARE
ONE
WHICHONE
DETERMI EWHICH
.YES.DETERMINE
;YES.
COLUMN
NEXTCOLUMN
GROUNDNEXT
.NO.GROUND
;NO.
COLUMN
NEXT COLUMN
TO NEXT
INDEXTO
TABLEINDEX
KEYTABLE
.MOVEKEY
;MOVE

#NROWS-1
#NROWS-1
#KLAST
#KLAST
FCOL
FCOL
#ECODE
#ECODE

EXAMINED?
BEENEXAMINED?
COLUMNS BEEN
ALL COLUMNS
HAVE ALL
;HAVE
COLUMN
NEXTCOLUMN
EXAMINENEXT
NO.EXAMINE
;NO,
CODEININA A
ERROR
WITHERROR
RETURN
YES.RETURN
;YES.
WITH
CODE

16-13
1613

DETERMINE ROW
ROW NUMBER
NUMBER OF
OF CLOSURE
CLOSURE
:DETERMINE
FROW
FROW

INX
INX
LSR
LSR

A

BCS
BCS

FROW
FROW

INCREMENT KEY
KEY TABLE
TABLE INDEX
INDEX
;INCREMENT
:SHIFT
SHIFT INPUTS
INPUTS LOOKING
LOOKING FOR
FOR GROUNDED
GROUNDED
ROW
: ROW

IDENTIFY KEY
KEY FROM
FROM TABLE
TABLE
:IDENTIFY
LDA
LDA
RTS
RTS

KTAB.X
KTAB,X

:GET
;GET KEY NUMBER
NUMBER FROM
FROM TABLE
TABLE

KEYBOARD TABLE
TABLE
:KEYBOARD
COLUMNS ARE PRIMARY
PRIMARY INDEX. ROWS SECONDARY INDEX.
.COLUMNS
OARE
THE KEYS IN THE COLUMN
COLUMN ATTACHED
ATTACHED TO OUTPUT BIT 0
ARE FOLLOWED
:THE
ETC. WITHIN
COLUMN ATTACHED
ATTACHED TO OUTPUT BIT 1 ETC.
WITHIN
BY THOSE IN THE COLUMN
FIRST, FOLLOWED
O IS FIRST.
COLUMN. THE KEY ATTACHED
ATTACHED TO INPUT BIT 0
; A COLUMN.
ETC.
ATTACHED TO INPUT BIT 1. ETC.
, BY THE ONE ATTACHED

11
10. AND "GO"
DECIMAL POINT IS 10,
"GO" IS 11
O TO 9. THE DECIMAL
:THE DIGIT KEYS ARE 0
KTAB

11,5.6,7.10
3,2,0,4,8,9,1,11,5,6,7,10
3.2.0.4.8,9,

BYTE

THE
RELEASED SO THAT THE
BE RELEASED
KEYS TO BE
WAITS FOR
FOR ALL KEYS
:SUBROUTINE SCANO WAITS
CLOSURE CAN BE FOUND
: NEXT CLOSURE
LDA
STA
KEYOPN LDA
AND
CMP
BNE
BNE
RTS
RTS
.END
END

SCANO

#0
VIAORB
VIAORA
#OPEN
#OPEN
KEYOPN
KEYOPN

KEYBOARD COLUMNS
;GROUND
:GROUND ALL KEYBOARD
INPUTS
KEYBOARD ROW INPUTS
;GET
:GET KEYBOARD
INPUTS
UNUSED INPUTS
:IGNORE UNUSED
;IGNORE
PRESSED?
BEING PRESSED?
KEYS BEING
ANY KEYS
:ARE ANY
;ARE
RELEASED
ALL RELEASED
UNTIL ALL
WAIT UNTIL
:YES, W
;YES.

16-14
16-

PROJECT #2:
PROJECT
2 : A Digital Thermometer
Purpose: This project
project is a digital
digital thermometer
thermometer which
which shows the temperature
temperature in
degrees Celsius on twoo seven-segment
seven-segment displays.
Hardware:
port. two seven-segment
Hardware: The project
project uses one input
input port and one output
output port,
seven-segment
74LSOONAND
NANO gate or a 74LS08
74LSOB AND gate depending
displays, a 74LS04 inverter, a 74LS00
depending on
the polarity
polarity of the displays, an Analog Devices AD7570J
AD7570J 8-bit
8-bit monolithic
onolithic A/0
A/D concon­
verter. an LM311 comparator,
drivers. resistors, and capacitors
verter,
comparator, and various peripheral
peripheral drivers,
(See Chapter 11
11 and Reference 1 at the
as required by the displays and the converter. (See
end of this chapter
chapter for discussions
discussions of A/0
/D converters.)
Figure 16-2 shows the organization
organization of the hardware. Control
Control line CB2 from the VIA is
O through
used to send a Start Conversion signal to the A/0
A/D converter. Input
Input lines 0
through 7 are
attached
attached directly
directly to the eight
eight digital
digital data lines from the converter. Output
utput lines 0
through
through 3 are used to send BCD digits
digits to the seven-segment
seven-segment decoder/drivers.
decoder/drivers. Output
Output
line 4 activates
activates the displays and output
output line 5 selects the left or right
right display
display (line 5 is '1'’
1sused to determine
for the left display). Control
Control line CA11 is
determine when the conversion
conversion is comcom­
(BUSY becomes one).
one).
plete (BUSY

THERMOMETER
THERMOMETER
The analog part of the hardware is shown in Figure 16-3. The
ANALOG
thermistor
therm
istor simply
simply provides a resistance that depends on tem-­
HARDWARE
HARDWARE
perature. Figure 16-4 is a plot of the resistance and Figure 16-5
shows the range of current
current values over which
which the resistance is
constant. The conversion
conversion to degrees Celsius in the program is performed
performed with
ith a calibracalibra­
tion table. The two potentiometers
potentiometers can be adjusted to scale the data properly. A clock
for the A/0
RC network, as shown in Figure 16-3.
16-3. The
A/D converter
converter is generated from an RC
C1 =1000
pF, so that the clock frequency
values are R7=33
R7=33 kO
f l and C1
=1000 pF,
frequency is about 75 kHz A t
this frequency.
frequency, the maximum
maximum conversion time for eight
eight bits is about 50 microseconds.
BUSY goes high, it sets bit 1 of the VIA Interrupt
vers,on
When
hen BUSY
Interrupt Flag register. The 8-b,
-b it version
following
e1gh• data
da-a ' nes
.,es are
of the converter
converter requires the follow
ing special connections
connections. The eight
DB2 through
through DB9 (DB
(DB11 is always high during
during conversion
conversion and 080
DBO low• -,.=
The Sr:ir:
Short Cycle
C" is oe-'o
8-bit
26-SCB) is tied low so that only an 8-b:
8-bit input
input (pin 26-SC8)
-b 't conversion
performed. In the
:;; ':~a::
BE were
present case,
case, High Byte Enable (pin 20-HBE
ano -c.''
20-HBEN)I and
Low 3.
Byte
Enable o"
(pin 2 1-LBEN)
outputss were
enabled
both tied high so that the data outpu
;,e•e always
~.a e~ac
ea
The A/0
A/D converter
converter uses Ithes c::ess
successive
approximation
.e a:::::r:,x
~a· en method
rnethod to perform a conversion.
:o: thee inputs
nou·s o'
0/A
The ADCss data reg,s
register is ccnne~ieo
connected to
of an internal
internal D
/A converter
converter whose
output
a'>OOlJ
-2 is
ts :omoared
output (available at ou-,
OUT1 and
OUT2)
compared to the analog input. When a converconver­
sion is initiated
initiated, the ADC og
logic sets Ithe data reg,ster
register to all zeroes
ith the exception
exception of
zeroes with
s1gn1f1cantb,it (MSB),
lv1SB which
,ch is set to one. If the analog input
the most significant
input is less than the
resulting
value. then the MSB is reset to zero;
zero: otherwise
resulting internally
internally generated analog value,
otherwise it
remains a one. The next most s,gmflcant
significant bit 1s
is then set to one and the process repeated
until
,n this way. After
until all eight
eight bits have been ·tested in
After the eighth
eighth cycle, the value in the
which most closely
closely corresponds
corresponds to the analog input.
register is the value which

fast. but it requires that the input
This method is fast,
input be stable during
during the conversion
process.
changing or noisy inputs
inputs would
would require additional
additional signal conditioning.
conditioning.
process. Rapidly changing
The references at the end of this chapter
chapter describe more accurate
accurate methods
methods for handling
1/0.
analog I/O.

16-15

p
b7
PB7

~ (not used)

pb6
PB5
--lnot

used)

PB,
Output PB5
O

Port
Port
(VIA
(VIA

PB4
PB3

Port B)
Bl PB2
P
PH,
PB1
f

CB2
CB2

PB0
PBo

l
t

'
pa
PA7

-

-

PA5
P
fi -:
Input

P A5,

Port

PA4
,

PA3
(VIA p a
Port A
A) P
PA2
PA1
PA,
CA1

'
Analog Input
u t-

-

-

Start
Conversion

• 'It

I

t

•

Do D1 D2 D3

Do D 1 D2 D3

A/0

Display
and

Display
and

Com1ert8f

Driver

Oriv8f

(left)

{right)

Common

Common

-

BUSY

ru

I

_L:j-}

~

16-2. I/O
1/0 Configuration
Figure 16-2.
Configuration for a Digital Thermometer
Thermometer

1 6-16
16

RS
R6
50 kO
n
OFFSET ADJ
- W
r
— "O + 15 V

-1 5 V O '

+5 V

+15V

RS

2 M!l

VREF
-10 V

1

22

R3
200 n

Voo

Vee

2

R2
5k0

4

OUTl

VREF

RI
1\0

+5 V

5
OUT2
R7
33 kO

-

24

CLOCK

+15 V

Ar

T'

Thermistor

8

AD7570J
AID
Converter

Cl
IOOOpF

R4

3
1 kO

SYNC

ANALOG
INPUT

D88
D87

Gain Adjus,

RS
68 k!I

+ 5V

-

D86
20

A
21

From VlA C82 outout
To VlA CAI
+5 V

nput

25
25
27
26

(not used)

SRO

D89

A

-15 V

COMP

HBEN

D85

L8EN

D8'!

9

(not used)

10

PA7

11

PAS

12

PAS

13

PA4

14

PA3

"-

15

'6

S"llT

D!!J

~

08'2

BSEN

D81
0BO

SC8

AGND

To VIA

Par. A

OA

•7
PAO

8
19

(not used)

!not used)

DGND
23

6

-

~A

D

Note:
pgp is
and the
.VREF· and
INPUT range is 0Oto -Vpgp,
the ANALOG INPUT
used. the
Is used,
Note· If positive VREF

075
41 of the A D
(pin 4)
COMPARATOR'S
OUT11 (pin
7 5 770
1-1input should be connected to OUT
COMPARATOR's (-)
iv1oer
RTj is
er ,s
is:
the voltage d ivid
from the
mput fro
analog in
the th e rmistor The analog
is the

Ra
R
b

Volt
15 V
x 15

Ra++ Ar
R8
RT
Since
= 68 kO.
f l , the in
pu is:
is:
input
RF""'
Since Rp
r

K

1.02
10
2 MO
fl

________________
-----Volt

Ar+

V/ftW

68 kO

Volt.
Rrj has a m inimum
um value of 34 kO
H (T
see Figure 1 6-4}) so full scale is 10 V
SO'C,, see
IT== 50°C

Figure 16-3. Digital
Digital Thermometer
Thermometer Analog
Analog Hardware

16-17
16-17

1000000 ----------------------------,

-------...........

l"C)
T (°C)

R(Ohm)
(Ohm)

0

365
365 000
000

25
25

100
100 000
000

50

34
34 000
000

100
100

6 000
000

"CX.....
"O..

100 000

.......
.......

.......

...........

10 000 L.,. ___________

.... __________
25
25

0

J
...,

50

Temperature
l"C)
Temperature (°C)

16-4. Thermistor
Figure 16-4,
Thermistor Characteristics
Characteristics
(Fenwal GA51J1 Bead)
Bead)
(Fenwal

100 ----------------------------.

The curve is linear(i.e.. the resistanceis
independentof current)for currentsless
than 0.1 milliampere.

10

0.01

0.1
(milliampere)
I (milliampere)

E-I Curve for Thermistor
(25°C)
Figure 16-5. Typical E-l
Thermistor (25°C)

16-18
16-18

1,0

General
Program
Flowchart
G en
e r a l P ro g
ra m F lo w
c
r:
t:
Start

ln1t1ahzat10n

Send Start
Converst0n Stgnal
to A D converter

Read data from

A/O converter

Convert data to
degrees Celsius

Display
temperature on
LEDs for Saxseconos

16
-1 9
16-19

P ro gram D e s c ription:

1)
1)

Initialization
Initialization
Memory locations
FFFC and FFFD
FFFD (the 6502 Reset
Reset locations) contain
locations FFFC
contain the starting
starting
address of the program. The initialization
initialization configures
configures the VIA and places a value in
addresses.
the Stack Pointer. The Stack is used only to store subroutine
subroutine return addresses.
11 contains
VIAs.
Remember that
that Chapter 11
contains numerous
numerous examples of how to configure
configure VIAs.

2)

Send Start
Start Conversion Signal to A'D Converter
Converter
The CPU
CPU pulses the Start Conversion line by first placing
placing a one and then a zero on
output
CB2. Each
Each input
output line CB2.
input from the converter
converter requires a starting
starting pulse.

3)

Wait
ait for Conversion to be Completed.
·o·to '1'1transition
BUSY line sets bit 1 of the VIA Interrupt
Register.
A ’O’
transition on the BUSY
Interrupt Flag Register.
Actually.
Actually, the converter
converter only requires a maximum
aximum of 50 microseconds
microseconds for an 8-bit
8-bit
conversion.
conversion, so a short delay would
would also be adequate. Note that
that reading the
converter
Flag Register so that the next
converter data clears bit 1 of the VIA Interrupt
Interrupt Flag
operation can proceed correctly.
correctly.

4)

Read Data from A'D Converter
Converter
Reading the data involves a single input
input operation.
operation. We should note that the Analog
Devices AD7570J
AD7570J has an enable input
input and tristate
tristate outputs.
outputs, so that it could be tied
directly
Bus. The 7570 converter
is. of course,
course.
directly to the Microprocessor
Microprocessor Data Bus.
converter is,
underutilized
underutilized in this particular
particular application.
application, particularly
particularly since we are interfacing
interfacing it to
the 6502 processor through
through a VIA. A simpler
simpler 8-bit
8-bit converter
converter such as the National
5357 described in Chapter 11 would
would do the job at lower cost.

16-20

ConvertData
Datato
to Degrees
DegreesCel1iu1
Celsius
5)5) Convert
Flowchart:
Flowchart:
Start
Start

T

V1lu<1• Date
received from

AID converter
Index= -1

lnde.x• lnde.x+

c ' )

USING A
The
conversion uses
tablee that
inlargest in­
the largest
·a,ns the
~a•:.contains
ses a ao
The conversI0
CALIBRATION
CALIBRATION
put
value
corresponding
to
a
given
temperature.
The
pro­
proThe
:emperature.
a ;; e
put value corresoc c g
TABLE
TABLE
than
gram
the table,
greater than
value greater
for aa value
:: e ookingg for
s
gram searches
or
received from
first
The first
converter. The
the converter.
'•om the
equa to the value rece
or equal
tenth
the tenth
is. ifif the
that is,
temperature; that
such
value it finds corresponds
required temperature;
the required
to the
rresponds to
such v
ten
temperature is1sten
the temperature
data. the
the data,
to the
entry is the first valuee larger
equal to
or equal
than or
larger than
appl1capresent applica­
the present
for the
adequate for
but adequate
degrees. This search method
inefficient but
method isIs inefficient
tion.
tIon.
BCD
to BCD
converted to
then converted
The
conversion s
subroutine
hich isis then
value wwhich
binary value
returns aa binary
broutme returns
The convers,o
remainder
by
the remainder
unul the
operations until
counting operations
and counting
ten and
sub•ractIng ten
repeated subtracting
by repeatedly
signifileast signifi­
the least
produce the
becomes
to produce
back to
added back
then added
ten isis then
f nal ten
nega I e Thee final
becomes negative
cant
d
ig
it
cant d1g1t
approximation.
The
mathematical approximation.
by aa mathematical
or by
calibration or
by calibration
obtained by
be obtained
could be
table could
The table
anycalibrated any­
becalibrated
must be
The
thermometer must
the thermometer
since the
simple. since
metnod isIssimple,
calibration method
Thecalibration
be
value toto be
way.
temperature value
each temperature
for each
location for
memory location
one memory
occupies one
table occupies
The table
way.The
caliTo cali­
memory. To
lessmemory.
displayed.11Reference
far less
usesfar
that uses
method that
describes aamethod
Reference22 describes
displayed.
the
produce the
brate
potentiometers toto produce
the potentiometers
adjust the
first adjust
must first
you must
thermometer. you
the thermometer,
brate the
correspondvaluescorrespond­
proper
output values
converter output
theconverter
determine the
thendetermine
andthen
rangeand
overall range
properoverall
ing
temperatures
specific temperatures.
ingtotospecific

1 6 -2
1
16-21

6)
6)

Display
Prepare Data for Display
Prepare
Flowchart:
Start

Get least tignificent
digit ond let
output to LEDs

Get most
s,gntf'ocant digit

Set output to LEDs

End

For the least significant
significant digit.
digit, we simply
simply set the bit that turns
saved in page zero address
on the displays. The result is saved
LSTEMP.
LSTEMP.

BLANKING
A LEADING
ZERO
ZERO

leadThe only difference
difference for the most significant
significant digitit is that a lead­
7°C). This
ing zero is blanked (i.e
(i.e.,.. the displays show "blank
"blank 7" rather than "07"
7 " for 7°C).
zero. The
setting the bit that turns on the displays if the digitit is zero.
simply involves not setting
MSTEMP.
result is saved in page zero address MSTEMP.

1616-22

DisplayTemperature
Temperaturefor
forSix
SixSeconds
Seconds
7)7) Display
Flowchart:
Flowchart:
Start

Count = TSAMP

Send most
s,gr,ficanl d,got

toloft_,...,

W.t 2 ms

---·
Send-

to"ll"t-

W•t 2 ms

Count= Count- 1

End

continuously. IfIf
be litlit continuously.
appearstoto be
Each
that itit appears
sothat
enough so
often enough
pulsed often
display isis pulsed
Eachdisplay
and
onand
flashon
appeartotoflash
would appear
displays would
TPULS
thedisplays
ms),the
50 ms),
(say50
longer (say
madelonger
were made
TPULSwere
off.
off.
the
countthe
locationstotocount
memorylocations
page-zeromemory
The
o page-zero
two
counterinintw
16-bitcounter
usesaa16-bit
programuses
Theprogram
time
between
temperature
samples.
time between temperature samples.

1 6 -2
3
16-23

THERMOMETER
PROGRAM NAME:
NAME: THERMOMETER
DATE OF PROGRAM: 5 /1
/1/79
/7 9
;PROGRAMMER: LANCE A. LEVENTHAL
;PROGRAM MEMORY REQUIREMENTS
BYTES
REQUIREMENTS: 173 BYTES
;RAM
REQUIREMENTS: 5 BYTES
BYTES
RAM REQUIREMENTS:
;1/0
REQUIREMENTS: 1 INPUT PORT.
PORT. 1 OUTPUT PORT
PORT (1
(1 6522
I/O REQUIREMENTS:
6522 VIA)
;THIS PROGRAM IS A DIGITAL THERMOMETER
THERMOMETER THAT
FROM
THAT ACCEPTS INPUTS FROM
. AN AID
CONVERTER ATTACHED
THERMISTOR. CONVERTS THE INPUT
A/D CONVERTER
ATTACHED TO A THERMISTOR.
; TO DEGREES
DEGREES CELSIUS.
CELSIUS. AND DISPLAYS THE RESULTS
RESULTS ON TWO
; SEVEN-SEGMENT LED DISPLAYS
;A/D
CONVERTER
A
/D CONVERTER
:THE A/D
CONVERTER IS AN ANALOG
CONVERTER
A/D CONVERTER
ANALOG DEVICES 7570J
7570J MONOLITHIC
MONOLITHIC CONVERTER
; WHICH
PRODUCES AN 8-BIT
WHICH PRODUCES
8-BIT OUTPUT
;THE CONVERSION PROCESS
PROCESS IS STARTED BY A PULSE
PULSE ON THE START
; CONVERSION
CONVERSION LINE (CONTROL
(CONTROL LINE 2 ON VIA PORT
PORT B)
B)
;THE CONVERSION IS COMPLETED IN 50 MICROSECONDS AND THE
THE
; DIGITAL DATA
DATA IS LATCHED
;DISPLAYS
:TWO SEVEN-SEGMENT LED DISPLAYS ARE USED
USED WITH SEPARATE DECODERS
DECODERS
: (7447 OR 7448
OF DISPLAY)
7448 DEPENDING ON THE TYPE OF
:THE DECODER
DECODER DATA
BITS 0
OTO
OF
DATA INPUTS ARE CONNECTED TO BITS
TO 3 OF
; VIA
PORT B
VIA PORT
:BIT 4 OF VIA
PORT BIS
VIA PORT
IS USED TO ACTIVATE
ACTIVATE THE LED DISPLAYS
4 IS 1 TO SEND DATA
LEDS)
; (BIT 4
DATA TO LEDS)
;BIT 5 OF VIA
SELECT WHICH
LED IS BEING
BEING
VIA PORT B IS USED TO SELECT
WHICH LED
: USED (BIT 5 IS 1 IF THE LEADING DISPLAY IS BEING
BEING USED,
USED.
; 0 IF THE TRAILING DISPLAY IS BEING
BEING USED)
USED)
;METHOD
;STEP
STEP 1 - INITIALIZATION
INITIALIZATION
; THE MEMORY STACK (USED
(USED FOR
FOR SUBROUTINE RETURN
RETURN ADDRESSES)
ADDRESSES) IS
; INITIALIZED
;STEP 2 - PULSE START CONVERSION LINE
; THE A/D
CONVERTER'S START CONVERSION LINE (CONTROL
(CONTROL LINE 2 OF VIA
A/D CONVERTER'S
; PORT
PORT Bl
PULSED
B) IS PULSED
:STEP 3 - WAIT
FOR AID
SETTLE
AIT FOR
A/D OUTPUT TO SETTLE
CONVERTER IS ATTACHED
THE BUSY LINE FROM THE CONVERTER
ATTACHED TO CONTROL
, ; LINE 1 ON PORT
PORT A OF THE VIA. WHEN BUSY GOES
GOES HIGH TO SIGNAL
; CONVERSION COMPLETED,
COMPLETED. IT SETS
SETS BIT 1 OF
OF THE VIA INTERRUPT
INTERRUPT
; FLAG REGISTER
REGISTER
:STEP 4 - READ A/D
DEGREES CELSIUS
CELSIUS
/D VALUE.
VALUE, CONVERT TO DEGREES
A TABLE IS USED FOR
FOR CONVERSION,
CONVERSION. IT CONTAINS THE MAXIMUM
MAXIMUM
FOR EACH TEMPERATURE
TEMPERATURE READING
READING
INPUT VALUE FOR
s-EP
TEMPERATURE ON LEDS
LEDS
STEP 5 - DISPLAY TEMPERATURE
-THE TEMPERATURE
TEMPERATURE IS DISPLAYED ON THE LEDS
LEDS FOR
FOR SIX SECONDS
SECONDS
3:~0RE
CONVERSION IS PERFORMED
PERFORMED
BEFORE ANOTHER CONVERSION

16-24
16-24

THERMOMETER VARIABLE
VARIABLE DEFI
DEFINITIONS
ITIO S
:THERMOMETER

MEMORY SYSTEM
SYSTEM CONSTA
CONSTANTS
:MEMORY
.START
STARTING ADDRESS
ADDRESS "OR
FOR PROGRAM
PROGRAM
.STARTI
STARTING STAC
STACK AJDClESS
ADDRESS O
ON PAGE
PAGE 11
ORAGE
q RAMS
G ADDRESS
,STARTI
STARTING
ADDRESS -FOR
RAM STORAGE

BEGIN
=$0400
=$0400
BEGIN
STKBGN =$FF
=$FF
STKBGN
TEMP
=
=00
TEMP
I/O UNITS
UNITS AND
AND VIA
VIA ADDRESSES
ADDRESSES
1/0

rOUTPUT p o = " D'SPuAYS
==-=:>
SiPUT f>0«'r R W CONVERTER
5-p~ "OR
=::G
~
:.DAr- -A ::; =::::DIRECTION
REGISTER
FOR PORT
PORT B
B
C REG
- - :. =::::.DATA
DIRECTION
REGISTER FOR PORT A
A
c'1 :>t-1ERALCONTROL
• :.. 0PERIPHERAL
:VIA
CONTROL REGISTER
REGISTER
REGISTER
.;VIA INTERRUPT FLAG REGISTER

VIAORB =$AOOO
=$A000
VIAORB
VIAORA =$A001
=$A001
VIAORA
VIADDRB =$A002
=$A002
VIADDRB
VIADDRA =$A
003
=$A003
VIADDRA
=SAO0C
VIAPCR =$AOOC
=$A00D
D
=--1
VIAIFR
RAM -E
TEMPORARY
PQRARY STORAGE

DCTRC
INPUT

•=TEMP
·=TEMP
*=
*+ 2
•=•+2
•=
*+ 1
'='+1

LSTEMP

‘=
*+ 1
•=•+1

:DISPLAY
DISPLAY PULSE COUNTER
:TEMPORARY STORAGE FOR
FOR CONVERTER
CONVERTER
: INPUT
;LEAST SIGNIFICANT
SIGNIFICANT DIGIT OF
TEMPERATURE
: TEMPERATURE
OF
SIGNIFICANT DIGIT OF
.MOST SIGNIFICANT
TEMPERATURE
; TEMPERATURE

MSTEMP •=•+1
*+ 1

DEFINITIONS
BUSYF
BUSYF

=%00000010
=%00000010

LEDON
LEDON
LEDSL
LEDSL
MSCNT
MSCNT
TSAMPH
TSAMPH

= %00010000
00010000
=%
00100000
=%00100000
=$C7
=$C7
=6
=6

BUSY
L G BUSY
.PATTER,
PATTERN FO
FOR EXA'J'
EXAMINING
STA-us
STATUS
LEDS
TO LEDS
-o SE
.CODE
CODE TO
SEND OUTPUT TO
DISPLAY
LEADING DISPLAY
SE~ECT LEADING
TO SELECT
CODE TO
CODE
DELAY
MS DELAY
GIVE 11 MS
TO GIVE
EEDED TO
:COUNTT NEEDED
OF
NUMBER OF
THE NUMBER
IS THE
SAMPL IS
TSAMPH X
X TSAMPL
;TSAMPH
A
IN A
PULSED IN
ARE PULSED
DISPLAYS ARE
THE DISPLAYS
;TIMES
TIMES THE
PERIOD.
SAMPLING PERIOD.
TEMPERATURE SAMPLING
TEMPERATURE
PERIOD
SAMPLING PERIOD
OF AA SAMPLING
LENGTH OF
HE LENGTH
THE
HUS 2·TPULS.TSAMPWTSAMPL
IS THUS
IS
2*TPULS*TSAMPH*TSAMPL
2•TPULS
OF 2'TPULS
FACTOR' OF
THE FACTOFf
MILLISECONDS THE
MILLISECONDS
THAT
FACT THAT
THE FACT
BY THE
INTRODUCED BY
IS INTRODUCED
IS
FOR
PULSED FOR
IS PULSED
DISPLAYS IS
OF 22 DISPLAYS
EACH OF
EACH
TPULS
MS
TPULS MS
MS
IN MS
LENGTH IN
PULSE LENGTH
.DISPLAY
DISPLAY PULSE

TSAMPL
50
=250
TSAMPL = 2

TPULS
TPULS

==2
2

•=$FFFC
'=$FFFC
RESET
PROGRAM
THERMOMETER PROGRAM
REACH THERMOMETER
TO REACH
ADDRESS TO
RESETADDRESS
WORD
WORD

BEGIN
BEGIN

1625
16-25

INITIALIZATION OF THERMOMETER PROGRAM
:INITIALIZATION
*=BEGIN
•=BEGIN
LDX
LOX
TXS
LDA
LDA
STA
LDA
LOA
STA
LDA
LOA

#STKBGN
#STKBGN

POINTER
INITIALIZE
STACK POINTER
:INITIALIZE STACK

##0
0
VIADDRA
VIADDRA
#$FF
#$FF
VIADDRB
VIADDRB
##%11000001
% 1 1000001

INPUTS
;MAKE
LINESINPUTS
PORTAA LINES
:MAKE PORT

STA
LDA
STA

VIAPCR
VIAPCR
#BUSYF
#BUSYF
VIAIFR
VIAIFR

OUTPUTS
;MAKE
LINESOUTPUTS
PORTBB LINES
:MAKE PORT
BUSY
LOW. BUSY
START
CONVERSIONLOW.
:START CONVERSION
ACTIVE LOW-TO-HIGH
LOW-TO-HIGH
:; ACTIVE
CONTROL
PERIPHERALCONTROL
;CONFIGURE
VIA PERIPHERAL
:CONFIGUREVIA
INITIALLY
FLAGINITIALLY
;CLEAR
BUSY FLAG
:CLEAR BUSY

;PULSE
:PULSE START CONVERSION LINE
START

LDA
STA
LOA
LDA
STA

#% 1
1100001
#%11100001
VIAPCR.
VIAPCR'
#% 1
1000001
#%11000001
VIAPCR
VIAPCR

HIGH
CONVERSIONHIGH
;SEND
STARTCONVERSION
.SENDSTART
LOW
CONVERSIONLOW
STARTCONVERSION
;SEND
.SENDSTART

READ DATA
:WAIT
AIT FOR
FOR BUSY TO GO HIGH AND READ

WTBSY

LDA
BIT
BEO
BEQ
LOA
LDA

#BUSYF
#BUSYF
VIAIFR
VIAIFR
WTBSY
WTBSY
VIAORA
VIAORA

;HAS
COMPLETED?
BEENCOMPLETED?
CONVERSIONBEEN
:HAS CONVERSION
;NO,
AIT
:NO.WWAIT
;YES.
CONVERTER
FROMCONVERTER
DATA FROM
READDATA
:YES.READ

TEMPERATURE IN DECIMAL
;CONVERT
DATA TO TEMPERATURE
:CONVERT DATA
JSR

CONVR
CONVR

JSR
JSR

BINBCD
BINBCD

TEMPERATURE
TOTEMPERATURE
;CONVERT
DATA TO
:CONVERTDATA
;: IN BINARY
;CONVERT
BCD
TOBCD
BINARYTO
:CONVERTBINARY

FOR DISPLAY
;CONFIGURE
DIGITS FOR
;CONFIGURE DIGITS
ORA
STA
TXA
BEO
BEQ
ORA
ORA
STA
SVMSD STA
SVMSD

#LEDON
#LEDON
LSTEMP
LSTEMP

SVMSD
SVMSD
#LEDON
#LEDON
#LEDSL
#LEDSL
MSTEMP
MSTEMP

;SET
(LSDININA)A)
LEDS(LSD
TOLEDS
OUTPUTTO
:SETOUTPUT
DIGIT
SIGNIFICANTDIGIT
;SAVE
LEASTSIGNIFICANT
:SAVELEAST
;GET
DIGIT
SIGNIFICANT DIGIT
MOST SIGNIFICANT
:GET MOST
ZERO
MSDISISZERO
OFFIFIFMSD
;LEAVE
DISPLAYOFF
;LEAVEDISPLAY
LEDS
;SET
TOLEDS
OUTPUTTO
:SETOUTPUT
DISPLAY
;SELECT
LEADINGDISPLAY
:SELECTLEADING
SA
VE MOST
DIGIT
SIGNIFICANTDIGIT
MOSTSIGNIFICANT
:SAVE

iPULSE
LED DISPLAYS
THE LED
:PULSE THE

PULSE
PULSE
~LOOP
TLOOP

LOA
LDA
STA
LOA
LDA
STA

#TSAMPH
#TSAMPH
DCTR+1
DCTR+1
#TSAMPL
#TSAMPL
DCTR
OCTA

PULSES
DISPLAYPULSES
FORDISPLAY
; :16-BIT
COUNTERFOR
16-BITCOUNTER

16-26
16-

DSPLY

LDA
STA
LDY
JSR
JSR
LDA
STA
LDY
JSR
DEC
DEC
BNE
DEC
DEC
BNE
BEQ
BEQ

DISPLAY
LEADINGDISPLAY
TOLEADING
;OUTPUT
.OUTPUTTO

MSTEMP
MSTEMP
VIAORB
VIAORB
#TPULS
#TPULS
DELAY
DELAY
LSTEMP
LSTEMP
VIAORB
VIAORB
#TPULS
#TPULS
DELAY
DELAY
DCTR
DCTR
DSPLY
DSPLY
DCTR+1
DCTR+1
TLOOP
TLOOP
START
START

LENGTH
;DELAY
PULSELENGTH
DISPLAY PULSE
:DELAY DISPLAY
DISPLAY
LI GDISPLAY
iOUTPUT
TRAILING
:OUTPU TO0 RA
LENGTH
PULSELENGTH
:DELAY
DISPLAY PULSE
:DELAY DISPLAY

ZERO?
EDZERO?
:HAS
REACHED
COUNT REAC
:HAS COUNT
PULS G DISPLAYS
KEEPPULSING
: 0. KEEP
;NO.
DISPLAYS
AGAIN
PEl'!A UREAGAIN
GO SAMP
YES GO
.
;YES.
SAMPLE E -E
TEMPERATURE

SPECIFIED IN
S SPECIFIED
OF MS
BEP OF
THE U
■SUBROUTINE
WAITS FOR
NUMBER
FOR THE
:SUBROUTINE DELAY WAITS
REG STER X
DEX REGISTER
;: INDEX REGISTER
Tl G WITH INDEX
REGISTERY BY COUNTING
DELAY
WTLP

LDX
DEX
BNE
BNE
DEY
BNE
BNE
RTS
RTS

DELAY
MSDELAY
FOR 1MS
;COUNT
.COUNT FOR
;WAIT
AIT 11 MS

#MSCNT
#MSCNT
WTLP
WTLP

~s
;COUNT- MS
cou

DELAY
DELAY

TO
SUBROUTINE CONVR CONVERTS
/D CONVERTER
CONVERTER TO
VER-5 INPUT FROM
A A"'D
:SUBROUTINE
•PUT DATA IS IN
AB_E INPUT
DEGREES
BY S
USING A -TABLECELSIUS 8
DEGREESCELSIUS
NUMBER IN
,S A BINARY NUMBER
O AND THE RESULT IS
; THE ACCUMULATOR
A 01'!
: THE ACCUMULATOR
REGISTERS
:REGISTERSUSED: A.X
USED· INPUT
:MEMORY LOCATION USED:

CONVR
CONVR
CHVAL

STA
LDX
INX
LDA
CMP
BCC
BCC
TXA
RTS
RTS

INPUT
#$FF
#$FF
DEGTB.X
DEGTB.X
INPUT
CHVAL

READING
INPUT READING
:SAVE INPUT
-1
INDEX AT -1
:START TABLE INDEX
INDEX
INCREMENT TABLE INDEX
:INCREMENT
GET ENTRY
FROM TABLE
ENTRY FROM
:GET
ENTRY?
IS A/D
A/D INPUT BELOW ENTRY?
;IS
LOOKING
NO, KEEP
KEEP LOOKING
:NO.
YES, RETURN
IN ACCUMULATOR
RETURN WITH TIN
:YES.

WAS FOUND BY CALIBRATION.
DEGTB WAS
:TABLE DEGTB
CORRESPONDS
DEGTB CONTAINS THE LARGEST
LARGEST INPUT VALUE WHICH CORRESPONDS
:DEGTB
ENTRY
FIRST ENTRY
THE FIRST
READING (I.E
TO A PARTICULAR TEMPERATURE
(I.E.... THE
TEMPERATURE READING
LARGEST
IS DECIMAL 58 SO AN INPUT VALUE OF 58 IS THE LARGEST
READING -— VALUES
TEMPERATURE READING
ZERO TEMPERATURE
: VALUE GIVING A ZERO
ALLOWED
ARE NOT ALLOWED
ZERO ARE
: BELOW ZERO

DEGTB

BYTE
.BYTE
BYTE
.BYTE
.BYTE
.BYTE
.BYTE
BYTE
.BYTE
BYTE
.BYTE
.BYTE

58.61.63.66,69.71,74,77,80,84
71. 74. 77.80.84
58.61.63.66,69.
87,90,93,97,101,104,108
OB
87.90.93.97.101.104.1
112,116,120.124,128.132,136
124. 128.132. 136
112.116.120.
141.145.149.154.158.163,167
141.145.149.154.158.163.167
00
172,177.181,186.191.195.200
172.177.181.186.191.195.2
204,209,214.218,223,227,232
.232
204.209.214.218,223.227
236.241.245.249.253,255
236.241.245.249.253.255

16-27

LESS THAN 100 INTO
;SUBROUTINE BINBCD CONVERTS A BINARY NUMBER LESS
TWO BCD DIGITS. THE INPUT DATA
DATA IS IN THE ACCUMULATOR
ACCUMULATOR AND THE
• TWO
THE
DIGIT) AND THE
REGISTERX (MOST SIGNIFICANT DIGIT)
RESULT IS IN INDEX REGISTER
; RESULT
DIGIT)
ACCUMULATOR (LEAST SIGNIFICANT DIGIT)
; ACCUMULATOR
REGISTERS
A.X
;REGISTERS USED: AX

LDX
SEC
SEC
SUBTEN INX
SBC
BCS
ADC
RTS
RTS
.END
BINBCD

#$FF
#$FF

#10
#10
SUBTEN
SUBTEN
#10
#10

-1
;TENS COUNT = -1
;SET CARRY INITIALLY
;INCREMENT TENS COUNT
SUBTRACTED?
BE SUBTRACTED?
TEN STILL BE
;CAN TEN
YES. CONTINUE
;YES.
;NO. ADD BACK LAST TEN

16-28
16

REFE
REFERENCES
RENCES
1. E.
E. R.
R. Hnatek,
Hnatek. AA User's
User's Handbook
Handbook of
of D
D/A and
1.
/D Converters.
iley. New
and AA,D
Converters. W
Wiley.
New York,
York.
1976
1976
2. T.
T. A.
A. Seim,
Seim. "Num
"Numericall Interpolati
for ,croproces
2.
Interpolation for
Microprocessor-Based
sor-Based Systems,"
Systems." ComComputer Design,
Design. February
February 1978,
1978. pp.
puter
pp. 111-116,
111-116
3.
3.

D. H.
H. Sheingold
g1talConversio
D.
Sheingold,. ed
ed... Analog-D1
Analog-Digital
Conversionn Notes,
Notes Analog
A,..a og Devices,
Devices. Inc..
Inc. P.
P 0.
0.
Box 796,
796. Norwood,
Norwood. MA.
MA. 02062,
Box
02062. 1977
1977

4.
4.

D. P.
P. Burton,
Burton. and
and A.
A. L.
L. Dexter,
Dexter. Microprocessor S s
D.
ystems
Handbook.. Analog
i?r!lS Handbook
Analog
Devices. Inc
P. 0. Box
Box 796.
796. Norwood
Devices.
Inc.,.. P
Norwood. M AA 02062
02062 1977
• 9,,

5.
5.

J B.
8. Peatman,
Peatman. Microcom
J.
Microcomputer-based
puter-based Design.
Des ;;~ McGraw-*-

6.

F. Molinari. et al.,
F.
al. "Shopping
"Shopping for
for the Right Analog 1 0 Board
October 11,
11. 1978,
1978. pp
October
pp. 238-243
238-243

7.
7.

Auslander
D M
M et
et al.. "D
"Direc
·a O
Auslander,. D
irect D g
igital
Process
Practice
s
ocess Control: Pra::·
-= and
a d Algorithm
Ag
ms
for Microproc
ons." Proceedings
for
Microprocessor Apphca11
Applications,
gs of the IEEE.
IEEE February
=e:iruarv 1978. pp
pp
199-208

New York. 1977
Electronic Design.

8.

R. J.
J. Bibbero,
81bbero. Microprocessors in
R.
Instruments
1977
In lnstrumen
ts_and
___C o n tro
_ l W iley. New York. ·977

9.

~
;;rs o
A. Mrozowski. "Analog
"Analog Output
Conversion
pu·. Chips
cs Shrink A-D
Electronics. June 23. 1977. pp
Electronics.
130-133
op • 3
- 33

Software,

10.
10.

P. R.
R. Rony
Rony et
et al..
a ' M iccrocor,-:::
P.
c o m p jte ' ".er'a: ng
puter Design. Dece,,..oe
December· •1977.
377 pp 106-108

11
11.

P H.
H. Garrett.
Garrett. Analog
Analog S s·2
croproces
P
ystemss for
Microprocessors
inicomputers.
sors and Minicomp
uters. Reston
Reston
Publishing Co . Reston
Publishing
Reston. V A
1978
9

12.
12.

The Optoelectronics
Optoelectronics Data Book.
Texas Instruments. Inc.,.. P.
The
Book. Texas
P. 0.
O. Box
Box 5012.
5012. Dallas.
Dallas.
TX.. 1978

13.
13.

The Optoelect
ronic Designers
The
Optoelectronic
Designer's Catalog. Hewlett-Packard. Inc.,•• 1820
1820 Embarcadero
Embarcadero
Road. Palo Alto,
Alto. CA 94303.
Road,
94303, 1978.
1978.

16-29
16-29

Sample and Hold Devices.
Devices." ComCom-

Index
Accumulator.
Using th
the. 44-2
A ccum
u la t o r , U s
ACIA I n t e r
Interrupt
Routine. 1 2
12-32
AC
pt Rou
ACIA In te r r
Interrupts. 6 8
6850., 1 2
12-9
AC
-9
ACIA R e g is
Registers
AC
rs

Credit Verification. Flow charting the. 1 3 -2 4
Credit Verification Term inal. Structured
Program for the. 1 3 -4 4
Cross-Assembler. 2 -1 6

6551., 1 1 11-118
65
6850, 1 1 -1
11-111
68
11
A/D C o n v
Converter In te
Interface. 1 1 11-98
A/
Address F ie
Field., N u m
Numbers a n
and C h a r a
Characters. 33-11 11
Add
Addressing M o d
Modes., 3 -1
3-111
A d d re
1
Post-Indexed (In d
(Indirect). 5 -2
5-20
P o s t-In
Pre-Indexed
(lndirectlt) . 5 -2
5-22
P re -ln
d e x e d (In d
Addresses., S to r
Storing., 33-7
A d d re
Algebraic
Notation. 11-8
A lg e
ic N o ta

D / A Converter Interface

11-93
Data. Forming C'asses of. 14-27
Data Flowcharts- '3 - 2 0
Debouncing ~ Sc^tw a'e 11-47
w ith Cross-C oup^o >iAN D Gates. 1 1 -5 0
Debugging. 13-3
Using Test Cases from. 14-25
Deciding o n a M ajo r C h a n g e . 15-21

Algorithms.
Better. 1 5
15-2
A lg o r
ith m s . B e
-2 1•

D e c im a l D a ta o r A d d re s s e s . 2 -1 0

Arithmetic
and L o
Logica
c
A r it h
m e t ic a n
a l E,o,;sss
Expressions.
2 -1 1
Arithmetic
Program
-es·
a~
..4 .!-La
A r it h
ic P ro g
ra m . T e
s tin gg a
n. 1
28

D e c im a l M o d e . 8 -5
_
ni it a
tait io n
ions
8-6
L im
s. 8-

Arithmetic
with
-aces
,:_
A r it h
m e t ic w
it h T a
b le s . 4
- 1• 55

Decimal N u m b
umbers. D o u
Doubling a n
and Halving. 8-21•
Dec

ASCII
Characte•s
2-''
AS
II C h a r a
rs . 2
-1 1

Decimal R o u n
Rounding., 8 -2
8-22
Dec

ASCII.
Hand',ng
Data in
In. 6-1
6-1
AS
II. H a n
lin
Da

Defining N a m
Names,
D e fin
e s , 2-6

A s sembleer.
r. 1-5
-5

Definition
List. R u
Rules
D e f in
itio n L is
le s for. 15-1
15-11

Anthme!lc
Expressions.
3-111
A r it h
m e t i c E x p re s
io n s , 3 -1
1

Typical. 1 5
15-11
Typ
-1 1

Choosing aan., 11-6
C hoo

Def1n1t1ons.
Placement oof. 22-7
D e f in
itio n s , P la c e

One-pass.
2-16
O n e -p
a s s , 2 -1

Delimiters.. 22-2
D e lim

Two-pass., 2 -1
2-16
T w o -p

D ivision A lg o r
ith m . 8 -12
rithm.

Assembly L a n g u
Language.
Apphcat1ons
for.
1-10
Asse
e , A p p lic
io n s fo
r, 1 -1

Documentation.
13-3
D ocum e
a t io n , 1 3

Assembly L a n g
Language F ie
Fields.
2-1
Asse
s , 2-1

Documentation
Package,
15-17
D ocum
n t a t io n P a c k
age, 15
7

Assembly L a n g
Language P ro g
Program.. 11-4
Asse

Documenting
Status and C o n
Control T ra n s
Transfers,.
D ocum
t in g S ta

Binary a n
and B C
BCD,
Accuracy
in,. 8 8-6
B in
D, A c c u
a c y in

Double B u ffe
Buffering., 1 2 12-19
Dou

Binary., D e c
Decimal A c c u
Accuracy
in., 88-3
B in
a c y in
Binary I n s t r u
Instructions.
1-1
B in
n s , 1-1
Binary R o u n
Rounding. 8 -2
8-21
B in
1
Bit T e
Test In s t r u
Instruction.
11-79
B
t io n , 1 1 B o o tstrap L o ader.
r, 2 -17

Bottom-Upp D e s
Design. 1 3
13-50
B o tto
Breakpoint.
14-2
B re a k
t, 1 4
In s e
Inserting,. 1 4
14-3
BRK
RK I n s t r uction,
t io n . 1 2-4

As aa B re a k
Breakpoint.
14-2
A
t, 1 4
Calibration
Table, U s
Using a,
a, 1 6
16-21
C a lib
io n T a b
-2 1
Chec
0
Checklist. W
Whatt tto In c
Include in
in. 1 4
14-110
C ode
e C o n version P ro gram. D e b ugging a. 1 4-15
C o ding., 1 3-3
R e la
nce o
Relative I m p o r
Importance
of. 13-1
13-1

11- 880
11
8 - B it S u m m a tio n., 5 -4
Errors.
rro rs . Common., 14-11
4-11
Considerations. 113-5
C
-5
Example F o
Format. 4-1
4-1
E xa
E x a mples
s . G u id elines for. 4-1
4-1
External R e fe re
References
2-B
E x te
nces. 2
-8
F lo w c h a r tss. H,nts
in ts f o r U s in g . 1 5 -9
F lo wchart,ng
c h a r tin g . A d v a n tages
g e s o f. 1 3 - 1 8
D is a d v antages of, 1 3-18
Sections. 1 3
13-24
S ec
Format. 22-2
Fo
FO R T
R A N . 1-7
ORTRAN.
1-7
G e neral
ra l S e rvice R o utines. T a s
k s for. 1 2-37
sks

EL6Hand
Assembly. 11-5
EL6H
and A sse
-5

C o m bining
in g C o ntrol I n f o r mation
io n , 1 1 -7
9
-79

H and C h e cking Q u e stions,. 14-110
0

C o m menting
tin g E x a mples.
. 1 5-5

H a s hing,. 9-4

Guidelines., 1 5
15-3
G u id e

H e x a decimal L o a
d e r. 1-3
ader.

Questions fo
for.
15-6
Q ues
r, 1 5

High-Level L a n g
Language. 11-11
H ig h
-11

T e c h niques., 2 -15

A p p lic
a t io n s for. 1-11
plications
1-11

Com m o
node o
Common-Anode
or C o m m o n
Common-Cathode D is p
Displays,

Advantages oof. 11-9
A dvan
-9

1 1-65

D is a d v antages of. 1-9

C o mpiler.
r, 1-7
-7

lneff1c1ency
of. 11-8
In e f f ic
ie n c y o

O p t imizing,
iz in g , 1-8

M a chine I n d e p endence of. 1-7

Cost oof.
1-8
Co
f, 1

Overhead
for., 11-9
O v e rh
e a d fo

C o mputer P ro gram,. 1-2

P o r tability
b ilit y of. 1-7
-7

Conditional
Branches.
Long, 5 -1
5-11
C ond
n a l B ra n c
hes. Lo
1

S y ntax of. 1-8
-8

Con
t io n , 1 1 Control a n
and S ta
Status I n f o r m
Information,
11-78

U nsu
it a b ilit y of.
f, 1 -10
uitability

xxi
xxi

Index (Continued)
(Continued)
Information
Hiding
Principle.
13-32
In fo rm
a t io n H id
in g P r in c
le . 1 3

Memory
Loader EError H a n
Handling.
13-9
M em
o ry L o a
lin g , 1 3

Input, F a c
Factors in
in., 1 3
13-4
In p

Operator
to r Error Correction
c tio n in., 13-11
Memory
o r y Map, Typical.
ic a l, 15-10
Meta-Assembler.
2-16
M e ta - A s
s e m b le r , 2 -1
Microassembler.
2-16
M ic r o a s
s e m b le r , 2 -1
Mnemonics,
Problem w
with.
1-4
M
m o n ic s , P
h, 1
Modular
Programming.
Advantages
of.
13-29
M od
u la r P ro g r a
m m in g . A d v a n
ta g e s o
f, 1 3
Disadvantages
n ta g e s of.
f, 13-29
Rules for.
r, 13-34
Modularization.
Principles
of.
13-30
M
la r iz a t io n , P
ip le s o
f, 1
Multiplication
lt ip lic a t io n Algorithm.
o r it h m , 8-7

Input S y s te
Systems., C h a r a c
Characteristics
of.
12-1
In p
t e r is t ic s o
f, 12-1
Instruction
Execution.
Status C h a
Changes w it
with,
In s tru
c t io n E x e c
n , S ta
h,
3-18
3Instructions.
Defining
a Sequ
Sequence oof. 2 -1
2-13
In s t r u
c t io n s . D e f
in g a
Interrupt-Driven
Programs., D e b u
Debugging.
14-13
In t e r r u p
t- D r iv e n P ro g
in g , 1 4
Interrupt
Handling
by M o n
Monitors.
12-15
In t e
rru p t H a n
lin g b
it o r s , 1 2
Interrupt
Inputs,. 1 2
12-3
In t e
r r u p t In p
Interrupt,
Non-Maskable.
12-2., 1 2
12-4
In te r
r u p t, N o n - M a
s k a b le , 1 2
Interrupt
Response., 1 2
12-3
In t e
rru p t R esp
Interrupt
Return A d d
Address., C h a n
Changing
the. 1 2 12-18
In t e
rru p t R e
in g th
Interrupt
System., S p e
Special F e a
Features oof.
12-3
In t e
rru p t S ys
f, 1 2

Names. C h o
Choice oof. 22-6., 1 5
15-2
Nam

Interrupts.
Disabling.
12-31
In te r r
p ts , D is a
lin g , 1
2-31

Names., U
Use
of. 2 2-6
Nam
se o

Disadvantages
of
D is a d v
ta g e s o

12-2
12

Emptying
a Bu
Bufferr w
with.
12-22
Em p
in g a
it h . 1 2
Enabling a n
and D is a
Disabling.
12-2
Ena
lin g . 1 2
on Particular
tic u la r Microcomputers.
o c o m p u te r s . 12-15
Reasoning B e h
Behind., 12-1
12-1
R eas
6530 a n
and 6 5
6532 M u lt if
Multifunction
Device., 1 2
12-9
65
u n c t io n D e v
Vectored. 1 2
12-12
V e c to
1/0 D e v
Device T a
Table. 1 1 11-123
I/O
1/0 D e v
Devices. S y n c h r
Synchronizing
with.
11-78
I/O
o n iz in g w it
h , 11
Jump a n
and B ra
Branch T e r m in
Terminology,
9-17
Ju
o lo g y . 9 -1

Non-Decimal
Number
Systems. 2 2-10
N o n -D
c im a l N u m
b e r S y s te
Notation.
Differences
in., 33-5
N o ta
tio n , D iffe r
e n c e s in
Object
Program., 11-2., 11-5
Ob
c t P ro g
Octal or Hexadecimal.
e c im a l, 1-3
One-Pass Assembler.
m b le r , 2-16
Operator
Interaction.
13-6
O pe
to r I n t e r a
c tio n , 1 3
Origin Pseudo-Operation.
-O p e r a tio n , Set.
t, 3-110
Passing P a ra m
Parameters., 110-1
Pas
0-1
PIA In te r r
Interrupts.
6520. 1 2
12-5
P
u p ts . 6 5
Polling,. 1 2
12-2
Po
Interrupts.
12-11
In te r r
p ts , 1 2
-1 1

Key C lo s
Closure. W a it
aItIng
for a. 1 1 11-84
Ke
in
fo

Interrupts.
Disadvantages
of.
12-11
In te r r
p ts . D is a d v
ta g e s o
f, 1 2
-1 1

Key T a b
Table. 1 6
16-6
Ke
Keyboard E rro
Errors. C o rre
Correcting.
13-15
K eyb
c tin g . 1 3

Portability.
1-6
P o r ta
b ilit y , 1

Keyboard I n t e r
Interrupt,
12-116
K eyb
r u p t. 1
6

Priority.
12-2
P rio
rity . 1 2

K e y board R o utine. E x p anding
in g the. 1 3 -54

Problem D e f in
Definition.
13-3
P ro b
itio n , 1 3

Keyboard S c
Scan., 1 1
11-81
K eyb
1

Processing., F a c
Factors in
in., 1 3
13-5
P ro c e
P ro gram D e sign., 1 3-3

L abel F ield. 2-2

Basic P r in c
Principles
13-17
Ba
ip le s oof. 1 3

L a b eling., R ules of. 2-4

Programming
Guidelines.
4-2
P ro g r a
m in g G u id e
lin e s . 4

L a bels. C h o osing., 2-3

Pseudo-Operations.
P s e u d o -O
e r a tio n s , 22-4

L a bels in J ump
p In s t r u
c t io n s , 2-2
uctions.

BYTE
. . DBY
T E , . T EXT
T .... W ORD. 3 -109
BYTE.
BYTE.

L a n guage L e vels., A p p lic
a t io n A reas for,
r. 1-10
lication

Future T re
Trends in
in., 1-11
1-11
Fu

R AM. A llo c
a t in g . 2-7
Allocating.
I n itia
liz in g . 2-8
ln1t1alizing,

L e ading Z ero,. B la nking
in g a,
a. 1 6-22

LED
Control. 111-61
LE
D Con
1-61

R eal
al T ime. M a in t
a in in g . 1 2-29
intaining.

L ink E ditor. 2 -17

R e al-Time C lock. 1 2 -23

L inking
in g L o aders. 2 -17

Frequency oof. 1 2 12-23
F re q u

Locationn C o u
Counter . 22-7
Loca

P r iority
it y of.
f, 1 2-23

L ogic A n alyzer. 1 4-9

Important
Features oof. 1 4
14-9
Im p o
r ta n t F e a
Logicall D e v
Devices., 1 1 11-123
Log

Synchronization
with.
12-23
S y n c h ro
n iz a t io n w
it h . 1 2
R e d esign. C ost of.
f, 1 5 -18

Reentrant S u b r o
Subroutine.
10-2
Reen
u tin e . 1 0
R e gister D u mps, 1 4-4

Machine
Language,. A p p lic
Applications
for. 11-1100
M ac
in e L a n g
a t io n s fo
Program., 11-2
P ro g

R e lo cating
tin g L o ader. 2 -17

Macro A s s e
Assembler.
2-16
Ma
b le r, 2 -1

R e lo cation C o n stant,
t, 2-3

Macros. A d v a n
Advantages
of.
2-14
M ac
ta g e s o
f, 2 -1
D is a d v
a n ta g e s of.
f, 2 -14
vantages
M a in te
n a n c e a nd R e d esign., 1 3-3
intenance

Keyboard., 1 1
11-81
M atrix
tr
K eyb
1
M eas
u rin g P ro gress in S tages., 13-1
Veasuring
13-1
Me
m o r y D ump., 1 4-6
'.'emory
M em
o r y . S a ving. 1 5-19
'/e,..,orv

Page Z e
Zero oof. 44-3
U s in~g P a

R e lo cation. 1 0-2

Resident A s s e
Assembler.
2-16
R es
b le r, 2 -1
R e o r g anization.
a tio n , M ajorr or M inor., 1 5-18
R o llover.
r, 1 1 -90
S a ving M e mory,
y , 1 5 -19

Saving E x e c
Executionn T im
Time. 1 5
15-19
Sav
Searchingg M e th
Methods.
9-6
S e a rc
s, 9
S e lecting
t in g D ata f r om C la s
e s , 1 4 -27
sses.

xxii
xxii

Index (Continued)
Self-Checking N u m
Numbers. 8 -1
8-17
S e lf- C h

s~.;~

Self-Documenting
Programs.
Rules for,. 1 5
15-1
S e lf- D o c
u m e n tin g P ro g
m s, Ru
-1

s.-,
a~c
l~out.t, 13-7
13-7
S
w it·c h a n
d L_ig h t In p

Separating S ta
Status In f o r m
Information.
11-79
Sepa
a t io n , 1 1 -

Sv.1
a~a
Ou:outs . 13-7
13-7
S
w it cc•
h an
d L_ig h t O u tp

Simple S o r
Sorting A lg o
Algorithm.
9-12
S im
r it h m , 9 -1

Switch
and L ig
Light S y s
Sys;e,,.,
Defining . 13-7
13-7
Sw
it c h a n
te m . D e fin

an dc L!..ig h t EErrorr H a n d
Handling., 13-7
13-7
S w it c h a

r

Single-Step., 14-1
14-1
S in g le

Flowcharting.
13-2:i
F lo w c h
a tin g . 13-20

Limitations
of.
14-2
L im it
a t io n s o
f, 1 4
Software Simulator.
r , 14-8
6520 P
PIA I n t e r r
Interrupts., 1 2
12-5
65
6522 VVIA In te r r
Interrupts,
12-6
65
ts . 1 2
Enabling a n
and D is a
Disabling., 1 2
12-6
Ena
6551 A C
ACIA C o n f ig
Configuration.
Example oo'f. 1 1 - 1 1 8
65
r a tio n , E x a
6551 A C
ACIA R e g is
Registers., 1 1 11-118
65
6800/6502
Addressing
co,,,oa,
see
6800
/6 5 0 2 A d d re
in g M ode C o m
p a r is o
n.
3-105
3 -1
In s tru
c t io n C o m parison. 3- 1 0
truction
i066
Register C o m p
Companion. 33-1 005
Reg
Similarity.
3-105
S im
ila r it y . 3 - 1
Status C o m p
Comparison, 33-1 0
105
S ta
5
6850 A C
ACIA C o n f ig
Configuration,
Example oof.
-115
68
u r a tio n , E x a
f, 111• - 1
6850 A C
ACIA R e g is
Registers., 1 1 -1
11-111
68
11
6850 A C
ACIA., S p e
Special F e a
Features
of. 1 1 -1
11-111
68
s o
11
6850 A C
ACIA In te r r
Interrupts., 1 2
12-9
68
Sort P ro g
Program.
Debugging
~-1• 9:i
So
m. D ebu
in g a. 1 4
Testing a.
a. 1 4 14-28
Tes
Sorting M e th
Methods. O
Oth eer. 99-1·:5
S or
Source P ro g
Program.. ,1 -5
-5
S ou
Software
Develcpr,,~c·
S:ages o~ f. -1 3S o ftw
r e D e v e lo
p m e n t. S ta
3-1•
Standard In te
Interfaces. 1 1 - 1• 22.!
S ta n
4
S ta n
Standard P ro g
Program L ib r a
rarvy FForm ss. •1 55-1• 3J
Start B
81t
Interrupt
'2-34
S ta
it In t e r
p t. 1 2
-3 4
S to pwatch
w a tc h I n put P ro c edure. 16-1
6-1
S tr u ctured
r e d K e y board R o utine. 1 3 -44
S tr u ctured
r e d P ro g r amming., A d v a ntages
s of.
f, 1 3 -39
Ba
es o
Basic S tr u c
Structures
of.. 1 3 13-35
D is a d v antages of. 1 3-39
R ules
s for., 1 3 -49
W hen to Use.
se. 1 3-40
S tr u c
re d R e c
Structured
Receive R o u
Routine., 1 3 13-46
S tr u ctured
r e d T e sting., 1 4-27
S tr u ctures., E x a mples of.
f, 1 3 -38
R ules
s for., 1 3-49
Stubs., 1 3
13-50
S tu
E x p a nding, 1 3-50
S u b ro
in e I n s t r u
t io n s . 10-1
Subroutine
Instructions.
10-1
S u b ro
u tin e L ib r
Subroutine
Library., 10-1
10-1
S u b routines., D o c u menting.
n t in g , 1 0-2

Modularizing
3-3
M odu
iz in g thne
e . 13-31
J-4
Structuredd P,:;;•3-S
r o g r a m m in·g
g inn the . 13-41
Top-Down D!)e;e s ig;·n o f. 13-51
3-5'
TopSw,tch-Sasec
','=e m o r y L o a d e r. D e fin in~;i
S w itc h
B
d M
g a. •
13-9
F lo w c h a r tin g th e . ' 3 -2 2
M o d u la r iz in g t h e . '3 - 3 *
S tr u c t u r e d

(ram i— c so r. 1 3 - 4 2

T o p - D o w n D essgr* c C 1 3 - 5 2
S w it c h S o u r c e , 1 1 - 4 7
S y m b o l T a b ie . 2 - 6
T e r m in a t o r s f o r S tr u c tu r e s . T3-43
T e s tin g . 1 3 -3
A id s . 14-25
R u le s fo r . 1 4 -2 9
S p e c ia l C a s e s

1 4 -2 7

T h e r r o o r n e fe r A n a 'o g H a r d w a re . 1 o
6 - 115
5
T o p - D o w n D e s ig n . A d v a n ta g e s o f. 1 3 -5 0
O s a d v a n t a g e s o f. 1 3 - 5 0
F o rm a t fo r . 1 3 -5 5
M e th o d s . 1 3 - 5 0
-,ansm1ss1on
Errors.
Correcting. 1 3
13-15
T ra n s m
is io n E rro
rs , C o r r e
-1 5

TTL
Encoder.
Using a.
a. 1 1
11-56
TT
L E nco
d e r. U s
TTY
Interface. 1 1 11-103
TT
Y In te
T TY R e c
e iv e M o
eceive
ode,, 1 1 11-103
T TY.
. S ta ndard. 1 1 -103
T TY
Y T r a nsmit M ode. 1 1 -108
T w o-Pass A s s embler.
r, 2 -16

UART,
11-110
UA
RT, 1 1V a r iables., L ocal or G lobal. 2 -14
V e c toring,, 1 2-2
V e r if
ic a t io n T e r minal.
l, D e fining a,
-1 2
ification
a. 1 3
13-12
E
4
Errorr H a n d
Handling., 1 3
13-114

Inputs, 113-112
In p
2
M odu
r iz in g th
Modularizing
the. 1 3
13-32
O u tputs., 1 3-12
-1 2
T o p -Down D e sign of.
f, 1 3-53
V
-6
VIA In te r r
Interrupts., 6 5
6522., 1 2
12-6
E n a bling a nd D is abling 6 522., 1 2-6
-6
F illing a B uffer., 1 2-19

xxiii

About the Author
Lance A. Leventhal is a partner in Emulative Systems Company,
Company, a San
San
Lance
Dif!!go-based consulting
and
Diego-based
consulting firm specializing in microprocessors and
microprogramming.
He serves
serves as Technical Editor of the Society for
microprogramming. He
Computer Simulation and as a Contributing
Contributing Editor for Digital Design.
Design.
He is a national lecturer on microprocessors
IEEE,the author of
He
microprocessors for the IEEE,
five books and over forty
five
forty articles on microprocessors, and a regular
contributor
contributor to such publications
publications as Simulation,
Simulation, Digital Design,
Design, and
and
Kilobaud.
---Kilobaud.
Dr. Leventhal's previous experience includes affiliations
affiliations with
with Linkabit
Corporation, Intelcom
lntelcom Rad
Rad Tech, Naval
Naval Electronics Laboratory Center
Center
He received a B A degree
degree from
and Harry Diamond Laboratories. He
Washington
S. and Ph.D.
Washington University in St. Louis, Missouri, and M.S.
Ph.D.
degrees from the University of California at San
San Diego. He is a mem­
degrees
memSCS, ACM,
ACM, and IEEE.
IEEE.
ber of SCS,

BOOKS
OSBORNE/McGraw-Hill
E/McGraw-Hill GENERAL BOOKS
An Introduction
Introduction to Microcomputers
Microcomputers series
by Adam Osborne
Volume
O -— The Beginner's
Volume 0
Beginner's Book
Volume
Volume 1 -— Basic Concepts
Concepts
Volume
(1971Sed.)
Volume 2 -— Some Real Microproce11ors
Microprocessors (197b
Volume
ed.)
Volume 3 -— Some Real Support
Support Devices
Devices (1978
(1978 ed.)
Volume
Volume 2 1978-1979
1978-1979 Update Series
Volume
Volume 3 1978-1979
1978-1979 Update Seriu
Series
The 8089
1/0 Processor
8089 I/O
Processor Handbook
Handbook
by Adam Osborne
Book
The 8086
8086 Book
R. Rector
by R.
Rector and G Alexy
8080
8080 Programming
Programming for Logic Design
by Adam Osborne
6800
6800 Programming
Programming for Logic Design
by Adam
Adam Osborne
Z80 Programming
Programming for
for Logic Design
by Adam Osborne
8080A/8086
Language Programming
Programming
8080A/8085 Assembly Language
by L. Leventhal
Leventhal
6800
6800 Assembly
Assembly Language Programming
Programming
by L. Leventhal
Leventhal
Z8000
Z8000 Assembly
Assembly Language Programming
Programming
by L. Leventhal
al.
Leventhal et al.
Running Wild:
Next Industrial
Revolution
ild: The Next
Industrial Revolution
by Adam Osborne
PET-CBM Personal Computer
Computer Guide
Janice Enger
by Carroll Donahue and Janice
PET
IEEE 488
488 Bus
Bus (GPIB)
(GPIB)
PET and the IEEE
by E.
Jensen
E. Fisher and C.
C. W. Jensen

OSBORNE/McGraw-Hill
OSBORNE/McGraw-Hill SOFTWARE
Practical
Practical Basic Programs
by L. Poole et al.
Some Common BASIC Programs
by L. Poole and M. Borchers
Borchers
Some Common
Common BASIC Programs PET Cassette
Cassette
Some Common BASIC Programs PET Disk
TRS-80 Cassette
Cassette
Some Common BASIC Programs TRS-80
Payroll with
ith Cost
Cost Accounting
Accounting - CBASIC
Payroll
by Lon Poole et al.
Accounts Payable and Accounts
Accounts Receivable
Receivable - CBASIC
Accounts
by Lon Poole et al.
General Ledger
Ledger - CBASIC
General
by Lon Poole et al.

Some Common Basic Programs -— PET/CBM
edited by Lon Poole et al.
edited

